<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SchoolOfSRE笔记</title>
      <link href="/2020/12/30/SchoolOfSRE%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/12/30/SchoolOfSRE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c6390147028d2b9ef0a5b5822171e3ad2022404aac0418f3586cf4115f9ec30c">f049b01eb4bc28b2ca81719b8fdd37410ba146d201d58e5732830601495c7926e3edfb957a6d6503f0a5218c59a467f233ad9a3bb712e7858fddff7c9d6efdd79c53dbc2050700412e38f37835228c2de71959601980ecbe0c06c39b88199887440c323f97faef087a9f03227ffe44df4cf4499e2f756ef3658f613e9bdf1436e993affaade5d53cd4d739e16dbbdbb70e8e490f0140555e0c97dc4c267c5a1b145aa5f01ab3a2ee40008461e6ce276f35c7074bfbec4c5290f1a4eac0e7dfc2bdfb706a14196af026dd66d564e924ca2c05c7e5f1c15b7e6b52e809f78bf5559989251b724e89b6e8d42f6d27720037b655c9391c17724f59b847254a62a10ceafa7390fc355b7c433ca8c2db1ce6a1906a87f726383f2a0347abd1ba39149fed21817d0fa58104aa4763f48410a294dfd3bb3346349e43b6ebf776c8f062211ffe82e937a9df7e0238a2b058d15b16b4d6127287f2c6cc0e2946f5077631fbdf151a1ae92ae0f16c9f2733a06d3862981a3a5329d165ec3c67a14a12cbb82c1812b7d837a628b49eff5fed9ad73fd4eaefd2a28a42a7c96476575296dea974407c0e22b9a6cad25534c6d652932ed1b2274e36a33ae6ae613eabd4a8a3d571e0b016081c495a555db3a20be7d528df9a3d4e0ef58308b61b02cae1a8b48f58526cfe435809f4bebc8bce1548140816f13141bfeb4bcbe63191438071391f356ee8603e9568cae456508399987210a645a435c51efcd9c41b5e7489304fe0204cdd8e84aff64e557ad828d39460aa104e81fe4bac868bca750bc23633179206f231e6fd4b967e245383c5802bfdb945678cd120facc38f4b01ee98418197f214c42cb3b0d3f15d500107766e234ebbd38a9a459252d36dbae1a1276f5aafea67f5081fe26627b18ec49671a8bfc00192480a13493cd20d92ac172183853e25e89844be9e0d6734b2a78103eb95772f911e872ef797083e935e8b5051ff928cd813043ff3e332c595e657b9f8f0c15c4d5433d86a565e92b8d38dc8ecd7e7dffaea72220cea04bc794401f851963c226d473edfabb863d8e3cb850219c4e14e657c5fd93b9f476e4b77a05b8c19b966e0d372266c7d07a3ab35cfee323ee729aa34caa27263b260ecbdae8eab39d57995049464f15b85a9958fa00dbb4875bfb76b9ea21b21323e2e4ee9b167634665cbe3dcf5b3f5b0b7737f1eaf5a97653dfbc956508ae1853fc917b7828a1ec915cd41f991f34b0580cba5ff0b9523b61d5a27504a3484dbf74f13bc96b88adf4a20f8324f10f5fe4e255f11cd0489d31278f1a0bee0286b2277e2a6c059524c1e32df00d281a11fe1d7d4d823b442421ca55d262413e57d27608a36d3ef2aab0a7135d58c0d9e21cdd1b3453e87d62a8cc49d520a3a2d91f4350dc679407b6285ce47b65a0122dea38a56629fffa14fbf8bb678b45000b68971a900d30e5cf01dcbda049d742c1fcf14bdebde59e452f9f304846ca3455e4abb709c1db33957f09bc2d660c99e0c26daa7b28e236e8b4d403bc02508826a600f6764ef310719d0975b89c94460823051a7f2e7e8120d839bf87674fa174708fde2ad7eae857d1ad671539681fb97473bfe98a78c7a87204a9782a59f50ce99c56cb6d79508e494ea98d8517a741c44cfda2a59b4f48ea80dde77cf627caf976d41fb47ec5754f12013b097c85faf4c82c42606408f764699e05bd855cf4a04b64e7e992fece2324edcc29356733fc62e3984cfd1e718fbf006d2176fd622c8c88da9c4d89c0f8f56955b3ea371a099064577280ccf362999168c66ca75603aaa7b8be348f32ae138410ba2d0c61ba45c5ae170089736a8acac0754d8bc3d983ab80822e7f9cb47fce24c6eaaceb17f0b00b563018de28a73ada80e0dd1155e15636426feff955035988748004d500935b881014b4f817b20f627e460be2382d6e6d559df352703a5ee0ff16a5d8cd5721023c5e9c20cec97e2315ef1842d7b23ef188aede7883ec4ba345b530497402e3ea833d1c1b89ddaa2e0c0a39a9840787a9bbb9cb3977b67db00b47623c9143051a56f7441deff02a15a39d22e2474b315d8bf590d7e05c0a642c5cbf43b56995cc2f3535facfeaccf301e03a8b4e24d162029c9fd98246e2b23970592709641f804eaed7aa61299e2234934ea96f6294dd43329572d1556f90e7cd20104e64a4fe7b2c5a02f989e74a1b66c0999283b995dd039a3d3dc40b7c7aca153eb62ba55f62522add5b123553cfca55012867939d202427cfe162e187f9bfea8cc6fd69706d49fe532f521a782c3696602448e0b0062bda2999b89f62a9f7dc9393ff22a2a22e3b4f8ac29e35c03a555e28423ad001f94dcfa3c769586267d14460eb7beb18b5aac67c6a00dee603d62a85175066eb35a002df76e80830dec809e3c3a2f53c48c34286f2deea809041b52de88d435f215ef86fb62742f6a93c9406bfd26fc073fdce0c79e80ae01f027d3ba493e075062c17946b03b11f42eb6bb2a7b94b165501a4e5eb134da01bca1a8e4ede16509bcf345c581673b00ab31bff98bddccb26a5940ff26040bf621f8b1331780a2880fc869844cf2d4f11f9d2376f3bd9c2a044e4c84da04cc044c451ea22a054f9f59e5f2fcf3052cd9116a2809ee5f00de4bc49b953d6fa02d383b586ec84de01a14ac0666adf54ba2721fb96128b1488f6928ba40f68ee0ebb752094df2cd6abb5b900a8ed49bf5f4abab9476624109dfcb270ee26b281cd13e517027445834ba0faf5ee766a9c59f21647b59378b1de28423f103a895231999e123a670984bb32d3b3a50250a51df4828cbd431244c8ae18f308e697ab2a49bb2e17b1dfc455e9c5e1c1dbd84dc888a7a6fad007943fc15bb51b0cc59bff62ef12759abd1b5eda1c6bf4bed654469370e777bfd6136ed58844c6285d22fa0ff016d20e4e3cff5c8911b4f72ac182ccf6604f18f51a7132ebf833066ee36164c9f54d55be62b7476caa914deed5999fcc6cf428ebd3701d592ea9df0e15aa7b41fff8cb3f7bbd88658eb178a0275a1ef2cad1d30dbe6e85701b22d642bf9dc23d57b3261471e712e7fa68ef42dbda053177900a5fb27b7259df7b17b3e14a1d21b095b9430dfec605f4a2c64abff07b8a1a2391e3a91fe19c33edea7bec9fc77ccdccbb452956ae2112e522bcc0b6ffad124df5bb0ecc5c2e884faa76f3b355f3954abb5cbabc54cc9c485944aed1527587358e4d194ea258c2296ff944c0fc5a92867b6f3c1becb60634e02eed3f8749be525bde74dac447260be655d417d8a352cb2b4f38652c9d251a1d7c014b6945e06372c89d5ab9b44768d019524adb6985a6785f7fa92282b604c8803fb9ed410a7d9f81432cf92dc806c342f385e90b8c14e4aedb63f228c5c883da181793e83f80725187138410af1b6b1a78a885acd2926d617fc0c831a74b8f3dd9ec10b8a5c436cfb7ed1c6b1871b50f4f156da3a0591249568e35bb31ab263e35780f419360bcd6e6200a5f935a74a63ab3365f859971551c1e6b6312ff0dd9e5a2ca5bd737fdc6cd85b495ffa927f4773f4666ca81ae73cbd5cf427b607103c8e43cf993f4ac65e1b3e54f73d51ec74f905edc8a779be95d3b46c37f59b2fb2f8e613af24a39ddad8419f13edf5f7ab16f3fe6dca76a3ed20dec83cf0e9da401f114c6f19d011ef4ffd3fba13e886cdaeff8b6ae26cd71af2296c4fd852894bd61cba56acde41904bfb34b0a781a8a430da6533550d086d9dde868a35187d593b94f148eac46ae3e83e4e8106859791fdaaa607eb0d134956a17261ebc49ab8e613368bb163e731dbd65ff94991f2378c2284f4e67c0c7292dd941460c9d451ca2ca7a73bb8ce95bcebe5ce16b67416eb60b788968ed1a703e76f607b3bf15c0f119e113b63ab8bac36f9162d707b190a77baa27fdf1b0a7634b6cf1526e987399235ce28da183c803ff154b6ae3916e2b6b747c08e8f95446a7f900956d78c9fcc785b85d2d5b0b8d932309c03648f00d0cb3e4248e300dc3a5f869e84bc8b0052bdd615a298b078802d83cefa1a79db3a5640c36016ff8149c36759432f7450b1bd82bb3505c5ab7ef5bc3b9a01cfe2b34a077b44793c7af55d071b888dc7216e94d17476b0023416dc18d95474e732b22434101934e3e1b29ac04ac245acf9106fc820bb257bca004e81610cbab1076db54b0bc1016bfe6b9b6b147c55f0227361409e9d5239cdfe7e0d5761716e27860c9fcc23360103501975d918420d1e6b0697159cf99188c10d65ab9576c35eb2c90bc129e59359fd8a269dc69ad1840ae799885df499eba394044dc41e87e570bd3375f07c36cb6cfd84c99843489bbf06dc1d114b24bf7f34c307e36c9fa9e0bd71ecb18f967c20e11ec0ad266457815cd32cd8bf41375860c5971f41de0288e6288533099a136d5c69e4dd04a3f8567605cce3fd18907863e99ca22a373dd05d15b9a145ae8f8f07cea930198c3eba95d8ad0aec57fce2ded4a8abc90fc986927e069d144df66c932c2710d335c7087c546d1712a3a1c421e34896ddae0763318632201146aa84d02613170b792d75abd34d2f87f4f36c2dab34ae3388f7fbfacda098753ddccb078d9e5b03ea1939c648a4ebc200b2171fd83ad52adaeef3664019b114a17830b6d2b0527f765d9d279219e892c457e766ceec28919f558320acf3d79e4069cea7b4785bbe8ac0677c13ec08284a9013bb3aee800a53c412774c231aa30255055854ec077a609f3c71646004b3514b6dcfb81abd1f9e21666623e7877c886ce1000c0b57300882c7cd1a4b58e1490a95b58ee1c40851c4c61f53690c015742e285d467d2e764a6830cb108e9d7bc3cb8a0dd109280289f3e7bca13a5384adf6c84d63cfb0dc0b903fc74141aae473ec9390469af6b554b683fd226d27ee468ebe87d9b60201f08aebdc2b4f5587566cb43a1c05dd2daefd13f9d9a1ae3d86d5430ac871c46056c524d3962ce8597d47339ab44ad7249e1034ae68e24cded0c5a323d8cf6b8598ce48d625874e6ae38dcfa4c31f1fd4b663e4e47cd6debad645939b7bfb5642481eed445e69111fa1f0b64038c57d00e84ca99f8d7aad24c698f94711c07a8967cc3dba79b34c12508352effb87c51135051e77227cff23c8dd6637cf620e19fb73e343549cff77cd6902016ceb974c23dba5960a4fb5f033328dc524368dea95b707953cc32d3fee4a0a7a74e5eaa402ea4d79f76f8d288432ae9cf1d779d96b07e2cbe6cb988b1476aeadc7c3d06aaa44b0c16d4c598a48ced97d9a051534d475a9d7664f26b64b4dba3327c7b948dc20f933f80026cd678bc29045831a9034d5b11fe5536c8b9def07f2d162e043c6213c26f198928c20d6624fcce0629de46eae9afe70bff35b2913c80fba5ac7952654a65af393c6a2016eab4309e7e06ff13f35d00c2604e12b2fb32c18d3abfc7b35f6b178269018c28e5375d3a905f395505adeaa773d8ce3025e5d66c6664c4aced86a567bf94dde32140f08d848d845c874a58f1bb3213220874d6c367f7730931820437391d50acbfc148e76e3a5552699589de47b9154d0dd13d91c48d8801717aca5b78315db0cea84af0fcb79d2c1871143840041c5fab7624c53db317a7fdca1dd65b16b0169ba3615f39c68ea4436ec8e404b34dd69757a66ec6b2589494ca8a52be2237f8bc07c2e00552f25a91b0c87c2942892d2f63fad04046ec4112d42e95aa4479b53cb28bc41769825959d9ad209991104f45b214dcf8d4b3f67f80084c8ca284cd88c7ef617de549d745941dd9de792af8aa691cf499c4737ee50eaf0b088a8cec3e17052e2c0ff3c28ea7ab9746a3a5cbec5722e14b4770c5131317da4310bdc18f7eeb757c13c77ecde6d8c582558b4b86bcb9acfdfa469c8caf19da4a2e72b4c65958b6293699ca7ddf790123e33c20b5b139301e9bba9368c126c08af6eca25304aa21b56b479f21e0f76bdaa90bb968e5b0776ac59fe28b7d5ecc2d1080ea1afff99afa3f3b740ba0e43ee2f2e189e274712a3a157c52825525fad7ff1924ef53cb0886a5a42d9083d26e86ba16b16e809211c713e57786a0c6579645d2552868f1b8ab532293457776dd28392e959ee41a1a5302f8b1d953ce41750f304bbca3e01f5a3683abbab47f55eeb2792f64bf4f0a03e12f47de69a372702b78568886664ac65e0d302828943136ff4f7f98a28b5801fab083778c388fe131b53c3446ce63283b6fbadeff504d1e29df3d3624d4ff1b56499c9e09b37c980a3579b3d382cf032d9f3306383eaf960308904c21d54efa61227586993dc61dbb0f31b3d5b247e5e12558b67d65b27057db372e43685f61ecb0f1b30162e6add390a193982f329a8b533afb8739abc6e14b5202ee56d16abc3715b84f6955529cdd69b443afd4e0b32c40b612b2bd58f60fb4e04e7d391e5a8b526c99b4c01ffa827dcf9b1472313325fe7f7edc17669d526bdef764b3914a52e3e6f8d282e76ac44999cff54dc0792cc9253c15cea659ac0e7fe61ca5aa2225f09bd560ea32daa85c4f82a9d96f4c055ef5c9d77757be25ee60c9bae164cc8b5ff4b4180859c3ce20920d3e70f4dbc0bade43fb5a7869915431be9f247c7f638167d162bd3237e39604d78a3a7072c283e96725630cef7f8dbfa361fb9a8a61ab1c310a776ea5bc04ecc01be3a1c2abf6fc5070f43faa642d6213ce378f6a71da603176071f0c5c043f21381e7dced546c32f6fae1f428583e9524dcf95d44366148fcfb857a35df454cbd03eefed7445e2d446e17d8d4263f2a7f640090453d8dc813a639cf18d3b2f35f469cedc90a947a5dee6a5da373e743d29ec9288333e8c7cb2b2e66a1ccc6efc93aba093ae7c66b5334919e7e6705ffe5f30b18aa09069cff6e66595800ae407c6b5c564db5095b003c9427358fa54ca2d24c58d6989da76301fcd2f78ab810f1450ba2a408c3bc18f3e00401a80def5f3aa5f0cc4ada8b859f6a0cc277c00ec244730e9fd8a957948b81444c322525a7d27ce30636af314f10b890f21e2925586b05b51b3488ba773b5a925d127653d53db61142013b1adb332115289d00053a8364c08fe2a4d5fcdebc384d6b8c3ec4ca9bbc6cfbcdc149792c1dbeed626e019d6de6b743bcf49c7dd2cc7640b7b9948a259fd89451cbfbb0f698126589a6f35da83b7f133d771f7dabefe8390be83f4197b9438df069281be1dcf719febad83f57c2f7bf60ccd71da22378d038d9a94c78068d1279fb32d9afb92198bcab857a31aa2601c89458b5c7d1f1d307f25968a73e04eaa5e9e548e7283382dcd0cf492aeb81d3aac67b157bf0e7ffe02c851c29a1b1c79358b7b9e3c9573e516fd57f6af4aae6d7ead9144b8c7929e31c3123307e46a40e9d7bada1b6f3580a3684729159906a16a058f6c8f77e0702208bbdc317d3ef1b1c05d1761ce147308a59c7a459b826c34bba7f56a84e9b72837e529d7f78d6c9a16875669cfd85a0ea5d64935adcf62b3634ac2cd17330900a485aababdfcb077000cd8c712c345a004dcaccc71cf6c00edaf70c07bb78199cf9ea6f0f9a1f8101c2ade516b587198de77a5116c3e7771fb5a706b61930f07792edf4d9a2257272c7201bf2676198e4b67603f0c1fcc21fef075e9b6e4541b2c95769a94cee48df65c73cecd980affe68343ba584aa0e101b0c89ff06074e3af1f6e11c265e2505a94b37537d54e52b492806bd620f6ffff295e129ec62ff5b616ee022e42c83eb0a987f3bbfed0ac0f0394283c208d7fb86eeb335edc37d7f49e411a52543592f0e568df87a74a2485429e364695e08815878874e7b03d77706bb58f3a6c4dbe49512eb3fdf9f1eb80fc1cd98070baeb6de03aaf127e86702d91c688719d084e0f60ebc8bfbac1ea9d87e49ffbe72a5bc918d08246b7afbcee696d39b6cc078ab236583105b49e24a1a4a331094662a9a982a9d7bed96fcb7a72fb462d3a89183fb37f860cfc4bf50fbe74067a78effddb6f10442ba4de9dceb0c0e5a9be5fd13f19b3f1051f2f4e8a9a5abd18eda37c30389695198cd3413ba266421cca70738476e3e6c055b35da4460d30dd8c94bdb1b1ee9b5154866c2f1587c6f23470259eddc747c00140d9c66f3802422b656bbcb2604da337e972e6f8bd47a110d2a002ba2ee881cca9ceebdc3a6e94b937812957a4e24f019926ba2cf6fa6f9d19de946499ba951518a36633ab1f61de1f866072eb906921d71c7392151e4f2f71363d18c6fa1d40cf5a96d295509bce33064a07cf017f8bc49a58c8ee0d91dca9a746cf4bf61ce5ef37135e778db10bd630b3c409c88808cc2ebb50e7f4c9d5d97a1bdafb33d7bbcac64359359eae269b6b98576a5f19b4683a975b1ba9601508086b6ca1498caa887ac60080ff5c6c9b66c572b8014f2c38c3e2028d1366d39a6c10367fdd5ffe8cb7b65dc5defecf2f57704baad39495ed8ca0ac36ff18c4b00e291d2b3d056b3e08914f7abefefdffabebf30fdc6cc7365bda93536242599beaf68b874701e754f31cf5cce0f19a10bee1a4897e0c00d5d65dbab9af5c8f61891eee001b4f066815d986a4083705cb17620c068cbcce0048c594e1a2426aa7c1d6de56a6a60760b7ed6dda411bfac8cf240e2e75ed6002f00ff409f4661bd0cf1c53dfc6491f88e76a38868365fabe537494cd8f36b35bdfd6da50f0194ec5b086c1341f710bd370caa2c4953e239f1147f81fa4918f5fe19c5fc2742053be1e1e53bf809facd0b7a4744955cbd668a1c4bd902881997c5ccda190e7cd157632b53570c970d802d96a72d7eed0fda2b0348ba07446382b6629ae33bf6f0fbe6f44070ca0fd7b1bb076c4ad1062fb6bc5d3c98f959733c54c480e37acb2dda7648dfa1fc07a08b32280048570682e77eb1a33e247893f86c95f3405974a664c278e2c0464a7a24e1afdae98cff1b69b13744113d255fc344af13ceb9efbb88e15fed5f8b768b162e79530a3b28475849dbc7f4346970291d815f124a5708ebdbe8be022fee37131f80cbb63b85a0bd60d51127693549181603def6bc84c96f3d699b6107e58fdb7266605385326531bac1326fd7c4e27e89caeb033bc63b88cfcbcc42b63a2b573c16a17b5a0c7670205732e609ade3a3ede90daa87bce21eae8ef0a1865807029b483a049bb0805393401e07fd0916a56969bdbdaa7f232f06403d32a4313731282cf32b6fccaed0926fb5ae3ecceacdf064cc2ceab394effa8d44fe56dd20b8f401df3390a45b14ccbd449740cc56eda579c2366d4cb01badae4ce26380c100b44c6357c66e1d788870c91baf0574ec50ce194c52cd0cb47fa95e53649e945b81466e97e3cff50f3f9d86f14563abb4d47ae2f71a30c2e46ed78a29aec37ef787c6d6f9d38b68681aacfb3de96bd2bb9c140de0fa8d31e92cbbe49b0ca35c4a8e6c7304ea9d60052843da4209a0d4a415c6ce176dbd955513c2e0e54c4305e1041a38e0da4cb7219c5cf7d94ad7090e5b3a7a31b34817ba74dc4c471766414685878a595cb5ad204b05fc41e7f6bd21e062e18cdea20f2dacaca7fdfba795d71b242e7b1a9eefcc2f8bea438f21477125f9838923ee343d3c6a1ec3d14ac86dc37072c56263792faae5954ce7eb6efb3b85f06315d6470ea37d18cf8a5bb2059354eb9c92f20c6d81a84904a051fa762f0b64f61810cef3a248c129be476d22b67c893cfae4c088d62dcaf1869c61b0bdab2b489d1ddcd7c5f28b98855594c46311b95353a853804cf359be4d8ad5bc4df684884b479d0e354f91541fcf1dbb69aa0a233a2cb93f5ca0fac6d07331597f04640b8195f1f2efff807260af7a9b0d7bdc8fdabdde819f703f8b2b11d9058b547b1ffb5fa4a556995a8ac438b93252fb0f09c713634a102a1bf2fe2893478d937aaf74481b525c2aaefff5197358f92a6ebe7c8e94fc75fc6f0fe7018783299cf1d21d1b4a8d7d7f569cc8c188a6cecd801cb3f6cd3ac57aec55633f7cd93865f5b312afd83e22fa4625a7ec3a4b9176c4783514471a1ea9a82b7b32e6d34d82758eb567ca8f46cb98b2ec54eb8a30a95d981bc924a2bbc544ed00a93ee93df0549d14fd8a6d4eca509f10a270add5605305bc5dcbb0549d46879e68260b8990126016e46270ed1e1a7436d61be43f19d14939abe3264279f6ec2834b96f891ed47b9e8b22992373b6ff7b22e50fae9bea565a32148e6a5f8d6b344ce814137182f7a3a5aee03073a9cecafd5bd17cc466fd35f66e1c13153e839bd3a8ab6b95221e038341e107a6d2908aa2113b3a9dab9b84d2b721a5ac853704cd7ace290b472c1125c397776e314773be70460e35968d4485f96aa2b578ca7b81b49111e096d99c546e9a21d7882025ed2585fee1d4c7752df23272fcb1fbde5a8479947e1cb15447c076ada113d8173fd49d3d2bc9cba07560299bbe328206cc870c60f0425b07ec4dc14ebd258095337c6cae474a8cecf306167386bf222734a52685a8211b9ac680a6a8947bc7475e6db42e4cc8f4bcdbed15f08e39b9d64408db2a9b44ce56f517db182b762af3ac9ffce6ef3a42cec625d2487660bdb34299243b1c6e6b6e55d39f7ab498776350976354c6fd10d542c9556a650eba6fc38a38879f95d39a2919a5d3d277dfb7c55fe650c3c334f83476f21b80207685035486773151426162e5d99e55e8c4e5b1a6e7521fb824a99725106b74468f8d460e5b032e13d4c88ce637353616c6e80aa5930b70b0c2640d44b5ed71e65de4a107b09012ce8812a13606b74bd85c37e45d5226fe3862e54529fb86c2d6879106a7a9fdcc6600bf0aa52f26cba054b89c84ddcbcb64a159545db99ceda839724423c9704a6450e4257e44a42db0c170bf7c8e4909bf6ae62a9038d51608441dbe58602a9ac548b7200af0be2eda48eb645e30d75e031531364b20dc8a00a49ec166ff7d4acd87263da825588c6e9163ef05f73d362132f9e8c5354f1675351b357622b668be6e092195abae92db594f729720057f0968f5cb00c2683622d403698ef1a408d8807f54f83638d0f5e9a43c10270f179cb0a14dde6adaf5d3f2aed6590e14b80702cacd9e275e55b0ccf067824ec45b19d35b0cd70d7ef305f279566ec1b9c066430d35e63f36a329b04554478b945237515ab1788be64b9c314bcbf3332a77c8211c2403294c7c6f8297f6c16fa4cfc504ac073a22d60b9abe6f87d279ebc8a3286f5d6e1a7bd16af2272054ad679786cbee4fad49d4c4bddb2c087d43007d31b3302e35582d4a9fe41bbc4ee73bf63b3a8ef543f81f9fd9672edada1b9d60d08535151bb3495a02ba78a09dd21856933f69f878b324713530a06afad4fb46e7fc43e62db92752ebd6f39d08f1b13ded322235d7e5b3f9a0c02bd761c572601ad9103a52de18c250ed7f7c9ded17bd31902377bf1c1f4ba527280e19e84078bf995c924400fe021f2e762c53844be0b07a3458297406cd7d018edcf4af8d7c4f3bed628eabb6383ffc2e65c81f64d559a63d50cde673b6d353b16889ba728b9d42b90bb634de8aa8bf8de86aacbba99fe6c9ccc421c2300e285c9864a1019ae8b2c874991a861d71252d0f9f1ce22c9a7cb84ab420d682e78552aacde89330dfdf0d103bc9893ff785082806d497ef21e338b2e7024289a3b94bc1e556c767844e99e33364b394cef9fc31302ec592bbdc3bc1db6051149a55ff861b20e5aeb93667440941bb44589a9b52f797fb77e123793e1829a5ced3261ad728214fa6e317e49f0734611e9a34baebbfa6d0a12f2335b62942da329ec89756e10f23b93547801f31efc3bfb3ff91691484e0340f6aa58ba3b8d694f19c065104583d4534a22c4d1fd18a62b1d7400cd0a7b5193d275743dbe0f4e8cf8df0a16a1c45d34a850b9b17554d62c1c62c492ea7648dc3bb36525f777c6084c6470fb480d23a55d182d434d46d328d2dd578ac870e9f8aa13c5390cc8e3b821cbbc1a959f062350c3fe55b7bf8d1b5d6e240b247a678e55074aa0d52b0851af19dc6281f1cff18089276448b2a7bc9c2a6f780a16bc4a66acefc1df4b1b94cd49ea32967711a696c193e7b54619f43cfaa974286a2395286a97a89196d1a4b56507af4d9a7ddfca284a49bbaddf7968c0d4d299728140a33a66ae3b412823d5f48f36372417d8336e84db04d2180aa67640d98128029d93e33e1fcc6a261a14197be9e789adbe9122b3ee96e2699071c89c0001a0498ddfe7ae8876809325671111630d5c82cdc328a3e046311d464746ad0bf24afe758a29dd8d23767be6089db753129f8b6a97756e09924fb7160dfe10e0096a116bdff89cbb9c72f3e81c2fcc6b7cf232ac720129d9a952fe71d1107899de0e31c1e511384ea59a158dadb09a2138dbeb09d7aa98981b5193a7f5d6807cef0a48b090101cb6b33708f300e5c8dab9bbfc11866d11ae78a9bfdda610536735d651b870a25cc22716f995c11e4ebfb8f5d7310c36e7dced71658d06ec8a2a5fafc0be1f07a3fa242f3cadd6d8eb7195f41b3a9da96ff31d83ebbff043af9f398b652fea5bf8e802a1b6da59162c83ef9b37aca2dbd4be963f58b2e650a20e62b90c5300c047c06c7af00413b8f306264be5a66a76976b4152e992b7cc37b2702c6abffcab2d1214f2cfd36d5bbd6c481146d93bbf1e1c1ffd59454eb898612730bdd621fa80de3ecca8ffe4a4f793e122e7082019146cb97aae7559046fb72831a7bc0db74eef69f694bf3d2537329fdbb5dbc846e9626c2069493683daa47ec860f1d319758d1e5747925df1634bd2e29039ceee47c275135f6dd5d9ec793031956a384732d939851031457021a3a4ef4f647f7eb85ebc8614b79dcdf67e95080c2a928dea55db97c2c56048ed6a6ce729cc7259253650a61ce01ac73b89d02f7e43276d829dbd92be8e83e7303fb4bd039edffa3306eee321785e96ca0d79e1171f12df7b9b9bbcbeffbc09850e5abfaa92da98d167d09f6725224e13f83fca864bd8215eb08534f26f1542777f64952cceaa6982e4f8d19c5a3dd69ad63d9bf137108b2b858958a2cadb90a9052fbd0cd5b8a799843bd2eaafc04013ee2dcd1110efd9cbf0250bbe0381396f06bc8ea0f0385f2b0298766973516b54c00351c9ff53f5f3bd17e4dd4668a09fa6d59fa8f15b7cfb3aff66e8db4986a136cc05c3d7ecdf4cdef917d92a9ebbd4e7489658584f469b9fd2d624449c14da31003218c3c8633825c18acce64f10f73040d88923c37916f0c21b63bbe63cd950062f29a873160136333761494039b61a0a9923554438d7e1b765885a8356417cb78bd9a49d18e60f03df33c709d21bc560f71d2a2dfa59d7ddcb093d65efae15bd0cf86a62d088919b4929e582445c86292a9c4309c3464ccd59b0ba9ddf8acd37432c93c245b1e914f0df6b37ca9eb2d898de4a7d0d88a356cde5993f9e947a42b0674761c1ff31887dd67a3129923d8c90fa2b484eb13ea51ca986657e9a3848d140405e4adda406d3b59e06699533f9d95af03fafbf667a0cf06a8e0533b677cf76ba35ef16b7650bc3afaad3dd7c3f2459faf3ced993408ad39c116ab6c2b96fa0423a4fb4ee28ab7f543a69b4a00a1678bbe53383f1588517096f588d09ca089e9c1afd8de31c4a8cf5a6c5e102eeb53bd83b088aba613dfef37deb619e5a64471d5efb83ef7fb5f4895a92d66e54ff9d8c759d31c34eb8755bc6fc9dca1da174ff34a3e7362d3e87ac30691eb5d3b4bb18d40304e7d9a046d5d5fb4b764ecddd736c81405d056322646b3af51fc72f8c8e1d6bc1e278de0f7e2a9d6e268c7cca124dd976b7e7c3e67f3a27d5083505090a06433b8e70304aa7f27027b0ee640379062ba98d6fba3f1c89d332b87754b930a1e9f13744b55c4d6111368696e5e9713270218cc6a9cc7f630e24c89bde2c378d4a441e420b5b7f500afbf7a8607befca18e1295baff75544187f80473e3473862107d3f0172ceaa4ae471a2eeb0318fcc5313bcc9e27a599e0c4c8aded13e5cb77f845f6010b74eec88d1bd8f3acd92d2a0bb00b136b8da31468eb5dc8bbc5b02dd863675a4ba80c3d8f0f6cfdbbe3cb735284997ee532d052038f61a6c37f10e60764ca144e3a4486ed2824ab2d047b6e8bc0a95d32d377d60848948d0bb1a1f04619f79d6153c822c04d0219887ae444c963e6544ac3879236503b087dfaed6583438349d25dbf51177b69a6d29d0cf18713cdafd986b57acbb1e9d26b2c67223f65da998d42047b8d60dc1a1de9060b1bdbf3095d6aca7fa473849a98ed4c06e34a653f7654f6d042cf6e48e9f1c899d24ced7e37c5d6c3aaf0ba36b0f29862f7bfb3acd8d3a6ccc95c5b2ae079b1941a9156921ec539361ea2dd2566098a580c2e8f6bcc52ffde8a61d88c06593d87d1e1cfccf0e34b6766e29e16121ab9deee57bb5b8aa816dfd46eed5eebcb8346d1e44d339756fb31db6f63bebb2f52257f2f663ab91765bec99da89ca5b2a54b7b745762e452f354730b16b65c2226110e18b23556535b0356bdbff58924491392599da1dbd0b376187570b6ba014c914b2bd298d1554c339b9c7179763e80fa6a48716c7148335761e2514026baadbefa185be4f8a54c654a951dade77e4357fd61f26e0a167dd5801e7d293502ffad6088f4412ae804b1d85484deed955cf67edecc24cb8e85cae9e07e524dcae7532cd8b0670383b0bad764356c1621ac3c92bf356367f21b015e8954a69089444084cedf00cda203bb2690633d341bcd22be28e16ca36c61a5e659eb39673da007d0cca0805a950b4b008a75c5cf8f726bff9e9259f33187ce10620a1c64e948c814564c35cbf705294a716bb67a9fc8f8fc184d5ac43ae382dfe23307e7f39809e3e99c9e0e8f35bb4e6560839bab40d73933ba40f1e6bdbf7ad3fd9f0e91d44e3f64c76edb1b28a9a993e01f39e589ca1a109d815cc10d50e3bf2754533a9b0d5b1d8e48e2bb3acfce7f85b56c067525acd243c3fa4442034da4d366567c7ef3ed021f3168472b995d33869a8dc1273e8071904af9c7face68022a2388c81f71b9c562064d8edddf4cc6e7431b82ce4f09d230844bd614c5e479a52dc408138e197ac7f5b58d34da720c203a037bcf125152394e5f612a2d1e0531aa73836d8ea997692dab0b274eb022f28f0789a5b977e1fe5a4a8616fda1cd3eb7b9c70ab50985f17324e0429bb61f74a604923213545ef0191199f7385397b4c9c924751a5ebf2060c953deb18f6d41f995e7b894802923143b82acf4a689dad447b25cbc0cb1947fa6e02dac14afc65cbfd8ad28dbaa106740b679cc8d853ef083fe875b75dee54eda2a3204018621ef78872a781e95887205c2609a5cbb116954b5313ade2163b6d1e6d1309c3263d0820107f145ec6edf379cc1ea327a59627ab7e2162b185f80007c063d6ea2cc6f958e9f38a97a0fb5e48b0e79ba304fa3c34eb46c8e426da24cd10d97657e25c8237cf22cff03552bc1bed885880341d3d053e88b11e62b260764ed6cff44bf8f8b21dc580f2dc46cf38974814384c10e2c40c6096fc20b75ed300952319572257d446eb593ca5cd9ccd10097ee8181a46876c5773bcccec4d25acf7ea07a3e77f5d324bc54f8d6310da7d37b89398a19a7ada023ea7ae08baf6f53475cca0cebf10646c69aad03af807cdf5754a74b1bea2e32c2996e33fc8a91e6ba8182f3af1c5c68a3a657a521cb3a30cde29eb2ea01a1f343bf76511732d2f21f0618d416b8921583e1d8c1e03cb7085612b176a1a405beda6ad70116f86bde3db7078b963f1fe38b91b9b154058d304d585ad0fbe79acf8170c47329414e0df640e94e881a8cbf691852f2c847d2998fe8c1037d61889e72a07e3054f3ebc17db06113bb68f585007df44de0021a61cac1787a48209dac67b929d1d58445c4fea0edc7d33f4a3137273e2dbf07b83f348350895270d09eb526c26780057f956a4c35dd74b597ddc550bbe0a1ccda9a0055ea8d6a0ccc2bc3c38170e960d2e91772f529b75d173ad49ca24fe3870a4fc41dcf8a0a4c117f5efbf4c50957ccc9e5b1d141f49983b7792b966e26271101c73b9f54dcbddaffb8eda070b0327844e7c23c3d19674b7d9b0f9c2285747871cf734d1c1f2a1576a5a0363a6955810af9bab6328e566e1cc193db42b2a8ad22a58a1746a5266150d27b5eae2778a3f0d6a5de495708e62c81de9bc3cbd2e939d03de6022c78316ee20553e3789f79e8e50974b1ecf4a5c89d2cad27f70a121759f08f069925d8d2efc6f285b3e3a89d4d8831ce17041f9e4a25188a84b488a036a5d7c86ec72d84148f64fde0b8bd865161026e8fdba33a7791ecb48d1b29da47856286f4adc6d7715036150f8cbf4d3376b35bb1cc88005eaae1159c29abe295a5ecbde7ed2d33b11dea3e8d0da57846be837ab1407873145c6a4fc7b37e184f2e3e2d79359d162bf575b99106a51596a79d4fd8d11352c0179f6bfc3191c7a016c0925d89d82972d2f33caa6363effefb9dc7515b50aa5279d51cc88d525e0961f0132005d5486d5637415823e67f9f8f753ad61bfbbc094ad2584bdd205a53cfa6b9d879dc9232e4f250d7a880265e2cff367ef668508655508b00b9d7c0cdaeb9379a8bd6e7f5a5a3b2095d092d97f9451aa5aebb2b1708515a2f4e9e686ea511b13888a61dffd68e1147a018c9fc4633f063a282d8ea411d837e907e155cdb88debf77b641171ed876ab2751e4dcf7ec1be3463a1e79c31638d639dc90ed1ceb9e6c634fab6e985eb7f0d3f487294f1b28117bb166c574f40bfee181a57e461547af6134766f2ea5b6abf30aaf7d6660d2701963be3d1cf29a77d2f27e762a2537e5b1a139da466243c1c98fc861e937578f23d34060a6fa4b21c9d61a33afc9d45dc394b62f4585ba82a5f81db856f087f30747644e1a07dbfc36e23acae84da115d963e13d936dc13a99c69598bd9808087ed9c34747e86afe0bf7e1575e2514631f7851bd4d4828f781615ef89daf00621d0fc52f89c7fcb776b48162a9ccce82889fda03b0874078d041c476a83edc6399d7d742d1f0d06769839e22aae778c0bb2a865733968b7363e6f2fe6b5e58cc2b10e51495ee0c343a7a2f2b6ccfa989253b80c29138df23b451083d1c177f4e3357c0bead8cdd5bb69e9b5fc71cc8b260f441999b7e2f542c2424ace310a508afe1fac65b485faea9e9cb91aaa898667f672696ffd348e1b9f170d9034cc10eb96d0964a3d5f17d718df3b2cd0622905797c4656470904e0784399bc70268351f9d7524e85431111a62c34aea1ec22363fe011cf1567078771476a0bb182ac1b95fc06f3cd54de19e19f1b89c44a1392a6355f2450e6d12516c9cbc4e4f1f9b44c440e58a790f54782e079fd10255880c6f9f76aec6513103eead492d72bd2da40757f044eb8f8ab1f135b8757cb00a0abb8bba246a2480262fccb6861ce30a69ce3c033557e3fe12c9e8d72bb05d1a1886f68b20550bbde1b4e6a93561423c6a4eec1a5fddbf82a7c6274a88c24ca04b5c9c562db74cd23adf3d9c38833327a0ad60235cb4837e78833c1c274eec0de7ecd14cbede8c02c6fbb2e1f58aefa761304e59c6929f86ff80f44a8d92def71d264ea0b9ba8b9c352511cc08c5ddcf7bda799b46402b5581dcb7d3cfb5592e307cd5b6f57971b44cc5cf242831775609578005359c9b3f2117afaa5eed190b3a765a0fb4797f7b3e83dc3c9ed74c3d36053ad4ee53153cef5e9413400d0279f0d45e3fe851d0bc876c118b3fd3378d000f280a428141446c9c496f427ce6ff8e0b9071e017699732c35aeabafcbfbff7da63b6bcce9356445b816b1d5c5cd9e3072d3ee9ccac15903050927aab9a10688da56298f02228d90accef0a0492e0983fa85913ac10d096d0d5bce5743e6d8d5c2419ef2c27208f016b1eda4d7bf1d85538ddfc7ec369a0d27c478bf67ad7f974343d7c3a8d4c0470dca905f9d9592915d9b81bfb0c69bec6b389e197c3546dccbac4affa0695a7352ca3f4d12f0e004e3e0205df8470fcfffb1e9aa4b051d5ab3e7c11dcc689365b43af58a3a63f45b43df94a4f52c5d30c3c8efd8823016c1f4903cbc8c09a6b99ba2bc11e1792317161c6fbaf7f8ace11cf43f9a295cc7762e5d8a24e36762ffc26851c9c16321f7929632970455efc093326119a3fd441f3eb7a106fabd612b8ec222b675687cd9e21550f4dead36ba843ccf85cf6e87fb63519525ddc60cc8fc9a51f29ad81eb7a9e7e5a94d5b872f8057037f9363d323691335b846d73abf7367443e5bdf283966d04922916a92aebfa7ae2764049f8a0b40c53288226c3b24a2e7afcd215214e854a85ff0fd1f002d13a2d1176c2b8820e980a0a8f66f240547d3e85025fe7cf7ddfaa017b3cbd1987bc7f534fc3a3e9d445fc2c00a4d341535b44302042483fb8ebc4d76dfbd029cd7d7b76212882531324baa957c0e994bbe9a40c23410b44bfcc115f0b7c5e9495b9cf2579db57bb29d2ec6cb11cc8e976e64fb570ceb00b9f14fea588930c12b4538d5cc83d11223d73b82714577abed0862585ad120c73d3ee6f9a34a5f77c6d18f21266b7addaf3e5e634a42f9f95dc4ec2ff8c303a5b2671125101c187cf2cd86df8ce50410319238df6cfdf0c402a8f0a8021180e2e0ecff30296e58d1b74d22687c33846339aac769282c889bd33ef041a4754dc3524ffe43456d834c6c0c41aba2e132eed324373b4cdfdb03ddee04d5d9312b7f4f1c5c1d087fd7866dca77c54ba79634096a3af22e0a278efe67b15ed3ab4ad2d94a66a5e080b335267def21bce693ff70bbe7be5d29979091206ad5fa64808b79a0a67cf18d3654dc69d248131974ad186d7af2b75b425e9643fc5b21399a2ee971d9c823fd8ebcc13ad29e139f958143081c2181b5a560870c6015f347821f608098d6bf10d4009d52a194d0b5d1d0a5f3279a7143d85b11a8c6ce30591479a454927d92028e442d3070aff7f8ecff2c2b4c10faaf8f6b4eec9e17233ad4ffffb41e4ccf10ccb31ee88b50bb2da261874299620c0a994736c11c0a60030310aacf7e8915abfabf30a05b5b348505991aeb0b34d89abf894b26ffc4f13c82be40c3a76ce952dbd23cdbaf85390cc0b394a4880cba32b49beba1d1ad4d3fd587b7df737d2bee49f92d8ea081651e642f17ccd9deed077e3edc875014cb938094be823c1ba501f2706774ebe828cc1055b0a1526f3ecde65ba21d18bf97dbfca6341a2748fec006c7e5082be043a2aa6889819376cc230c4e26d109f5ed35c58d9743348ef139246cb5d41765feb57b1e6e66db953429cc03dd4d70548679dabd4b9ef4b6735104d51c5df5f3444a34a3ac2735ac7245ad0b57a6b74d69a73531d3d28ebb1b0d0b282214790cdaf5bcf20aa2e9632fa46ef48109710384b3bde249b6ee7df22a0f060a66334e3151f9c605c94f5f665281e8aa1e224afca6f50554af50e2bc228d9c90f67ba03af8ca73cd07d2c6650f798e7d6c40819f03517da3cdf2d2e253c750c4f3c9eabf28185fa2dd878807b2efc7185c87799720bbd2b01f6b8096a013b67b90794e39b7450c6993b55e3c8781de1b948408ebc13e74e24cc8abde4d52c0eda7be166bf529eb29df5636ad7b0cacd48ca698180a07798cefecd92bbb12256780030a1ec3c8b5b6885ee9d5c1a5b7f9dfd2e416d357918053431ed9e5999b7335ef923ee393608de89fc37c03366e1168c9c11cd66401696764c3813cdd7a861077d03f9074db35e5f15df01b995376fbf582988c48307dbc1bc2e7fb38ba6c270e31c5f03a7df0d686d86c3d4a343df72ec6f71ffd80c0f1a5d0c6c22e87205b4d50fa3d3a4a90f3b068e25e83ba6241015ba5264a52df24ea2722ca6b5daaff5f9545c0c8585900ce2543390f3db1c462e5aa8d676e9af930727a9710e206bc259b21a7f7d985aae81b149608140cfb6cb631ce5112f806ded2e17f4914018f468e3c379a7af73d308d1693727b58f7a3205a9ecc4aeb5b6d8604a36c556d8a87ac69bd782167796ce585ca8066cf71d147416de84470711c3dde672b74559d25d5ee59674aaad77eebb79f834b045e891481582694501f70a291f31be81fcce4ea13b4fcd4ff19cc607d584f08b821d27dcba2fafc15ac2a830f2a2a6b05a61ca4f5585ff5ee2741bf319e0491a7c9edd377fe959fdff4dd759c9b6c377a006b8c267e95acd2666e8e03ef1c6b2ab81b9a9adae7c3197b750785f7732f648bbecdae3180810d6e811fceb7cd350fe27057a635d72f83a6ca23307949f7e71d5b3a8f45205edc1d647a60769477e8daa16d05226959c668cff10147d3d1d16ae48071612bf5523fb74dcfdbc23a5fa359baac0f915e395e27898b08abd604e381bc239ae6dac6a4e259b58c9767437d05a8ec56e3689a6ebd4595ec1e08b8282d81ac7ec6edbcc0d68650d9f56f0552f65b0ce1abcd779bec44c776114e6652dafff72a387c745e3c183615440ce531bf71f74429361eb08c12cb668ec90420a68dd56de6147750f81399a4d2731edc38722f79dceb884fc0af2a866129e9783ce36ba8a9605317bb467805b4f9b588610a6eaaac9b6bf1bddb46b47d770cbc93d3157ee2d0d0b06ee6d9e29336e8cf296512cb3f9f8a3ebb49256962b2ffe877699df9e0cadaee646d99ab62127893651bf437e730baa89dc62b3e6bc2ec0fec435ba669e92f8be74fc973b0a1a7dcb934868837ed13803498df8f43bbf8cb7604e6e6be8385467a33d2dda56b83ca82bdeb885158a68a94758ae6fa11ba4ee0440e894dec96757faef55d8345c652dceacccf2f81cd1e2dc33cbd91f7681b8767019216d90a86aec7ad123e00c340551c326e93910a12ca572f3bbc54c7a95a69562242ff2dc0a03ab2c22f154c006afc095102b197c233721295b9939e7910e5d0c2754743806cc7fd7864d21aadd29a7a6eb3867ec314cb9f567e7e6ddb2101ef655d16ed3e40d103440d4777f0beba831dc5ba052e8cad433aca107ef8f3adc5f2730bdbb070072f3c0df66aac77f4be8b6ecebd76a8a678b8c911f1b5af8824da44ec4deb03c6cbc50c51461f430c5a38eda497e605e46fda07886b4f8c97ac0b89c3b5b05f223706d2cfa5d4a2c9fc1eb5fdb42065cad53d1d946eb0b10b3b879788c340e0feaed5937aa237ffce3cc4a920bf4493fb938af38e46a1f7b6c3f3c16f9a5c903e2e3251f111a412eeac8c7c33cb0b28ec840d01575ba05d1a9cbcbdc093ed6b4f35b90417913ed7425a3645184a3c03fc402fd0062561a1d8f840cbbf028e442d73a9f46147f1fb56d5d0fcbe01f56a036a182e6c3691e4d7672b9e19bc54622193e35844ce76b331bdaef9c2f4d88da2e272e3aa80bd65a48ad1c4cde77f0ad452bedc7d6683e7e32f250286fa0f9825acb9afc0a93aab824b9427fe3baec0b24a5339c7e242301b453f2828a71f9f859749f145364b84a4512225edcdebb46bce3803763e8a1e628e9d9f59d3bd3c037e79c16813190ab8ba74b7d699695bcd4d5941ba920103567c3ed1feeddf1482f26fc078788dc3b61570edcaa3be8441aa85f26fa29379f501eccad034e3f0a2211c370b36b05a4999c6407a99c879374582f25be306aab4fd605b1f5148ee2d9f235abd5e7eedba42cfb1d709d9a79910fe57ddf9b9efe374c56f8bfcd20bd956ddb73ffad205e60858a3b35ed6e20c9a4e595ce01c6851e3aba9b9ae949a7b717b7aec6c3b740cc0e723cb1814a978230482cbb26e87c4109668b6428e9014c10af0c331e8c764752ba9e038baad363e8d03ef2238b394eaba671c00f84c66e0d4f61defe6bc8b816e8648507c820aae5db31b230dbf992a7b89416c530139509fadc58a9501be8938617428d37b837021e4520fdd40423e56c65fb3503382c921afda0f8ee0a89223113cb59bb1c3e104d7803441055c5616962cda0c646d0999bb35d60db39509ff1b80db97d42451d8b3edf8cfbec985451db3e4b2b5c345e0322869a5d3891546af0cf3fdd6adf7254dc6be6f4aea9f204dd4c91aeceb6c8f02463c143423bb8b54456402247189a9a6a6a6359cce6cad15dbc935b1e5de82c519f5289a06acd0396e9c14fbacf623b6f005c5d40ae39a311da900cb93d2f31260f8ab24ed4f7dff1436de595bd8c84cee4233e1cf8d98f09ff809810845579a05507fe0d806af71972492e4a32b76ee6cb070204fb74f303c0cd15abe53fb1500b43dfece95d0c945ba0e3560fde228ae0796b4e9d94ad1e8f34bf50f800a3d2e06d57165ddb9829c1748f1b41fd7695ad9ce877e4206413f6274cfb04bac6b2b65a668fcf3601e0ba83cc0a6d3efce3ce07c23e0d2a956cd2e076c32240df39917c4bdd5b33149ad20c3776dffe8718c974a598babacec837dbc1bc16701b70a41f2553d4c98bdf0040ff2a655f665d31d25a784fa88ee6ce3dafa279d35bb41a5f57b64848a085c8c9acdbbbbc7d5957f10a46742217ff8ce0dca4c2b73507bc17f2dbf144fd460e26136708eb7c958f5967f61fba72b21984a2efc7702fd4c2905611bf244771562bd1fa8ce5f68970828dd4db4ef33732a104c25941f888e48888f72cb95c56935cfd5d000453e6b1ae83086488abbdf5c1e14d8e4a5de91cb8b6b5885938a3d1453fc3142dcd37dae03eee2536ec5f15892adf46a54522d16e3723d226b74a71fbddd75e9f92ce312bfb148d47efdba2f8752fdfa8effb61b485d807e38033d4d72c4973adfcdbd6811ef32bc954e35de306ec9df3fd73da96db116717218e8d9c8c654fbe01db5000cbaa4a84c87202150165dc3eaec22a2b6ab73260d979ea7027ea33ac26368bd8498f6fd081d437e270748d215a3feb6c1cf73eeddf9a2e0dfba9996bb14047f80ce610c7615a6a775c6b6a8c2b609feb570bb4f2833a56414bdf929049dd1698eb18cd9489e1117eae43fbd6191620697514e9cea8f6cf5c08cc271b807e36f997ea675c685093ccaf6a34bde46b0647bc3f9d103adc577d46e1a04e11a38169d753eefd8328f7a7eba4ed147e9de9f586d2447c67ab829b2a4ada9019f9a70009f1d5ab625f6059ae96501d0c3e1db8294a93f77a9a7862973736946e817afa0c409d1829c575be947fc0d546f4ecd7078b63bb02ee8e5b7bcbe0a9338a59c1d93b6ce5ca2220c7b04adec4db677816384cff3181b028edbd2bfd03c9bef8135be591a718a21efcfcf4f9047aa75ce62eb9274ed8fe8771a470fb196fff9a1ffaf518a99d6842fee62fcc5e0f43d5d0bc956bab4175998073a8b79c95c1f7472eb06dc497fb1f789994a501a1492324a110e7503086844e4e53586ed16a5224d35fd0e8835f1ae6346cd1f9a2bcd82ae715b1d09bf40896aec596264b2cd98e30228c56ade06fe49735c1990764b162abe4e594ff80eb5419bfe7bc8f801bbefd726ff163b67fddc5eaa399f945f08847984d50ac48d5366b3450f9ec1dcd11b0690a9371836d895007674ab4dca2e6211a11415832e06d5c43cca7a1a9dab969b6d01f064787a5e402156a5591549d4d8ead95d456b4c5090aa5d441c6be97964605904b1febc0bbb6591f51ae3c4985776bb336daedf51d0722197b8bfed645861a142d751a6814b11becc86933895b8b45382b102f9302d4d9c281a9f0432ffb72c2114a8a859f019a9423dceba9db4c45973319fb5a024c6e82e8f5cb9af298d8dcb6f47ea750151b538bcb2aa0e2db6b85369454ae5cdd0fe40cf569449ffc336a49ef9114e737e064f5de4d8d50e97b21e88528563222fbe9d78f25b9cd221f297c5fea8fb056a936e8f83b9120b0af8246ba6c15704da03317e766a94d4ed72468b3beb2aa20f7291add0e6ee3c4034220750d7162cc292853749cadad6453f68b1b81e1f1b5b795004cf0981ca3411e18f7743f0c6469217446de4f185ccb74cf7cbf07f079ce586eeafe1e5893e4123bef0847988a5c56036680b5d7213588b95e5d3ccf89265bede492f8679053363147ed24a187b138ccf481db6f34a56e069691eb2659a59f555343627dc3919647046c6f2740d24696f80237a7a8fd0c4b3242b2f35b1aeead274c0e3cbe235e22b589005257368e36969fe4a6e42f7063396a8f8de5f6298a34fee5a085ee497d4abbf07ffac4bc651d34878ae3ef7c5dbfe9ab007da15766fc7ac7fb545f461691ca5a2482692567b2ec2e1f6bc26d3f18f0cf9bf1867a24d126f782799dd7c75091551b508c386117c5b5555a8f9c9799a6ee75014267cd7efbb8415f9d5880e687ba25c4ceac7c1be3459a250a2f5c37288d973d9a58327345838424b1a85192a5d4e9a38079ea7a79c52ae07993794c24ed860337ae087471eeaca914875f52e6b713f716ceae6f3a314e13a3bbd3129eb22d676ce647fa5f43af9c2e5a492b39f0016207fb1ad928e9d98fee4dba19dc19e037ed1f4629641dfe8810f84f4d19d44fca78bbe0c8956d5b30f109a71e1187e88af178a4a234caca02acb703ee2513f34fbbb4959d18bb2331d8c2e46431fd43c365856062e5351582cdf4b01327c3a79097acb1200246cf149ca888c9cdb03b07d2775c5ffe7631506206aaffcca3be679d1b2a2393f36cde1628a0b5b83c74aca86130d8a3241ccb42245ebae93637a86ff9d4b1d8357fa925367d76613726856259394dc0248db2b2910b419e3fb9aa0fb39bcc1b263186fb1713438dd3c1a5081cf7b91ac0c170db4eed76d5e97d090a3a1e43d0744221e95320c251c6aa7df8ca0b2f9da7affdf19e3d064639542a07c5e4850b99f17e708ae93b2d65d9454852f209dbcb1571de95d300b693706abe80899f274943539afb58db18fcdeec3c1f8c3cd96b88435ab6a1cd9ffdbf1692a0a2d6f02decc35c7f82228e33bce53c5d5152fdeb515c82587c0eecc16ecac94b7dfc0683d5e186052e0ccd0cba2bc0490a9c270915d2dcb59d7e5051771804c4eb23b0a74e01fc2cc53407fad9a01502db4f44c565dd7ba16e5f75be6638791cfa25cdde7f7ab823a9d480497b8061667ae723cc4327d6058bb7d26eb23c76d0e6b970163a8641c80d26bf9d2622df2cfc53930c41582715c194db73e698a3b54f4887811223ed444d82c5bf1b23637de860e7d491ef26742a3dcfc3ca65c3fd6e27e4c3ecaaa4347d0c947897e84da2e09eebd91cf11926759625863f0498f6a5dd54491f136037a50fecd4074ed3f39d3894ccc7b7a26db9dc0d7029d0fc55d8492d262efb4cb42ea8487c4716f28b780116b75c58237d4240ca9d78d2a05c996f83bac5ffa9cdf1da7cb521f0831c8b47b4294b3ecd66a3bb6f9ce5d1fa775e94393e84af1c449108b0180165d328eecd4be5cf4756e1e6ff1dbf582a70d09c88a74721133b9dda321a96045a560a9c1665cfa4f4fd24a712547b564410a61d4dabfd6d8645e63ffce9fd2d133a86ed41cd673a947d1adbe30dd9ff80b1c1766138cfb72ec9496aa2fde59c5b06e28440279ce806c1a3979020a1f312286e635e36829cd52c683f8b24e3c4b5524541069dbffc15f3ec2b030bc998276656df46d8bc03453d47dc36bf2b51af1a8ab46c37c20dd8c346903bb1eca2df61725fbad728d706fcd4dc5272fe5bfdc141c9c3814aaa3e286bc107989df276f5d51e4403d99d90a9b7d3985a02d5b4c8b2f473232faf6beeaff3eb6166891be6cead39f76d49827d558ba4460a0913b25cb233d18a601d2e6ea13569a7a46baf3fdb3f47667f7ab274316193471ff97b5f9a3854599403f1462771bac9150db7eebb078a6240ddbd3ec90e056f57e6f3e18d68abba3398e18f308499b0cd514f22fdc42601077777b6e448c8d3ea3f42903ec8d83cc5b031a96037079d2d3536cc81baf6ca0ee5d4142b65af3907a49ec1168888d20ffbd57b04f5b07147649d17ae4a543770d8ff30652f657d60be751b102387c394d8e82f61b578f00aabeb3c1c979cf534dedaa4acf1a8547e044b6b0de8eab099acaa4487e9608e9c858c221053cfd64c79d5d2e2009278b8d2bf14396d8979ae69569ba6c9d9b51eadf09356945e17152599f7dbcff3053b90d2649c9677a1070e869c794e2598cbdb0f10983c0c74c1526c4ac2c93f3edcd0cbd30ae5fc1cafc73816071ad206ab7c0c9df7613318e2bc515dba1179d57358e98957d192be7698b1a02bb6596cc08cbf8140d7e503a6a782f720c0f5ed42fb1662b260c57b869ff2ecae57730dd1a2585acb646870cf5a11e807f20ccff28fe4728583d02e2432d5892a0f90ca1c97cb460afdf2d4e088403ec9e3d157851ffeedf745483e75510b3903ce8fd498b8d973c0b7847aa834d14689b51dd6469a470c5eb5da97a6638369dea6dc56478daa3d99cf28a9fbbc735db128b05e9fa4be9e9803f512f8322eba4c89529998bc20e14338eebe1acc6eaec13df0fd2e3f5daf62bdaadf86c42a6439dabbfc0b78da4f6b434a686e55592597adc6696c2ab341896a241cd734c0a76454b4f6124de33154d3628fea5c2d565f6fcd3d20c0901814db599ecd4a703c34170e4823ba8bed89932cf134cbddf51c795a13025e5bb48425ec88cff92ed201b478228120f29b02741293a948703217aea7673dcbb34843d4eac292dd567836f226f39a77c4116a1dd95da75cd9f595eb7eece1220d94e9742a7a04bfba2f37ef15a04f9a251f1a2bad369dea8cc63f59364f41cab35059b67be949b87278964dfd0bb5e341e65f713e98bf546e1bccd0091414eaf5bf2cfd3e8118f9f6c1fdd6fe20ba8d7056aef01d056c390e66b594d04d7371ebdd7a11d7126186cea8b12ad9ac3f353835a3338e07c2499953ec4c43230686d18d6d31e1c69e6e6bec3863e9338838f135343a0f7bdd338d3084d41beba74fe381d221da7f31e0e0346bebd327fc5db20678e16baf0461f3f868ecbfb4af25e2269728c0a4b89c57f5e6fe3bb24bcf3839716ac4d01231553684f5445307a3c9937ab2273eb6c6836d3cae74f439e7c9ca7cfdb806dda99092000ca3570a4e6a0dc923522627c6ca4e76bd66203218a3c689de968c26c26244341d9b58ca75cf13f3109c249b59a6a16ab32df4491f3695233870676e6220d0b7fef6a3695b70fc7bb14337798e46b6637e155a8b2b04b9732bc6ed9ca8004081b5e838dce411124eef5d125df918f79a70fc7b50202b9ef2b535c84308da171b19b5d4c15f8a41012b088a8cee5a1cfd471af3f3bb550dc06c1e40362ea7202e89688048ce2b9fda6d8accb63663d2dc6fd8af8f4d89a269ad240ae7073fa57f2f8f185434ec79d473aa53c79d53e797a0f3d64f0232a5bec8af58c039c66d25692d6423e20b2733692519666d4117aed1ad166ba970e2164b384ea3887873cab98a1fdb1ce45dbb920404cf0e99dcc373a262ddbbe9b6a67a02106c24e647ebc4b14ea68d0f7df44f943db491720d51cb68b18abe1eba9b4d4f3e8e9c8acd034d55bda1ca6a9489cf8812cbb9b8b0cdfd4515c6cea93b168dd3be197048ec91f2b6449acc4af65b0c91aaeb370bae7378a66096cc7c370b99cffbd66b72a27dbb839daf5f8eface071e8af1e8a1d640ca30107269230c9402bc869e060093a735a66d928fa0aa011a185e8282c96ec4097256316d213dac6cc4421cf90f4fb03231bbd79b7dbed33768c3943092c1783422a167826080c70806f470ca69c60b78951a40efa7d1543e6f8883551a0ed469b274b16e828093d60ceadfdb9b037c9b2658154e32d84f5e9d2615755680cab2490128feb4f8c2cde480e8286786568815a0a51edd3f2d9ddb25e224ffb1b851300e95d1b55f2987955aee1eabc7281320df35b597f74870eaf0933bb0c39ba983c3107b7db4ed3eb99c247914117a0865c38dc3b9d26ca7e035881e94bd8cf37c18db1e19a48bd85609cdf3b5693173c414c16e0fddd162cc7fcd0af6f3522f47209d5f79a5ebce5f9f111e8e8d8af353e1ceda88c8f4ca867c835fd5fcde759b769678cf24e44e823ad085bc702b1aa93cc061c849ec631a3acc94c7aefbdd9880bae1b9c413f33131c9dc5020d9b41b522075cccf0984b6234703726c090869b05bed56601c8c5c7b9cbe5d745a3c6426c370ba4e31714e75cb40d4e81675657da7289e418844171cc941c974884351781b577f4affca6b5fa7f6b81e4fc33978c943db26821ee52f5ff6303a36c77496d83aed59b368b501705995e119e0d53daec08356a4eda0a881a906d1a6659849625fbe5c8964c617c24b1b53a2fb1f009a269d556b1df63834b59545781fb0df58ee4905b8a28c6a70817d40427f2441fb63de37a1e98e95b68d94d1beda00b52d449fd89f9245284b8aaa4ae88f7983de85c2070831a71656b7048b79daf3bade10534b791df019d9c827ffadf206fcf6c571852fa17d242b6c419ed3c371e67c429d0137345f7976be27a52c3c79b19b59aa3638781d5ef3a4b9544bb2b0b18b113761d8713bea430900f516fb112fbfa42f38e8520e7f086edb0a89c470ee0a87a6ca06a29522989e770713fd41c4d3d6e8332dab9fe466593eb426dc2667d4005f848276ce84f32559a291c4316c4f179cbdfb51b353486261c01ababf9cbde25ca333e87854e667cd81b73d72abdf3e935a3b626da371b166afdf5d2b146363f7922fcfea6a4b11a076d9a0ea675bb7783a224ebe562f1d5856b277324ec31e42fe34c67d3d716ce6ca547fbbb77a99b18e5c6aeadfd20d3e3db52a4e68abf2ffd336b4c017f26ce911c702375fd547bb1894d943b63d30a54194437437553ba14dc5f83e093a15252a9a1189acaaebf00c39e0ab5370147250343bc8ac32cb326bad7ed9288daa2cbc3c5e969c36233de0f37f56db1173e53d0a8b4f6583a1e2ef7ae24e3fd5e4ea0d220149d2e72ae2d83d0e75ffb69b892d626da67e0157956cb7ccd3cd227d117ac9dd92248afd6aa73c0393e2c81b2dc9822002ae3bf35f5592fb6de6e968888f174a04bccf5f9a81b4bcdb46c13a02b0e5122bd2490e207813709d8916caa876072ca0f68c6e3266150e6499a65c49300f5909dcf773571b548a7d39d5dd44d40f75f22cc9062dedbf6266573c843f860b64a92c0629bfbf6fa707203d9ff64635a6c600ba04ab063caa1955012220c3a9c0f8bfb014fdd8490d1b286fa6e28e3dda0c4d17e54f7eb266b098f76886b7692d3efe1ff591bd63495490c9c8328731e03f032d527eb183b7f52e7eb2c5684b8aeffa7ed7a98af5b1f1d122b74ed70a6e0509b4ca05336f8f30a524808734dce83d5bb67d963b587d81edda54e3506ef8762e34da9752d9aad814c696d369b2485e0679b2dfcfef8f98b85d82c7fce609d66eef24e09e8e1640dde9b2b7dcbae7a7579c5181c714cd3c20835e540862baf6055f569285c11c96328a7755e87ff9c0af65f971da3b30817e0b311e6f3c4c98cc34be20a52e633911e5e6a05fcba8971bb4e8a5220a9da7800eab954467e73a15bcfff1030ab26f452bc3e251d8993d2354490a6cd59520b166d59b065088d6568b2918ae43d673837dcc6ade93ff3580876d91c71632cd8c1a34a725ba5dd31c6276d228642383cd1a1dc6b84ae0681b2f5013d8c53f45e902f89b60f598b8060283aa4a7bd3a0fb7c69a7d1e0949a6c79a1a3bc40506bdf9ad83eef3771f27bb5d057f5053ed192c7fa8b9ed6e4067670affc28e7c3ecfe546c43a85d863a273e43f5e34ef6f726a9071fa96877d73606c6c010937ecb0c1d968a52b6784ea2653fcf498c7ec03a58ab75475649e8beaee4627d9128a7ffae1c5b34741f4d1af95f6a5d05cb074f9b8402c85485a0e69d888bc0f9f38f91546d19d088150dd7f2542a7c03b96d8820d63d07778896a90db6da3e464839ff34436362b3b0dfd42dfc0a9cb4ce8e5d3d30e2de37099d2cf66cf81ede52be4090d4b6167d67a16348d55e49b9110bf407f7f74d982517375c96b4729a577417da04057e78172dcae1afd2896d8358e661c69ade726f260e0eb0206c72652f82b9e674c80e4912abe37529c0e9d2b364667784a9896ff974817d0847222e4f85a6fdfc610b87050f5e9cc450cbcba58e3625dc8d38a2023723e800077f7b214f941775f8712145a7b93a6a3fa6ab3aed70adf64ff27d32b5761d00ad3094198e9f5bca067983868d1e4f19af6f606f23927eaf60dc84090332533d93068b1dd2cc72a43e9c7b3a4b3293676302c11191f307f269c0ad271f476cc6b1caa4afadd725d0804d1d9383d934ffcb76ca9165bb7309e9fa36c252f63af106fc55b5d594aeec6319591f23f85b9e7f36dd5aa64ed2fe820e4f5a8fc9c02e7bc786fd514b280c5e8f97d785b9a4e9901e9742dafc58f4686a0b16c7ed94f12c3cfafff8d95fa78e12accc2da5e596030f45106a8a5c59e333bbb5e7f50eabd50e167dd62b562afb48e8a985499c51663644d949fe9aa8c7f1af29ed22aa14547cb2b8ff1cd2be0174cd6668efc7186e8207728089599061aaea6491fb11de96887974e6bf4c1915b3c6eb0e25727314d41008a96bb4c79e91ec2b9c9c298450e5658c5a707fa781e814e9d75a974c3c4bcb2fafdb9ad2f63e1808e0100a9668ecc8ec835cf470d6446be0636de5d9fe5122c91a9daddb1b19bd10dc9ec1195a11b98d3c68a9e67f7605224d64f7c4fa9ad874e9ae9ad65c5aa77dc8c9e4d1cad66c95f520563f53352eb951b126f62a5570759d940c91921f6eb5f81281407ca77841c71f0410240a76bd89ee49e2a55f21520944dd24f3c5caeec4ea7fde37fe7c37b36a18d2dcb071f41094ca6d2f2a7cae494fbddec3551773ddcb00b1bad994bdf040de098e6d9881775543cca9c68775501ac90a753ecfb2b33affeaa37ccac75d4c5dcf2bcf47c8fa570ad644b4890ec6f403b13195f03a37aead962dfdba56bbf0ee15589497fd0e690d52e85c6e068e62f84c7d63fa42d93c27413b18074a3669216d06ee856bb930eb379e251cbb95c18b29e378189a49d690ba89ad89beafe2cee5b4e0324d1b5295ab07b49da7659a5ec840750fdc0c95ed6159b564e49707e061436fec43781569ca39609153e7d0563ee7835d2a0ed6c93ed2cb57d50d3d68a0fa762495a78589f2c395beea3ad33bf05e11ba71103426bdf07cf134f9352aa142290385fcbc969d5db0bac0686a43c8f7c0591cc6a40def0c4793d0485cf29f8c4c4706d83a4b6f3f88af549651ceb169a6aa7862b708a4d4efbec0f60473efb65170600e0b6d488aeebc80131d93f81b9be73b721d2d776a551580e3c9a1739fa0c5879b50c08b6a304df0a1395b75c99e9ad729bf7a1e6373182646eed122c9b4eaf82e0f38718b63715a358856cb3a8842063b8074e50d51e0537fa064d759649d964f95ccbbd7a8f6b2c6633c5bbf7cbe2382ee7a25ba76a52359c504199e7458c677b94bd4ba182dac45160caf01abd710b58738022378b1b77f0bedc453d02035895d278821e002a87e15387d0683fcc2a0051a28940d5b860842128d09e96d98fa5fb1d6072c354ec28c31f94a258f1f64177f910858d404c2fd83d343224fb11273e89126c971edff76645029681bb812d93b553a22e5baf943a3ff7b1daf26ea2e1b75a5869bf61d6f30ce0c768aa1e57cd025b385aa5535bac04854f157f4c879b88f2a5261fda76333d76996bce80f972529da977e159804f2f0a4f7270ca27f7da844f8e84b9ce1320f6c9be1a7304bf009397850fb6f9386e7012cff53a20de67e19149f6642eb0d8f27872ad1c6ca18e7bd2502382f8ec9aebd22206a620d54b7a943c0ee428e066ef5878921f2a7c16be59ed1cf441a349875808e053e89c724115773b6edad53cdb41f2a75694776ecbdcba9ed17a109bfe167afb0dd7f4a63fee4c5dc518fd09f7237f5d61ea1e92722b0666902dc11597ae9e0c0177e0ae1ebc1b7c762ab55ba099122e27f20d60019457002ee0bbd9d86efc5cd8ea12ff98a2a35b7e6441916b90dbc61e15371f726a2b227a867fa1997e69b8ccc56d120dae96b315f88dbc5be971aace2bb5b98adbd72ce7b68c43a4b4aa0e0a04b35ef8d1dbac87b99b7ac163c413777de2aba6a067fabb7bca2085802f11afecec618c98f3b885a988255eccd0cf911a8d33eeaef4833954a23ddc98a92cbd9fd3ff8688b94621837f7b11f543408553837ce9ea86092108b65f77d60447df72899b74cc9cd6fcb5f4faabc05854d0cc508fdfe451a4149443aeb9aa73d329507f3d96e1c589d774ce4901bd138a6fa950b251c921eaf55867d95746e1d0963af63bed836e2f703b26fe1912325acd0a56ab2e71b3292fc66b5f72fcf2bfd5b96a56d1d85be249fb20623673f0485ce708ac2cf624da7a413622c36793f553f4770203391dec4b1c3c1d3543dd556cb1902732c5bbbc048457ec37ee4e5bed6cb659b7f9e9d7d2af44f45401242745768a30caa8adf7fcfb9f8d6db136f1987772adc23a4ff12b631da2d375291c4b20867f6d1ce46d8a6d397bdf213ee012424fceb2942e94add0748f3dd2064fc7fc4de95953d4d17682a5f209bcb7304fa6d593dfcacc39f9a1412bca5b5cc7b180a5e0dd0b52348e7f49dfe6f8fc41eb28ccffe92e40387a22e3e0ef9114f3445ddc02e7049e650158e5575fd9ee8571a5cd828c19566086c72934d65df18f4116063f56951c60cfd6f0f47139130119299304f288ce65259cc75cb812904d0968e00f94b7b68a4bf3156639126af4b3db5704eaef4c9438b2ac9831a8bfda487bd7459a5135a46e48b169d730aae5f60aa0c9d7aafb89de3b5219d7d542d3a081a9ae80b86c1a88b0ff2a21bfc78130ec2190f96772f4e6f3cfa51ab974935cf44efef9f09955cceabf44d6ebcc99cb515f6f75e563652f8857016b19003e2f334a4fb7cd158fa4eefa686886561211b5a97cb1bf59369675c73f3d709d16e0e51db0adc36c1fed988adaf6c387ec77baf0e698edd569ab2bb17e5167188373516f8b9d03f887bb8050c07d21291e17045deac7fea91f90b4d278986a2bbcd8d4a589e9c64ab2d6c564ab0d54d4c5ed66e7d5f910658d984bca37460be816169b5b8d243152a2a3d094c13430a7d13c7d055da71890fe6fa717e59cbde8a67a84af4dc353472a7793913bf1a9102dedee436a1503951c4abb24c3141c7a645a47a01b3cb5c16d231d5c483dd3c9e4d958917437f1ca681fc87af5b53f2ec8f945b3b04bc17bfbf54077ac24074d4fa857e8a3b1bb5fa311facab00d93051883611279ac8709ed90fe7fd6bb662ade809164f172a7b41f60186abe9632e720ec512d2f125916fcb38b28cbda4b27118e43c12cfe79b7b0827edc37fc91fd44b6ac81bbf74f45aabad0592f9f4a46f7e2548729a8192c2610d15540e07da80399c007f1ee97e2980c4c24398694448739077a3928e6864a1892d81fd175d67742597f0e8521297847770c3faf2374f2adf732e79cfbe7fe42634d557495b6b027307cdcf3f57121f4c1780c538dbd71a7c20d85cd1ff74268dc608edaef4694f36786b619dc163f3b8779546a267e3a83a899ac55bc56c5b0e85075a35e163728abf2a0e1f3533afdf1b9e5e4d1188145a9bc7912f155c02a14cd95b7f6ae21d10637b1c4859a1297455d4d7b15665d58fa66bb17ca5ad60c2e1e77c681f357f24274cce96ac84a487ac4bf0fabe5dac89baeb19d7cfc6b3005504c2ee008e08b64d4d3cabf1f6c12838c1901b04b7f86d1fb16538327e154fb90a848400436c72e6f62426bd9abb02bcae2f8bf8507bd313ed249f60504052b7a6ebcb4be0aecf5c832094cb0fa87bcd031752b27917f75e91b8950939deddd204e02ae8c13528437999e592998cc68da314b9595c9d3ed97854cfeb0a3dd828d8127e68616c5dcddefbabb771f45c83e32ba610062572a78d795b4cc6fd66eaa4eea57c96870b1f1f935951aa749fc8a04317c31eddb4be6c6755cc444e67c56e1a072327f701e749a8db1d45781ffd52623ad6df8bf79982afeaeb03538907723f9e6ec049e01ad20639e9b36988b32abdc43cee00f2f9b0d70626a537f7267bfe4af945079df964c07cbdb3a5e04508e56f808cf5e0b706f0297bed63905639052ad20b64b58bb1bdfd37699b2a48c9059a5506a33eebffe723c94b164a20f89661c89fadde2d9e32a49a5d36fe62c5b5e8b597aba589f9e06790c4c1c1cc5bafe23a20e0fa2609297a756e68624369452b907ff5cf09f2bb95e3e041a3ab0ed110a36d300e6b2d4b427cd06bfbdb680a7b279e0bea3d763be7fa44e42a2d649ec669897590b68517d6b0d4a36a09fca62cf8a74d9c7589097e340f62e2dceea71d8f3582a8710a7cf5dd79d36591dfd62edddb9bcf2bfef6540797d353fed028866bf09cbb5794218c6ba8a662a44707e421dd3d9223db5a48dff714bf15a1504e1638054991d2554ceb8d7aac7daca250a697e508a11da38a70f4c721d19af4c66a7d70d34225aac8f59e339a07a9146dc9fc33445f0ba1777cea284855121dc77101149219bbaa2b8db396ac501b3c293127e1a74cc2edae1434597de47020afe883136f67e3a002be6730d30f0de10d9b496294b3097ee462f16839ea1c730d2b3c4e4327acd6a6448a90746e9815225be2483ffcde702e73b1565da40c8fc7dfd7cb5adea00b4b2a096b58ef0f8abfe8659a121a55d813ee6bd5d002a012ed480ee8b37ec2f55a06290bd6cc644fe86eaa5fc51e70ec1141dbb0c55adbc44ad45a5d092d21db24eed48255aef21043c9c69f8781504c699f5fcd0f248ecdab6643967ea1de8157faba908a34a152b914bc34423fd75be18bc88fd82afc485d492df0d0bec5af9b8f434956d11496ed805fe933b8615d1b0b347e1edcafa32116d859f7ada98c44bcfccb99cc734d757cf6ac5c710cb480df57dbd4ae9eaf93d5afea172c874d9e92d94cf195a2719dfd524365810c35d2ed30c0b6052c5859aea4ba7d6630e5ce570d7aa8f68ef50a4811e7cf01faf371466d7c510cde9e20c866c2e4ab3404955b94d9f49c0f9836f99dc7318131dc718535a85ef10ee410e01be61158a87b26c0146140154072246fc44d172b46c6d37f4243714a5c5f0c9e410cc7b9627a4d0dde1aa747903d1a3c3166244b3fff2c0f2052167db8c29406b5c1c3c5d39e6283f9ba9756364a5e0ed2800a4859fb35b920e057f95c2875222d335a3037b0ded5c7c3b3a8942d952ffd576589d6f5f842a6b386c791a99d58987a1b260dde200aa2386c3e6f962d1f9a1e8d43afc6f8feb639cee6c14b65aef0d0eaf794cac9784fa1d8ae729b9eb2165ba547fa39a2cec04290763809ee5092c13ab88afd63421951625373e008494d0dac68a24e00cf9eb7d926384b37f7f1269a346eefb98795519e8e4d7dd125684e0e0abc6f569dd598f35e7be990eae0500b7d4c1ec35e45dad638eb60397bd0e494243ef5c2dfb932b6de2e2f8bf8524282301ee8f235b808a8196cae92f916b31be391478d57f60d92cce32b2956fae4a652b1aad48affdf1f439c5dc4c28894e8468b2ad7c097dc9d7411c83a1e9eca88f317931e52cf0dba92a398247689671d816d1e6a9299e14a30312c079d62e15ce032a775195e71a3c677ba047b257e6b724a33d723d4cdaaf5f67642cae85c2c807baf1b16a2ab3aca901f8854ae6eacb779d7d4dfa7a912825288d16059f49f82c20be93fdec26a3bfe05d587504d4427c850290b38659ee8041b8b360e0dac2296756c3099e11488c30617c15741bb216155ec360500b0c10845dc0b8df06128a58a5e24a4e88ba11b34d36f8f1ea34f34312167944c3acc8fa4b9be6d3ead34d68511b92ea33f7cb90385eb98f778394c6fbf2411281cb11ed2f96db4f53fafda359ba68ccc604acb7a397c9900de254279e65942237dd1454f6112e458d253310eaade27700f60107da98d6412dd5c8aa189426661b35fef7ef81369417d8a4885894d1d611b7f5e9faf9babd2c54dd1932cbfa395ca2d1787058dc50868c4dc50f7491496a218c9aecc7ca9fe039ca7129d8c58062ac79c1bc72e0e1a8c03fc77865ddc46dd023ee9d1ff4d16dbefca7030e1570d172f00eec1cade7d89da633a2374e43b39a5c8704908757434566c857130f6dd3cc041cb3b3ef168cae9b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> SRE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP发展史</title>
      <link href="/2020/12/23/HTTP%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
      <url>/2020/12/23/HTTP%E5%8F%91%E5%B1%95%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<p>面试的时候提到了关于HTTP协议的发展变化, 没答出来. 只记得之前在一些公众号文章中瞥过几眼, 现在来做个总结~</p><h2 id="万维网发明-HTTP-x2F-0-9"><a href="#万维网发明-HTTP-x2F-0-9" class="headerlink" title="万维网发明 - HTTP&#x2F;0.9"></a>万维网发明 - HTTP&#x2F;0.9</h2><p>这玩意就真的算是HTTP协议的祖宗了, 这个也叫做<strong>单行(<code>one-line</code>)<strong>协议. 他是和<code>HTML</code>, 浏览器, 服务器(<code>httpd</code>的前身)一起诞生的. 而这四个部分其实就构成了我们熟知的</strong>万维网</strong>.</p><p>那么这个协议既然是最初的, 相比很简单了. 那么有多简单呢?</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure><p>没了.</p><p>没有MIME信息, 没有长连接, 没有缓存, 没有cookie等等HTTP头部信息. 那么作为他的响应也很简单:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HTML</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Content--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">HTML</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除此之外, 客户端和服务端均使用ASCII流通信, 当文档传输结束之后, 连接就会被关闭. 有意思的是, 这个HTTP 0.9是个可以使用telnet的协议, 你可以尝试一下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">telnet google.com 80</span><br><span class="line"></span><br><span class="line">Connected to XXX.XXX.XXX.XXX</span><br><span class="line"></span><br><span class="line">GET /about/</span><br></pre></td></tr></table></figure><p>接着就可以看到HTTP响应了, 只不过是使用的1.0版本的:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/http0.9_telnet_response.png" alt="http0"></p><p>而且能看到, 我们的连接直接中断了. 由此我们可以稍微总结一下HTTP&#x2F;0.9的一些特点:</p><ul><li>只支持纯文本</li><li>传输结束之后关闭连接</li><li>无状态. (HTTP的无状态性的特点从一开始就有了)</li></ul><p>那么你可能好奇如果出错怎么办, 其实很简单, 返回一个描述错误信息的HTML.</p><h2 id="构建可扩展性-HTTP-x2F-1-0"><a href="#构建可扩展性-HTTP-x2F-1-0" class="headerlink" title="构建可扩展性 - HTTP&#x2F;1.0"></a>构建可扩展性 - HTTP&#x2F;1.0</h2><p>随着浏览器和服务器的迅速发展, 包括HTML标准的更新, 而HTTP0.9的协议成为发展门槛, 因此人们渴求一个不单单发送超文本文档, 还可以提供更加丰富资源类型的请求和响应, 以及内容协商的协议. 因此在1996年成立了HTTP-WG(Working Group), 于是推出了一个草案版本.</p><p>从这里开始, 我们需要在请求资源的后面加上协议版本了, 并且从这里开始引入了HTTP头的概念, 我们在发送请求的时候加上<code>User-Agent</code>了, 并且响应结果也得到了极大地信息补足, 一个典型的请求响应就像这样:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.0</span></span><br><span class="line">User-Agent CERN-LineMode/2.15 libwww/2.17b3</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"></span><br><span class="line"><span class="language-http"><span class="meta">HTTP/1.0</span> <span class="number">200</span> OK</span></span><br><span class="line"><span class="language-http"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span></span><br><span class="line"><span class="language-http"><span class="attribute">Content-Length</span><span class="punctuation">: </span>137582</span></span><br><span class="line"><span class="language-http"><span class="attribute">Expires</span><span class="punctuation">: </span>Thu, 01 Dec 1997 16:00:00 GMT</span></span><br><span class="line"><span class="language-http"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 1 May 1996 12:45:26 GMT</span></span><br><span class="line"><span class="language-http"><span class="attribute">Server</span><span class="punctuation">: </span>Apache 0.84</span></span><br><span class="line"><span class="language-http"></span></span><br><span class="line"><span class="language-http"><span class="language-clojure">(<span class="name">text</span> response)</span></span></span><br><span class="line"><span class="language-clojure"><span class="language-http">(<span class="name">connection</span> closed)</span></span></span><br></pre></td></tr></table></figure><p>可以看到, 我们的响应头部中增加了<code>Content-Type</code>, 这意味着我们可以传输纯文本之外其他类型文档的能力了.</p><blockquote><p>其实HTTP&#x2F;1.0最具突破性的更新就是引入了HTTP头部, 有了这一段数据区, HTTP被赋予了巨大的可扩展性, 协议变得非常灵活.</p></blockquote><p>在返回的头部中, 我们还可以看到一些<code>Expires</code>, <code>Last-Modified</code>关于缓存的设计了, 并且我们在响应开始时发送了状态码, 这样浏览器就能了解这次请求的结果了, 这样就可以调整响应的行为, 例如更新缓存或者是使用本地缓存.</p><p>另外, 此时的请求响应头部还是均使用的ASCII编码. 并且此时仍然是每次请求都需求一个新TCP连接, 这是十分浪费性能的. (参考三次握手以及TCP的慢开始)</p><p>注意, HTTP&#x2F;1.0这是一个实验性质的草案版本, 没有作为官方标准来使用过, 因为当时还是有多种实现方案的.</p><h2 id="标准建立-HTTP-x2F-1-1"><a href="#标准建立-HTTP-x2F-1-1" class="headerlink" title="标准建立 - HTTP&#x2F;1.1"></a>标准建立 - HTTP&#x2F;1.1</h2><p>从1997年开始, 为了解决1.0实现混乱, HTTP1.1标准发布, 消除了早先版本很多歧义内容, 并且引入了很多性能优化的特性, 例如长连接, 支持请求基于byte的范围资源, 更好的cache机制, 以及流水线(pipeline).</p><p>那么现在一个完整的请求返回大家就很熟悉了:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">$&gt; telnet website.org 80</span><br><span class="line">Connected to xxx.xxx.xxx.xxx</span><br><span class="line"></span><br><span class="line">GET /index.html HTTP/1.1 </span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>website.org</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4)... (snip)</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip,deflate,sdch</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US,en;q=0.8</span><br><span class="line"><span class="attribute">Accept-Charset</span><span class="punctuation">: </span>ISO-8859-1,utf-8;q=0.7,*;q=0.3</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>__qca=P0-800083390... (snip)</span><br><span class="line"></span><br><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK </span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>nginx/1.0.11</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Via</span><span class="punctuation">: </span>HTTP/1.1 GWA</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Wed, 25 Jul 2012 20:23:35 GMT</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Wed, 25 Jul 2012 20:23:35 GMT</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0, no-cache</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="language-yaml"><span class="number">100</span> </span></span><br><span class="line"><span class="language-yaml"><span class="string">&lt;!doctype</span> <span class="string">html&gt;</span></span></span><br><span class="line"><span class="language-yaml"><span class="string">(snip)</span></span></span><br><span class="line"><span class="language-yaml"></span></span><br><span class="line"><span class="language-yaml"><span class="number">100</span></span></span><br><span class="line"><span class="language-yaml"><span class="string">(snip)</span></span></span><br><span class="line"><span class="language-yaml"></span></span><br><span class="line"><span class="language-yaml"><span class="number">0</span> </span></span><br><span class="line"><span class="language-yaml"></span></span><br><span class="line"><span class="language-yaml"><span class="string">GET</span> <span class="string">/favicon.ico</span> <span class="string">HTTP/1.1</span> </span></span><br><span class="line"><span class="language-yaml"><span class="attr">Host:</span> <span class="string">www.website.org</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">User-Agent:</span> <span class="string">Mozilla/5.0</span> <span class="string">(Macintosh;</span> <span class="string">Intel</span> <span class="string">Mac</span> <span class="string">OS</span> <span class="string">X</span> <span class="string">10_7_4)...</span> <span class="string">(snip)</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Accept:</span> <span class="string">*/*</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Referer:</span> <span class="string">http://website.org/</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Connection:</span> <span class="string">close</span> </span></span><br><span class="line"><span class="language-yaml"><span class="attr">Accept-Encoding:</span> <span class="string">gzip,deflate,sdch</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Accept-Language:</span> <span class="string">en-US,en;q=0.8</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Accept-Charset:</span> <span class="string">ISO-8859-1,utf-8;q=0.7,*;q=0.3</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Cookie:</span> <span class="string">__qca=P0-800083390...</span> <span class="string">(snip)</span></span></span><br><span class="line"><span class="language-yaml"></span></span><br><span class="line"><span class="language-yaml"><span class="string">HTTP/1.1</span> <span class="number">200</span> <span class="string">OK</span> </span></span><br><span class="line"><span class="language-yaml"><span class="attr">Server:</span> <span class="string">nginx/1.0.11</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Content-Type:</span> <span class="string">image/x-icon</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Content-Length:</span> <span class="number">3638</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Connection:</span> <span class="string">close</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Last-Modified:</span> <span class="string">Thu,</span> <span class="number">19</span> <span class="string">Jul</span> <span class="number">2012 17:51:44 </span><span class="string">GMT</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Cache-Control:</span> <span class="string">max-age=315360000</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Accept-Ranges:</span> <span class="string">bytes</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Via:</span> <span class="string">HTTP/1.1</span> <span class="string">GWA</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Date:</span> <span class="string">Sat,</span> <span class="number">21</span> <span class="string">Jul</span> <span class="number">2012 21:35:22 </span><span class="string">GMT</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Expires:</span> <span class="string">Thu,</span> <span class="number">31</span> <span class="string">Dec</span> <span class="number">2037 23:55:55 </span><span class="string">GMT</span></span></span><br><span class="line"><span class="language-yaml"><span class="attr">Etag:</span> <span class="string">W/PSA-GAu26oXbDi</span></span></span><br><span class="line"><span class="language-yaml"></span></span><br><span class="line"><span class="language-yaml"><span class="string">(icon</span> <span class="string">data)</span></span></span><br><span class="line"><span class="language-yaml"><span class="string">(connection</span> <span class="string">closed)</span></span></span><br></pre></td></tr></table></figure><p>由于<code>Host</code>的引入, 我们现在可以把不同域名配置到同一个IP地址的服务器上了. 并且我们可以从头部信息中得到大量的信息, 例如:</p><ul><li>响应是分块的</li><li>缓存机制有额外控制</li><li>内容可以协商, 包括语言, 编码, 内容类型</li><li>在一次连接中我们同时请求了HTML页面和一个图标文件</li><li>在第二次连接中我们标明了<code>Connection: close</code>也就是说我们显式声明了结束连接</li></ul><p>事实上, 我们的HTTP&#x2F;1.1默认情况下就是长连接, 也就是说, 除非你带上了<code>Connection: Close</code>, 否则连接始终都是保持住的, 即时客户端没有带上<code>Connection: Keep-Alive</code>的头部. 但尽管如此, 众多浏览器还是会提供这个头部.</p><h2 id="扩展-进化-HTTP-x2F-1-1-与-HTTP-x2F-2-0"><a href="#扩展-进化-HTTP-x2F-1-1-与-HTTP-x2F-2-0" class="headerlink" title="扩展, 进化 - HTTP&#x2F;1.1+ 与 HTTP&#x2F;2.0"></a>扩展, 进化 - HTTP&#x2F;1.1+ 与 HTTP&#x2F;2.0</h2><p>这个1.1+是我说的, 并不是官方说法. 我们刚刚在上面说过, HTTP头部信息的引入, 为HTTP带来了巨大的可扩展性,   因此从1997年开始, HTTP就一直在扩展.</p><p>2000年, 状态层转换出现, 这也就是我们现在常说的<code>REST</code>, 我们通过基本的HTTP&#x2F;1.1方法里访问特定的URI. 起初, 最早的HTTP1.1有这些动词:</p><ul><li>GET</li><li>POST</li><li>PUT</li><li>DELETE</li><li>TRACE</li><li>OPTIONS</li><li>CONNECT</li></ul><p>接着从2010开始, 我们新增了<code>PATCH</code>来部分更新某些资源.</p><p>并且从2005年开始, 针对于Web的API大大增加, 由此也引入了很多的新HTTP头部, 例如:</p><ul><li>CORS支持</li><li>DNT隐私控制</li><li>WebSocket以及<code>Upgrade</code>头部来进行协议升级</li></ul><p>经过了15年的发展, 现在到了2020年, 已然是HTTP&#x2F;2.0的时代了.</p><p>为了应对当前越来越复杂的Web页面和Web应用, 数据量也越来越大, 为了能够更快速的传输数据, 早先谷歌使用了一种叫做<code>SPDY</code>的协议, 这可以被视为是HTTP&#x2F;2.0的雏形.</p><p>相较于HTTP&#x2F;1.1, HTTP&#x2F;2最大的不同就是成为了二进制协议. 也就是说不能直接可读和手动创建, 除此之外, HTTP&#x2F;2是一个多路复用的协议, 我们将传输的信息分割成了更小的消息和帧, 然后对他们采用二进制格式的编码.</p><p><img src="https://www.pingdom.com/wp-content/uploads/2015/06/Sk%C3%A4rmavbild-2015-06-11-kl.-10.54.59.png" alt="HTTP/2 – The new protocol on the block | Pingdom"></p><p>HTTP&#x2F;2开始强调<strong>流</strong>的概念了. </p><p>流(Stream) – 双向的字节流可以在一次建立的连接中传递多个信息(Message). </p><p>信息(Message)在HTTP&#x2F;2中就是一个完整的帧(Frame)序列, 用来映射逻辑上的请求和响应消息</p><p>帧(Frame)就是HTTP&#x2F;2中最小的单元了 , 每一个帧都包含着一个帧头部, 用来标明这个帧属于哪一个流.</p><p>并且从图中我们也能看到, 流是多路复用的, 并且是有优先级的. 而这个二进制帧层也支持流之间的优先级别和依赖关系, 由此更有效率的请求和响应数据. 另外, HTTP&#x2F;2还可以支持流控和服务端的推流, 以及头部压缩.</p><h2 id="然后-–-HTTP-over-QUIC-HTTP-x2F-3"><a href="#然后-–-HTTP-over-QUIC-HTTP-x2F-3" class="headerlink" title="然后? – HTTP over QUIC (HTTP&#x2F;3)?"></a>然后? – HTTP over QUIC (HTTP&#x2F;3)?</h2><p>QUIC的全称是<code>Quick UDP Internet Connections</code>, 也就是使用UDP的快速网络连接. 是由Google在2012年提出的, 相当于重新划分了一次网络分层, 请看:</p><p><img src="https://kinsta.com/wp-content/uploads/2019/03/http2-stack-vs-http3-stack.png" alt="HTTP/2 stack vs HTTP/3 stack"></p><p>我们刚刚说过, HTTP&#x2F;2提供了多路复用, 但是这实际上是被TCP限制了. 我们使用一个单一的TCP连接来进行多个流的同时传输, 如果这个时候哪怕只有一个流出现了报文丢失, 整个连接(当然包括该连接下所有的流)都会被劫持, 直到TCP重传. 这个时候, 哪怕是已经传输到目标节点的buffer中了, 也需要一同被阻塞, 直到丢失的报文被重传过来.</p><p>而使用了QUIC的话, 就不存在这种问题了. 那么你可能会问, 我如何确保可靠性呢? QUIC同样是个可靠的协议, 不同于TCP的Seq Number, QUIC使用Packet Number来代替, 而每一个Package Number都是严格递增的, 由此避免了原先Seq的歧义性, 另外, QUIC使用Stream Offset来保证数据传输顺序.</p><p>QUIC简单总结的话, 相当于是一个4+5+7层协议了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控系统与Zabbix</title>
      <link href="/2020/08/21/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E4%B8%8EZabbix/"/>
      <url>/2020/08/21/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E4%B8%8EZabbix/</url>
      
        <content type="html"><![CDATA[<p>我们要始终假设自己的系统处在高危状态.</p><span id="more"></span><h2 id="监控的概念"><a href="#监控的概念" class="headerlink" title="监控的概念"></a>监控的概念</h2><p>为什么要做监控? 我们的系统上线后, 可能随时都会遇到各种各样的问题, 因此我们需要监控各种指标, 从而能够及时发现问题. 那么这些指标有哪些呢? 例如CPU, 他的负荷量是否长期居高(90+)不下, 中断次数是否过多? 磁盘IO?内存使用量? 是否一直在swap? 软件层面上, 例如Nginx是否正常运行? 最重要的, 业务层面上, 并发量, 响应时间, 每秒钟的事务量等等, 这些都是我们需要进行考量.</p><p>所以监控的第一步, 我们需要得到这些数据, 也就是<strong>采样</strong>. 但是这些数据, 获取单一时间点的值的意义不大, 我们需要将获取的数据进行<strong>存储</strong>, 持续采样, 得到历史数据和趋势数据. 得到了这些数据之后, 我们需要进行<strong>展示</strong>. 当数据出现异常, 我们首要做的是就是<strong>报警</strong>. 由此, 我们就得到了一个完整的监控系统所必须的几个功能: 采样, 存储, 展示, 报警.</p><p>监控管理是贯穿在整个运维过程中的, 对于不同类型的系统, 主机, 我们对应的监控系统也是不一样的.</p><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><p>对于上面的几个过程, 采样就是周期性的获取某个关注指标相关的数据. 现在回忆一下我们之前看过的Ansible和Puppet, 我们可以使用ssh通道, 也可以在目标主机上安装一个agent. 这里甚至也可以是一个传感器. 当然啦, 这里也不一定非要是主机, 我们的被监控对象也可以使交换机路由器这些网络设备, 还有UPS也可以被监控. </p><p>因此一般, 我们会在网络中存放一个NMS, 也就是监控机. 通过agent或者是通道来发送命令. 再使用通道的情况下, 很多数据的获取, 我们需要管理员权限才可以获取, 这种时候我们如果目标主机的sudo权限设定的不当的话, 监控可能会失败, 如果使用管理员账号, 可能又会有信息泄露的风险, 不安全. 而如果使用agent来与NMS进行交互的话, agent可以在本地发起子进程来进行调用. 因此使用agent的方式更加安全.</p><p>除了使用ssh&#x2F;telnet通道, master&#x2F;agent这两种, 我们还有哪些采样的通道嘞? 硬件接口, 例如IPMI, 智慧平台管理接口, 很多厂商都有实现, 例如DELL的DRAC, HP的Integrated Lights-Out等等. 另外还有一个大家都很熟悉的东西, 那就是<strong>SNMP</strong>, 简单网络管理协议, 这个古老的协议使得很多设备都自带一个它的agent. 例如在windows上, 我们可以找到可选功能安装页面, 启用之就行了. 在Linux上, 我们需要安装一个软件包就行了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# yum info net-snmp</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.usinternet.com</span><br><span class="line"> * epel: mirror.steadfastnet.com</span><br><span class="line"> * extras: ftp.ussg.iu.edu</span><br><span class="line"> * updates: mirror.genesisadaptive.com</span><br><span class="line">Available Packages</span><br><span class="line">Name        : net-snmp</span><br><span class="line">Arch        : x86_64</span><br><span class="line">Epoch       : 1</span><br><span class="line">Version     : 5.7.2</span><br><span class="line">Release     : 48.el7_8.1</span><br><span class="line">Size        : 332 k</span><br><span class="line">Repo        : updates/7/x86_64</span><br><span class="line">Summary     : A collection of SNMP protocol tools and libraries</span><br><span class="line">URL         : http://net-snmp.sourceforge.net/</span><br><span class="line">License     : BSD</span><br><span class="line">Description : SNMP (Simple Network Management Protocol) is a protocol used for</span><br><span class="line">            : network management. The NET-SNMP project includes various SNMP tools:</span><br><span class="line">            : an extensible agent, an SNMP library, tools for requesting or setting</span><br><span class="line">            : information from SNMP agents, tools for generating and handling SNMP</span><br><span class="line">            : traps, a version of the netstat command which uses SNMP, and a Tk/Perl</span><br><span class="line">            : mib browser. This package contains the snmpd and snmptrapd daemons,</span><br><span class="line">            : documentation, etc.</span><br><span class="line">            : </span><br><span class="line">            : You will probably also want to install the net-snmp-utils package,</span><br><span class="line">            : which contains NET-SNMP utilities.</span><br></pre></td></tr></table></figure><p>有一个封装了SNMP协议功能的开源监控项目, 叫做<code>cacti</code>. 他将数据存储到了一个叫做<code>RRDTool</code>的数据日志和可视化系统中.</p><p>另外还有一个叫做JMX的玩意, 全称是Java management extension. 这个数据管理接口可以采集Java虚拟机的各项指标.</p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>至此我们就差不多说完了采样, 接下来我们来说说存储系统. 对于历史数据而言, 我们可能需要每次采样的结果, 保存时长三个月半年不能. 但对于趋势数据而言, 我们需要的就不会是每次的完整结果了, 我们可能需要的只是每个小时的最大最小和平均, 因此它的数据量远远小于历史数据, 也就是聚合数据, 我们可以保存时长较长周期.</p><p>最为常见的存储系统就是FS了, 显然这是十分麻烦的. 首先我们的指标非常多, 这仅仅对于一个主机而言. 如果我们想要获得某一个时间的数据, 就需要将整个巨大的文件载入到内存中, 这显然是不合理的. 因此我们就想到了使用关系型数据库, 但是对于监控系统而言, 数据的插入是非常多的, 也就是写操作, 这就会造成每秒钟事务的非常多. 另外一种就是轮询数据库, 也就是我们刚才提到的<code>RRD</code>: RoundRobin DataBase. 我们可以在一开始直接获得一个环状的数据区域, 当整个环填满了之后, 新数据就会将旧数据覆盖掉. 还有一种就是我们刚刚学习的NoSQL, 例如redis&#x2F;mongo.</p><h3 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h3><p>展示就很简单了, 我们可以直接使用WebGUI, 或者是APP之类的.</p><h3 id="报警"><a href="#报警" class="headerlink" title="报警"></a>报警</h3><p>报警就很好理解了, 我们可以使用邮件, 短信, 或者是微信等等等等, 任何能够到达用户的通知方法都可以. 一般情况下, 我们需要写脚本, 这样只要触发该脚本即可.</p><h2 id="Zabbix"><a href="#Zabbix" class="headerlink" title="Zabbix"></a>Zabbix</h2><p>Zabbix可以使用我们刚才提到的各种数据采集方式, 同时可以进行阈值定义, 支持递进式的报警机制. 使用mysql&#x2F;pgsql来存储数据, 支持网络自动发现, 并且可以提供丰富的可视化选项. 我们可以使用布置监控代理来实现分布式监控. 同时, Zabbix提供了API, 我们还可以二次开发.</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/Zabbix_Architecture.png" alt="Zabbix_Architecture"></p><p>Zabbix的架构如上图所示:</p><p>其中最重要的组件就是Zabbix Server, 负责接受agent发送过来的各种数据. 同时各种配置信息也都保存在这里. 接着是Database, 听名字就知道这是个用于存储收集到的数据的组件.</p><p>Zabbix可以使用两种方式进行数据监控, 也就是被动和主动, 被动也就是Zabbix server去拉取数据, 然后agent返回数据, 而主动也就是Zabbix的agent主动将数据推到server端.</p><p>在Zabbix中, 我们可以把多个指标放在一个组中, 而这么一个组, 就叫做<code>application</code>, 而一个指标项就叫做<code>item</code>.</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/Zabbix_logical_diagram.png" alt="Zabbix_logical_diagram"></p><p>从逻辑层面上, 我们可以得到这样的一张关系图. 主要的过程在右下角.</p><p>安装Zabbix已经不能再简单了, 官方的网站上有着保姆级的教程, 并且配置文件的注释也十分的详细. 之后的配置都在WebGUI中进行.</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/zabbix_login_page.png" alt="zabbix_login_page"></p><p>配置完成之后就可以进行登录了, 默认的用户名是<code>Admin</code>, 密码是<code>zabbix</code>.</p><p>剩下的使用GUI就没有什么难的了.</p><p>另外, 我们可以安装一个zabbix的辅助程序叫做<code>zabbix-get</code>, 它相当于一个Zabbix接口的访问客户端. 例如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# zabbix_get -s 192.168.10.102 -k &quot;net.if.in[ens33, packets]&quot;</span><br><span class="line">1010580</span><br><span class="line">[root@node1 ~]# zabbix_get -s 192.168.10.102 -k &quot;net.if.out[ens33, packets]&quot;</span><br><span class="line">1050160</span><br></pre></td></tr></table></figure><p>这个时候可以去agent端验证一下, 由于我这边两个节点一直在发包, 所以就没办法获得相同的结果啦.</p><h3 id="Zabbix的核心功能"><a href="#Zabbix的核心功能" class="headerlink" title="Zabbix的核心功能"></a>Zabbix的核心功能</h3><p>我们在添加item的页面, 可以看到zabbix agent提供了很多标准的item, 有些是不需要参数的, 而有些是需要我们加上参数的. 例如上面的流量监控, 就是需要我们提供网卡名称的. 例如CPU上下文切换: <code>system.cpu.switches</code> 就是一个不携带参数的item.</p><p>这里我们贴个例子:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/zabbix_example_node2.png" alt="zabbix_example_node2"></p><p>可以看到, 我们在node2上设置了5个监控项, 并且zabbix为我们列出了上次检查的时间, 最新的数据以及变化量.</p><p>具体的一个配置页面如下:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/zabbix_node2_item_configuration.png" alt="zabbix_node2_item_configuration"></p><p>首先是改监控项的名字, 接着选择使用何种方式进行数据采集, 这里我们一律使用的都是Zabbix agent. 接下来的key就是指明具体的监控项啦, 选择了监控项会决定下面的信息类型, 也就是数据类型啦, 有些可能返回的是个无符号整数, 有些可能是浮点型, 有些也可能是字符串. 接着我们还可以自定义数据的单位, 例如我们可以把网络流量每秒钟的出口报文这个一个key的单位自定义成为:<code>packets/sec</code>. 接着我们还可以设定间隔时间以及更加灵活的采集时间, 还可以进行schedule.</p><p>接下来的两个配置用来指明我们存储数据的方式. 还记得之前说过的application吗. 也就是item的组, 如果是新建组就直接在文本框中写名字就好了, 如果是要分配到已有的组, 就在下面的Applications选择即可. 另外, 向上看, 我们有一个叫做<code>preprocessing</code>的tab, 在这里我们可以对数据在展示之前进行预处理, 包括文本替换, 数据结构修改, 数学运算(倍乘), 验证等等.</p><p>经过一段时间之后, 我们可以前往数据页查看图表:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/zabbix_node2_itemvalues_graph.png" alt="zabbix_node2_itemvalues_graph"></p><p>但是这个时候你会发现, 我们只是获取了数据, 并且有了一个可视化的界面, 但是还有一个很重要的动作没有. 那就是设置<strong>触发器</strong>.</p><p>目前我们只收集到了数据, 还没有做到当某个指标对应的数据超出合理范围的时候给相关人员发送警报. 简单的说, 触发器其实就是表达式, 用来定义阈值. </p><p>触发器支持多个函数, 例如平均, 计算数量, 最大最小值, 数据存在性, 求和, 正则等等. 一个基本的触发器表达式就像这样:</p><p><code>&#123;&lt;server&gt;:&lt;key&gt;.&lt;function&gt;(&lt;parameter&gt;)&#125;&lt;operator&gt;&lt;constant&gt;</code></p><p>高度灵活, 所以我们创建出非常复杂的测试条件. 但是需要注意的是, 当条件满足的时候, TRUE表示的是PROBLEM状态, 反之, 就是OK状态.</p><p>在设置triggers的页面, 我们可以不手写表达式, 让zabbix为我们生成, 例如我们添加一个这样的触发器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;node2.zabbix.com:net.if.in[ens33, packets].last(#1)&#125;&gt;10000</span><br></pre></td></tr></table></figure><p>这就是说, 当我们最后一个入站报文的值大于10000的时候, 就会被触发. 设置好了之后我们可以去图表页面看一下:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/zabbix_node2_inbound_trigger_graph.png" alt="zabbix_node2_inbound_trigger_graph"></p><p>这里会看到一条红线, 这就是警戒线了. 平常我们的节点没啥流量, 所以只有十位数个位数的流量, 我们让他<code>yum update</code>一样, 瞬间这个值就会上去了. 然后我们可以去check一下problems页面就会看到红色闪烁的<code>PROBLEM</code>了, 当问题没有了之后, 状态就会变成<code>RESOLVED</code>. 而触发器的状态也会变成<code>OK</code>了.</p><p>另外, 想象这样的一种情景. 我们的一天服务器上运行的Nginx出现问题不能提供服务了, 但是这是因为我们的服务器本身宕机了, 如果我们对Nginx和服务器本身都加了触发器, 那么Nginx的触发器在这种情况下是不是压根就没意义了呀? 所以这就叫做, 触发器之间的<strong>依赖关系</strong>. </p><p>那么接下来, 我们就要定义Actions了.</p><p>首先我们需要定义条件, 也就是何时才使用这个action, 接下来下一步就是定义要做的操作. 我们之前说过, Zabbix可以进行步进式的操作设定, 也就是通过设定步骤来指明操作的层级.</p><p>例如我们在这里适用Linux的本地邮件来做个例子, 注意要先到Administration里面添加本地邮件这种Media Type和发送的消息内容(Zabbix有各种模板供你选用)才行, 另外还需要给你要发送的用户也配置上Media.</p><p>这样, 当我们的触发器触发到了这一个Action的时候, 我们就可以看到:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# mail</span><br><span class="line">Heirloom Mail version 12.5 7/5/10.  Type ? for help.</span><br><span class="line">&quot;/var/spool/mail/root&quot;: 1 message</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">  1 zabbix@localhost.loc  Sun Aug 23 18:09  23/1060  <span class="string">&quot;Problem: ipps too high&quot;</span></span></span><br><span class="line">&amp; </span><br><span class="line">Message  1:</span><br><span class="line">From zabbix@localhost.localdomain  Sun Aug 23 18:09:45 2020</span><br><span class="line">Return-Path: &lt;zabbix@localhost.localdomain&gt;</span><br><span class="line">X-Original-To: root@localhost.localdomain</span><br><span class="line">Delivered-To: root@localhost.localdomain</span><br><span class="line">From: &lt;zabbix@localhost.localdomain&gt;</span><br><span class="line">To: &lt;root@localhost.localdomain&gt;</span><br><span class="line">Date: Sun, 23 Aug 2020 18:09:45 -0500</span><br><span class="line">Subject: Problem: ipps too high</span><br><span class="line">Content-Type: text/html; charset=&quot;UTF-8&quot;</span><br><span class="line">Status: RO</span><br><span class="line"></span><br><span class="line">&lt;b&gt;Problem started&lt;/b&gt; at 18:09:42 on 2020.08.23&lt;br&gt;&lt;b&gt;Problem name:&lt;/b&gt; ipps too high&lt;br&gt;&lt;b&gt;Host:&lt;/b&gt; node2&lt;br&gt;&lt;b&gt;Severity:&lt;/b&gt; High&lt;br&gt;&lt;b&gt;Operational data:&lt;/b&gt; 9.9 Kpackets/sec&lt;br&gt;&lt;b&gt;Original problem ID:&lt;/b&gt; 53&lt;br&gt;&amp; </span><br></pre></td></tr></table></figure><p>接下来我们来说说Zabbix的主机配置模板, 我们可以设置一个链接至主机的模板, 从而实现主机的快速监控配置. 我们前往Configuration的Template里面,可以看到很多内置的模板. 模板可以导出, 也可以通过链接的方式进行模板之间的继承.</p><p>模板支持使用宏, 也就是预设的文本替换. 宏也有等级, 一共有三种:</p><ul><li>优先级最高的, 全局宏, 在Administration中定义</li><li>模板宏, 在模板配置中定义, 也可以进行链接继承. </li><li>主机宏, 优先级最低, 在主机页面定义.</li></ul><p>我们一开始就介绍过Zabbix支持网络发现, Zabbix提供了多个网络发现方式, 例如使用HTTP, SSH, SMTP, Zabbix agent等等. 在扫描到之后就会添加到监控主机当中来.</p><p>一旦发现主机, 就会产生发现事件, 也就是说我们的发现操作一共分为两步:</p><ul><li>discover</li><li>actions: conditions, operations</li></ul><p>Zabbix定义了多种发现事件:</p><table><thead><tr><th align="left">Event</th><th align="left">Check of service result</th></tr></thead><tbody><tr><td align="left"><em>Service Discovered</em></td><td align="left">The service is ‘up’ after it was ‘down’ or when discovered for the first time.</td></tr><tr><td align="left"><em>Service Up</em></td><td align="left">The service is ‘up’, consecutively.</td></tr><tr><td align="left"><em>Service Lost</em></td><td align="left">The service is ‘down’ after it was ‘up’.</td></tr><tr><td align="left"><em>Service Down</em></td><td align="left">The service is ‘down’, consecutively.</td></tr><tr><td align="left"><em>Host Discovered</em></td><td align="left">At least one service of a host is ‘up’ after all services of that host were ‘down’ or a service is discovered which belongs to a not registered host.</td></tr><tr><td align="left"><em>Host Up</em></td><td align="left">At least one service of a host is ‘up’, consecutively.</td></tr><tr><td align="left"><em>Host Lost</em></td><td align="left">All services of a host are ‘down’ after at least one was ‘up’.</td></tr><tr><td align="left"><em>Host Down</em></td><td align="left">All services of a host are ‘down’, consecutively.</td></tr></tbody></table><p>其实也就是Host, Service和Up&#x2F;Down, Discovered&#x2F;Lost的组合.</p><p>可以采取的行动有这些:</p><ul><li>Sending notifications</li><li>Adding&#x2F;removing hosts</li><li>Enabling&#x2F;disabling hosts</li><li>Adding hosts to a group</li><li>Removing hosts from a group</li><li>Linking hosts to&#x2F;unlinking from a template</li><li>Executing remote scripts</li></ul><p>因为我们先定义发现规则, 接着在设置发现事件触发之后采取的行动就可以了. 这里提个醒, 增加action的切换在左上角, 想吐槽一下这个UI, 真的好不明显啊.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Zabbix </tag>
            
            <tag> Monitor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoSQL概念和MongoDB</title>
      <link href="/2020/05/30/NoSQL%E6%A6%82%E5%BF%B5%E5%92%8CMongoDB/"/>
      <url>/2020/05/30/NoSQL%E6%A6%82%E5%BF%B5%E5%92%8CMongoDB/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><blockquote><p> NoSQL  &#x3D;&gt; <strong>N</strong>OT <strong>O</strong>NLY <strong>SQL</strong></p></blockquote><p>现在我们来了解一下NoSQL的概念. 为了引入NoSQL, 我们先从现在的大数据来说说. 互联网公司每分钟甚至每秒都产生巨大的数据量. 并且数据量的增长速度还在越来越快, 因此, 数据的存储, 处理分析都会出现各种各样问题.</p><p>因此, 衍生出的数据库系统, 我们有:</p><ul><li>并行数据库: 水平切分, 分区查询</li><li>NoSQL数据库管理系统: 非关系模型, 分布式, 可能不支持ACID数据库设计范式<ul><li>数据模型简单</li><li>弱一致性 (分布式通用概念)</li><li>元数据和数据分离</li><li>高吞吐量</li><li>水平扩展能力和低端硬件集群</li></ul></li><li>NewSQL数据库管理系统 (Combination of ACID and scalability of NoSQL)<ul><li>Azure Cosmos DB</li></ul></li><li>云数据管理系统</li></ul><p>我们现在很流行的大数据分析处理方案就是MapReduce, 例如Hadoop. 而Hadoop的数据库软件, HBase也是一个NoSQL数据库系统.</p><p>典型NoSQL数据存储模型有这些:</p><ul><li>列式存储: 以”列”为中心进行存储, 将同一列数据存储在一起<ul><li>应用场景: 在分布式文件系统上提供支持随机读写的分布式数据存储</li><li>典型产品: HBase, Cassandra</li><li>优点: 快速查询, 高扩展性, 易于实现分布式扩展.</li></ul></li><li>文档数据: 键值模型, 但是存储为文档<ul><li>应用场景: 非强事务需求的Web应用. </li><li>典型产品: MongoDB, Elastic</li><li>优点: 数据模型无需事先定义.</li></ul></li><li>键值数据: 基于哈希表实现的K-V<ul><li>应用场景: 内容缓存, 用于大量并行数据访问的高负载场景</li><li>典型产品: Redis</li><li>优点: 查询迅速</li></ul></li><li>图式数据: 图式结构<ul><li>应用场景: 社交网络, 推荐系统, 关系图谱</li><li>典型数据: Neo4j</li><li>优点: 图式计算</li></ul></li></ul><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>接下来我们就来说说MongoDB, 今天的主角.</p><p>MongoDB, 刚刚也已经提到, 是一个文档数据模型的NoSQL数据库. 在我们的epel源中就有mongodb的包 但是版本是2.6, 如果需要新版本就还是使用mongodb官方提供的yum仓库就好.</p><p>官方的文档写的很详细了, 熟悉一下CRUD操作直接来一遍就行. 这里做一个简单总结</p><p>插入操作:<br><code>db.coll.insert()</code></p><p>查找操作:</p><p><code>db.coll.find(cond, specified field)</code> -&gt; <code>cond: &#123; field: &#123;operator&#125;, ... &#125;</code> </p><p>其中, 比较操作使用<code>$gt $gte $lt $lte $ne $in $nin</code> 逻辑操作使用: <code>$or $and $not</code></p><p>存在性判断使用<code>$exists</code> 值类型判断<code>$type</code></p><p>MongoDB的查询语法还是很有意思的, 都是使用<code>&#123;&#125;</code>来描述一个操作, 通过<code>operator: value</code>来指明.</p><p>接下来我们再来说说说谈到数据库的时候, 就一定绕不开的一个话题, 那就是<strong>索引</strong>.</p><p>对于特别大的数据集, 索引就十分重要了. 索引会对一个特定字段来实现, 这个字段一般都是查找的条件. 我们将这些查找条件抽取出来, 放在一个专门的数据结构, 然后进行排序. 索引也是需要增删查改的, 当我们的原始数据的数据发生变化, 索引也需要发生变化. 因此我们说索引加速的查询操作, 但是加重了IO操作. 不过对于大量数据而言, 索引还是利远远大于弊的.</p><p>我们知道索引可以降序也可以升序. 另外, 根据索引查找的结果不是直接结果, 而是一个指向结果的位置. 索引是个数据结构, 因此也有不同的类型, 其中对于MySQL我们之前说过是B+ Tree. MongoDB同样, 也是使用的B+ Tree.</p><p>另外一种索引就是哈希索引. 哈希索引把对应字段每一个值当做键, 构建哈希, 使用这个哈希值来查找. 一般来说, 哈希索引会构建哈希桶, 现检索哈希桶, 再在桶里面查找对应的值.</p><p>另外还有空间索引和全文索引.</p><p>对于MongoDB而言, 它支持多种索引形式. </p><ul><li>单字段索引</li><li>组合索引(多字段索引)</li><li>多键索引 - 用于数组</li><li>基于位置的索引, 空间索引</li><li>对于文本的搜索, 全文索引</li><li>哈希索引</li></ul><p>MongoDB创建索引很简单, 直接对应的collection中使用<code>createIndex</code>就可以了. 这个过程我们也可以理解成是一个排序过程, MongoDB使用<code>1</code>来表示升序, <code>-1</code>表示降序. 创建各种索引的方式也很简单:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">addresses</span>.<span class="title function_">createIndex</span>( &#123; <span class="string">&quot;xmpp_id&quot;</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">sparse</span>: <span class="literal">true</span> &#125; ) <span class="comment">// 创建一个稀疏索引</span></span><br><span class="line">db.<span class="property">members</span>.<span class="title function_">createIndex</span>( &#123; <span class="string">&quot;user_id&quot;</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">unique</span>: <span class="literal">true</span> &#125; ) <span class="comment">// 创建一个unique约束</span></span><br></pre></td></tr></table></figure><p>接下来我们回到服务端程序, mongod. 来看一下它的一些常用选项吧.</p><p><code>fork=&#123;true|false&#125;</code> mongod是否运行到后台</p><p><code>bind_ip=IP</code> 监听地址</p><p><code>port=PORT</code> 指定监听的端口</p><p><code>maxConns</code> 最大连接数</p><p><code>logPath</code> &#x2F; <code>syslog</code> 可以指定是mongo自己来管理日志或者交给rsyslog来管理日志.</p><p>等等等…</p><h3 id="MongoDB的复制功能"><a href="#MongoDB的复制功能" class="headerlink" title="MongoDB的复制功能"></a>MongoDB的复制功能</h3><p>和MySQL一样, MongoDB也需要在某一个数据服务器离线之后, 仍然需要通过冗余继续提供数据服务. 因此需要复制功能. MongoDB有两种类型的复制功能, 其一就是主从复制<code>master/slave</code>, 另一个就是<code>replica set</code>复制集. 更常用的, 是复制集.</p><p>我们可以把replica set理解成是服务于同一个数据集的多个mongodb实例. 在MySQL中, 我们是使用的二进制日志来实现复制, 从节点去获取主节点的日志来进行重放. 而MongoDB的主节点将数据修改操作保存到了oplog中.</p><p>对于mongodb来讲, 当主节点不可用的时候, 两个从节点会对主节点进行心跳检测, 当一段时间内收不到心跳回复后, 这两个从节点就会触发选举操作, 谁的优先级高, 谁就会自动成为主节点. 这种模式下, 最好是存在一个第三节点, 用来参与<strong>仲裁</strong>过程. 这样当从节点联系不到主节点的时候, 就会去联系仲裁节点. 这个仲裁节点甚至可以是一个web服务, 只要安装mongodb服务即可, 并不需要参与到操作日志的保存和数据操作. 因此对于mongodb的复制过程, 应该至少三个节点, 且应该是奇数个节点.</p><p>在复制集中, 节点有这些分类:</p><p>第一种, 0优先级的节点, 冷备节点, 不会被选举成为主节点, 但可以参与选举.</p><p>基于这一种, 我们有被隐藏的从节点, 它也是一个0优先级的从节点, 且对客户端不可见.</p><p>第三种, 延迟复制的从节点, 同样, 也是一个0优先级的从节点, 且复制时间落后于主节点一个固定时长(数据一直是过期数据)</p><p>还有就是我们说过的仲裁节点.</p><p>说完这些节点, 我们就来说下MongoDB的复制架构, 一个就是oplog, 另一个是heartbeat.</p><p>我们先来说这个oplog, 他是一个大小固定的文件. 通常这个文件位置在local数据库中.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; use local</span><br><span class="line">switched to db local</span><br><span class="line">&gt; show collections</span><br><span class="line">startup_log</span><br></pre></td></tr></table></figure><p>我们说过这个大小是固定的, 因此在一开始的时候, 这个空间(5%)就会预留出来了. (最小是990MB, 最大是50G, 当然这个大小是可以修改的) 另外, 这个日志文件是幂等性的. 不过当然, 既然大小是固定的, 我们就不能从一开始进行存储数据.</p><p>那么如何应用这个文件呢. 我们的从节点一般有这些方式来应用:</p><ul><li>初始同步</li><li>回滚后追赶</li><li>切片块迁移</li></ul><p>local数据库存放了副本集的所有元数据和oplog.</p><p>当从节点联系不到主节点的时候, 就会触发选举, 除此之外, 还有这些事件可以触发选举机制:</p><ul><li>新副本集初始化时</li><li>主节点收到stepDown()命令时</li><li>某从节点有更高的优先级且已经满足成为主节点的其他所有条件</li><li>主节点无法联系到副本集的”多数方”</li></ul><h3 id="MongoDB的分片功能"><a href="#MongoDB的分片功能" class="headerlink" title="MongoDB的分片功能"></a>MongoDB的分片功能</h3><p>随着我们业务发展, 数据量会越来越大. 渐渐地, 单机资源CPU. MEM…会不够, 为了扩展MongoDB, 我们就可以将数据进行切片. MongoDB可以自己做分片, 而MySQL就需要使用额外的分片框架来实现了.<br><img src="https://docs.mongodb.com/manual/_images/sharded-cluster-production-architecture.bakedsvg.svg" alt="Diagram of a sample sharded cluster for production purposes.  Contains exactly 3 config servers, 2 or more ``mongos`` query routers, and at least 2 shards. The shards are replica sets."></p><p>在MongoDB内部, 有三个组件:</p><ul><li>mongos: 这是一个router, 接受用户的查询请求, 相当于代理</li><li>config server: router需要知道查询的数据在哪一个分片上, 需要一个元数据服务器, 存放了索引的mapping</li><li>shard: 数据分片, 也成为mongod实例</li></ul><p>当我们的sharding有节点挂掉了的时候, 就会出现数据不完整的情况, 因此, 我们需要做replica, 同样的, 作为元数据服务器, 如果它挂掉了, 整个集群就完蛋了, 所以这个也需要做复制冗余.</p><p>接下来我们来看一下分片的策略, 显然每一个分片应该保证尽量平均才行, MongoDB使用<code>shard key</code>来进行集合中文档的分片分布. 这个<code>shard key</code>是一个被索引的域, 也就是说, MongoDB通过索引排序来进行分片的划分.</p><p>当我们进行分片操作的时候, 我们可以选择<code>shard key</code>, 文档中的这个<code>shard key</code>的值就会决定它在不同分片中的分布. 我们之前说过, 索引十分类型的对不, 所以同理, 不同类型的索引, 也会决定不同类型的分片.</p><p>首先第一种是基于范围的切片:</p><p><img src="https://docs.mongodb.com/manual/_images/sharding-range-based.bakedsvg.svg" alt="Diagram of the shard key value space segmented into smaller ranges or chunks."></p><p>此时我们的分片是连续的, 在这种分片模式下, shard key越接近的文档就越有可能会被分在同样的chunk或者shard中. 这种分片模式是默认的.</p><p>另一种是基于哈希的分片:</p><p><img src="https://docs.mongodb.com/manual/_images/sharding-hash-based.bakedsvg.svg" alt="Diagram of the hashed based segmentation."></p><p>显然, 哈希所以不存在排序, 但是在这种模式下, 我们可以使得数据写操作更分散.</p>]]></content>
      
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的主从复制架构</title>
      <link href="/2020/05/09/MySQL%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%9E%B6%E6%9E%84/"/>
      <url>/2020/05/09/MySQL%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="主从复制简述"><a href="#主从复制简述" class="headerlink" title="主从复制简述"></a>主从复制简述</h2><p>我们之前在说到集群架构扩展的时候说过, 有两种最典型的扩展方式, 即: Scale Up &amp; Scale Out.</p><p>对于MySQL这样的存储系统来说, IO压力十分之大使得它经常成为集群架构中最需要性能的一环. 动辄128或256G的内存+RAID10的后端存储. 但是我们之前说过, 提升服务器的性能, 往往很容易在不久之后就再次达到性能瓶颈. 因此考虑Scale Out, 可是数据库系统不同于我们之前所说过的Web服务器, 我们需要让数据库系统获得一模一样的数据. 这成为我们数据库架构的关键点.</p><p>其实, 对于任何一个有写操作的负载均衡场景中, 这都是一个共性问题. 因此, 一个典型的解决方案就是<strong>主从复制</strong>, 即: <strong>主节点仅负责写操作, 将数据集同步&#x2F;复制到从节点, 从节点仅负责读操作.</strong> 这样当用户的请求到达时, 如果是写操作, 就交给主节点, 读操作就分发给一个从节点.</p><p>在MySQL的复制过程中, 最重要的东西就是我们之前说到的二进制日志. 从服务器拿到主服务器的二进制日志进行replay, 即可进行数据集的同步. 因此我们说, 复制过程是单向的.</p><p>通过复制, 除了实现上面提到的数据分布功能, 我们还可通过复制实现冗余和备份的功能, 以及达成高可用和故障切换, 甚至实现MySQL的升级测试.</p><h2 id="MySQL主从复制原理"><a href="#MySQL主从复制原理" class="headerlink" title="MySQL主从复制原理"></a>MySQL主从复制原理</h2><p>我们先从从节点开始.</p><p>从节点会启动两个线程, 分别是I&#x2F;O Thread和SQL Thread. 其中I&#x2F;O Thread负责从Master节点请求二进制日志事件, 并且保存在中继日志中. 而SQL Thread负责从中继日志中读取日志事件, 然后再在本地完成重放操作.</p><p>而主节点会启动一个dump Thread, 为每个Slave的I&#x2F;O Thread启动一个dump线程, 用于向其发送二进制日志事件.</p><p>这种复制过程, 是<strong>异步</strong>的. 因为主节点可以不需要等待从服务器的反馈, 不过这样牺牲掉的东西, 是数据的可靠性. 因为从节点进行重放操作是又在失败的隐患的, 例如网络因素, I&#x2F;O因素等等. 另外, 从节点也有可能会落后于主节点的数据(或者不可避免的会落后). </p><p>接着我们回到这个主从复制的本身. 我们说做这个的目的是什么? <strong>负载均衡</strong>. 那么问题来了, 既然要做均衡, 就需要一个调度器, 这个调度器必须工作在7层, 还必须理解请求中SQL语句是写操作还是读操作. 如果是读请求, 就要基于负载均衡规则, 调度给一个从节点, 如果是写操作, 就只能无可选择的给主节点. 这个负载均衡器, 就是一个MySQL的反向代理, 不过, 我们一般把它称为语句路由节点或者读写分离器(r&#x2F;w splitter).</p><p>接下来我们考虑假设从服务器宕机的场景, 读写分离器应能通过健康状态检测来监控后端的从服务器的状态, 如果发现有不健康的节点, 应该自主将他从可调度的名单中移除. 但是我们可以稍微在想多一点. 我们知道MySQL的查询有一个很重要的部件叫做SQL Cache. 缓存可以极大程度的减轻读压力. 如果我们能够在架构中增加一个memcache, 用来存储查询缓存, 并且让客户端优先去缓冲中查询, 如果hit则直接返回, 请求根本都不需要进入到我们的MySQL中, 如果miss, 则可以在读取完数据集之后写入到缓冲服务器中. 这样, 就可以避免反向代理节点实现过多的功能.</p><p>但是, 如果主节点宕机了呢? 如何实现写操作? 显然, 主节点宕机, 就无法实现写操作. 此时, 我们就需要将从节点中的一个当做主节点. 这种方式看起来很美好, 但是, 实际上存在很多问题. 例如, 当主节点存在并行事务, 而从节点完成的不一致的时候, 是没有办法简单的直接转移的. 虽然MySQL在5.6推出了GTID, 全局事务ID, 来区分每一个事务, 简单的替换仍然不太可靠. 另外一种解决方案就是使用Corosync等工具实现主节点的高可用, 我们用Active的节点来做主节点, Passive的随时等待替换. 那么问题来了, 这两个家伙怎么做同步嘞? 这次就简单了, 我们可以使用共享存储, 因为同一时间只有一个在做写操作. 块级别的分布式存储也可以考虑. 但是这种解决方案复杂且不方便. 或者也可以简单的使用IP SAN. 只不过这种情况可能会有昂贵的开销. </p><p>或者, 还有一种解决方案可以考虑. 那就是Master-Master模型, 即两个节点既是主节点又是从节点. 这样是如何实现的呢? 两个节点都写入中继日志, 然后将中继日志传输到其他的节点然后另外节点执行日志中对应的事件. 如何区分事件是那个节点的呢? 我们之前在说MySQL日志的时候, 就提到过, 日志中有一个字段叫做server id, 用这个就可以区分是哪个服务器的事件了. ok, 在这种模型下, 我们也可实现高可用和冗余. 只不过, 主主模型会造成数据不一致. 主主模型其实是比主从模型更容易出问题. 另外, 在这种模型下, 写操作依然没有被分担.</p><p>不过 既然都有双主了, 我们还可以有环状的多主模型…</p><p>现在回到我们之前说的主从复制架构, 其实主节点在接受这么多写请求的时候压力就已经很大了, 这个时候还要分出很多dump线程来给从节点发送日志就更难了. 因此我们用一个从节点作为中继节点, 接受日志的同时, 向其他的从节点发送数据. 此外, 这个中继节点可以使用一种特殊的存储引擎: <code>blackhole</code>. 因为这个节点是没有必要存储数据的.</p><h2 id="主从复制模型的实现"><a href="#主从复制模型的实现" class="headerlink" title="主从复制模型的实现"></a>主从复制模型的实现</h2><p>事实上, 实现一个最基本的主从复制很简单. 仅需要以下几步:</p><ol><li>主节点开启二进制日志</li><li>主节点设置一个全局唯一ID号</li><li>主节点创建有复制权限的用户</li><li>从节点开始中继日志</li><li>为从节点设置一个全局唯一ID号</li><li>从节点连接到主节点, 启动复制线程</li></ol><p>接下来我们来执行一遍.</p><p>首先我们开启二进制日志并且指明一个Server ID</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/mysql_master_basic_config2.png" alt="mysql_master_basic_config2"></p><p>接着我们来确认一下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show global variables like &#x27;%log_bin%&#x27;;</span><br><span class="line">+---------------------------------+-------+</span><br><span class="line">| Variable_name                   | Value |</span><br><span class="line">+---------------------------------+-------+</span><br><span class="line">| log_bin                         | ON    |</span><br><span class="line">| log_bin_trust_function_creators | OFF   |</span><br><span class="line">| sql_log_bin                     | ON    |</span><br><span class="line">+---------------------------------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; show global variables like &#x27;server_id&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| server_id     | 1     |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>ok没有问题, 接下来我们创建用户.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; grant replication slave, replication client on *.* to &#x27;repluser&#x27;@&#x27;192.168.10.%&#x27; identified by &#x27;replpass&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>这样主服务器就完成了. (别忘确认iptables开放3306的访问)</p><p>接下来是从服务器的配置:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/mysql_slave_basic_config.png" alt="mysql_slave_basic_config"></p><p>启动之. 然后就可以来指明主服务器的位置了. 使用这个指令:</p><p><code>CHANGE MASTER TO</code></p><p>在这个例子里, 就像这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; change master to master_host=&#x27;192.168.10.101&#x27;, master_user=&#x27;repluser&#x27;, master_password=&#x27;replpass&#x27;, master_log_file=&#x27;master-bin.000001&#x27;, master_log_pos=499;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>这里我们需要指定从主节点的哪一个二进制日志的哪一个位置来开始复制, 可以来看下主节点当前的位置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show master logs;</span><br><span class="line">+-------------------+-----------+</span><br><span class="line">| Log_name          | File_size |</span><br><span class="line">+-------------------+-----------+</span><br><span class="line">| master-bin.000001 |       499 |</span><br><span class="line">+-------------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>接下来我们就来查看一下当前的从节点状态:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">ariaDB [(none)]&gt; show slave status\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: </span><br><span class="line">                  Master_Host: 192.168.10.101</span><br><span class="line">                  Master_User: repluser</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: master-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 499</span><br><span class="line">               Relay_Log_File: relay-log.000001</span><br><span class="line">                Relay_Log_Pos: 4</span><br><span class="line">        Relay_Master_Log_File: master-bin.000001</span><br><span class="line">             Slave_IO_Running: No</span><br><span class="line">            Slave_SQL_Running: No</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 499</span><br><span class="line">              Relay_Log_Space: 245</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: NULL</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 0</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>此时你会发现, Slave_IO和Slave_SQL都是off的, 因为我们还没有启动复制线程, 启动的方法也很简单:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; start slave;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>默认会将两种线程都启动, 不过我们也可以指定只启动哪一个.</p><p>这个时候我们再来查看一次状态, 就会发现, 已经在等待主节点发送事件, 并且两个线程也都是running的状态了.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show slave status\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 192.168.10.101</span><br><span class="line">                  Master_User: repluser</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: master-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 499</span><br><span class="line">               Relay_Log_File: relay-log.000002</span><br><span class="line">                Relay_Log_Pos: 530</span><br><span class="line">        Relay_Master_Log_File: master-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 499</span><br><span class="line">              Relay_Log_Space: 818</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>ok, 接下来我们去主节点做点事情, 看看会不会复制到从节点上.</p><p>我们删除一些数据, 查看一下master log的位置变化, 接着回到从节点, 查看状态. 这个时候的位置就已经更新到主节点一致了, 并且我们在主节点所作的更改也都反映到从节点了.</p><p>不过, 我们现在的主从复制只是最基本的, 还有很多问题需要考量, 例如, 我们应该限制从服务器为只读的. 事实上, MySQL就有一个变量叫做<code>read_only</code>. 只不过, 此变量对拥有SUPER权限的用户无效. 因此 有一个小trick是在我们的从服务器上开一个连接线程, 然后<code>FLUSH TABLES WITH READ LOCK</code>. 接着不关闭此线程就行了.</p><p>另外, 我们如何保证主从复制的事务安全?</p><p>我们之前说过, 在事务提交的时候, 会事先先写入到日志文件中, 然后反映到数据文件, 但事实上, 我们的日志文件在内存中也是有一个缓冲区的, 事务写入是先写入到缓冲区中, 然后再推到文件中的. 这样的话, 从节点接收到的日志文件有可能包含不完整的事务或者有可能主节点已经提交事务了, 但是由于日志文件没有得到及时更新, 从节点也接受不到. 再这样的情况下, 我们可以做这样的操作:</p><ul><li>在master节点, 启用<code>sync_binlog</code>, 即当事务更新的时候立刻刷新到日志文件中.<ul><li>如果使用InnoDB存储引擎, 开启<code>innodb_flush_logs_at_trx_commit=ON</code>, <code>innodb_support_xa=ON</code>. 第一个看名字就可以理解, 即当事务提交的时候就刷新到日志中. 第二个是开启分布式事务.</li></ul></li><li>在slave节点, 开启<code>skip_slave_start=OFF</code>,  也就是不要开启自动开启复制线程, 这样有可能复制主节点的错误数据导致数据风险. 我们应该手动开启.</li></ul><p>另外, 我们来到从节点看一下他的数据目录.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 mysql]# ls</span><br><span class="line">aria_log.00000001  ibdata1      mariadb-bin.000001  master.info  mysql.sock          relay-log.000002  xtrabackup_binlog_pos_innodb</span><br><span class="line">aria_log_control   ib_logfile0  mariadb-bin.000002  mydb         performance_schema  relay-log.index   xtrabackup_info</span><br><span class="line">hellodb            ib_logfile1  mariadb-bin.index   mysql        relay-log.000001    relay-log.info</span><br><span class="line">[root@node2 mysql]# cat master.info </span><br><span class="line">18</span><br><span class="line">master-bin.000001</span><br><span class="line">873</span><br><span class="line">192.168.10.101</span><br><span class="line">repluser</span><br><span class="line">replpass</span><br><span class="line">3306</span><br><span class="line">60</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">1800.000</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>其中有一个叫做<code>master.info</code>的文件. 这个文件记录了我们的复制所需要的信息, 因此这个文件十分重要. 另外, 还有一个<code>relay-log.info</code>, 其中也记录了当前复制的位置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 mysql]# cat relay-log.info</span><br><span class="line">./relay-log.000002</span><br><span class="line">904</span><br><span class="line">master-bin.000001</span><br><span class="line">873</span><br></pre></td></tr></table></figure><p>同理, 我们从节点的<code>relay log</code>也是先写缓冲再文件的, 我们也可以通过配置变量来使得数据sync到文件中.</p><h2 id="主主模型的实现"><a href="#主主模型的实现" class="headerlink" title="主主模型的实现"></a>主主模型的实现</h2><p>主主模型实现起来其实十分容易, 只要将两个节点都打开二进制日志和中继日志, 都配置MASTER指向, 然后都启动复制线程就可以了. 不过, 我们之前说过主主模型存在很多弊端(数据不一致), 所以就不展开了.</p><p>另外, 主主模型可能还需要考虑到关于自动增长ID的问题.</p><h2 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h2><p>半同步复制是Google为MySQL开发的复制插件. 我们可以从安装的服务端应用程序看到这两个插件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# rpm -ql mariadb-server</span><br><span class="line">...</span><br><span class="line">/usr/lib64/mysql/plugin/semisync_master.so</span><br><span class="line">/usr/lib64/mysql/plugin/semisync_slave.so</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在我们之前配置好的主从复制的基础上, 主节点和从节点安装对应的插件, 接着启用他们, 开启复制线程. 就可以使用半同步复制了.</p><blockquote><p>在我们装好插件之后, 变量就会变多, 状态也会变多.</p></blockquote><h2 id="复制过滤器"><a href="#复制过滤器" class="headerlink" title="复制过滤器"></a>复制过滤器</h2><p>复制过滤器可以使得我们让从节点复制指定的数据库, 或者指定数据库的指定表.</p><p>有两种实现方式:</p><ul><li>主服务器仅向二进制日志中记录与特定的数据库(特定表)相关的时间. 不过, 这种情况下, 我们就无法实现时间点还原. 通过这两个变量来控制:<ul><li>binlog_do_db&#x2F;table 白名单</li><li>binlog_ignore_db&#x2F;table 黑名单</li></ul></li><li>从服务器SQL_THREAD在replay中继日志的时间时, 仅读取与特定数据库(特定表)相关的事件并应用于本地. 在这种实现方式下, 会造成网络和磁盘IO的浪费. 通过这两个变量来控制:<ul><li>replicate_do_db&#x2F;table</li><li>replicate_ignore_db&#x2F;table</li></ul></li></ul><p>这些变量在我们查看复制状态的时候也可以看到.</p><p>当然, 我们也可以通过SSL来进行复制, 通过建立私有CA来实现.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cluster </tag>
            
            <tag> Database </tag>
            
            <tag> Replication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的备份和恢复</title>
      <link href="/2020/03/22/MySQL%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"/>
      <url>/2020/03/22/MySQL%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<p>接下来我们来说说MySQL的备份和恢复相关. 关于备份和恢复, 小到可以仅仅涉及一条命令和一个SQL文件, 大到可以说成一个学科. ( 然后发现, 每件事情不都是这样的. 简直就是废话23333. )</p><span id="more"></span><h2 id="说说备份"><a href="#说说备份" class="headerlink" title="说说备份"></a>说说备份</h2><p>首先我们来说说, 为什么要备份? 备份的目的主要是应对应急情况下的不时之需. 也就是所谓的<strong>灾难恢复</strong>, 包括不限于人为操作, 硬件故障, 软件故障, 自然灾害, 外部攻击等等. 除了灾难恢复, 有时候我们进行测试也是需要进行备份的. 这里可能会有人说, 我们可以使用类似RAID10的手段来进行硬件上的数据备份. 没错, 这个做法是为了保证数据不会因为硬件的故障丢失和损坏, 但是对于数据的删除操作, 任何情况下也无法进行冗余, 说白了, 无论使用哪种数据存储设备, 备份都是必不可少的.</p><p>备份, 一定不是镜像. 因为镜像会同步主体的操作. 所以一般情况下, 我们的备份更多有可能是离线的. </p><p>不同的业务模型需要的备份的力度也不同, 我们可以看:</p><ul><li>能容忍最多丢失多少的数据</li><li>恢复数据需要在多长时间内完成</li><li>需要恢复那些数据</li></ul><p>另外, 有的时候, 我们的备份的数据集都没问题, 但是有可能因为还原出问题导致备份的数据集全部失效, 因此我们需要经常做做还原测试, 用于测试备份的可用性, 以及做还原演练.</p><p>说回备份本身, 我们的备份类型分为: <strong>完全备份</strong>, 这会整个数据集, <strong>部分备份</strong>, 只备份数据子集. 从数据变化的时间轴出发, 我们也可以划分成: 完全备份, 增量备份, 差异备份. 看名字挺好理解了, 就不展开了.</p><p>另外, 我们的备份还分成:</p><ul><li>热备份: 读写操作均可执行</li><li>温备份: 读操作可进行, 写操作不可执行</li><li>冷备份: 读写操作均不可进行</li></ul><p>从上到下, 需要的技术要求也越低.</p><p>我们前面在说InnoDB存储引擎的时候, 引入过一个概念叫做MVCC, 即多版本并发控制. 我们可以对内部的数据做一个快照然后备份, 因此InnoDB存储引擎就是支持热备的, 而MyISAM, 一般情况下, 是不能够进行热备的.</p><p>而温备, 就相对来说简单一点, 直接对服务器层面上施加一个写锁就可以了. 虽然听起来很不错, 但是实际上, 真正实施起来还是有很多问题, 例如在我们进行备份的时候, 有一个事务正在执行, 这个施加写锁的请求就会被挂起等待事务完成, 如果事务很大, 需要数小时才能完成, 那也就意味着我们的备份也需要数小时之后才能进行. </p><p>最后, 做冷备, 就意味着服务会被关闭, 这就不用多说了. 所以说到底, 最后还是需要热备.</p><p>另外, 我们可以把备份的方式分成:</p><ul><li>物理备份: 直接复制数据文件进行备份</li><li>逻辑备份: 从数据库中导出数据另存来进行备份 (数据库协议)</li></ul><p>我们来简单分析一下这两种备份的优与劣.</p><p>首先物理备份只需要文件层面的复制就好了, 而逻辑备份需要使用遵循数据库服务端协议的客户端来操作. 但是, 物理备份需要和存储引擎相关联, 数据文件所使用的存储引擎回复时也得用一样的, 而逻辑备份就和存储引擎无关.</p><p>除了需要备份数据, 我们还需要备份二进制文件, InnoDB的事务日志, 代码(存储过程, 存储函数, 触发器, 事件调度器), 服务器的配置文件等等, 这些都是我们需要考虑的.</p><p>接下来我们就来说说备份工具吧!</p><p>首当其冲, 大家都听说过的, 就是<code>mysqldump</code>了. 这是一个逻辑备份工具, 适用所有存储引擎, 支持温备, 能够对InnoDB存储引擎进行热备, 支持完全备份, 部分备份.</p><p><code>xtrabackup</code>, 是一个由Percona提供的支持对InnoDB进行热备的工具, 支持完全备份和增量备份.</p><p>然后就是我们的复制归档工具: <code>cp</code>, <code>tar</code>等等, 这些就是物理备份工具了, 只能进行冷备.</p><p>以及, <code>lvm2</code>的快照, 可以实现一个几乎的热备, 为什么说是几乎呢? 因为lvm并不能备份, 他只是一个快照功能, 说到底, 还是需要借助于文件系统管理工具进行备份.</p><p>还有一个仅适用于MyISAM存储引擎的冷备工具: <code>mysqlhotcopy</code>, 不过很少有人用就是了.</p><p>如何选择这些工具呢? 我们可以像这样:</p><ul><li>mysqldump+复制binlog<ul><li>使用mysqldump进行完全备份, 复制binlog指定时间范围的event进行增量备份</li></ul></li><li>lvm2快照+复制binlog</li><li>直接使用xtrabackup</li></ul><h2 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h2><p>接下来我们来说说其中一个工具, mysqldump. 在我们的数据量较小的情况下, mysqldump就是一个很不错的选择. 这个程序是mysql自带的, 而xtrabackup是需要另外安装使用的. </p><p>mysqldump是从文件系统层面上的备份, 上面也说过了, mysqldump是一个逻辑备份工具, 所以, schema和数据是存储在一起的. dump出来的东西, 是一个单个巨大的SQL语句, output的东西也是一个单个巨大的备份文件.</p><p>mysqldump说白了其实就是通过mysql协议连接到服务器然后进行一个全量的查询.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump [options] [db_name [tbl_name ...]]</span><br></pre></td></tr></table></figure><p>我们可以直接指定选择什么数据库, 或者通过传递选项来备份所有的数据库. 当然了, 我们也可以进行表级别的备份.</p><p>不过, 需要提到的是, 如果在备份的时候, 下面的三种方式, 第一种略有不同:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage: mysqldump [OPTIONS] database [tables]</span><br><span class="line">OR     mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...]</span><br><span class="line">OR     mysqldump [OPTIONS] --all-databases [OPTIONS]</span><br></pre></td></tr></table></figure><p>如果我们没有传递<code>--databases</code>或者<code>--all-databases</code>的话, 备份的结果中是不包含创建数据库的语句的, 而另外两个会自带创建数据库语句.</p><p>接下来还是回到我们之前说的问题, 显然我们不能直接就从一个正在运行的线上数据库dump数据, 因为这样获取的数据备份会出现新旧数据夹杂在一起. 因此我们需要在备份时候做锁定表的操作.</p><p>mysqldump就有提供类似的选项:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--lock-all-tables, -x</span><br><span class="line">Lock all tables across all databases. This is achieved by acquiring a global read lock for the duration of the whole dump. This option automatically turns off --single-transaction and --lock-tables.</span><br><span class="line"></span><br><span class="line">--lock-tables, -l</span><br><span class="line">For each dumped database, lock all tables to be dumped before dumping them. The tables are locked with READ LOCAL to allow concurrent inserts in the case of MyISAM tables. For transactional tables such as InnoDB, --single-transaction is a much better option than --lock-tables because it does not need to lock the tables at all.</span><br><span class="line"></span><br><span class="line">Because --lock-tables locks tables for each database separately, this option does not guarantee that the tables in the dump file arelogically consistent between databases. Tables in different databases may be dumped in completely different states.</span><br></pre></td></tr></table></figure><p>其中, 我们可以直接给所有的表都施加一个全局的读锁, 不过在我们只备份其中的几个表, 这个选项就有点太过了. 因此可以选择只锁定我们需要备份的表. 注意这里是读锁, 因此还是可以进行读的操作的. </p><p>首先我们说MyISAM存储引擎. 我们前面也说过了, 它是不能热备的, 因为我们就锁定备份库然后进行备份操作就行了. 而对于InnoDB而言, 我们可以实现热备, 为了实现热备, 我们会使用到InnoDB的事务功能.</p><p>mysqldump可以启动一个巨大的事务操作, 在备份结束之后才commit. 这个选项叫做<code>--single-transaction</code>. 这样我们备份的数据就是一个时间点的.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--single-transaction</span><br><span class="line">           </span><br><span class="line">This option sends a START TRANSACTION SQL statement to the server before dumping data. It is useful only with transactional tables such as InnoDB, because then it dumps the consistent state of the database at the time when BEGIN was issued without blocking any applications.</span><br><span class="line"></span><br><span class="line">When using this option, you should keep in mind that only InnoDB tables are dumped in a consistent state. For example, any MyISAM or MEMORY tables dumped while using this option may still change state.</span><br><span class="line"></span><br><span class="line">While a --single-transaction dump is in process, to ensure a valid dump file (correct table contents and binary log coordinates), no other connection should use the following statements: ALTER TABLE, CREATE TABLE, DROP TABLE, RENAME TABLE, TRUNCATE TABLE. A consistent read is not isolated from those statements, so use of them on a table to be dumped can cause the SELECT that is performed by mysqldump to retrieve the table contents to obtain incorrect contents or fail.</span><br><span class="line"></span><br><span class="line">The --single-transaction option and the --lock-tables option are mutually exclusive because LOCK TABLES causes any pending transactions to be committed implicitly.</span><br><span class="line"></span><br><span class="line">This option is not supported for MySQL Cluster tables; the results cannot be guaranteed to be consistent due to the fact that the NDBCLUSTERstorage engine supports only the READ_COMMITTED transaction isolation level. You should always use NDB backup and restore instead.</span><br><span class="line"></span><br><span class="line">To dump large tables, you should combine the --single-transaction option with --quick.</span><br></pre></td></tr></table></figure><p>mysqldump还可以备份数据库相关的event scheduler, 通过<code>-E</code>或者<code>--events</code>选项来指定.</p><p>存储过程和存储函数也是可以备份的, 通过<code>-R</code>来指明备份这些.</p><p>默认情况下, 触发器也是被备份的, 如果想要避免备份触发器, 传递<code>--skip-triggers</code>.</p><p>在锁定表完成后, 进行日志滚动: <code>--flush-logs</code>. 为什么要做这个操作呢? 这样当我们一次备份结束, 在下一次备份的时候就可以直接把新的binlog拿来用了, 而不需要看上一次备份的master-log的位置在哪里.</p><p>总的来说, 在中小规模的数据库下, mysqldump可以说是一个廉价可靠易用的解决方案.</p><h2 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h2><p>接下来我们再来说说<code>xtrabackup</code>这个工具. </p><p>在我们的epel源中收录了他的2.3.6版本, 可以直接通过yum下载安装.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# rpm -ql percona-xtrabackup</span><br><span class="line">/usr/bin/innobackupex</span><br><span class="line">/usr/bin/xbcrypt</span><br><span class="line">/usr/bin/xbstream</span><br><span class="line">/usr/bin/xtrabackup</span><br><span class="line">/usr/share/doc/percona-xtrabackup-2.3.6</span><br><span class="line">/usr/share/doc/percona-xtrabackup-2.3.6/COPYING</span><br><span class="line">/usr/share/doc/percona-xtrabackup-2.3.6/README</span><br><span class="line">/usr/share/doc/percona-xtrabackup-2.3.6/VERSION</span><br><span class="line">/usr/share/man/man1/innobackupex.1.gz</span><br><span class="line">/usr/share/man/man1/xbcrypt.1.gz</span><br><span class="line">/usr/share/man/man1/xbstream.1.gz</span><br><span class="line">/usr/share/man/man1/xtrabackup.1.gz</span><br></pre></td></tr></table></figure><p>可以看到下载生成的文件很少, 基本就是几个应用程序然后就是帮助文档了.</p><p>这里有一个innobackupex的程序, man文档中说他是一个perl脚本, 用作xtrabackup的wrapper, 但是实际上这个东西就是一个软连接, 指向xtrabackup.</p><p>在我们使用xtrabackup进行备份的时候, 应用程序会在我们的备份目录中创建这些文件:</p><ul><li>xtrabackup_checkpoints – 备份类型(完全或增量), 备份状态(如是否是prepared) 以及 LSN (日志序列号)</li></ul><p>对于每个InnoDB页都会有一个LSN.</p><ul><li>xtrabackup_binlog_info – mysql服务器当前正在使用的二进制日志文件以及到备份这一刻位置的二进制日志时间的位置</li><li>xtrabackup_binlog_pos_innodb – 二进制日志文件及用于InnoDB或者XtraDB的表的二进制日志文件的位置</li></ul><p>我们来执行一次备份操作, 就会好理解很多.</p><p>首先还是看一下我们当前的表:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/hellodb_table_innodb.png" alt="hellodb_table_innodb"></p><p>使用的都是InnoDB引擎. 接着我们要来确保一下<code>innodb_file_per_table</code>这个选项是要打开的.</p><p>我们直接运行一次全库的备份: <code>innobackupex --user=???--password=??? /backups/</code>, 这里其实默认就带上了百分的参数<code>--backup</code>因此我们可以忽略不写.</p><p>执行的结果最后告诉我们备份的目标地址以及一些信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">200507 12:58:29 Backup created in directory &#x27;/backups//2020-05-07_12-58-28&#x27;</span><br><span class="line">MySQL binlog position: filename &#x27;mariadb-bin.000003&#x27;, position &#x27;245&#x27;</span><br><span class="line">200507 12:58:29 [00] Writing backup-my.cnf</span><br><span class="line">200507 12:58:29 [00]        ...done</span><br><span class="line">200507 12:58:29 [00] Writing xtrabackup_info</span><br><span class="line">200507 12:58:29 [00]        ...done</span><br><span class="line">xtrabackup: Transaction log of lsn (1646953) to (1646953) was copied.</span><br><span class="line">200507 12:58:29 completed OK!</span><br></pre></td></tr></table></figure><p>在这个备份的目录下, 我们可以看到刚刚提到的那些文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# ls -l /backups/2020-05-07_12-58-28/</span><br><span class="line">total 18460</span><br><span class="line">-rw-r-----. 1 root root      386 May  7 12:58 backup-my.cnf</span><br><span class="line">drwx------. 2 root root      272 May  7 12:58 hellodb</span><br><span class="line">-rw-r-----. 1 root root 18874368 May  7 12:58 ibdata1</span><br><span class="line">drwx------. 2 root root       48 May  7 12:58 mydb</span><br><span class="line">drwx------. 2 root root     4096 May  7 12:58 mysql</span><br><span class="line">drwx------. 2 root root     4096 May  7 12:58 performance_schema</span><br><span class="line">-rw-r-----. 1 root root       23 May  7 12:58 xtrabackup_binlog_info</span><br><span class="line">-rw-r-----. 1 root root      113 May  7 12:58 xtrabackup_checkpoints</span><br><span class="line">-rw-r-----. 1 root root      471 May  7 12:58 xtrabackup_info</span><br><span class="line">-rw-r-----. 1 root root     2560 May  7 12:58 xtrabackup_logfile</span><br></pre></td></tr></table></figure><p>如果查看checkpoints的内容, 我们也可以获取这一次备份的信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 2020-05-07_12-58-28]# cat xtrabackup_checkpoints </span><br><span class="line">backup_type = full-backuped</span><br><span class="line">from_lsn = 0</span><br><span class="line">to_lsn = 1646953</span><br><span class="line">last_lsn = 1646953</span><br><span class="line">compact = 0</span><br><span class="line">recover_binlog_info = 0</span><br></pre></td></tr></table></figure><p>备份完成了之后, 在进行数据恢复之前, 我们现需要对备份进行整理, 以确保不会出现事务相关的问题. 整理的选项就加上<code>apply-log</code>就可以了.</p><p>尽管我们备份的时候是不存在未完成的事务的, 我们还是可以执行一下整理命令来看一下效果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xtrabackup: cd to /backups/2020-05-07_12-58-28/</span><br><span class="line">xtrabackup: This target seems to be not prepared yet.</span><br><span class="line">xtrabackup: xtrabackup_logfile detected: size=2097152, start_lsn=(1646953)</span><br><span class="line">xtrabackup: using the following InnoDB configuration for recovery:</span><br><span class="line">xtrabackup:   innodb_data_home_dir = ./</span><br><span class="line">xtrabackup:   innodb_data_file_path = ibdata1:10M:autoextend</span><br><span class="line">xtrabackup:   innodb_log_group_home_dir = ./</span><br><span class="line">xtrabackup:   innodb_log_files_in_group = 1</span><br><span class="line">xtrabackup:   innodb_log_file_size = 2097152</span><br><span class="line">xtrabackup: using the following InnoDB configuration for recovery:</span><br><span class="line">xtrabackup:   innodb_data_home_dir = ./</span><br><span class="line">xtrabackup:   innodb_data_file_path = ibdata1:10M:autoextend</span><br><span class="line">xtrabackup:   innodb_log_group_home_dir = ./</span><br><span class="line">xtrabackup:   innodb_log_files_in_group = 1</span><br><span class="line">xtrabackup:   innodb_log_file_size = 2097152</span><br><span class="line">xtrabackup: Starting InnoDB instance for recovery.</span><br></pre></td></tr></table></figure><p>首先是获取我们备份目录下的内容然后读取InnoDB存储引擎的配置.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">InnoDB: 5.6.24 started; log sequence number 1646953</span><br><span class="line">xtrabackup: Last MySQL binlog file position 436, file name ./mariadb-bin.000001</span><br><span class="line"></span><br><span class="line">xtrabackup: starting shutdown with innodb_fast_shutdown = 1</span><br><span class="line">InnoDB: FTS optimize thread exiting.</span><br><span class="line">InnoDB: Starting shutdown...</span><br><span class="line">InnoDB: Shutdown completed; log sequence number 1646963</span><br><span class="line">xtrabackup: using the following InnoDB configuration for recovery:</span><br><span class="line">xtrabackup:   innodb_data_home_dir = ./</span><br><span class="line">xtrabackup:   innodb_data_file_path = ibdata1:10M:autoextend</span><br><span class="line">xtrabackup:   innodb_log_group_home_dir = ./</span><br><span class="line">xtrabackup:   innodb_log_files_in_group = 2</span><br><span class="line">xtrabackup:   innodb_log_file_size = 5242880</span><br><span class="line">InnoDB: Using atomics to ref count buffer pool pages</span><br><span class="line">InnoDB: The InnoDB memory heap is disabled</span><br><span class="line">InnoDB: Mutexes and rw_locks use GCC atomic builtins</span><br><span class="line">InnoDB: Memory barrier is not used</span><br><span class="line">InnoDB: Compressed tables use zlib 1.2.7</span><br><span class="line">InnoDB: Using CPU crc32 instructions</span><br><span class="line">InnoDB: Initializing buffer pool, size = 100.0M</span><br><span class="line">InnoDB: Completed initialization of buffer pool</span><br><span class="line">InnoDB: Setting log file ./ib_logfile101 size to 5 MB</span><br><span class="line">InnoDB: Setting log file ./ib_logfile1 size to 5 MB</span><br><span class="line">InnoDB: Renaming log file ./ib_logfile101 to ./ib_logfile0</span><br><span class="line">InnoDB: New log files created, LSN=1646963</span><br><span class="line">InnoDB: Highest supported file format is Barracuda.</span><br><span class="line">InnoDB: 128 rollback segment(s) are active.</span><br><span class="line">InnoDB: Waiting for purge to start</span><br><span class="line">InnoDB: 5.6.24 started; log sequence number 1647116</span><br><span class="line">xtrabackup: starting shutdown with innodb_fast_shutdown = 1</span><br><span class="line">InnoDB: FTS optimize thread exiting.</span><br><span class="line">InnoDB: Starting shutdown...</span><br><span class="line">InnoDB: Shutdown completed; log sequence number 1647126</span><br><span class="line">200507 13:06:18 completed OK!</span><br></pre></td></tr></table></figure><p>接着会读取最后一个二进制日志文件, 然后创建一个新的日志文件, 标记序列号.</p><p>接下来我们就可以进行恢复操作了. 注意在恢复的时候, mysql服务可以为关闭状态.</p><p>恢复的参数是<code>--copy-back</code>.</p><p>在执行完毕之后, 你可能会遇到文件权限的问题. 这是因为在执行完操作之后, data的属主属组会变成mysql没有权限访问的对象, 因此, 我们需要在启动之前更改数据文件的属主属组.</p><p>这里我们做的是一个全库的备份. 如果是增量备份呢?</p><p>想要实现增量备份, 首先我们需要一个已有的备份. 我们之前说过每个InnoDB的页面都会包含一个LSN信息, 增量备份就是通过这个信息来实现的. 我们可以用下面的命令进行第一个增量备份: (省略user&#x2F;password)</p><p><code>innobackupex --incremental /backup --incremental-basedir=BASEDIR</code></p><p>这里BASEDIR指的就是完全备份所在的目录.  这个备份倒没什么, 但是此刻聪明的你一定想到了, 在进行准备恢复操作的时候, 就会有一点不同了.</p><p>首先我们需要在每个(完全+增量)备份中, 进行事务的重放操作. 重放之后, 所有的备份数据就会合并到我们的完全备份上.  接着我们就对所有的备份将未提交的事务进行回滚就行了. 反映到实际操作, 就像这样:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --apply-log --redo-only BASE-DIR</span><br><span class="line">innobackupex --apply-log --redo-only BASE-DIR --incremental-dir=INCREMENTAL-DIR-1</span><br><span class="line">innobackupex --apply-log --redo-only BASE-DIR --incremental-dir=INCREMENTAL-DIR-2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样, 将每个增量备份都执行一边, 就ok了.</p><p>我新建了<code>mydb.t2</code>并且插入了两行数据, 接着我们执行<strong>增量</strong>备份的命令.</p><p>执行一遍之后我们再来查看一下checkpoint:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 2020-05-10_03-10-25]# cat xtrabackup_checkpoints </span><br><span class="line">backup_type = incremental</span><br><span class="line">from_lsn = 1646953</span><br><span class="line">to_lsn = 1650558</span><br><span class="line">last_lsn = 1650558</span><br><span class="line">compact = 0</span><br><span class="line">recover_binlog_info = 0</span><br></pre></td></tr></table></figure><p>这一次的备份类型就变成增量了. 而且同时LSN也不再从0开始了.</p><p>接下来我们来尝试进行数据恢复. </p><p>在准备工作结束后, 再次查看全量备份的checkpoint, 我们可以看到:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# cat /backups/2020-05-07_12-58-28/xtrabackup_checkpoints </span><br><span class="line">backup_type = log-applied</span><br><span class="line">from_lsn = 0</span><br><span class="line">to_lsn = 1650558</span><br><span class="line">last_lsn = 1650558</span><br><span class="line">compact = 0</span><br><span class="line">recover_binlog_info = 0</span><br></pre></td></tr></table></figure><p>接着就copy-back即可, 别忘记改变属主属组.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MariaDB存储引擎和事务</title>
      <link href="/2020/03/03/MariaDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2020/03/03/MariaDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>我们之前初步了解了MariaDB, 接着学习了MySQL的一些关于权限, 缓存和索引的东西. 接下来我们继续聊聊关于存储引擎的相关知识.</p><span id="more"></span><p>我们之前聊过MySQL的架构, 其中, 有很多可插拔的第三方或者社区支持的<strong>存储引擎</strong>, 说到底MySQL的很多特性都是来源于存储引擎的, 其中比较有名的就是MyISAM和InnoDB, 相比于MyISAM, InnoDB支持事务, 这一点就让InnoDB让更多人选择, 或者成为默认的存储引擎(5.5版本之后). 但是当然啦, 存储引擎不止这两个, 还有很多的, 接下来我们就来就其中几个比较重要的来做说明.</p><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><p>我们在创建一个新表的时候, 就会指明使用到的存储引擎. (CREATE TABLE … ENGINE&#x3D;…), 所以说到底, 存储引擎是一个表级别的概念, 就是表的类型.</p><p>首当其中就是InnoDB了. InnoDB的设计目标是处理大量的短期事务, 并且, 在机器宕机, 出现断电等导致内存数据还没有被写入到磁盘中的情况下, InnoDB可以自动的进行数据的修复, 这样的一大好处就是避免数据的不一致, 而MyISAM不具备这样的特性, 从而只能进行手动的修复, 手动的修复就会很容易的造成数据不一致(inconsistent).</p><p>InnoDB的数据存储在<strong>表空间</strong>中. 这个表空间就是InnoDB组织数据的”黑盒子”, 在文件系统上表现为一个由InnoDB理解的文件系统. 因此, InnoDB也可以支持裸设备, 即是说, 你可以直接分个区无需格式化从而直接供InnoDB使用.</p><p>对于InnoDB来说, 有多种存放数据的策略:</p><ul><li>所有的InnoDB表的数据, 索引, 都放置在同一个表空间中. (不易管理, 一些操作不被支持)</li><li>每个表使用单独的表空间存储表的数据和索引 <code>(innodb_file_per_table=ON)</code></li></ul><p>对于第一种存放的方式, 在datadir定义的目录下, 会出现<code>idbdata</code>开头的文件, 自动编号.</p><p>我们来看看默认配置下, datadir下的文件样子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 mysql]<span class="comment"># ls -l /var/lib/mysql/</span></span><br><span class="line">total 28704</span><br><span class="line">-rw-rw----. 1 mysql mysql    16384 Mar  4 10:26 aria_log.00000001</span><br><span class="line">-rw-rw----. 1 mysql mysql       52 Mar  4 10:26 aria_log_control</span><br><span class="line">drwx------. 2 mysql mysql     4096 Mar  4 12:17 hellodb</span><br><span class="line">-rw-rw----. 1 mysql mysql 18874368 Mar  4 10:26 ibdata1</span><br><span class="line">-rw-rw----. 1 mysql mysql  5242880 Mar  4 10:26 ib_logfile0</span><br><span class="line">-rw-rw----. 1 mysql mysql  5242880 Mar  4 10:26 ib_logfile1</span><br><span class="line">drwx------. 2 mysql mysql     4096 Mar  4 10:26 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 Mar  4 10:26 mysql.sock</span><br><span class="line">drwx------. 2 mysql mysql     4096 Mar  4 10:26 performance_schema</span><br></pre></td></tr></table></figure><p>其中的ibdata1就是我们的表空间了.</p><p>接下来我们修改配置加上<code>innodb_file_per_table</code>之后, 来创建一个新表试试.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; create database mydb;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; use mydb;</span><br><span class="line">Database changed</span><br><span class="line">MariaDB [mydb]&gt; create table t1 (<span class="built_in">id</span> int, name char(30));</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [mydb]&gt; Bye</span><br><span class="line">[root@node1 mysql]<span class="comment"># ls /var/lib/mysql/mydb/ -l</span></span><br><span class="line">total 208</span><br><span class="line">-rw-rw----. 1 mysql mysql    65 Mar  8 11:32 db.opt</span><br><span class="line">-rw-rw----. 1 mysql mysql  8586 Mar  8 11:32 t1.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql 98304 Mar  8 11:32 t1.ibd</span><br></pre></td></tr></table></figure><p>可以看到, 在这个数据库目录下, 有一个叫做<code>t1.ibd</code>的文件. 这个玩意就是表空间文件, 表现为<code>table_name.ibd</code>这个样子. 另外的一个<code>*.frm</code>的文件是表格式定义(format).</p><p>接下来我们快速过一遍InnoDB的一些特性:</p><ul><li>基于MVCC来支持高并发 – MVCC-Multi Version Concurrency Control</li><li>支持所有的事务隔离级别, 默认级别: REPEATABLE READ</li><li>使用间隙锁防止幻读</li><li>使用聚集索引</li><li>支持”自适应哈希索引” – Adaptive Hash Index</li><li>支持热备 (在线) – <code>xtrabackup</code></li><li>支持行级锁</li></ul><p>我们之前在介绍MariaDB的时候就说过, 它使用的其实不是InnoDB存储引擎, 而是一个社区的改良版, <code>XtraDB</code>. 其实在我们列出存储引擎的时候就能看到:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/show_engine_percona_xtraDB.png" alt="show_engine_percona_xtraDB"></p><p>这个Percona是一个著名的MySQL的技术顾问公司.</p><h2 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h2><p>接下来我们再来说MyISAM, 这个存储引擎早期是针对一些数据仓库设计的, 即较少的写操作, 较多的读操作. 因为不适合在线事务处理. 但MyISAM是MySQL很早期的存储引擎, 因此是十分成熟的. 并且他还有一个很棒的特性就是支持全文索引(<code>FULLTEXT idnex</code>), 可以压缩, 支持空间函数. 相较于InnoDB精细的锁粒度, MyISAM是表级的锁, 因此十分容易出现竞争态. 还有就是我们说过的, 不支持安全恢复.</p><p>因此在MariaDB中, 我们使用MyISAM的时候, 就会使用<code>Aria</code>存储引擎, 你可以在上面的图中的最后一行看到. 这就是支持安全恢复的MyISAM存储引擎.</p><p>那么MyISAM是如何存储数据的呢? 我们之前使用的hellodb数据库就是使用的MyISAM引擎, 我们来看看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># ls /var/lib/mysql/hellodb/ -l</span></span><br><span class="line">total 140</span><br><span class="line">-rw-rw----. 1 mysql mysql 8636 Mar  4 12:17 classes.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql  172 Mar  4 12:17 classes.MYD</span><br><span class="line">-rw-rw----. 1 mysql mysql 2048 Mar  4 12:17 classes.MYI</span><br><span class="line">-rw-rw----. 1 mysql mysql 8630 Mar  4 12:17 coc.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql  112 Mar  4 12:17 coc.MYD</span><br><span class="line">-rw-rw----. 1 mysql mysql 2048 Mar  4 12:17 coc.MYI</span><br><span class="line">-rw-rw----. 1 mysql mysql 8602 Mar  4 12:17 courses.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql  144 Mar  4 12:17 courses.MYD</span><br><span class="line">-rw-rw----. 1 mysql mysql 2048 Mar  4 12:17 courses.MYI</span><br><span class="line">-rw-rw----. 1 mysql mysql   61 Mar  4 12:17 db.opt</span><br><span class="line">-rw-rw----. 1 mysql mysql 8658 Mar  4 12:17 scores.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql  180 Mar  4 12:17 scores.MYD</span><br><span class="line">-rw-rw----. 1 mysql mysql 2048 Mar  4 12:17 scores.MYI</span><br><span class="line">-rw-rw----. 1 mysql mysql 8736 Mar  4 12:17 students.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql  624 Mar  4 12:17 students.MYD</span><br><span class="line">-rw-rw----. 1 mysql mysql 2048 Mar  4 12:17 students.MYI</span><br><span class="line">-rw-rw----. 1 mysql mysql 8656 Mar  4 12:17 teachers.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql   92 Mar  4 12:17 teachers.MYD</span><br><span class="line">-rw-rw----. 1 mysql mysql 2048 Mar  4 12:17 teachers.MYI</span><br><span class="line">-rw-rw----. 1 mysql mysql 8622 Mar  4 12:17 toc.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql    0 Mar  4 12:17 toc.MYD</span><br><span class="line">-rw-rw----. 1 mysql mysql 1024 Mar  4 12:17 toc.MYI</span><br></pre></td></tr></table></figure><p>可以看到一共有三种文件类型, <code>frm</code>,  <code>MYD</code>, <code>MYI</code>. 其实大概可以猜出来, 其中<code>frm</code>和上面一样是存储表的格式的, D代表Data, I代表Index, 因此, 对于MyISAM来说, 数据和索引是分开存放的. 每一个表都是这三个文件.</p><h2 id="其他的一些存储引擎"><a href="#其他的一些存储引擎" class="headerlink" title="其他的一些存储引擎"></a>其他的一些存储引擎</h2><h3 id="CSV存储引擎"><a href="#CSV存储引擎" class="headerlink" title="CSV存储引擎"></a>CSV存储引擎</h3><p>首先CSV (逗号分隔) 就是一种数据结构, 把它当做表来处理, 就是这么简单. </p><p>显然这是不支持索引的, 但是对于导出导入就很灵活.</p><h3 id="MRG-MYISAM"><a href="#MRG-MYISAM" class="headerlink" title="MRG_MYISAM"></a>MRG_MYISAM</h3><p>可以将多个MyISAM的表合并成为一个虚拟表.</p><h3 id="BLACKHOLE"><a href="#BLACKHOLE" class="headerlink" title="BLACKHOLE"></a>BLACKHOLE</h3><p>就是<code>/dev/null</code>, 没有实现任何的存储机制.</p><h3 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h3><p>内存存储引擎, 性能很好(因为全是内存表), 支持hash索引, 并且还有表级锁. 这个临时表存在一个存储的上限, 达到上限就会被写入到磁盘上.</p><h3 id="PERFORMANCE-SCHEMA"><a href="#PERFORMANCE-SCHEMA" class="headerlink" title="PERFORMANCE_SCHEMA"></a>PERFORMANCE_SCHEMA</h3><p>伪存储引擎, 用来记录MySQL的一些运行数据. 启动前和启动后都是空的.</p><h3 id="ARCHIVE"><a href="#ARCHIVE" class="headerlink" title="ARCHIVE"></a>ARCHIVE</h3><p>用于数据归档, 仅支持insert和select. 会缓存所有写并使用zlib进行压缩, 但是每一次的select都要进行全表扫描. 有行级锁和专用缓存区.</p><h2 id="MySQL的并发控制"><a href="#MySQL的并发控制" class="headerlink" title="MySQL的并发控制"></a>MySQL的并发控制</h2><p>接下来我们简单的说说, MySQL的读写锁.</p><p>读锁就是共享锁, 一个资源可以被多次增加读锁; 写锁就是独占锁, 或者说叫做排它锁. 那么对于并发访问控制而言, 锁的粒度就十分重要了, 比较常见的是, 表级锁和行级锁. 这里肯定不是越精细就越好, 精细的粒度带来的是更大的锁开销, 因此, 寻找一个锁策略可以在数据安全和锁粒度这两者中获取平衡就至关重要了.</p><p>几乎每种存储引擎都可以自行实现自己的锁策略和锁粒度, 同时MySQL在服务器级别也实现了锁, 默认的锁级别就是表级锁. 并且用户是可以进行显式请求施加锁的, 虽然这不是一件推荐做的事情, 因为大多数的情况下, 这些操作都是存储引擎自动完成的, 尽量应该避免用户的干预. 我们把这里的隐式锁叫做存储引擎自动施加的, 而显式锁就是用户手动添加.</p><p>接下来我们演示一下, 用户手动加锁的操作. 还是先看看帮助文档:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; <span class="built_in">help</span> lock</span><br><span class="line">Name: <span class="string">&#x27;LOCK&#x27;</span></span><br><span class="line">Description:</span><br><span class="line">Syntax:</span><br><span class="line">LOCK TABLES</span><br><span class="line">    tbl_name [[AS] <span class="built_in">alias</span>] lock_type</span><br><span class="line">    [, tbl_name [[AS] <span class="built_in">alias</span>] lock_type] ...</span><br><span class="line"></span><br><span class="line">lock_type:</span><br><span class="line">    READ [LOCAL]</span><br><span class="line">  | [LOW_PRIORITY] WRITE</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES</span><br></pre></td></tr></table></figure><p>通过<code>lock tables</code>来指明加锁. 解锁使用<code>lock tables</code>.</p><p>现在我们登陆两个线程, 一个加锁, 另外一个尝试做操作, 来看看变化.</p><p>线程1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [mydb]&gt; lock tables t1 write;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [mydb]&gt; unlock tables;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>线程2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [mydb]&gt; select SQL_NO_CACHE * from t1;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | name |</span><br><span class="line">+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [mydb]&gt; select SQL_NO_CACHE * from t1;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | name |</span><br><span class="line">+------+------+</span><br><span class="line">1 row in set (12.46 sec)</span><br></pre></td></tr></table></figure><p>其中, 第一次的查询操作是没有加锁的, 而第二次的查询时, 我们已经加锁了, 因此查询被堵塞. 在我们释放锁的一瞬间, 结果就返回了. 从查询的时间可以看出来, 这次查询是被堵塞了.</p><p>注意这个地方我在每次查询的时候都加上了<code>SQL_NO_CACHE</code>参数, 目的就是为了防止缓存. 如果你在加了写锁之后发现还可以访问数据, 那大概是来源于缓存, 这个时候你可以update表一次, 从而令缓存失效就可以了.</p><p>除了这样加锁, 我们还可以在查询的时候就加上锁, 也可以使用<code>FLUSH TABLES</code>来加锁. 不过这里就不赘述了.</p><h2 id="MySQL的事务"><a href="#MySQL的事务" class="headerlink" title="MySQL的事务"></a>MySQL的事务</h2><p>什么是<strong>事务</strong>嘞? 这可真是老生常谈了, 事务是一组原子性的SQL查询, 或者说是一个独立的工作单元. 任何一个事务都要经过ACID测试, 即:</p><ul><li>A: Atomicity: 原子性. 整个事务中的所有操作, 要么全部成功执行 , 要么全部失败回滚. 具体实现上, 我们需要撤销和重做日志.</li><li>C: Consistency: 一致性. 数据库总是从一个一致性状态转换至另外一个一致性状态.</li><li>I: Isolation: 隔离性. 一个事物所做出的的操作, 在提交之前, 是不能被其他的事务所看见的. 由此引入, 多种隔离级别, 隔离级别会影响到并发性能和数据的安全性.</li><li>D: Durability: 持久性. 一个事务提交, 其所作的修改会永久保存在数据库中.</li></ul><p>我们来看下事务的生命周期:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="事务的生命周期"></p><p>大体上, 我们需要显式启动事务, 接着进行一堆修改操作, 一旦提交, 就会持久保存. 或者, 进行回滚操作, 就会回到最初的状态.</p><p>当然, 只有支持事务的存储引擎才能支持上面的操作. 我们之前使用的测试sql是使用的MyISAM引擎, 我们可以修改成InnoDB来做测试.</p><p>事实上, 对于InnoDB而言, 默认每一条语句都是一个小事务, 有一个控制这个行为变量:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; show global variables like &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>也就是自动提交, 这参数默认是开启的, 也就是所其实每一次的SQL的操作, 都会被打开一个事务, 然后自动提交. 这个行为其实是很消耗磁盘IO的, 所以建议显式的进行事务请求和提交, 就可以有效降低数据库的IO.</p><p>其实事务还支持<strong>保存点(save point)</strong>, 这个其实有点类似git的版本控制, 我们可以选择回滚到某一个位置, 来看文档:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; help savepoint;</span><br><span class="line">Name: &#x27;SAVEPOINT&#x27;</span><br><span class="line">Description:</span><br><span class="line">Syntax:</span><br><span class="line">SAVEPOINT identifier</span><br><span class="line">ROLLBACK [WORK] TO [SAVEPOINT] identifier</span><br><span class="line">RELEASE SAVEPOINT identifier</span><br><span class="line"></span><br><span class="line">InnoDB supports the SQL statements SAVEPOINT, ROLLBACK TO SAVEPOINT,</span><br><span class="line">RELEASE SAVEPOINT and the optional WORK keyword for ROLLBACK.</span><br></pre></td></tr></table></figure><p>我们可以直接选择回滚到某一个位置上.</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>接着我们来说说事务的隔离级别. 有以下的级别:</p><ul><li>READ UNCOMMITTED (读未提交)</li><li>READ COMMITTED (读提交)</li><li>REPEATABLE READ (可重读)</li><li>SERILIAZABLE (可串行化)</li></ul><p>在事务中, 会出现很多问题, 这些问题有:</p><ul><li>脏读: 读别的事务没有提交的数据</li><li>不可重复读: 数据两次读到的值不一样</li><li>幻读: 多个事务, 其中一个事务多次执行的结果在第二个事务的干预下产生了不一致.</li></ul><blockquote><p>关于这个地方, 我要稍微多说说关于这个幻读, 因为有点难以理解. SQL标准上的意思更多的是在强调: 查询结果出现了新增行. 举维基百科的例子就很清楚了:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/%E5%B9%BB%E8%AF%BB_from_Wikipedia.png" alt="幻读_from_Wikipedia"></p></blockquote><p>对于这些问题, 不同的隔离级别会有不同的读问题.</p><p>定义MySQL的隔离级别的参数叫做<code>tx_isolation</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; show global variables like &#x27;%isolation%&#x27;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| tx_isolation  | REPEATABLE-READ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到我们现在用的是可重读.</p><p>说回到我们的InnoDB, 我们提到了一个特性叫做MVCC机制, 即多版本并发控制, 这个机制会在MySQL启动的时候存储数据集的快照, 然后通过这个快照来实现很多事务和并发操作. 不过这只是一点点浅显的实现, 关于MVCC的技术细节还是十分复杂的. 这里就略过啦.</p><p>但是, 尽管我们有事务, 还是可能会有新的问题, 考虑这样的场景. 一个事务进行提交, 其中包含大量的写语句, 假设现在使用的是机械硬盘, 机械硬盘的一个特性就是需要寻道. 如果我们的要操作的数据块是分散的, 大量的随机IO是需要消耗很多时间的, 假设正在寻道中, 数据库服务器崩了, 那么我的这些操作也就中断了, 数据就不一致了. 这咋办?</p><p>这就需要日志了, 还记得我们之前提到的事务日志吗? MySQL在提交事务操作的时候, 不会直接写到数据文件里面, 而是先写事务日志, 而这个事务日志文件是磁盘上连续的地址, 一次寻道, 就可以全部写进去. 这样的话, 如果数据库崩溃, 即使内存中缓冲区的数据被清掉了, 但是在重启的时候, 数据库会进行一次检查, 将事务日志的内容写到数据文件中. 另外, 这个事务日志一般都是多个出现, 一般是2个或者3个. 这是为了防止文件过大.</p><p>事务日志的写入类型都是 “追加”, 因此写入操作都是 “顺序IO”. 这些日志都是<strong>预写式日志(write ahead logging)</strong>.</p><p>事务日志是由存储引擎控制的, 我们来看看innodb的日志:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># ls /var/lib/mysql/ -lh</span></span><br><span class="line">total 29M</span><br><span class="line">-rw-rw----. 1 mysql mysql  16K Mar  8 11:30 aria_log.00000001</span><br><span class="line">-rw-rw----. 1 mysql mysql   52 Mar  8 11:30 aria_log_control</span><br><span class="line">drwx------. 2 mysql mysql  272 Mar  8 13:32 hellodb</span><br><span class="line">-rw-rw----. 1 mysql mysql  18M Mar  8 13:32 ibdata1</span><br><span class="line">-rw-rw----. 1 mysql mysql 5.0M Mar  8 13:32 ib_logfile0</span><br><span class="line">-rw-rw----. 1 mysql mysql 5.0M Mar  4 10:26 ib_logfile1</span><br><span class="line">drwx------. 2 mysql mysql   48 Mar  8 11:32 mydb</span><br><span class="line">drwx------. 2 mysql mysql 4.0K Mar  4 10:26 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql    0 Mar  8 11:30 mysql.sock</span><br><span class="line">drwx------. 2 mysql mysql 4.0K Mar  4 10:26 performance_schema</span><br></pre></td></tr></table></figure><p>我们可以看到两个一样大的文件<code>ib_logfile</code>, 这就是InnoDB的日志啦, 当然这个日志文件的大小也是可以调整的, 日志的数量也是可以调整的, 包括存放的位置都有变量控制:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; show global variables like &#x27;innodb_log%&#x27;;</span><br><span class="line">+---------------------------+---------+</span><br><span class="line">| Variable_name             | Value   |</span><br><span class="line">+---------------------------+---------+</span><br><span class="line">| innodb_log_block_size     | 512     |</span><br><span class="line">| innodb_log_buffer_size    | 8388608 |</span><br><span class="line">| innodb_log_file_size      | 5242880 |</span><br><span class="line">| innodb_log_files_in_group | 2       |</span><br><span class="line">| innodb_log_group_home_dir | ./      |</span><br><span class="line">+---------------------------+---------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="MariaDB的日志文件"><a href="#MariaDB的日志文件" class="headerlink" title="MariaDB的日志文件"></a>MariaDB的日志文件</h2><p>接下来我们继续说说MariaDB的日志文件, 我们在上面说到的InnoDB存储引擎对应的数据文件叫做<code>X.ibd</code>. 为了保证数据, 事件, 服务等等多类功能, 提供了多种日志, 这些日志包括:</p><ul><li>查询日志: query log (默认是不会开启的, 因为磁盘IO过多)</li><li>慢查询日志: slow query log (慢查询是指查询时间过长的查询, 为了检查和分析速度慢的原因)</li><li>错误日志: error log</li><li>二进制日志: binary log</li><li>中继日志: relay log</li><li>事务日志: transaction log</li></ul><p>我们一个一个看配置和使用.</p><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>查询日志是用来记录查询操作的, 这个日志如果开启会有非常大量的数据. 如此大量数据, 我们如果要分析日志就会变得比较困难了, 因此这个查询日志有两种记录方式:</p><ul><li>文件: file</li><li>表: table</li></ul><p>因此, MySQL的查询日志其实也可以导入到MySQL中. 我们先来看一下变量:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/log.png" alt="log"></p><p>这里的<code>general_log</code>就是控制我们的查询日志是否开启的, 默认是关闭的. 而后存储的路径, 这个路径默认是主机名, 这里我的是<code>node1</code>, 所以就这样了. 另外这里的路径是相对的, 我们也可以修改成绝对路径. 后面还有<code>log_output</code>, 表示日志存储格式是文件类型. 除此之外, 也可以改成<code>TABLE</code>或者<code>NONE</code>. </p><p>当然了, 并不是所有的查询操作都有被记录的价值. 更多的我们应该关注慢查询日志.</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p> 慢查询是指执行时长超出指定时长的查询操作. 这个指定时长其实也是我们定义的.</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/long_query_time.png" alt="long_query_time"></p><p>默认的时间是10秒钟. </p><p>同样的, 也有对应参数标明开启状态和存储位置:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/slow_query_log.png" alt="slow_query_log"></p><p>除此之外, 向上面看, 还有其他的参数表示慢查询的一些过滤器啥的. 关于过滤器, 我们可以稍微多看看. 这个会对查询的记录做限制, 例如全连接, 全表扫描, 缓存未命中, 临时表查询等等等才会记录. 另外, 还有记录速率, 记录的详细程度等等选项.</p><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志虽然叫做错误, 但其实并不仅仅是错误信息, 也有可能其他的一些信息, 例如daemon启动关闭的事件. 另外, 错误日志中还会出现:</p><ul><li>运行中产生的错误信息</li><li>scheduler运行event时产生的日志信息</li><li>主从复制架构中的从服务器上启动从服务器线程时产生的信息</li></ul><p>我们使用的CentOS 7发行版中是默认打开了错误日志的, 我们可以见到:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/error_log.png" alt="error_log"></p><p>简单看一下这个文件的内容, 也就是上面的说的那些信息. 有些东西看起来像是警告而不是错误, 那是因为还有一个选项. 叫做<code>log_warning</code>, 这个选项决定是否要记录警告信息到错误日志文件中去.</p><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>二进制日志是最重要的日志了, 它用来通过”重放”日志文件中的事件, 来生成数据的副本. 在我们的数据目录下就能看到:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># ls /var/lib/mysql/</span></span><br><span class="line">aria_log.00000001  hellodb  ib_logfile0  mariadb-bin.000001  mydb   mysql.sock</span><br><span class="line">aria_log_control   ibdata1  ib_logfile1  mariadb-bin.index   mysql  performance_schema</span><br></pre></td></tr></table></figure><p>在一些发行版中这个二进制日志是默认打开的, 但也有的版本是需要手动开启的. 控制这个日志开启与否的变量叫做<code>log-bin</code>. </p><p>在mysql的客户端中, 其实也可以查看我们当前的二进制日志, 有这么一条:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show binary logs;</span><br><span class="line">+--------------------+-----------+</span><br><span class="line">| Log_name           | File_size |</span><br><span class="line">+--------------------+-----------+</span><br><span class="line">| mariadb-bin.000001 |       436 |</span><br><span class="line">+--------------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>这样是展示当前服务器上的日志有哪些 (注意这里并不是正在使用的, 后面会说), 我们之前说过, 这个日志本身mysql也是可以看的, 我们可以通过客户端来检视这些日志中的事件:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/bin_log_show_event.png" alt="bin_log_show_event"></p><p>我们来看下这里面的表头, 首先是我们读取的文件名, 接着是当前事件的起始位置和结束位置, 这里我们可以结束位置和下一个事件的起始位置是一样的, 也就是说, 这个结束位置, 实际上是指下一个事件的位置, 虽然名字是这么叫的. 接着还有, 事件的类型, 执行的服务器的ID, 这个ID在我们之后的主从复制的架构中会说到.  以及每一个事件的信息.</p><p>接下来我们可以做个实验, 我们停止服务之后再开启:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# systemctl stop mariadb</span><br><span class="line">[root@node1 ~]# systemctl start mariadb</span><br><span class="line">[root@node1 ~]# </span><br></pre></td></tr></table></figure><p>接着还是来查看一下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show master logs;</span><br><span class="line">+--------------------+-----------+</span><br><span class="line">| Log_name           | File_size |</span><br><span class="line">+--------------------+-----------+</span><br><span class="line">| mariadb-bin.000001 |       455 |</span><br><span class="line">| mariadb-bin.000002 |       245 |</span><br><span class="line">+--------------------+-----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>看! 现在就有两个了, 这就说明 我们的这个日志文件是自动滚动的. 那如何得到当前正在使用的日志文件的信息呢? 我们可以使用<code>show master status</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show master status;</span><br><span class="line">+--------------------+----------+--------------+------------------+</span><br><span class="line">| File               | Position | Binlog_Do_DB | Binlog_Ignore_DB |</span><br><span class="line">+--------------------+----------+--------------+------------------+</span><br><span class="line">| mariadb-bin.000002 |      245 |              |                  |</span><br><span class="line">+--------------------+----------+--------------+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>这样就可以看到当前正在使用的以及当前的事件要写在什么位置.</p><p>另外, 我们的二进制日志有三种记录格式, 分别是:</p><ul><li>基于”语句”记录: statement</li><li>基于”行”记录: row</li></ul><p>以及将两种混合的mix模式, 让系统自行判定基于哪种方式来进行记录. 那我们为什么需要有多种记录方式呢?</p><p>考虑这样的情况, 如果现在有两个事务, 一个是update所有年龄大于等于60的某个值, 另一个是将一个人的年龄从59改成了60, 在这种情况下, 如果记录到日志中之后, 进行重放就会出现问题, 因为语句的执行顺序不一定会相同. </p><p>基于行, 我们就记录数据. 基于语句, 我们就记录执行的语句.</p><p>接着我们再来说说二进制日志文件的构成, 有两类文件:</p><ul><li>日志文件: mysql-bin.文件名后缀, 二进制格式</li><li>索引文件: mysql-bin.index, 文本格式</li></ul><p>我们可以cat一下这个索引文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 mysql]# cat mariadb-bin.index </span><br><span class="line">./mariadb-bin.000001</span><br><span class="line">./mariadb-bin.000002</span><br></pre></td></tr></table></figure><p>那么哪些变量操作我们的二进制日志的行为嘞? 来看:</p><ul><li><code>binlog_format</code> 默认这里是statement, 表示我们基于语句进行记录</li><li><code>max_binlog_size</code> 单个二进制日志文件的最大体积, 默认是1G, 如果达到最大值就会进行自动日志滚动 (当然啦, 这个肯定不会是精确值).</li><li><code>max_binlog_stmt_cache_size</code>, <code>max_binlog_cache_size</code> 这两个看名字就懂啦</li><li><code>expire_logs_days</code> 设置日志的过期时长. 默认是0. 意为不启用</li><li><code>sync_binlog</code> 是否启动二进制日志的同步功能, 0表示不启用, 1表示启用, N(&gt;1)表示等到N个二进制日志收集之后才会被同步.</li></ul><p>在我们装的mysql的bin目录下, 有一个专门的用来dump二进制日志的工具, 叫做<code>mysqlbinlog</code>. 这个玩意可以让我们直接在命令行中看日志中的事件, 来随便截一段看看:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">at 313</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">200322  5:50:45 server <span class="built_in">id</span> 1  end_log_pos 409 Querythread_id=2exec_time=0error_code=0</span></span><br><span class="line">use `mydb`/*!*/;</span><br><span class="line">SET TIMESTAMP=1584827445/*!*/;</span><br><span class="line">insert into t1 values (2, &quot;test&quot;)</span><br><span class="line">/*!*/;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">at 409</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">200322  5:50:45 server <span class="built_in">id</span> 1  end_log_pos 436 Xid = 13</span></span><br><span class="line">COMMIT/*!*/;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">at 436</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">200322  6:04:31 server <span class="built_in">id</span> 1  end_log_pos 455 Stop</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">End of <span class="built_in">log</span> file</span></span><br><span class="line">ROLLBACK /* added by mysqlbinlog */;</span><br></pre></td></tr></table></figure><p>你看, 这些信息其实就是我们刚刚看到的事件的各种信息, 例如发生的日期和时间, 服务器表示, 结束位置, 事件类型, 线程ID, 语句的时间戳和写入二进制文件中的时间差, 错误代码等等</p><p>说道工具的使用, 其实直接看文档就好, 一些常用的选项:</p><ul><li>start-position &#x2F; stop-position : 开始和终止位置</li><li>start-datetime &#x2F; stop-datetime : 开始和结束时间, 格式形如这样: YYYY-MM-DD hh:mm:ss</li></ul><h3 id="中继日志"><a href="#中继日志" class="headerlink" title="中继日志"></a>中继日志</h3><p>这个日志等到复制架构中, 我们再来聊. 这个玩意是从服务器用来保存从主服务器的二进制日志中读取到的事件.</p><h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>事务日志是由事务性存储引擎自行管理和使用的, 而且它们一般是成对的出现的, 一个叫做<code>redo</code>, 一个叫做<code>undo</code>.</p><p>关于事务日志, 我们在上一节中已经提到了一些. 这里我们就这样啦.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes架构基础</title>
      <link href="/2020/01/10/Kubernetes%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/01/10/Kubernetes%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>在熟悉了Docker相关的操作之后, 我们现在就可以来对大规模集群的容器编排下手了.</p><span id="more"></span><h2 id="容器编排工具栈"><a href="#容器编排工具栈" class="headerlink" title="容器编排工具栈"></a>容器编排工具栈</h2><p>我们之前在说Docker的时候就提到过了编排与自动化的概念, 当时我们还引用了维基百科的概念. 我们在使用Ansible的时候, 通过编写playbook就是在进行自动化的编排. 除此之外, 还有puppet, saltstack等等. 而Ansible这些对应的单元是一个个的虚拟机, 在我们引入了Docker之后, 就会发生些许变化, 当管理的对象发生的变化的时候, 我们也要改变我们所使用的工具栈.</p><p>首先就是Docker自己的Docker Compose, 但是这个工具面向的只是一个Docker Host, 也就是说, 他只能对一台主机的多个容器进行编排. 为了能够扩展到多主机的集群环境, 另一个软件就是Docker Swarm, 他可以将多个主机的 容器资源抽象成一个大的资源池, 进行整合工作. 但是将一个Host加入到这个Swarm成员有需要另一个工具, 叫做Docker Machine. 这三个工具, 组成了早期Docker编排的三剑客.</p><p>第二组工具的核心是Mesos, 一个Apache基金会下的分布式系统kernel, 能够对计算进行抽象并提供API支持, 它原生提供了容器支持. 但是说白了Mesos就是一个资源分配工具, 或者说是一个IDC的操作系统. 因此我们还需要一个容器的托管工具, 因为Mesos并不能直接运行容器, 这就是Marathon, 这是一个容器的编排框架.</p><p>最后一种常见的工具, 也就是我们即将探讨的Kubernetes. 就目前来看, Kubernetes已经占据了最多的份额.</p><h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><p>Kubernetes源自于Google内部的Borg项目, 据说google在内部使用容器技术已经超过了十年秘而不宣, 没想到Docker横空出世, 自己私藏的东西竟然被民间发现了, 于是使用Go语言重新实现了Borg项目. 这就是Kubernetes的来由.</p><p>Kubernetes能够实现<strong>自动装箱</strong>. 啥意思嘞? 就是根据资源之间的依赖关系自动的进行部署. 另外还可以<strong>自我修复</strong>, 当应用程序崩溃后, 得益于容器技术, 我们不再像之前一样需要进行复杂的部署流程了, 直接kill掉出问题的容器然后新启动一个就行了. 另外, Kubernetes还可以实现水平扩展, 只要物理服务器的资源足够, 就可以不断的新建容器. 以及, 服务发现以及负载均衡, 自动发布和回滚, 密钥和配置管理, 存储编排, 批量处理执行.</p><p>按照我们之前的理解, 其实Kubernetes也是一个集群, 在几个是主机上安装Kubernetes应用程序, 接着让他们协同工作. 值得注意的是, 这里的主机间是存在角色的, 类似我们之前所学到的MySQL的主从模型, 存在一个或多个Master Node和多个Worker Nodes. 这些Worker就是用来提供计算资源以及存储的, 说白了他们其实就是容器节点, 对于容器的启动, 调度等等操作就由Master Node来进行, 用户向Master发送请求, 有Master来分析后端当前的负载情况来进行具体的操作. 顺便说一个, Kubernetes也可以托管Kubernetes.</p><h2 id="Kubernetes的架构概述和基础概念"><a href="#Kubernetes的架构概述和基础概念" class="headerlink" title="Kubernetes的架构概述和基础概念"></a>Kubernetes的架构概述和基础概念</h2><p>既然我们说了是向Master发送请求, 那么必然会有一个API的组件, 在Kubernetes的Master Node上, 这个组件就叫做API Server, 除此之外, 必然还有一个叫做调度器(Scheduler)的组件, 他时刻关注后端的CPU, RAM存储等情况来对资源进行调度. </p><p>上面谈论的都是Kubernetes的Master, 但是对于容器, 我们之前在说到的Docker的时候提到过容器的健康状态检测(Health Check), 这就依赖在Worker上的应用程序**<code>kubelet</code>**了. 这个程序会监控当前主机上的容器状态并作报告. 现在假设, 这个Worker Node, 也就是我们运行容器的主机宕机了而不是容器崩溃的话, 在整个主机上托管的服务就都下线了, 这个时候就要做上面提到的自我修复了. 这些控制器会监控自己创建的容器健康状态, 如果有问题就进行调整. </p><p>我们再来贴个图:</p><p><img src="https://d33wubrfki0l68.cloudfront.net/7016517375d10c702489167e704dcb99e570df85/7bb53/images/docs/components-of-kubernetes.png" alt="Components of Kubernetes"></p><p>但是这个控制器组件(kubelet)也是会出问题的, 因此我们在主节点上有Controller Manager组件, 与容器节点上的kubelet应用程序通过API Server进行通信, 在这个组件的层次上, 我们进行冗余. 值得一提的是, Kubernetes包含许多类型的控制器, </p><ul><li>Node Controller: Responsible for noticing and responding when nodes go down.</li><li>Replication Controller: Responsible for maintaining the correct number of pods for every replication controller object in the system.</li><li>Endpoints Controller: Populates the Endpoints object (that is, joins Services &amp; Pods).</li><li>Service Account &amp; Token Controllers: Create default accounts and API access tokens for new namespaces.</li></ul><p>在Kubernetes之上, 最小的部署单元叫做**<code>Pod</code>**. 同时也是最基本的执行单元(逻辑上). 这个东西封装了容器, 以及配套的网络, 存储等等, 是一个对容器的抽象. 一个Pod里面可以有多个容器, 也可以只存在一个. 这个<code>Pod</code>使用标签(label)来表示元数据的, 这个label是一个kv形式的数据, 为了选择和挑选不同的资源, 还有<code>label selector</code>.</p><p>Pod管理是由Kubernetes的Controller管理的. 我们可以把Pod分成两种类型的:</p><ul><li>自主式Pod</li><li>控制器管理Pod, 控制器有:<ul><li>ReplicationController</li><li>ReplicaSet (不直接使用)</li><li>Deployment: 无状态应用</li><li>StatefulSet: 有状态应用</li><li>DaemonSet</li><li>Job, Cronjob</li></ul></li></ul><p>Pod有其自己的生命周期, 如果我们使用了控制器启动了一个pod, 那么这些pod就会被我们所指定的控制器监控并且受控制.</p><p>那么说到现在, 我们就有2个概念了, 分别是Pod和Controller, 他们组成了Kubernetes的工作负载. 但是, 想象这样的一种场景, pod是有自己的IP地址的, 当控制器kill掉一个创建一个新的pod的时候, IP地址也会发生变化. 这样的话, 我的前端如何追踪这个IP, 并且找到后端接口的地址呢? 由此我们就引入了**服务(Service)**的概念.</p><p>你可以把服务理解成对pod访问策略的一个抽象, Service通过我们之前说的selector来找到对应的Pod. 当我们Pod重建, IP发生变化, 但是label中的某些元数据没有变化, Service正式通过这种机制来找到对应的Pod的.</p><p>说到这里, 可能会有点晕了. 没事, 我们来窥探一个正在运行的Pod都有哪些信息:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">root@kbs-master</span> <span class="string">~</span>]<span class="comment"># kubectl describe pods myapp-5d587c4d45-8859f</span></span><br><span class="line"><span class="attr">Name:</span>         <span class="string">myapp-5d587c4d45-8859f</span></span><br><span class="line"><span class="attr">Namespace:</span>    <span class="string">default</span></span><br><span class="line"><span class="attr">Priority:</span>     <span class="number">0</span></span><br><span class="line"><span class="attr">Node:</span>         <span class="string">kbs-node1/192.168.10.125</span></span><br><span class="line"><span class="attr">Start Time:</span>   <span class="string">Mon,</span> <span class="number">04</span> <span class="string">May</span> <span class="number">2020 11:54:14</span> <span class="number">-0500</span></span><br><span class="line"><span class="attr">Labels:</span>       <span class="string">app=myapp</span></span><br><span class="line">              <span class="string">pod-template-hash=5d587c4d45</span></span><br><span class="line"><span class="attr">Annotations:</span>  <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Status:</span>       <span class="string">Running</span></span><br><span class="line"><span class="attr">IP:</span>           <span class="number">10.244</span><span class="number">.1</span><span class="number">.18</span></span><br><span class="line"><span class="attr">IPs:</span></span><br><span class="line">  <span class="attr">IP:</span>           <span class="number">10.244</span><span class="number">.1</span><span class="number">.18</span></span><br><span class="line"><span class="attr">Controlled By:</span>  <span class="string">ReplicaSet/myapp-5d587c4d45</span></span><br><span class="line"><span class="attr">Containers:</span></span><br><span class="line">  <span class="attr">myapp:</span></span><br><span class="line">    <span class="attr">Container ID:</span>   <span class="string">docker://462b4b2a0281ccd3dc2e9318fec515a027126db24ba346e4ca7000ef2d5a445f</span></span><br><span class="line">    <span class="attr">Image:</span>          <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line">    <span class="attr">Image ID:</span>       <span class="string">docker-pullable://ikubernetes/myapp@sha256:9c3dc30b5219788b2b8a4b065f548b922a34479577befb54b03330999d30d513</span></span><br><span class="line">    <span class="attr">Port:</span>           <span class="string">&lt;none&gt;</span></span><br><span class="line">    <span class="attr">Host Port:</span>      <span class="string">&lt;none&gt;</span></span><br><span class="line">    <span class="attr">State:</span>          <span class="string">Running</span></span><br><span class="line">      <span class="attr">Started:</span>      <span class="string">Mon,</span> <span class="number">04</span> <span class="string">May</span> <span class="number">2020 11:54:15</span> <span class="number">-0500</span></span><br><span class="line">    <span class="attr">Ready:</span>          <span class="literal">True</span></span><br><span class="line">    <span class="attr">Restart Count:</span>  <span class="number">0</span></span><br><span class="line">    <span class="attr">Environment:</span>    <span class="string">&lt;none&gt;</span></span><br><span class="line">    <span class="attr">Mounts:</span></span><br><span class="line">      <span class="string">/var/run/secrets/kubernetes.io/serviceaccount</span> <span class="string">from</span> <span class="string">default-token-pqnl7</span> <span class="string">(ro)</span></span><br><span class="line"><span class="attr">Conditions:</span></span><br><span class="line">  <span class="string">Type</span>              <span class="string">Status</span></span><br><span class="line">  <span class="string">Initialized</span>       <span class="literal">True</span> </span><br><span class="line">  <span class="string">Ready</span>             <span class="literal">True</span> </span><br><span class="line">  <span class="string">ContainersReady</span>   <span class="literal">True</span> </span><br><span class="line">  <span class="string">PodScheduled</span>      <span class="literal">True</span> </span><br><span class="line"><span class="attr">Volumes:</span></span><br><span class="line">  <span class="attr">default-token-pqnl7:</span></span><br><span class="line">    <span class="attr">Type:</span>        <span class="string">Secret</span> <span class="string">(a</span> <span class="string">volume</span> <span class="string">populated</span> <span class="string">by</span> <span class="string">a</span> <span class="string">Secret)</span></span><br><span class="line">    <span class="attr">SecretName:</span>  <span class="string">default-token-pqnl7</span></span><br><span class="line">    <span class="attr">Optional:</span>    <span class="literal">false</span></span><br><span class="line"><span class="attr">QoS Class:</span>       <span class="string">BestEffort</span></span><br><span class="line"><span class="attr">Node-Selectors:</span>  <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Tolerations:</span>     <span class="string">node.kubernetes.io/not-ready:NoExecute</span> <span class="string">for</span> <span class="string">300s</span></span><br><span class="line">                 <span class="string">node.kubernetes.io/unreachable:NoExecute</span> <span class="string">for</span> <span class="string">300s</span></span><br><span class="line"><span class="attr">Events:</span>          <span class="string">&lt;none&gt;</span></span><br></pre></td></tr></table></figure><p>这里是我已经启动了一个双节点Kubernetes集群, 在master节点上执行的结果, 从describe的结果中我们可以看到:</p><ul><li>myapp运行在node1&#x2F;192.168.10.125</li><li>有一个app&#x3D;myapp的label</li><li>有一个10.244.1.18的IP</li><li>被ReplicaSet控制器控制</li><li>有一个叫做myapp的容器</li><li>… (后面对我们这里的内容不重要, 就跳过了)</li></ul><p>刚刚说到, service通过label来寻找pod, 我们来看一个service:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">root@kbs-master</span> <span class="string">~</span>]<span class="comment"># kubectl describe svc myapp</span></span><br><span class="line"><span class="attr">Name:</span>                     <span class="string">myapp</span></span><br><span class="line"><span class="attr">Namespace:</span>                <span class="string">default</span></span><br><span class="line"><span class="attr">Labels:</span>                   <span class="string">app=myapp</span></span><br><span class="line"><span class="attr">Annotations:</span>              <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Selector:</span>                 <span class="string">app=myapp</span></span><br><span class="line"><span class="attr">Type:</span>                     <span class="string">NodePort</span></span><br><span class="line"><span class="attr">IP:</span>                       <span class="number">10.96</span><span class="number">.252</span><span class="number">.210</span></span><br><span class="line"><span class="attr">Port:</span>                     <span class="string">&lt;unset&gt;</span>  <span class="number">80</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">TargetPort:</span>               <span class="number">80</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">NodePort:</span>                 <span class="string">&lt;unset&gt;</span>  <span class="number">32691</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">Endpoints:</span>                <span class="number">10.244</span><span class="number">.1</span><span class="number">.16</span><span class="string">:80,10.244.1.17:80,10.244.1.18:80</span></span><br><span class="line"><span class="attr">Session Affinity:</span>         <span class="string">None</span></span><br><span class="line"><span class="attr">External Traffic Policy:</span>  <span class="string">Cluster</span></span><br><span class="line"><span class="attr">Events:</span>                   <span class="string">&lt;none&gt;</span></span><br></pre></td></tr></table></figure><p>请看! 这里的Selector是不是和上面的label一模一样? 接着我们可以看到这是一个web服务, 因为service对应的端口是80, 你可能会疑惑为什么这个service有三个终端IP, 我们刚刚在上面查看myapp的信息的时候, 说到这是一个由replicaSet控制器控制的pod. 从名字你也可以看出来啦, 这是一个保证复制数量的控制器:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">root@kbs-master</span> <span class="string">~</span>]<span class="comment"># kubectl describe deployment myapp</span></span><br><span class="line"><span class="attr">Name:</span>                   <span class="string">myapp</span></span><br><span class="line"><span class="attr">Namespace:</span>              <span class="string">default</span></span><br><span class="line"><span class="attr">CreationTimestamp:</span>      <span class="string">Mon,</span> <span class="number">04</span> <span class="string">May</span> <span class="number">2020 11:39:20</span> <span class="number">-0500</span></span><br><span class="line"><span class="attr">Labels:</span>                 <span class="string">app=myapp</span></span><br><span class="line"><span class="attr">Annotations:            deployment.kubernetes.io/revision:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Selector:</span>               <span class="string">app=myapp</span></span><br><span class="line"><span class="attr">Replicas:</span>               <span class="number">3</span> <span class="string">desired</span> <span class="string">|</span> <span class="number">3</span> <span class="string">updated</span> <span class="string">|</span> <span class="number">3</span> <span class="string">total</span> <span class="string">|</span> <span class="number">3</span> <span class="string">available</span> <span class="string">|</span> <span class="number">0</span> <span class="string">unavailable</span></span><br><span class="line"><span class="attr">StrategyType:</span>           <span class="string">RollingUpdate</span></span><br><span class="line"><span class="attr">MinReadySeconds:</span>        <span class="number">0</span></span><br><span class="line"><span class="attr">RollingUpdateStrategy:</span>  <span class="number">25</span><span class="string">%</span> <span class="string">max</span> <span class="string">unavailable,</span> <span class="number">25</span><span class="string">%</span> <span class="string">max</span> <span class="string">surge</span></span><br><span class="line"><span class="attr">Pod Template:</span></span><br><span class="line">  <span class="attr">Labels:</span>  <span class="string">app=myapp</span></span><br><span class="line">  <span class="attr">Containers:</span></span><br><span class="line">   <span class="attr">myapp:</span></span><br><span class="line">    <span class="attr">Image:</span>        <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line">    <span class="attr">Port:</span>         <span class="string">&lt;none&gt;</span></span><br><span class="line">    <span class="attr">Host Port:</span>    <span class="string">&lt;none&gt;</span></span><br><span class="line">    <span class="attr">Environment:</span>  <span class="string">&lt;none&gt;</span></span><br><span class="line">    <span class="attr">Mounts:</span>       <span class="string">&lt;none&gt;</span></span><br><span class="line">  <span class="attr">Volumes:</span>        <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Conditions:</span></span><br><span class="line">  <span class="string">Type</span>           <span class="string">Status</span>  <span class="string">Reason</span></span><br><span class="line">  <span class="string">----</span>           <span class="string">------</span>  <span class="string">------</span></span><br><span class="line">  <span class="string">Available</span>      <span class="literal">True</span>    <span class="string">MinimumReplicasAvailable</span></span><br><span class="line">  <span class="string">Progressing</span>    <span class="literal">True</span>    <span class="string">NewReplicaSetAvailable</span></span><br><span class="line"><span class="attr">OldReplicaSets:</span>  <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">NewReplicaSet:</span>   <span class="string">myapp-5d587c4d45</span> <span class="string">(3/3</span> <span class="string">replicas</span> <span class="string">created)</span></span><br><span class="line"><span class="attr">Events:</span>          <span class="string">&lt;none&gt;</span></span><br></pre></td></tr></table></figure><p>一共有三个, 当前的状态就是三个都在.</p><p>OK, 我们来看一下host的网络状态:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/Kubernetes_network_master_ipshow.png" alt="Kubernetes_network_master_ipshow"></p><p>发现什么奇怪的现象了吗? 没错 我们service的IP地址并没有出现在这里.</p><p><code>flannel</code>和<code>cni</code>都是<code>10.244.0.X</code>网段的, 他们是为Pod服务的, ens33是我们本机的物理网卡. Service的<code>10.101.214.X</code>网段在哪里?</p><p>相信聪明的你一定想到了, 此时查看一下iptables你就会发现, Service的这个IP实际上是个虚拟IP, 所谓的根据Service访问Pod服务其实就是一个NAT规则而已:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/Kubernetes_network_node_iptables.png" alt="Kubernetes_network_node_iptables"></p><p>注意这里要在pod的主机上查看嗷. </p><p>借用Kubernetes官方的图, 其实就是这样子:</p><p><img src="https://d33wubrfki0l68.cloudfront.net/27b2978647a8d7bdc2a96b213f0c0d3242ef9ce0/e8c9b/images/docs/services-iptables-overview.svg" alt="Services overview diagram for iptables proxy"></p><p>那么, 说道这里. 我们就可以小结一下了.</p><p>我们从最小的单元<code>Pod</code>出发, 在我们创建之后, Kubernetes会为<code>Pod</code>加上一些元数据. 接着, 我们定义一个控制器(e.g: ReplicaSet), 用来做高可用. 这个时候, 我们就有了服务, 但是需要为这些服务提供一个固定的访问接口才行. 因此, 我们需要通过某种手段, 来确保当后端服务的资源变动时, 接口也能知道并且及时改变, 这里的一种解决方案就是通过<code>Pod</code>的元数据以及iptables的NAT规则来进行动态的调整.</p><p>由此, 我们也可以看出来Kubernetes的网络构架是什么样子的. 也就是, Pod间组成一个集群私有网络, Node间组成一个私有网络, 而节点可以通过<code>kube-proxy</code>来访问Pod私有网络, Service使用虚拟IP组成网络. 用一张图来说明就是:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/Kubernetes_network_mage_overview.png" alt="Kubernetes_network_mage_overview"></p><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>我们先来剖析一下一个Pod包含哪些东西, 首先我们的Pod中最重要的一个部件就是主容器. 一般情况下, 在我们的主容器启动前, 我们会先进行一系列的初始化的操作, 这个初始化也是交给容器来执行的. 我们可以把它叫做<code>init container</code>. 这个初始化包含一些环境设定, 以及为了主容器的执行做一些准备. 当然这些初始化容器可能不止一个, 如果有多个, 他们是<strong>串行</strong>执行的. 当所有的初始化工作结束, 主容器就会开始执行, 这个时候会有一个<code>post start</code>的 过程, 当主容器刚刚执行的时候, 用户可以手动插入这个钩子. 所以当然了, 在结束之前, 同样也有一个钩子叫做<code>pre stop</code>. 除此之外, 还会有两个健康状态检测, 其中一个是存活状态检测, 另外一个就是检测主容器是否已经准备好, 也就是是否可以提供服务.</p><p>另外, 每一个Pod都会包含一个固定的, 容量很小的容器, 叫做<code>pause</code>. 每一个Pod的各个容器都使用这个<code>pause</code>的网络栈和存储卷.</p><p>Pod是有生命周期的, 他的状态有: <code>Pending</code>, <code>Running</code>, <code>Failed</code>, <code>Succeeded</code>, <code>Unknown</code>. 在我们创建Pod的时候, 会先将此Pod的状态信息写入到etcd中. Pod会先被调度到我们的某个节点上, 这需要scheduler一直参与. 当决定好在哪个节点上创建并且执行的时候, apiserver会再把etcd中的状态信息更新. </p><p>在我们Kubernetes中, 为了启动一个Pod需要这样的过程:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/Pod%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Pod生命周期"></p><p>Init容器是干什么的? 简单的说, 这是一个和我们应用程序容器分离的镜像, 我们可以把一些通用的工具集成到InitC中, 这样我们的应用程序镜像就不需要在来做这些操作, 从而专注于自己的业务功能. 另外, InitC可以作为我们主容器的一个访问代理来使用, 例如访问文件. 当然, 通过InitC我们还可以实现简单的同步操作.</p><p>当检测到我们Pod中的InitC容器启动失败,这个时候就会根据我们设置的重启策略(restartPolicy)来决定做哪些决策. 一共有三种:</p><ul><li>Always (默认)</li><li>OnFailure</li><li>Never</li></ul><p>看名字就能理解就不赘述了. 当然一直重启会对我们的系统造成额外的压力, 因此重启的时间间隔是随着重启次数不断增加的, 最多为300s.</p><p>接下来我们说说上文中提到的Pod健康状态检测, Kubernetes可以通过execAction, httpGetAction或者tcpSocketAction来检测, 这三种也就是Kubelet调用的由容器实现的处理程序. 包含一些探测间隔, 超时设定, 失败次数门限等等设定. 探针会获得三种结果: 成功, 失败, 未知.</p><ul><li>livenessProbe: 指示容器是否正在运行</li><li>readinessProbe: 指示容器是否正常提供服务</li></ul><h2 id="Pod-Controller"><a href="#Pod-Controller" class="headerlink" title="Pod Controller"></a>Pod Controller</h2><p>接下来我们来着重说一下Pod的控制器.</p><p>当我们新建一个Pod的时候, 删除之, 该pod并不会重建. 因为这是一个自主式的Pod, 它并没有被控制器管理. 因此, 自主式Pod的时候并不常见, 通过模板内嵌到控制器才是我们更好管理的一个方式. </p><p>我们先再次来列举一次, 常用的Pod Controller:</p><ul><li>ReplicaSet: 创建指定数量的Pod副本, 确保数量始终满足用户设定的值, 支持扩容缩容.</li><li>ReplicationController: 和ReplicaSet目的一致, 但是不支持set选择器. 推荐使用ReplicaSet而非ReplicationController</li><li>Deployment: 工作在ReplicaSet之上, 支持滚动更新和回滚, 声明时配置.(Recommended) 仅用于无状态应用.</li><li>DaemonSet: 用于确保每个节点指运行一个Pod, 常用一些系统级别的应用.</li><li>Job: 可以按照用户指定数量启动, 一次性. 按照工作是否完成来决定是否重建. 当任务完成直接退出.</li><li>Cronjob: 周期性的Job.</li><li>StatefulSet: 每一个Pod单独管理, 针对有状态的应用. 需要脚本嵌入模板来执行操作.</li></ul><p>手写脚本需要运维人员有很好的运维技能, 因此, 如果厂商或者第三方有提供维护脚本就会很方便. 因此, Kubernetes在1.2版本推出了一种资源类型TPR (Third Party Resources), 在1.7版本废止, 因为1.8版本中推出了CDR (Custom Defined Resources)</p><p>接下来我们就开始看这些控制器吧.</p><p>来看一个rs的模板吧:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">            <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">            <span class="attr">release:</span> <span class="string">canary</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">        <span class="attr">metadata:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">            <span class="attr">labels:</span></span><br><span class="line">                <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">                <span class="attr">release:</span> <span class="string">canary</span></span><br><span class="line">                <span class="attr">env:</span> <span class="string">qa</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">            <span class="attr">containers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">              <span class="attr">image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line">              <span class="attr">ports:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">                <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>接下来是一个deploy的模板:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">myapp-deploy</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">            <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">            <span class="attr">release:</span> <span class="string">beta</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">        <span class="attr">metadata:</span></span><br><span class="line">            <span class="attr">labels:</span></span><br><span class="line">                <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">                <span class="attr">release:</span> <span class="string">beta</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">            <span class="attr">containers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">              <span class="attr">image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line">              <span class="attr">ports:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">               <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>我们再来说一下Service这个资源, 在Kubernetes上, Pod存在生命周期, 为了给Pod提供一个固定的访问接口(中间层), 也就是这里的Service. 另外, 我们的Service名称解析强依赖与Kubernetes中的DNS服务, 也就是所谓<code>CoreDNS</code>, 旧版本的Kubernetes使用的是<code>kube-dns</code>. </p><p>Service在Kubernetes中有着四种类型:</p><ul><li>ClusterIP: 默认类型, 自动分配一个Cluster内部的IP, 使得服务只能从集群内部访问.</li><li>NodePort: 在ClusterIP的基础上为Service在每台机器上绑定一个端口, 这样就可以通过<code>NodeIP:NodePort</code>来访问到该服务</li><li>LoadBalancer: 在NodePort的基础上, 借助cloud provider创建一个外部的负载均衡器, 并将请求转发给<code>NodeIP: NodePort</code></li><li>ExternalName: 通过返回一个CNAME记录来使服务映射到<code>externalName</code>, 不创建代理 (kube-dns&gt;1.7&#x2F;CoreDNS&gt;0.0.8)</li></ul><p>说到Service, 我们还是要重复一下之前说过的, Kubernetes的网络:</p><ul><li>node network</li><li>pod network</li><li>cluster network (虚拟的IP)</li></ul><p>我们之前也说过, worker node通过使用kube-proxy和master node的api service进行通信, 通过Kubernetes的watch机制. 接下来我们说三种Service的代理模式:</p><p>第一种(userspace)Pod之间的访问机制是通过访问内核的iptables规则, 然后会被Service转到本地监听的套接字上, 也就是kube-proxy, 然后由它处理和分发, 接着还会再走内核的iptables分发到目标节点的kube-proxy, 最后到达目标Pod. 这种方法十分的麻烦, 因此我们有第二种方法.</p><p>第二种就是直接使用iptables, 而不使用kube-proxy. 当然了, 我们还是需要kube-proxy来维护netfilter规则的. 另外, 还可以直接使用ipvs来调度.</p><p>Kubernetes1.14之后默认使用的是ipvs, 如果ipvs没有被激活, 则会降级到iptables.</p><p>写一个简单的redis服务:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">logstore</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.96</span><span class="number">.96</span><span class="number">.96</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>但事实上, 从我们的Service到Pod, 会经过一个Endpoint. 这个Endpoint资源本质上我们是可以手动指定的. 如果我们没有修改默认的资源记录域名, 一般来说都是这样的(例如上面的redis):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.default.svc.cluster.local.</span><br></pre></td></tr></table></figure><p>也就是服务名+名称空间+Domain</p><p>另外, 还有一种无头服务(Headless Service), 也就是不指定ClusterIP, 指定为None或者空字符串, 这样对Pod的请求就会直达到Pod而不会由Service牵头, 这时候的Service可以提供分组服务而不用于调度.</p><h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><p>我们之前说过想要在外部访问到我们的Pod, 可使用NodePort. 我们使用ipvs或者iptables来进行访问的调度, 但是我们知道这两个都是处在4层的. 考虑一种简单的情况, 假设我们的站点使用的是HTTPS的协议, 那这个证书显然不应该是后端Pod的IP而应该是我们调度器的IP, 因为用户访问的域名解析结果显然应该是调度器的IP嘛. 那么问题就显而易见了, 因为我们真正提供服务的Pod和证书信息不匹配, 这个时候我们就需要在请求到达Pod之前, 将HTTPS的头拿掉, 也就要求我们要有一个七层的负载均衡器在前面. 这样, 我们的Pod就使用HTTP即可, 而在互联网中使用HTTPS就好, 然后在接入层卸载SSL.</p><p>基于此, 我们可以启动一个Pod然后共享宿主机的IP地址, 而这个Pod拥有能够七层调度的能力(可以把它想象成一个Nginx), 这样我们就不使用Service了. 当然, 如果这样做的话, 我们的这个Pod就必须是单点. 这个时候我们可以使用DaemonSet控制器来进行控制.</p><p>我们可以通过打上污点(taint)的方式, 让我们的控制器控制仅仅在若干个节点上进行, 并且让这些节点只运行这个调度器, 为我们集群提供一个统一的七层调度访问入口.</p><p>事实上, 这个东西就是Ingress Controller, 虽然他也叫做Controller, 但它并不是master node上的Controller Manager的子组件, 而是一个独立的应用. 这种方式看似美好, 但是存在一个问题, 因为我们的Ingress Controller并不能像我们的Service一样对后端的Pod有实时的watch, 由于Pod存在生命周期, 有可能Pod会被替换掉, 同时IP地址也会发生改变. 所以这个时候我们就可以考虑使用之前说过的headless service了, 让这个服务仅用来对我们的Pod做分组, 我们还是使用Ingress Controller进行调度, 这个时候我们就可以声明一个Ingress资源, 从而定义前端的调度规则. 并且它还可以注入到当前的配置中, 当后端发生变化我们的Ingress会知道, 于是他可以生成配置信息然后通知当前的Pod进行重载.</p><p>安装ingress很简单, 直接照着nginx官网的教程走就可以了. 当然, 除了Nginx, 也有很多ingress的实现方案, 例如HAProxy, 这里我们就用Nginx来做测试了.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kbs-demo deployments]# kubectl get pods -n nginx-ingress</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-ingress-94d765bfd-ttd28   1/1     Running   0          3m39s</span><br></pre></td></tr></table></figure><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>我们之前说过, Pod存在生命周期, 那么我们存在在Pod内部存储空间的数据就会随着Pod的重启而消失. 因此, 我们就需要在Pod自有文件存储之外的地方, 例如我们的节点文件系统. 这样在一定程度上我们就拥有了持久化存储能力. 问题是, 我们的Pod是有调度的. 因此我们直接丢到节点存储上是不合理的. 所以我们应该存储在脱离节点存储的位置上, 例如NFS.</p><p>Kubernetes的存储, 我们可以展开四个话题:</p><ul><li>ConfigMap</li><li>Secret</li><li>Volume</li><li>PV-PVC</li></ul><p>我们就一个一个来说吧.</p><p>首先说到ConfigMap, 这是个啥呢, 简单来说, 这就是一个向容器中注入配置信息的机制, 这就像是Kubernetes的配置文件注册中心(这样举例好像不对…但是API和思想差不多).</p><p>创建一个ConfigMap主要有三种方式, 通过目录, 使用文件以及命令行传参. 使用起来也挺简单, 我们在Pod的资源清单中<code>env</code>内部写上就可以了.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SPECIAL_LEVEL_KEY</span></span><br><span class="line">  <span class="attr">valueFrom:</span></span><br><span class="line">    <span class="attr">configMapKeyRef:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">      <span class="attr">key:</span> <span class="string">special.how</span></span><br></pre></td></tr></table></figure><p>另外, 我们在导入之后也可以在容器的<code>command</code>中进行引用. 除此之外, 我们还可以把我们configMap的文件直接挂载到我们的Pod中. </p><p>而Secret, 可以用来存储我们的一些密码密钥等需要被加密的配置数据. Secret可以使用Volume挂载或者当做会环境变量来使用. 使用起来Secret和ConfigMap十分相似. 我们Secret有三种类型:</p><ul><li>Service Account: 用来访问Kubernetes API, 由Kubernetes自动创建, 并且会自动挂载到Pod的<code>/run/secrets/kubernetes.io/serviceaccount</code>目录中</li><li>Opaque: Base64编码格式, 存储密码密钥等</li><li>Kubernetes.io&#x2F;dockerconfigjson: 用来存储私有的docker registry的认证信息</li></ul><p>因此我们配置容器化应用的方式就有这些了:</p><ol><li>自定义命令行参数: <code>args: []</code></li><li>把配置文件直接丢到镜像中</li><li>环境变量<ol><li>Cloud Native的应用程序一般直接通过环境变量加载配置</li><li>通过<code>entrypoint</code>脚本来预处理变量为配置文件中的配置信息</li></ol></li><li>存储卷</li></ol><p>上面的两个更多的都是为了向Pod内部注入配置信息而非存储, 接下来我们来说说存储卷Volume.</p><p>准确的说, 我们的存储卷是属于Pod的而不是容器. 我们说过, 每一个Pod都会启动一个超级小的容器, 叫做<code>pause</code>或者叫基础架构容器. 我们所有的容器都使用的<code>pause</code>的网络命名空间. </p><p>Kubernetes支持非常多的存储卷或者存储服务, 我们可以使用<code>explain</code>来看看支持的情况, 或者去官网看文档啦哈哈哈.</p><p>在Kubernetes的存储中, 重头戏应该就是PV和PVC了, 这两个玩意的全称就是<code>PersistentVolume</code>和<code>PersistentVolumeClaim</code>.  一个大概的流程就是, 我们负责存储的工程师来创建和部署存储服务(NFS, Ceph…), 接着由负责管理Kubernetes集群的工程师来提供PV, PV会成为存储系统对Kubernetes的存储抽象层, 接着由用户来声明PVC向PV发起获取存储空间的请求.</p><p>另外, 我们还可以声明一个Kubernetes的资源类型, 叫<code>StorageClass</code>, 来划分不同级别的PV从而根据不同的服务需求指标来提供给用户. 这样我们的PVC就可以不针对某一个特定的PV来申请资源而可以通过对<code>StorageClass</code>来发请求. 存储系统必须要提供相应的RESTful API. </p><h2 id="StatefulSet控制器"><a href="#StatefulSet控制器" class="headerlink" title="StatefulSet控制器"></a>StatefulSet控制器</h2><p>StatefulSet是针对我们有状态的应用设计的, 不同于无状态应用我们可以随意的重建和重启. 那么到底什么样的应用属于StatefulSet嘞?</p><ul><li>稳定且唯一的网络标识符</li><li>稳定且持久的存储</li><li>有序平滑的部署和扩展</li><li>有序平滑的删除和终止</li><li>有序的滚动更新</li></ul><p>我们着重来说一下他的滚动更新吧, 默认使用的更新方法是分区更新, 我们可以从文档中看到:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@kbs-demo ~]# kubectl explain sts.spec.updateStrategy</span><br><span class="line">KIND:     StatefulSet</span><br><span class="line">VERSION:  apps/v1</span><br><span class="line"></span><br><span class="line">RESOURCE: updateStrategy &lt;Object&gt;</span><br><span class="line"></span><br><span class="line">DESCRIPTION:</span><br><span class="line">     updateStrategy indicates the StatefulSetUpdateStrategy that will be</span><br><span class="line">     employed to update Pods in the StatefulSet when a revision is made to</span><br><span class="line">     Template.</span><br><span class="line"></span><br><span class="line">     StatefulSetUpdateStrategy indicates the strategy that the StatefulSet</span><br><span class="line">     controller will use to perform updates. It includes any additional</span><br><span class="line">     parameters necessary to perform the update for the indicated strategy.</span><br><span class="line"></span><br><span class="line">FIELDS:</span><br><span class="line">   rollingUpdate&lt;Object&gt;</span><br><span class="line">     RollingUpdate is used to communicate parameters when Type is</span><br><span class="line">     RollingUpdateStatefulSetStrategyType.</span><br><span class="line"></span><br><span class="line">   type&lt;string&gt;</span><br><span class="line">     Type indicates the type of the StatefulSetUpdateStrategy. Default is</span><br><span class="line">     RollingUpdate.</span><br><span class="line"></span><br><span class="line">[root@kbs-demo ~]# kubectl explain sts.spec.updateStrategy.rollingUpdate</span><br><span class="line">KIND:     StatefulSet</span><br><span class="line">VERSION:  apps/v1</span><br><span class="line"></span><br><span class="line">RESOURCE: rollingUpdate &lt;Object&gt;</span><br><span class="line"></span><br><span class="line">DESCRIPTION:</span><br><span class="line">     RollingUpdate is used to communicate parameters when Type is</span><br><span class="line">     RollingUpdateStatefulSetStrategyType.</span><br><span class="line"></span><br><span class="line">     RollingUpdateStatefulSetStrategy is used to communicate parameter for</span><br><span class="line">     RollingUpdateStatefulSetStrategyType.</span><br><span class="line"></span><br><span class="line">FIELDS:</span><br><span class="line">   partition&lt;integer&gt;</span><br><span class="line">     Partition indicates the ordinal at which the StatefulSet should be</span><br><span class="line">     partitioned. Default value is 0.</span><br></pre></td></tr></table></figure><p>那么分区更新是啥嘞? 我们会定义一个分区分界, 例如N, 那么当所有标识&gt;&#x3D;N的Pod都会被更新. 假设我们现在一共有5个Pod, 我定义成N&#x3D;4, 那么从Pod-0开始, 第一个满足条件(也仅有这个)的就是Pod-4, 当我们发布了此更新之后, 如果没有问题, 我们就将N改成0即可. (金丝雀发布)</p><h2 id="认证和serviceaccount"><a href="#认证和serviceaccount" class="headerlink" title="认证和serviceaccount"></a>认证和serviceaccount</h2><p>我们之前了解过, Kubernetes使用<code>api-server</code>来作为整体的管理控制入口, 还可以通过Ingress暴露出来的服务端口来访问. 但是显然我们不能允许来路不明的请求来访问管理接口, 因此我们就需要进行安全认证. Kubernetes使用了基于Role的模型.</p><p>任何客户端访问, 都需要3步, 即:</p><ul><li>认证</li><li>授权检查</li><li>准入控制</li></ul><p>对于认证而言, 最常用的两种就是基于HTTP和HTTPS, 通过交换token和交换证书(双向), 来进行客户端身份的认证. 而对于授权, 同样也有多种认证方式, 但目前最常用的就是RBAC了, 也就是基于角色的访问控制.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cloud Native </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELK栈初见-2</title>
      <link href="/2019/07/30/ELK%E6%A0%88%E5%88%9D%E8%A7%81-2/"/>
      <url>/2019/07/30/ELK%E6%A0%88%E5%88%9D%E8%A7%81-2/</url>
      
        <content type="html"><![CDATA[<p>我们在之前聊完了ELK栈第一个部分ElasticSearch的索引链程序Lucene , 也对搜索引擎有了一个大体的认知, 解下来就来看看剩下的组件吧.</p><span id="more"></span><h2 id="ELK栈是怎么工作的"><a href="#ELK栈是怎么工作的" class="headerlink" title="ELK栈是怎么工作的?"></a>ELK栈是怎么工作的?</h2><p>一图胜千言.</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/ELK_mspaint.png" alt="ELK_mspaint"></p><p>我们在我们的Server上安装收集日志的Agent (也可以叫做shipper), 通过一个消息队列发送给Logstash, 这里的消息队列一般是redis, 当然也可以是其他典型的MQ. Logstash可以进行数据清洗, 接着把处理的数据发送到我们的ES集群中, 最后, 由Kibana提供一个美观用户友好的管理接口.</p><p>接下来就来看看这个Logstash吧.</p><h2 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h2><p>Logstash基于JRuby研发, 因此也是需要跑在JVM之上的. 对于Logstash的工作模式, 其实就是一个**<code>pipeline</code>**. 这个管道就是承载输入输出过滤操作的载体. 首先, 输入将事件发送到一个默认存在于内存中的中央队列(也可以是磁盘), 每一个pipeline工作线程过会从这个队列中抓取批量事件, 接着按照我们定义的过滤器来执行, 最后发送到输出中. 默认情况下, 这些事件都是存在于内存中的, 因此一旦发生错误, 数据就会丢失. 所以Logstash也可以将发送的事件持久化到磁盘上. 我们Logstash的Server端是严重基于插件工作的. 插件用来定义输入, 编码, 过滤器, 输出等等.</p><p>安装Logstash很简单, 我们之前已经加入了elastic的yum仓库, 因此直接安装就可以了.</p><p>安装完成后, 我们可以来看一下安装生成配置文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 logstash]# rpm -qc logstash</span><br><span class="line">/etc/logstash/jvm.options</span><br><span class="line">/etc/logstash/log4j2.properties</span><br><span class="line">/etc/logstash/logstash-sample.conf</span><br><span class="line">/etc/logstash/logstash.yml</span><br><span class="line">/etc/logstash/pipelines.yml</span><br><span class="line">/etc/logstash/startup.option</span><br></pre></td></tr></table></figure><p>是不是感觉和Elasticsearch很类似? 这里我们主要关注的就是官方给出的conf示例和<code>logstash.yml</code>就行了.</p><p>简单的看一下这个示例配置, 你会发现, 定义一个logstash最基本的方法就是给出一个输入和一个输出就好了.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# cat /etc/logstash/logstash-sample.conf </span><br><span class="line"># Sample Logstash configuration for creating a simple</span><br><span class="line"># Beats -&gt; Logstash -&gt; Elasticsearch pipeline.</span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [&quot;http://localhost:9200&quot;]</span><br><span class="line">    index =&gt; &quot;%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    #user =&gt; &quot;elastic&quot;</span><br><span class="line">    #password =&gt; &quot;changeme&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里能很清楚的看到, 这个配置文件是域配置类型的, 很简单就能读懂, 通过beats来采集日志, 并且把它输出到一个本机的ES中. 我们可以仿照着这个配置文件写一个最基本的标准输入输出做两端的配置然后跑一下试试:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 logstash]# cat config/conf.d/simple.conf </span><br><span class="line">input &#123;</span><br><span class="line">stdin &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">stdout &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hello<span class="punctuation">,</span> Logstash!</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">          <span class="string">&quot;host&quot;</span> =&gt; <span class="string">&quot;node1&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;Hello, Logstash!&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;@version&quot;</span> =&gt; <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;@timestamp&quot;</span> =&gt; <span class="number">2020</span><span class="number">-05</span><span class="number">-24</span>T21<span class="punctuation">:</span><span class="number">02</span><span class="punctuation">:</span><span class="number">44.793</span>Z</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这里面会显示来源主机, 完整信息, 版本号和时间戳.</p><p>当然, 除了输入输出, 我们也可以配置过滤器. Logstash支持四种类型的插件配置:</p><ul><li>input</li><li>filter</li><li>codec</li><li>output</li></ul><p>这些插件都会有各种配置项, 而这些配置项支持的数据类型有:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Array: [item1, item2, ...]</span><br><span class="line">Boolean: true: false</span><br><span class="line">Bytes</span><br><span class="line">Codec: 定义编码器</span><br><span class="line">Hash: 字典</span><br><span class="line">Number</span><br><span class="line">Password</span><br><span class="line">Path: 文件系统路径</span><br><span class="line">String: 字符串</span><br></pre></td></tr></table></figure><p>另外也支持: 字段引用: [], 条件判断(包括正则和包含, 并且可以使用复合表达式)</p><p>既然我们说Logstash是基于插件的, 因此我们要研究的东西就是插件了.</p><h2 id="Logstash的各种插件"><a href="#Logstash的各种插件" class="headerlink" title="Logstash的各种插件"></a>Logstash的各种插件</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><h4 id="File"><a href="#File" class="headerlink" title="File"></a>File</h4><p>从指定的文件中读取事件流, 这个插件的工作性质类似于<code>tail -1 -f</code>. 这个插件使用FileWatch(Ruby Gem库)监听文件的变化. 而文件读取位置一些信息会被保存在一个叫做<code>.sincedb</code>的数据库, 这样就保证了不会出现漏读的情况.</p><p>此外, File还可以识别日志的滚动, 跟随文件到最新的.</p><p>一个最简单的例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">file &#123;</span><br><span class="line">path =&gt; [&quot;/var/log/messages&quot;]</span><br><span class="line">type -&gt; &quot;system&quot;</span><br><span class="line">start_position =&gt; &quot;beginning&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>type</code>属性是所有插件共用的, 对于file插件来说, 只有<code>path</code>是一个必要项. 接下来我们还是补充一个标准输出. 好让logstash可以运行.</p><p>然后我们在另外一个SSH终端登出登入一下就会看到有变化了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;@timestamp&quot; =&gt; 2020-05-24T22:49:49.574Z,</span><br><span class="line">       &quot;message&quot; =&gt; &quot;May 25 06:49:49 node1 systemd-logind: Removed session 31.&quot;,</span><br><span class="line">          &quot;host&quot; =&gt; &quot;node1&quot;,</span><br><span class="line">          &quot;path&quot; =&gt; &quot;/var/log/messages&quot;,</span><br><span class="line">      &quot;@version&quot; =&gt; &quot;1&quot;,</span><br><span class="line">          &quot;type&quot; =&gt; &quot;system&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;@timestamp&quot; =&gt; 2020-05-24T22:49:57.715Z,</span><br><span class="line">       &quot;message&quot; =&gt; &quot;May 25 06:49:56 node1 systemd: Started Session 32 of user root.&quot;,</span><br><span class="line">          &quot;host&quot; =&gt; &quot;node1&quot;,</span><br><span class="line">          &quot;path&quot; =&gt; &quot;/var/log/messages&quot;,</span><br><span class="line">      &quot;@version&quot; =&gt; &quot;1&quot;,</span><br><span class="line">          &quot;type&quot; =&gt; &quot;system&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;@timestamp&quot; =&gt; 2020-05-24T22:49:57.717Z,</span><br><span class="line">       &quot;message&quot; =&gt; &quot;May 25 06:49:56 node1 systemd-logind: New session 32 of user root.&quot;,</span><br><span class="line">          &quot;host&quot; =&gt; &quot;node1&quot;,</span><br><span class="line">          &quot;path&quot; =&gt; &quot;/var/log/messages&quot;,</span><br><span class="line">      &quot;@version&quot; =&gt; &quot;1&quot;,</span><br><span class="line">          &quot;type&quot; =&gt; &quot;system&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h4><p>我们也可以通过udp协议从网络连接来读取message. 通过传递logstash需要监听的地址和端口就可以了. udp使用也很简单, 只需要指明必要的端口号即可.</p><p>怎么测试效果呢?我们可以找另外一个主机然后安装一个<code>collectd</code>. 这个程序就可以周期性的发送收集到的系统信息. 通过配置一个Network插件, 配置上我们logstash的地址和端口就可以了. 这里就跳过了.</p><h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><p>当然也可以从redis中读取数据, 支持redis channel和lists两种方式.</p><p>目前logstash支持的输入插件十分繁多, 需要用时还是直接<a href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html">官网查询</a>就可.</p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>接下来来看看过滤插件, 之前也说过了, filter是logstash在将event通过output发出之前对其实现某些处理功能. 插件繁多, 我们这里就先介绍一个: <code>grok</code>.</p><p>grok可以说是在我们必然会使用到的一个插件, 他可以将非结构化的文本数据变成结构化的, 方便日后分析.</p><p>另外, 还有另外一个也可以做到这一点的插件, 叫做<code>Dissect</code>. 区别是, 他不使用正则表达式, 因此更快速, 更适用于当日志文件是重复的情况下.</p><p>默认情况下, logstash已经内置支持了大约120种的模式, 包括我们熟悉的mysql, nginx, apache httpd等等等等. 基于这些模式, 我们进行匹配就可以将文本信息进行拆解.</p><p>举个例子, apache httpd的pattern就是这样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTTPDUSER %&#123;EMAILADDRESS&#125;|%&#123;USER&#125;</span><br><span class="line">HTTPDERROR_DATE %&#123;DAY&#125; %&#123;MONTH&#125; %&#123;MONTHDAY&#125; %&#123;TIME&#125; %&#123;YEAR&#125;</span><br><span class="line"></span><br><span class="line"># Log formats</span><br><span class="line">HTTPD_COMMONLOG %&#123;IPORHOST:clientip&#125; %&#123;HTTPDUSER:ident&#125; %&#123;HTTPDUSER:auth&#125; \[%&#123;HTTPDATE:timestamp&#125;\] &quot;(?:%&#123;WORD:verb&#125; %&#123;NOTSPACE:request&#125;(?: HTTP/%&#123;NUMBER:httpversion&#125;)?|%&#123;DATA:rawrequest&#125;)&quot; %&#123;NUMBER:response&#125; (?:%&#123;NUMBER:bytes&#125;|-)</span><br><span class="line">HTTPD_COMBINEDLOG %&#123;HTTPD_COMMONLOG&#125; %&#123;QS:referrer&#125; %&#123;QS:agent&#125;</span><br><span class="line"></span><br><span class="line"># Error logs</span><br><span class="line">HTTPD20_ERRORLOG \[%&#123;HTTPDERROR_DATE:timestamp&#125;\] \[%&#123;LOGLEVEL:loglevel&#125;\] (?:\[client %&#123;IPORHOST:clientip&#125;\] )&#123;0,1&#125;%&#123;GREEDYDATA:message&#125;</span><br><span class="line">HTTPD24_ERRORLOG \[%&#123;HTTPDERROR_DATE:timestamp&#125;\] \[%&#123;WORD:module&#125;:%&#123;LOGLEVEL:loglevel&#125;\] \[pid %&#123;POSINT:pid&#125;(:tid %&#123;NUMBER:tid&#125;)?\]( \(%&#123;POSINT:proxy_errorcode&#125;\)%&#123;DATA:proxy_message&#125;:)?( \[client %&#123;IPORHOST:clientip&#125;:%&#123;POSINT:clientport&#125;\])?( %&#123;DATA:errorcode&#125;:)? %&#123;GREEDYDATA:message&#125;</span><br><span class="line">HTTPD_ERRORLOG %&#123;HTTPD20_ERRORLOG&#125;|%&#123;HTTPD24_ERRORLOG&#125;</span><br><span class="line"></span><br><span class="line"># Deprecated</span><br><span class="line">COMMONAPACHELOG %&#123;HTTPD_COMMONLOG&#125;</span><br><span class="line">COMBINEDAPACHELOG %&#123;HTTPD_COMBINEDLOG&#125;</span><br></pre></td></tr></table></figure><p>grok语法格式就是<code>%&#123;SYNTAX:SEMANTIC&#125;</code> 也就是预定义的模式名称和匹配到的文本的自定义标识符. 如果没有我们需要的, 就需要自定义了.</p><p>我们来用一下试试. 首先写好配置文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 conf.d]# cat fromhttpd.conf </span><br><span class="line">input &#123;</span><br><span class="line">file &#123;</span><br><span class="line">path =&gt; &quot;/var/log/http/access_log&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">grok &#123;</span><br><span class="line">match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;HTTPD_COMMONLOG&#125;&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">stdout &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们随便访问一次看看:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">       <span class="string">&quot;@version&quot;</span> =&gt; <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;httpversion&quot;</span> =&gt; <span class="string">&quot;1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;clientip&quot;</span> =&gt; <span class="string">&quot;192.168.10.101&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;bytes&quot;</span> =&gt; <span class="string">&quot;4897&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;timestamp&quot;</span> =&gt; <span class="string">&quot;25/May/2020:07:48:47 +0800&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;192.168.10.101 - - [25/May/2020:07:48:47 +0800] \&quot;GET / HTTP/1.1\&quot; 403 4897 \&quot;-\&quot; \&quot;curl/7.29.0\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="string">&quot;verb&quot;</span> =&gt; <span class="string">&quot;GET&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="string">&quot;path&quot;</span> =&gt; <span class="string">&quot;/var/log/httpd/access_log&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;response&quot;</span> =&gt; <span class="string">&quot;403&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="string">&quot;auth&quot;</span> =&gt; <span class="string">&quot;-&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;ident&quot;</span> =&gt; <span class="string">&quot;-&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;@timestamp&quot;</span> =&gt; <span class="number">2020</span><span class="number">-05</span><span class="number">-24</span>T23<span class="punctuation">:</span><span class="number">48</span><span class="punctuation">:</span><span class="number">47.965</span>Z<span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;request&quot;</span> =&gt; <span class="string">&quot;/&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="string">&quot;host&quot;</span> =&gt; <span class="string">&quot;node1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到, 整条信息会被当做message, 其他的已经被拆分出来了.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>接下来我们再聊聊输出.</p><h4 id="redis-1"><a href="#redis-1" class="headerlink" title="redis"></a>redis</h4><p>你会发现, redis既可以作为输入, 也可以作为输出. 回到我们一开始说的ELK的架构, 对于logstash的agent端而言, redis就是他的输出, 而对于server端, redis就是输入了. 简单的说, redis就是一个broker.</p><p>redis的配置也是十分简单的. 一般情况下我们只要说明一下数据类型和key就可以.</p><p>这里我们先略过, 来看一下另一个十分重要的output然后我们会在下一节综合使用这些插件.</p><h4 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h4><p>重要的输出插件当然就是本家的ES了.  ES也没有什么必要的值, 一般情况下我们可以传递index的值以及es的位置就好了. 另外这个地方也可以使用https, 只要加上CA证书相关的配置就可以了.</p><h2 id="ELK实例"><a href="#ELK实例" class="headerlink" title="ELK实例"></a>ELK实例</h2><p>接下来我们就来完整的把这个架构跑一下.</p><p>首先我们来说下实验的环境, 我们使用2个节点, 其中:</p><p>Node1 (192.168.10.101): httpd+logstash+redis</p><p>Node2 (192.168.10.102): logstash+elasticsearch+kibana</p><p>话不多说, 现在就开始配置两个节点.</p><p>在节点1上, 我们配置logstash的配置文件像这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# cat /usr/share/logstash/config/conf.d/fromhttpd.conf </span><br><span class="line">input &#123;</span><br><span class="line">file &#123;</span><br><span class="line">path =&gt; &quot;/var/log/httpd/access_log&quot;</span><br><span class="line">type =&gt; &quot;access&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">grok &#123;</span><br><span class="line">match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;HTTPD_COMMONLOG&#125;&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">redis &#123;</span><br><span class="line">data_type =&gt; &quot;list&quot;</span><br><span class="line">host =&gt; &quot;192.168.10.101&quot;</span><br><span class="line">key =&gt; &quot;httpd-%&#123;type&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在节点2上, 我们的logstash配置像这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]# cat /usr/share/logstash/config/conf.d/toes.conf </span><br><span class="line">input &#123;</span><br><span class="line">redis &#123;</span><br><span class="line">host =&gt; &quot;192.168.10.101&quot;</span><br><span class="line">data_type =&gt; &quot;list&quot;</span><br><span class="line">key =&gt; &quot;httpd-access&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">elasticsearch &#123;</span><br><span class="line">hosts =&gt; [&quot;192.168.10.102&quot;]</span><br><span class="line">index =&gt; &quot;elk-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们启动所有程序, 刷新一下web page, 这样日志就会增加, 然后由node1的logstash进行了处理推到了redis中. 接着, node2的logstash从redis中拿取数据交给了ES节点. 然后由kibana进行展示.</p><p>初次启动kibana需要让我们配置index和排序依据, 配置好了之后, 我们就可以看到记录了:</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/kibana_discover_show_1.png" alt="kibana_discover_show_1"></p><p>我们可以搜索筛选, 上面还有时间和数量的展示图. 左侧有我们所有的域. 此外, 我们还以使用kibana进行数据可视化.</p><p>当然, 之前就说过, 我们可以使用kibana来对我们的集群进行管理, 监控</p><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/kibana_discover_show_1.png" alt="kibana_discover_show_1"></p><p>以上.</p>]]></content>
      
      
      
        <tags>
            
            <tag> ELK </tag>
            
            <tag> Logstash </tag>
            
            <tag> Kibana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELK栈初见-1</title>
      <link href="/2019/07/25/ELK%E6%A0%88%E5%88%9D%E8%A7%81-1/"/>
      <url>/2019/07/25/ELK%E6%A0%88%E5%88%9D%E8%A7%81-1/</url>
      
        <content type="html"><![CDATA[<p>我们运行的各种服务在工作过程中都会产生巨大的日志, 如果是小规模的生产环境我们可以简单的通过将各种软件的日志复制到数据库或者直接文件系统上进行汇总. 当然这种不仅仅限日志量十分的少而且这样做会带来很多的弊端, 例如我们很难对其中的日志进行搜索和分析, 另外巨大的IO量对我们的硬盘也是一种巨大的考验.</p><p>今天就来学习ELK栈的第一步, 我们先来了解一下搜索引擎的简单原理.</p><span id="more"></span><h2 id="从一个典型架构说起"><a href="#从一个典型架构说起" class="headerlink" title="从一个典型架构说起"></a>从一个典型架构说起</h2><p>我们之前谈论过了很多架构模型, 其中最常见的就是在一个系统的最前方加入反向代理进行负载均衡, 我们把这一层叫做接入层, 接着向后, 接入层的服务会优先向后方的缓存服务请求缓存, 即缓存层, 包括一些静态和动态资源, 如果命中则直接返回, 如果发生了miss就会再向后方真正的服务提供者请求资源, 也就是说真正的服务器层.</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/%E4%B8%80%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9E%B6%E6%9E%84.png" alt="一个常见的架构"></p><p>想想看, 我们应该在那个地方进行日志的收集呢? 如果是真实服务器层, 可能80%以上的请求都没有到达这个地方, 显然我们应该在更前方部署日志服务. 如果是在缓存层呢, 在这地方是可以进行日志收集的. 但是显然, 接入层会过滤掉一些非法的请求或者是无权限的请求. 另外, 如果我们的站点足够大, 可能在接入层的前方还要一个CDN网络, 这些都要纳入我们的考虑范围中.</p><p>为什么需要日志? 通过日志, 我们可以来分析和获取PV和UV, 从而得到自己站点的推荐系统. 这是十分重要的. 这就是我们为什么要收集日志.</p><p>说到了收集日志, 稍微想一下就可以知道, 仅仅假设我们有4台Web服务器, 产生的日志量都是巨大的. 如果我们想在这些日志中知道某一个IP的访问次数, 可以说是一个比较麻烦的事情了. 尤其是这种检索只是一个很简单的检索.</p><p>我们可以把日志存储在文件系统中, 或者是数据库系统中, 甚至是一些分布式的数据库系统中, 例如拥有分布式能力的mongodb, 但是存储容易, 我们如何对日志进行分析呢?  当我们把数据存入数据库的时候, 对数据进行分析其实就是进行特定的查询, 能够做到. 但是涉及到日志的时候就会变得麻烦:</p><ul><li>其一是我们的日志数据并发量太大, 一般的关系型数据库很难撑住</li><li>其二是我们的日志是半结构化数据, 对于分析数据较为麻烦</li></ul><p>而且假设使用到MySQL, 由于使用的是最左前缀索引, 也会带来很多问题.</p><p>因此, 使用一般的关系型数据库来进行日志的存储和查询是不太方便的. 所以, 我们需要一个<strong>搜索引擎</strong>来帮助我们进行<strong>全文检索</strong>.</p><h2 id="初探搜索引擎"><a href="#初探搜索引擎" class="headerlink" title="初探搜索引擎"></a>初探搜索引擎</h2><p>搜索引擎可以做到根据我们的检索关键字来进行一般和更高级的检索. 这是数据库系统所做不到的. 我们说程序本身无非就是由数据结构和算法构成的. 对于我们的搜索引擎程序来说亦是如此, 他也需要一个数据存储模型和一个支持这种存储的算法.</p><p>一个搜索引擎, 主要是由两个部分构成的 , 其中一个叫做搜索组件, 也就是所谓的程序部分, 这个部分通过用户键入的关键字进行优化(正规化)并且构建出结果. 另外一个组件叫做索引链. 连接这两个部分的就是所谓索引. 这些索引从哪里来? 我们最熟悉的应该就是爬虫程序了. 如果说是我们上面的日志, 我们可以通过设置代理(Agent)来监听日志文件, 当文件被插入了新的数据就把数据流式复制到我们的收集程序中. 但是同样这还是上面的问题, 并发压力大, IO受不住. 因此我们可以在前端设置一个缓冲, 例如队列. </p><p>在获取到了源数据之后, 程序就需要对这些数据进行<strong>文档</strong>构建从而形成自己的索引了. 这里所说的文档其实搜索引擎的数据格式了, 在文档中, 存储了大量的键值对数据. 就有一点点像我们之前所了解的YAML格式. </p><p>接收到源数据之后, 构成文档. 我们知道使用搜索引擎搜索的时候一般都是通过键入关键字词而不是一句话, 因此我们需要进行<strong>切词</strong>. 在切完词之后我们才可以进行全文搜索. 另外, 对结果排序也是一个需要考虑的问题, 如何设计权重?</p><p>说到这, 我们就可以来简单的小结一下了, 一个搜索引擎的搜索组件就是由上面说到的构建查询部分加上查询的运行, 以及读取结果返回给前端. 当然了, 我们还需要一个前端的访问UI, 不管是命令行操作界面还是图形操作, 总归是有一个能够提供访问接口的东西.</p><p>说完了搜索组件, 我们就来说说所索引链. 这个组件就是用来构建索引的, 我们刚刚说了对收集到的文档进行切词构建索引. 这里的索引是<strong>倒排</strong>的. 一般SQL的索引是正排的. 什么是倒排的呢? 我们构建的索引形如这样:</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/%E7%B4%A2%E5%BC%95%E8%A1%A8%E7%9A%84%E6%A0%B7%E5%AD%90.png" alt="索引表的样子"></p><p>左边就是词, 而右边就是这个词出现的文档. </p><p>比如说正排就是在一篇文档中寻找出现的词, 正好是反过来的, 我们在SQL中也正好就是一个大单位数据中寻找小单位数据.</p><p>因此, 一个大体的获取索引链过程:</p><blockquote><p><strong>获取</strong>原始文档信息, 构建<strong>文档</strong>, 进行文档<strong>分析</strong> – 其中最关键的动作是<strong>切词</strong>, 创建<strong>倒排索引</strong></p></blockquote><p>以上就是索引链, 和上面的搜索组件一起成为搜索引擎程序. 当然我们这里所讨论的文档, 全部都是文本信息.</p><p>说起来简单, 其实这里的切词还是十分有讲究的. 这涉及到太多了, 例如, 用户的文档中有可能存在很多typo, 还有语法修正, 近义词同义词, 大小写, 语种等等. 因此我们也需要特殊的词根分析器, 其中比较有名的一个开源索引链程序, 就叫做Lucene. 当然他不负责进行搜索和文档获取, 也不提供任何前端界面. 而一个使用到Lucene的前端就是我们熟悉的Elastic Search.</p><h2 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h2><p>从上面我们知道, 对于一个索引链而言, 最重要的部分就是文档了, 而文档通俗的说就是包含了一个或者多个域的容器(键值对), 在搜索时我们所检索的东西是其中的field, 也就是所谓域.</p><p>创建域的时候, 我们可以对域指定选项来说明和限制Lucene在添加域的时候做哪些操作. 这个过程就是对域的分析过程. 这些索引选项, 指定在进行倒排索引的时候能否被搜索, 如何存储, 如何索引等等. 例如有:</p><ul><li>索引选项</li><li>存储选项</li><li>项向量使用选项</li><li>…</li></ul><p>他们可以单独也可以一起使用. 以索引选项为例, 它通过倒排索引来控制文本是否可被搜索:</p><ul><li>Index.ANALYZED: 分析(切词)并且单独作为索引项.</li><li>Index.Not_ANALYZED: 不分析(切词), 把整个内容都当做一个索引项.</li><li>Index.ANALYZED_NORMS: 类似于ANALYZED, 但是不存储加权信息, 这个信息在Lucene中被叫做<code>Norms</code></li><li>Index.Not_ANALYZED_NORMS: 类似于Not_ANALYZED, 不存储Norms.</li><li>Index.NO: 不对这个值进行索引, 也就是该域不能被搜索.</li></ul><p>再比如, 对于存储选项, 指定是否要存储域的真实值. 这是什么意思? 对于有些域的值是全大写的, 或者大小写混杂, 我们在存储的时候有时需要保留, 有时是不需要保留原始值的.</p><ul><li>store.YES: 存储真实值(相当于存储两份)</li><li>store.NO: 不存储真实值</li></ul><p>在默认情况下, 文档和域的权值都是1, 我们可以通过对文档和域进行加权操作.</p><p>由于Lucene是使用JAVA语言所研发的, 因此其中所有的东西都是对象. 我们在查询索引的时候, Lucene返回的是一个叫做scoreDoc的对象, 并且有序. Lucene根据加权标准计算出一个分值, 根据这个分值来排序.</p><p>当然了, Lucene只是一个库, 因此它提供了大量的API来搜索. 对于这些API就不再赘述, 在介绍ES的时候可能会捎带这说一说.</p><h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><p>ES在Lucene的基础上, 将Lucene API所提供的数据集进行分片, 从而能够支持分布式构建还有实时查询. 我们之前说过, Lucene中最重要的组件就是索引, 就类比SQL中的表概念一样, 这个索引组件中有很多文档. 就像SQL的索引和表是在硬盘上有物理文件的, 索引也是如此. 但是不同的是, Lucene的文档是<strong>schema-free</strong>的, 他不像SQL那样是定义好的.</p><p>和InnoDB类似, 倒排索引和文档都是放在一个文件中的. ES为了能够实现并行的搜索, 他将Lucene的索引进行了切片(shard), 每一个节点都持有部分的数据集, 这就给每一个节点引入了单点故障(SPOF), 由于每一个节点持有的数据集都不是完整的, 那么只要有一部分损坏, 就意味着全部的数据集损坏. 解决这个单点问题最简单的方法就是对数据集做冗余. 我们可以对这些数据集做副本, 这就像是之前我们使用到的MySQL的主从复制一样.</p><p>那么问题来了, 我在搜索的时候, 如何才能知道我要搜索的数据在哪个节点上呢? 这个时候, 我们可以把ES当做是一个分布式的存储, 想要获得数据, 要么使用客户端, 要么通过ES Restful API, 因此, 这个接口可以帮助我们进行调度转发或者请求决策.</p><p>由于ES是基于Lucene的, 因此很多基本组件都和Lucene类似:</p><ul><li>首先是<strong>索引</strong>, 是文档的容器. 索引是具有类似属性的文档的集合. 类似于表. 索引名必须是全小写字母.</li><li><strong>类型</strong>, 类型是索引内部的逻辑分区, 其意义完全取决于用户需求. 一个索引内部可定义为一个或者多个的类型. 一般来说, 类型就是拥有相同的域的文档的预定义. 但是建议还是在一个索引中存储一个类型的数据.</li><li><strong>文档</strong>, 文档是索引和搜索的原子单位, 包含了一个或者多个域. 基于JSON格式来表示.</li><li><strong>映射</strong>,  原始内容存储为文档之前需要事先进行分析(切词, 过滤, …), 映射用于定义此分析机制该如何实现.</li></ul><p>我们前面说过ES可以组成分布式的构建, 当我们把ES组成集群的时候, 也有一些集群组件的概念:</p><ul><li>Cluster: ES的集群标识为集群名称, 默认是<code>elasticsearch</code>. 节点就是靠这个名字来决定加入到哪个集群中. 一个节点只能属于一个集群.</li><li>Node: 运行了单个ES实例的主机即为节点, 用于存储数据, 参与集群索引及搜索操作, 节点的表示靠节点名.</li><li>Shard: 将索引切割成为的物理存储组件, 但是每一个shard都是一个独立且完整的索引. 创建索引的时候, ES默认将其分割成5个shard, 用户也可以按需定义(创建之前).<ul><li>primary shard, 主shard<ul><li>replica, 副本shard, 用于数据冗余和查询的时候的, 用户可以定义这个冗余的数量, 可以动态修改.</li></ul></li></ul></li></ul><h3 id="ES集群的工作过程"><a href="#ES集群的工作过程" class="headerlink" title="ES集群的工作过程"></a>ES集群的工作过程</h3><p>启动的时候, ES会通过默认的的多播方式, 或者单播方式在9300&#x2F;tcp查找同一个集群中的其他节点, 并与之进行通信. 集群中的所有节点会选举出一个主节点负责管理整个集群状态, 以及在集群范围内决定各个shards的分布方式. </p><p>集群存在状态: green, red, yellow.</p><p>green就代表工作正常, red表示不可用. 当有节点出现问题, 集群就是yellow状态, 即修复模式. 另外, 在yellow状态下如果有某主shard的节点出现问题, 此时就需要从副本shard中寻找一个, 并且把它提升成为主shard. 此时所有的副本shard处于未分配模式, 整个集群的吞吐率也会有限制. </p><p>另外, 主节点会周期性的检查集群. 如果副本数量不够, 会启动复制过程, 直到满足条件.</p><p>说这么多其实没啥感觉, 我们直接去跑一个双节点的集群玩一玩.</p><p>ES直接启动很简单, 配置文件就在<code>/etc/elasticsearch/elasticsearch.yml</code>, YAML格式的配置文件.</p><p>这里我们如果没有修改绑定的地址, ES默认就是本机单node模式, 监听在本地回环接口上, 也就是我们常说的<code>127.0.0.1</code>. 但是, 一旦我们修改到了一个公网地址上, ES就会默认从单机开发模式变成生产环境模式的配置, 并且强制进行一次启动检查. </p><p>这个启动检查就包括检查一些重要的配置, 其中需要我们显式声明一些关于节点发现的配置. </p><p>这里注意, 建议使用IPv4的地址来通信. 另外, 如果在配置文件中设置了IPv4地址但是仍然绑定的IPv6的话, 需要在<code>jvm.options</code>中加上:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.net.preferIPv4Stack=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>几个重要的配置例如:</p><ul><li>cluster.name: 集群的名字</li><li>node.name: 节点名</li><li>network.host: 发布和绑定的网络地址</li><li>discovery.seed_hosts: 要去搜索的节点列表</li><li>cluster.initial_master_nodes: 在一开始启动中显式指明的能成为master节点的节点列表</li></ul><p>当我们配好这些配置之后就可以启动了.</p><p>接着我们可以在启动完成之后通过<code>curl</code>命令来访问接口试试:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# curl -X GET &#x27;http://192.168.10.101:9200/_cat/nodes&#x27;</span><br><span class="line">192.168.10.101 18 92 0 0.00 0.02 0.09 dilmrt * node1</span><br><span class="line">192.168.10.102 23 93 0 0.00 0.03 0.08 dilmrt - node2</span><br></pre></td></tr></table></figure><p>可以看到我们两个节点已经启动, 并且位于一个集群中. 我们也可以直接访问9200端口, 这时候显示的信息就是相当于Nginx的<code>It Works</code>, 或者<code>hello world</code>. 我们来看下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# curl node1:9200</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;node1&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;myes&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;uRZGU96yS-6JpC3wDzK39A&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;7.7.0&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;rpm&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;81a1e9eda8e6183f5237786246f6dced26a10eaf&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2020-05-12T02:01:37.602180Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;8.5.1&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br><span class="line">[root@node1 ~]# curl node2:9200</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;node2&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;myes&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;uRZGU96yS-6JpC3wDzK39A&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;7.7.0&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;rpm&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;81a1e9eda8e6183f5237786246f6dced26a10eaf&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2020-05-12T02:01:37.602180Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;8.5.1&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到两个节点的集群UUID也是一样的.</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件也是ES的一个重要的组件, 我们可以通过进行加入插件来扩展ES的功能. 例如, 我们可以添加自定义的映射类型, 自定义分析器, 本地脚本, 以及自定义发现方式.</p><p>最简单的安装插件的方式就是直接把插件丢到目标目录下, 我们可以先来看一下安装生成的文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# rpm -ql elasticsearch</span><br><span class="line">...</span><br><span class="line">/usr/share/elasticsearch/bin/elasticsearch-plugin</span><br><span class="line">...</span><br><span class="line">/usr/share/elasticsearch/plugins</span><br><span class="line">/var/lib/elasticsearch</span><br><span class="line">/var/log/elasticsearch</span><br></pre></td></tr></table></figure><p>这个目录就是插件存放的地方了. 除此之外, 我们也可以使用它提供的插件管理程序.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# /usr/share/elasticsearch/bin/elasticsearch-plugin install analysis-icu</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Installing analysis-icu</span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Downloading analysis-icu from elastic</span></span><br><span class="line">[=================================================] 100%   </span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Installed analysis-icu</span></span><br><span class="line">[root@node1 ~]# /usr/share/elasticsearch/bin/elasticsearch-plugin list</span><br><span class="line">analysis-icu</span><br><span class="line">[root@node1 ~]# ls /usr/share/elasticsearch/plugins/</span><br><span class="line">analysis-icu</span><br></pre></td></tr></table></figure><p>就像这样. 我们可以直接安装官方的插件, 或者可以传递路径, 网络或者本地均可.</p><h3 id="ES的API"><a href="#ES的API" class="headerlink" title="ES的API"></a>ES的API</h3><p>实在是繁多, <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/rest-apis.html">API参考</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Lucene </tag>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器技术入门</title>
      <link href="/2019/03/25/Docker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/"/>
      <url>/2019/03/25/Docker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>从今天开始学习Docker容器!</p><span id="more"></span><h2 id="何为容器"><a href="#何为容器" class="headerlink" title="何为容器"></a>何为容器</h2><p>在说到容器是什么之前, 我们要先来复习一下虚拟化技术.</p><p>我们之前在看Xen的时候了解到了2种虚拟化级别分别是Type-I和Type-II, 其中第一类的虚拟化是在硬件架构上直接安装一个虚拟资源管理器, 我们一般把这个叫做Supervisor. 而后者这是正常安装一个Host OS, 然后再在上面进行虚拟化.</p><p>我们知道, 这种虚拟化的架构, 一个显而易见的缺点就在于调用复杂, 往往上层虚拟机一个调用需要跨越多个系统隔离层, 不仅如此, 我们虚拟化的环境, 一个虚拟机就对应着一个完整的用户空间, 在这么一个用户空间内, 我们运行了多个应用进程. 那么我们想到能不能把这么一个巨大的用户空间进行划分隔离, 从而使得一个内核, 多个用户空间, 进程之间互相不干扰, 使得每一个进程运行在一个沙箱中, 这种技术其实就是<strong>容器技术</strong> .</p><p>容器技术最早在BSD时期就有了, 当时把这种技术叫做jail, 十分形象吧. 沙箱即监狱, 进程所能到达的最大边界就是这个隔离的用户空间的边界. 后来, Linux模仿BSD也搞出来了一个类似的东西, 叫做vserver, 使用的到的一个技术点就是我们之前所熟悉的chroot, 根切换. </p><p>除了根切换, 一个隔离环境还需要个隔离哪些资源呢?</p><p>首当其冲的就是UTS了, 也就是一台Linux主机的主机名和一些基本信息, 还有文件系统的挂载点, 进程的ID号(PID), 进程间通讯(IPC), 用户和网络(例如端口).</p><p>为了能够隔离这些空间, 我们Linux内核在内核空间对这些资源使用到了命名空间(namespace)来进行管理和隔离.</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/namespace.png" alt="namespace"></p><p>好的, 现在资源隔离的问题我们已经解决了, 接下来想象这么一个场景, 如果一个容器中的进程突然要求获取全部的CPU资源, 会怎么样呢? 其实不会造成大问题, CPU资源是一个可压缩型资源, 其他容器中的进程就挂起等待CPU就好了. 那么如果是内存资源呢? 一个容器中的进程占据了大部分的内存使得其他的容器中进程无法申请到内存, 一个进程如果申请不到内存, 就会被直接kill掉. 这样的结果是我们无法接受的, 于是Linux使用了一个叫做<strong>控制组</strong>的概念来约束资源分配:</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/cgroups1.png" alt="cgroups1"></p><p>除此之外, 还支持组内嵌套.</p><p>我们把Linux容器叫做 - LXC, 也就是<strong>L</strong>inu<strong>X</strong> <strong>C</strong>ontainer.</p><h2 id="何为Docker"><a href="#何为Docker" class="headerlink" title="何为Docker"></a>何为Docker</h2><blockquote><p> docker – 处理集装箱的码头工人</p></blockquote><p>既然已经有历史悠久的容器技术了, 为啥还会有Docker的出现呢?</p><p>首先我们说, 在最初创建一个容器是需要自行写代码的, 不仅如此, 启动销毁一个容器都需要通过代码形式进行, 十分不方便. 那么与其搞这么复杂, 我为啥不直接使用虚拟机呢? 资源隔离的效果也要更好.当然性能和资源节约方面肯定还是容器更胜一筹.</p><p>接下来说到Docker, 其实Docker实际上就是一个LXC的加强版, 早期的docker版本其实就是对LXC的一个二次封装, 一个前端应用程序. Docker使用Go语言编写.</p><p>Docker真正强大的地方在与他的易用性, 主要体现在他的<strong>镜像</strong>上.</p><p>就像我们使用虚拟机那样, 我们把操作系统打包成一个镜像文件. 安装时直接进行使用这个镜像文件就可以处理了, 而docker也是如此. 甚至不仅如此, docker对镜像文件的处理, 更加精妙.</p><h3 id="Docker的镜像"><a href="#Docker的镜像" class="headerlink" title="Docker的镜像"></a>Docker的镜像</h3><p><strong>分层构建, 联合挂载.</strong></p><p>我们可以来看这么一个图:</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/docker_image.png" alt="docker_image"></p><p>可以看到, docker的镜像构成是分层的, 最底层的就是用于系统引导的文件系统, 包括bootloader和kernel, 当容器启动完成之后就会被卸载来节省内存. 通常是aufs&#x2F;btrfs这样的文件系统. 这是所谓的容器的内核空间. </p><blockquote><p> aufs叫做高级多层同一文件系统(advanced multi-layered unification filesystem), 主要用来为Linux文件系统实现”联合挂载”. 由于某些历史原因, centos上不支持使用aufs, 所以docker也使用btrfs, devicemapper, overlayfs等等.</p></blockquote><p>我们知道, docker宣扬单个容器(用户空间)只运行单个服务. 这也就是说, 如过我们现在需要多个功能不同的镜像, 按照传统的镜像构建, 我们就需要多份不同的<strong>完整镜像</strong>. </p><p>而现在, 按照docker的这种构建方法, 我们只需要一份基础层, 也就是上图中的rootfs, 我第一个容器需要跑Nginx, 好, 那么就把Nginx的层给挂载到基础层上面, 然后使用它, 另外一个需要使用到Apache httpd, 好, 那么就在把httpd的层给挂载到同一个基础层上面, 通过这种层叠和联合挂载的方式就会节省大量的资源. </p><p>不过值得注意的是, 基础层是公用的, 那么如果我在一个容器中进行了数据修改, 会影响到其他容器吗? 显然这种事情是不能被允许的, 我们本来就是需要隔离的环境嘛. 所以这些镜像层都是<strong>只读</strong>的. 那我的数据修改怎么生效呢?</p><p>Docker在容器的启动和执行时, 会在它所使用的镜像的顶层, 叠加一个可读可写的新层, 容器的数据操作都会生效在这么一个可写层上, 如果删除了某些资源, 上层就会把这个资源标记成不可见, 容器就会以为自己真的删除了, 实际上资源还原封不动的保留在下层, 数据修改亦是如此:</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/docker_image2.png" alt="docker_image2"></p><p>这里使用到的技术就是CoW, 也就是写时复制, 我们在之前说到LVM的快照的时候就已经说过了. 这里就不在重复了.</p><p>你可能会有这样的疑问, 假设我现在使用的服务是MariaDB, 产生的数据量是巨大的, 难道还要存储在这么一个可写层上? 其实原本, 这么一个可写层在容器停止的时候也是会被持久化的, 但更一般的, 我们在使用容器的时候, 数据都是直接存储在远端存储上的, 也就是说我们找一个共享存储, 把它挂载到自己文件系统上使用, 这样的好处是, 首先不会消耗太多的性能(写时复制还是很吃性能的), 另外在发生迁移的时候很方便, 我们只需要重新创建一个新的容器, 然后把使用的共享存储挂载上去就行了.</p><h2 id="何为编排"><a href="#何为编排" class="headerlink" title="何为编排"></a>何为编排</h2><p>我们经常听到这么一个概念, 叫做 – <strong>编排</strong> (<code>Orchestration</code>), 到底是个啥?</p><p>其实这个概念我们去年的学习Linux集群管理的时候就已经接触过了, 维基百科给出的解释是:</p><blockquote><p><strong>Orchestration</strong> is the automated <a href="https://en.wikipedia.org/wiki/Configuration_management">configuration</a>, coordination, and management of computer systems and <a href="https://en.wikipedia.org/wiki/Software_deployment">software</a>.[<a href="https://en.wikipedia.org/wiki/Orchestration_(computing)#cite_note-Erl-1">1]</a></p><p>A <a href="https://en.wikipedia.org/wiki/Category:Orchestration_software">number of tools exist</a> for automation of server configuration and management, including <a href="https://en.wikipedia.org/wiki/Ansible_(software)">Ansible</a>, <a href="https://en.wikipedia.org/wiki/Puppet_(software)">Puppet</a>, <a href="https://en.wikipedia.org/wiki/Salt_(software)">Salt</a> and <a href="https://en.wikipedia.org/wiki/Terraform_(software)">Terraform</a>.[<a href="https://en.wikipedia.org/wiki/Orchestration_(computing)#cite_note-2">2]</a>. For Container Orchestration there is different solutions such as <a href="https://en.wikipedia.org/wiki/Kubernetes">Kubernetes</a> software or managed services such as AWS EKS, AWS ECS or Amazon Fargate.</p></blockquote><p>编排是一个很宽泛的概念, 我们之前所使用到的集群管理配置工具, 例如Ansible, Puppet这些自动化配置管理应用都是编排工具. 在和Docker有关的概念中, Kubernetes就是一个有名的<strong>容器编排</strong>工具</p><p>所以说白了, 编排就是一个对我们计算机资源的自动化配置, 协调和管理.</p><h2 id="了解Docker"><a href="#了解Docker" class="headerlink" title="了解Docker"></a>了解Docker</h2><p>现在我们就来更多的了解下docker.</p><h3 id="Docker的架构"><a href="#Docker的架构" class="headerlink" title="Docker的架构"></a>Docker的架构</h3><p><img src="https://docs.docker.com/engine/images/engine-components-flow.png" alt="Docker Engine Components Flow"></p><p>这个是docker的引擎组件流.</p><p>我们可以很明显得看出来, docker是一个C&#x2F;S架构的应用程序, 客户端通过docker CLI发送RESTful API来访问服务器端的docker守护进程, 服务器端支持三种套接字形式:</p><ul><li>IPv4</li><li>IPv6</li><li>Unix Sockets</li></ul><p>因此我们也可以将docker的daemon部署在同一个系统中.</p><p>下图是docker的架构图:</p><p><img src="https://docs.docker.com/engine/images/architecture.svg" alt="Docker Architecture Diagram"></p><p>在主机中, 可以看到容器和镜像两个部分, 这是两个最重要的组件了. 镜像就从docker自己维护的一个hub上下载到本地. 在Client和Host之间, Host和Registry之间, 都是使用的https协议, 如果想要使用http, 需要手动指明.</p><p>当然了, 就像Github一样, 我们也可以构建自己的仓库. 那么有个问题, 在Github中, 我们使用到的仓库被叫做<code>Repository</code>, 而Docker叫做<code>Registry</code>. 这是为什么呢?</p><p>原因是这样的: 一个Registry之上, 除了提供镜像本身, 还有对用户的身份认证和对镜像的搜索应用. 在我们的docker仓库中, 一个仓库只对应一个应用, 仓库名就是应用名. 由于应用存在不同的版本, 为了标记这些镜像, 我们就给这些镜像加上一个**<code>tag</code>**, 通过仓库名加上标签就可以唯一标识一个标签, 当用户访问仓库名(应用名)访问而没有携带tag的时候, 就会默认使用最新版(latest). 我们把这些同一应用的镜像集合叫做Repository.</p><p>所以简单的说, 镜像的集合叫做Repository, Repository的集合叫做Registry.</p><h3 id="Docker的对象抽象"><a href="#Docker的对象抽象" class="headerlink" title="Docker的对象抽象"></a>Docker的对象抽象</h3><p>我们使用Docker, 就会和docker所抽象的资源打交道, 这其中就包括: 镜像, 容器, 网络, 存储卷, 插件等等其他对象.</p><p>上面已经对docker的镜像做了一层简单的分析和了解, 这里就不在赘述.</p><p>然后我们说到容器, 容器就是镜像的一个可运行实例, 我们可以通过docker API或者CLI来对一个容器做创建启动停止删除等等操作, 我们也可以使容器连接到一至多个网络, 附加存储, 甚至基于当前的状态来创建新的镜像. 当一个容器被移除的时候, 任何没有被持久化的数据都会消失.</p><h3 id="Docker的使用"><a href="#Docker的使用" class="headerlink" title="Docker的使用"></a>Docker的使用</h3><p>我自己去自行试验了, 记录略. (没踩到坑, 大概)</p><h3 id="Docker的虚拟化网络"><a href="#Docker的虚拟化网络" class="headerlink" title="Docker的虚拟化网络"></a>Docker的虚拟化网络</h3><p>docker默认使用bridge网络, 我们可以通过<code>docker network list</code>来看到:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]<span class="comment"># docker network list</span></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">210f0e83c9ce        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">f46b112b7488        host                host                <span class="built_in">local</span></span><br><span class="line">51c645c27224        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>不仅如此, 在我们安装完docker之后就会多出一个虚拟网卡, 他就是用来作为docker容器和物理网卡的桥和容器间通信的二层设备:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]<span class="comment"># ip link</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: ens192: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:50:56:99:4b:a5 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default </span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:15:e8:50:9f brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><p>这其实就是二层交换机.</p><p>不仅如此, 当你启动一个容器之后, 就会生成一个虚拟网卡, 这就是容器和docker0这个交换机的其中一半, 然后通过虚拟的桥连接到docker0上, 我们可以通过<code>brctl</code>看到:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]<span class="comment"># brctl show</span></span><br><span class="line">bridge namebridge <span class="built_in">id</span>STP enabledinterfaces</span><br><span class="line">docker08000.024215e8509fnoveth33dc701</span><br><span class="line">  veth4b0d096</span><br></pre></td></tr></table></figure><p>这个docker0桥默认使用的nat桥, 我们可以通过iptables来看到:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]<span class="comment"># iptables -t nat -nL</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">DOCKER     all  --  0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">DOCKER     all  --  0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">RETURN     all  --  0.0.0.0/0            0.0.0.0/0   </span><br></pre></td></tr></table></figure><p>可以看到, 只要是源地址是<code>172.17.0.0/16</code>网段的, 就会被进行地址伪装, 也就是SNAT.</p><p>接着我们再说第二种网络模型. 在这一种网络模型中, 我们有一个容器共享物理机的网络资源的命名空间, 这就意味着这个容器拥有了对宿主机的网络的修改能力, 也就是特权行为. 我们把这样的容器称作<code>Open container</code>. </p><p>另外, 还可以通过多个容器共享同一个网络命名空间, 我们把这种称作<code>Join</code>式的网络. </p><p>最后一种, 就是不携带网络通信功能, 只有一个loopback接口, 这种叫做<code>Closed Conatiner</code>.</p><p>用一个图来总结就是:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.comdocker_network.png/" alt="docker_network"></p><h3 id="Docker的容器网络"><a href="#Docker的容器网络" class="headerlink" title="Docker的容器网络"></a>Docker的容器网络</h3><p>通过在创建容器的时候传递网络参数就可以指定使用的网络模型.</p><p>不仅如此, 还可以通过传递参数的方式来注入主机名, DNS, hosts文件等等. 但是容器所使用的网络是一个内部网络, 为了能够将服务暴露出去, 我们需要将容器的端口和宿主机的端口做映射, 通过在创建容器的时候加上<code>-p</code>参数就可以进行mapping.</p><p>如果是只直接写上容器需要暴露的端口, 就会将这个端口映射到宿主机的一个动态随机端口上, 至于是那个端口, 可以通过查看iptables规则或者是使用docker port命令查看, 例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]<span class="comment"># iptables -t nat -vnL</span></span><br><span class="line"></span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">    0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:32768 to:172.17.0.2:80</span><br><span class="line">[root@docker ~]<span class="comment"># docker port web1</span></span><br><span class="line">80/tcp -&gt; 0.0.0.0:32768</span><br></pre></td></tr></table></figure><p>可以看到, 指定的80端口被暴露到了宿主机的一个随机的端口, 我们可以试着访问下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]<span class="comment"># curl 10.230.204.178:32768</span></span><br><span class="line">&lt;h1&gt;The busybox httpd server.&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>是没问题的!</p><p>但是动态的端口实用性仍然有限, 我们可以通过完整的指定地址和端口来完成映射. 另外, -p选项可以被指定多次.</p><p>接下来我们创建一个容器共享的网络空间, 在创建容器的时候指定网络为别的容器的网络就可以, 来试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]<span class="comment"># docker attach b1</span></span><br><span class="line">/ <span class="comment"># ifconfig </span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:03  </span><br><span class="line">          inet addr:172.17.0.3  Bcast:0.0.0.0  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:acff:fe11:3/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:8 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:656 (656.0 B)  TX bytes:656 (656.0 B)</span><br><span class="line">---</span><br><span class="line">[root@docker ~]<span class="comment"># docker run --name b2 -it --network container:b1 59.68.29.77:5000/busybox</span></span><br><span class="line">/ <span class="comment"># ifconfig </span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:03  </span><br><span class="line">          inet addr:172.17.0.3  Bcast:0.0.0.0  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:acff:fe11:3/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:8 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:656 (656.0 B)  TX bytes:656 (656.0 B)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是, 两者的文件系统等其他资源都是隔离的, 只有网络是共享的.</p><p>那么我们能不能像VMware那样来修改docker0桥的信息呢, 很简单, 在daemon.json文件中配置属性项就可以了, 其中最重要的属性就是<code>bip</code>也就是bridge ip.</p><h3 id="Docker的存储卷"><a href="#Docker的存储卷" class="headerlink" title="Docker的存储卷"></a>Docker的存储卷</h3><p>还记得文章的开头所说的关于镜像的构成吗? 我们说镜像的最上层是一个可写层, 使用CoW技术来进行数据操作. 然后我们提到使用别的存储来持久化数据. 并且还在上面说到Docker的对象抽象中有一个叫做<code>volume</code>的, 这个就是我们在这一小节要提到的存储卷. 通过将宿主机上的一个目录文件和容器中的文件系统中的目录进行一定范围的绑定, 通过大的文件系统隔离, 仅仅只把这个目录的空间进行关联. 当然, 除了宿主机上的存储, 我们也可以拿一个nfs服务器或者什么共享存储来当做容器的卷.</p><p>当我们进行了卷的绑定操作之后, 哪怕删除容器, 数据也会持久化在存储中. Docker有两种类型的卷, 每种类型的卷都在容器中存在一个挂载点, 但是在宿主机上的位置有所不同:</p><ul><li>Bind mount volume 用户指定位置</li><li>Docker-managed volume 由Docker来创建和管理</li></ul><p>操作起来也十分简单, 来看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]<span class="comment"># docker run --name b1 -it -v /data 59.68.29.77:5000/busybox</span></span><br><span class="line">/ <span class="comment"># ls /data/</span></span><br><span class="line">/ <span class="comment"># </span></span><br></pre></td></tr></table></figure><p>这样就是创建了一个容器内的<code>/data</code>目录指向宿主机的一个特定目录的存储卷, 这个存储卷由Docker进行维护, 那么到底是哪里呢, 我们可以来inspect一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> ...</span><br><span class="line"> <span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;0bd6ed489a4c9714c3a8089216407a3dd342c637c9f68872707aa92a89d6ec21&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/0bd6ed489a4c9714c3a8089216407a3dd342c637c9f68872707aa92a89d6ec21/_data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到在宿主机的位置, 接下来我们通过宿主机在这里写点文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]<span class="comment"># echo &quot;Hello docker&quot; &gt; /var/lib/docker/volumes/0bd6ed489a4c9714c3a8089216407a3dd342c637c9f68872707aa92a89d6ec21/_data/hello</span></span><br></pre></td></tr></table></figure><p>然后回到容器中, 就会看到:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># cat /data/hello </span></span><br><span class="line">Hello docker</span><br></pre></td></tr></table></figure><p>当然反过来也是完全可以的.</p><p>这是由docker来管理的, 接下来我们试试自行管理的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]<span class="comment"># docker run --name b2 -it --rm -v /data/volume/b2:/data 59.68.29.77:5000/busybox </span></span><br></pre></td></tr></table></figure><p>然后我们还是来查看一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;bind&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/data/volume/b2&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;rprivate&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>宿主机的目录也不需要提前建立, docker是可以帮你自动建立的.</p><p>同样的, 就像我们的共享网络一样. 容器也可以同时挂载本地的同一个卷.  除了手动指明, 还可以通过传递<code>--from-container</code>来直接复制别的容器的配置.</p><h2 id="了解Dockerfile"><a href="#了解Dockerfile" class="headerlink" title="了解Dockerfile"></a>了解Dockerfile</h2><p>dockerfile可以说是Docker的另一个重要概念.</p><p>什么是Dockerfile, 这个东西说白了就是一个纯文本文件, 里面是用于创建镜像的指令. 通过读取dockerfile中的指令, Docker可以自动化的进行容器build. 那么我们为什么会需要这么一个东西呢. 很简单, 假设我们从互联网中下载下来了一个Nginx或者是别的什么应用的镜像. 使用的时候我们总是会先进行配置, 然后才会投入使用.</p><p>而Dockerfile就是解决这样的问题, 当我们创建容器的时候, 在实际运行真正的服务进程之前, 我们会先运行另外一个程序, 这个程序就是会进行服务配置的一个自动化程序. </p><p>Docker会按照顺序从上到下的运行Dockerfile中的指令, 每一条指令都是独立的, 在Dockerfile中为了区分参数和指令, 我们通常会把指令大写, 尽管Dockerfile是大小写不敏感的. 使用<code>#</code>来表示一行注释. 一个Dockerfile必须使用FROM作为指令开头, FROM说明我们构建的基础镜像是哪个.</p><p>接下来我们简单的说一下Dockerfile的工作原理, 首先我们需要一个工作目录, 构建镜像所需要的所有文件必须包含在这个目录之下, 而不能在父目录中, 接着在这个工作目录中放着我们的Dockerfile, 需要注意的是这个文件名首字母必须大写, 然后, 就像我们的git一样, 如果说在子目录中的文件我不需要使用到, 就可以在这个工作目录中加上一个隐藏文件, 叫做<code>.dockerignore</code>, 语法格式基本上和<code>.gitignore</code>一样.</p><p>由于我们构建镜像的环境是基于一个基础镜像, 所以能够使用的命令都是限制在这个环境中的.</p><p>关于更多Dockerfile的语法和格式, 推荐阅读<a href="https://docs.docker.com/engine/reference/builder/">官方文档</a></p><h2 id="Docker的私有仓库"><a href="#Docker的私有仓库" class="headerlink" title="Docker的私有仓库"></a>Docker的私有仓库</h2><p>我们在说到上面的Docker的架构的时候就提到了Registry这个东西, 我们也可以搭建私有的局域网内的私有仓库. 其实, 搭建这么仓库很简单, 因为Docker官方提供了这么一个容器镜像, 就是专门做这件事情的, 这个镜像就叫做docker-registry. 可以直接通过yum下载安装软件包:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]<span class="comment"># yum info docker-registry</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">Available Packages</span><br><span class="line">Name        : docker-registry</span><br><span class="line">Arch        : x86_64</span><br><span class="line">Version     : 0.9.1</span><br><span class="line">Release     : 7.el7</span><br><span class="line">Size        : 123 k</span><br><span class="line">Repo        : extras</span><br><span class="line">Summary     : Registry server <span class="keyword">for</span> Docker</span><br><span class="line">URL         : https://github.com/docker/docker-registry</span><br><span class="line">License     : ASL 2.0</span><br><span class="line">Description : Registry server <span class="keyword">for</span> Docker (hosting/delivering of repositories and images).</span><br></pre></td></tr></table></figure><p>安装之后其实是一个叫做docker-distribution的东西:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]<span class="comment"># rpm -ql docker-distribution</span></span><br><span class="line">/etc/docker-distribution/registry/config.yml</span><br><span class="line">/usr/bin/registry</span><br><span class="line">/usr/lib/systemd/system/docker-distribution.service</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2/AUTHORS</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2/CONTRIBUTING.md</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2/LICENSE</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2/MAINTAINERS</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2/README.md</span><br><span class="line">/var/lib/registry</span><br></pre></td></tr></table></figure><p>安装的东西也很少, 最下面的那个目录就是存储用户上传的镜像的.</p><p>我们来看一下这个配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]<span class="comment"># cat /etc/docker-distribution/registry/config.yml </span></span><br><span class="line">version: 0.1</span><br><span class="line"><span class="built_in">log</span>:</span><br><span class="line">  fields:</span><br><span class="line">    service: registry</span><br><span class="line">storage:</span><br><span class="line">    cache:</span><br><span class="line">        layerinfo: inmemory</span><br><span class="line">    filesystem:</span><br><span class="line">        rootdirectory: /var/lib/registry</span><br><span class="line">http:</span><br><span class="line">    addr: :5000</span><br></pre></td></tr></table></figure><p>我们如果想要修改路径的话, 就在这里改变目录就行了. 默认监听本机的所有5000端口.</p><p>服务端默认使用的协议是http, 但是我们的客户端是一个默认htttps的客户端, 服务端和客户端不兼容, 怎么办?</p><p>由于是内网, 我们可以把我们的服务端当做非加密, 不安全的特例加进我们客户端的配置文件中, 也就是daemon.json的<code>insecure_registry</code>就可以了.</p><p>默认的工具只有CLI端, 如果需要Web界面, 可以使用harbor项目.</p><h2 id="Docker的资源限制"><a href="#Docker的资源限制" class="headerlink" title="Docker的资源限制"></a>Docker的资源限制</h2><p>我们对容器的资源进行管控, 主要是从三个维度:</p><ul><li>CPU</li><li>Memory</li><li>Block I&#x2F;O</li></ul><p>虽说是三个, 但是实际上, 我们真的能管控的还是仅限于前两个.</p><p>我们先来说说内存控制, 默认的情况下, 一个容器可以使用的资源是无限制的. Docker支持对容器的RAM和swap空间增加限制. 简单的说, 在进行容器的创建的时候, 增加一个<code>-m/--memory</code>参数就可以限制内存用量了, 你可以使用各种单位例如m,g啥的. 对于swap的限制依赖于对内存用量的限制, 也就是说, 如果你想要限制swap用量, 必须先明确指定这个容器的内存用量是多少. 对应的参数是<code>--memory-swap</code></p><p>对于这个swap设定, 其实逻辑有点奇怪. 假设swap设置为S, memory设置为M, 那么最后的容器总内存是S, 可用的ram是M, swap是S-M. swap指定为-1的时候, 代表无限制.</p><p>ok, 接下来来说说CPU. 默认情况下, 使用到的CPU资源也是无限制的. 我们来介绍三个CPU资源限制参数.</p><p>首先是<code>--cpu-share</code>, 传入一个默认是1024的可大可小的值. 得益于我们的CPU是一个可压缩的资源, 所以我们可以通过指明每一个容器使用CPU的比例来进行动态的划分. 例如, 我现在有三个容器的参数分别是1024:512:2048. 那么当三个容器都在运行的时候占总运算比分别是2:1:4. 但是如果第二个和第三个都不吃CPU的话, 第一个容器是完全可以占用全部的运算资源的. 因为此时的比例就是1:0:0了嘛. 所以这是一个容器之间对CPU的限制, 并不能对单个容器的CPU用量进行限制. 如果想要做到这个效果, 就应该使用下面的参数.</p><p><code>--cpus</code>, 简单直接, 直接指明你想让容器所使用到的最多的CPU资源. 例如, 指定<code>--cpu 1.5</code>就是限制该容器最多可以用一个半的CPU. 但是使用的是哪个核心, 我们是不知道的, 如果想要明确指定容器可以使用到的核心, 使用下面的参数.</p><p><code>--cpusets-cpus</code>, 我们的CPU从0开始, 一个四核心的主机, CPU就是0,1,2,3. 所以比如说我限制上面提到的容器只可以使用前两个核心, 那就写<code>--cpuset-cpus 0,1</code>即可.</p><p>如果想要看看限制的效果, 可以试着pull一个压力测试的镜像跑着玩玩, 例如<code>docker-stress-ng</code>跑着玩玩, 例如<code>docker-stress-ng</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Cloud Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Opensatck_2</title>
      <link href="/2019/03/13/%E5%88%9D%E8%AF%86OpenStack_2/"/>
      <url>/2019/03/13/%E5%88%9D%E8%AF%86OpenStack_2/</url>
      
        <content type="html"><![CDATA[<p>前一篇文章过了一遍权限服务和虚拟机映像服务, 而且都是在控制节点上进行的. 现在终于要开始部署计算服务了, 想想都激动. </p><span id="more"></span><h2 id="Nova"><a href="#Nova" class="headerlink" title="Nova"></a>Nova</h2><p>为了了解Nova是如何工作的, 我们先看下这个逻辑架构图的Nova部分:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/Nova-arch.png" alt="Nova-arch"></p><p>可以看到, 其中最重要, 和大部分的组件都产生关系的组件就是这个<code>Queue</code>了. 官方文档称呼这个东西叫做<code>central hub</code>, 都已经central了能不重要吗哈哈. 这个队列主要是在各种daemon中传递消息的, 通常使用的是RabbitMQ.</p><p>然后我们从最外面开始看, 这里唯一和外界打交道的就是nova-api了, 它是用来接受和响应终端用户的计算API调用的. 与之配合的, 上图中没有列出的一个组件是<code>nova-api-metadata service</code>, 听名字就知道了, 这个东西是用来接受来自实例的源数据请求的.</p><p>接着是调度器组件–<code>Nova-scheduler</code>. </p><blockquote><p>值得一提的是, 在Nova中原本有一个Placement API, 参与到scheduler的调度流程当中, 原本是一个可选的功能, 到了P版本的时候要求强制开启. 渐渐地, 在18年的年末, Placement API开始从nova项目中剥离, 渐渐地成为Openstack Placement, 期待最终替代nova-scheduler. 计划在S版本中成为一个独立的项目. 但是目前(这里用的是Q版本), 我们在配置的时候已经有点要单独看待的意思了.</p></blockquote><p>这个东西从队列中取出外部对虚拟机实例的请求然后来决定交给哪一个host来运行. 那么如何运行呢, 这就要交给Nova的另一个核心组件也就是计算服务了. <code>Nova compute</code>是一个用来创建和终止虚拟机实例的工作进程, 例如:</p><ul><li>使用Xen的XenAPI</li><li>使用KVM或者是QEMU的libvirt API</li><li>使用VMware的VMwareAPI</li></ul><p>根据虚拟机平台不同, 所使用到的HyperVisor API也不同. 然后再虚拟机启动之后把他在数据库中存储的状态进行update.</p><p>那就奇怪了, 上面的架构图中, 计算服务似乎并没和数据库进行直接的交互. 没错, 负责协调引领计算节点和数据库交互的模块就是<code>conductor module</code>. </p><h3 id="Nova的配置-控制节点和计算节点"><a href="#Nova的配置-控制节点和计算节点" class="headerlink" title="Nova的配置 - 控制节点和计算节点"></a>Nova的配置 - 控制节点和计算节点</h3><p>我们按照官方文档的说明, 对控制节点和计算节点的Nova服务进行配置, 然后进行安装验证. 下面说下我遇到的问题:</p><p>安装和配置完成之后, 惊奇的发现不停的报503和401错误, 原因大概率可能是因为配置文件里面的密码写错了, 另外, 如果密码参数是空白的话, 也会报错. </p><blockquote><p>我之前在说glance的时候说这个配置项在官方文档已经找不到了, 但是如果不在里面写上的话, 一些服务注册发现会遇到授权错误导致失败, 也即是401 Unauthorized错误的原因. 所以还是要写上的.</p></blockquote><p>如果配置完成我们会运行一个<code> nova-status upgrade check</code>来检查问题.</p><p>这里再记录一个奇妙的事情, 我在执行这个check的时候发现一个Warning提示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">| Check: Resource Providers                                           |</span><br><span class="line">| Result: Warning                                                     |</span><br><span class="line">| Details: There are 1 compute resource providers and 2 compute nodes |</span><br><span class="line">|   in the deployment. Ideally the number of compute resource         |</span><br><span class="line">|   providers should equal the number of enabled compute nodes        |</span><br><span class="line">|   otherwise the cloud may be underutilized. See                     |</span><br><span class="line">|   https://docs.openstack.org/nova/latest/user/placement.html        |</span><br><span class="line">|   for more details.                                                 |</span><br></pre></td></tr></table></figure><p>另外我也发现在使用compute列举服务的时候, 出现了重复的ID:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@controller ~]# openstack compute service list</span><br><span class="line">+----+------------------+-------------------------------+----------+---------+-------+----------------------------+</span><br><span class="line">| ID | Binary           | Host                          | Zone     | Status  | State | Updated At                 |</span><br><span class="line">+----+------------------+-------------------------------+----------+---------+-------+----------------------------+</span><br><span class="line">|  1 | nova-scheduler   | control_node                  | internal | enabled | down  | 2019-03-19T05:49:25.000000 |</span><br><span class="line">|  2 | nova-consoleauth | control_node                  | internal | enabled | down  | 2019-03-19T05:49:31.000000 |</span><br><span class="line">|  3 | nova-conductor   | control_node                  | internal | enabled | down  | 2019-03-19T05:49:32.000000 |</span><br><span class="line">|  8 | nova-compute     | compute_node1                 | nova     | enabled | up    | 2019-03-21T01:23:00.000000 |</span><br><span class="line">|  9 | nova-consoleauth | controller.rjjc.comcontroller | internal | enabled | up    | 2019-03-21T01:23:01.000000 |</span><br><span class="line">| 10 | nova-scheduler   | controller.rjjc.comcontroller | internal | enabled | up    | 2019-03-21T01:22:56.000000 |</span><br><span class="line">| 11 | nova-conductor   | controller.rjjc.comcontroller | internal | enabled | up    | 2019-03-21T01:22:57.000000 |</span><br><span class="line">|  1 | nova-scheduler   | control_node                  | internal | enabled | down  | 2019-03-19T05:49:25.000000 |</span><br><span class="line">|  2 | nova-consoleauth | control_node                  | internal | enabled | down  | 2019-03-19T05:49:31.000000 |</span><br><span class="line">|  3 | nova-conductor   | control_node                  | internal | enabled | down  | 2019-03-19T05:49:32.000000 |</span><br><span class="line">|  8 | nova-compute     | compute_node1                 | nova     | enabled | up    | 2019-03-21T01:23:00.000000 |</span><br><span class="line">|  9 | nova-consoleauth | controller.rjjc.comcontroller | internal | enabled | up    | 2019-03-21T01:23:01.000000 |</span><br><span class="line">| 10 | nova-scheduler   | controller.rjjc.comcontroller | internal | enabled | up    | 2019-03-21T01:22:56.000000 |</span><br><span class="line">| 11 | nova-conductor   | controller.rjjc.comcontroller | internal | enabled | up    | 2019-03-21T01:22:57.000000 |</span><br><span class="line">+----+------------------+-------------------------------+----------+---------+-------+----------------------------+</span><br></pre></td></tr></table></figure><p>然后google了很久都说是把数据库改一下就好了, 但是神奇的是进去之后发现并没有重复的compute节点, 于是我就把数据库洗掉了重新生成了一次, 这一次就好了, 想要尝试复现这个情况的时候也没成功. 所以就先当做是一个奇怪的现象记录在这里.</p><p>配置好了Nova之后我们就可以开始着手搭建最小化openstack的最后一步了, 来构建网络服务. 代码名为**<code>neutron</code>**.</p><h2 id="Neutron"><a href="#Neutron" class="headerlink" title="Neutron"></a>Neutron</h2><p>先来了解一下Openstack的两种网络选项, 分别叫做<code>Provider Networks</code>和<code>Self-Service Networks</code>.</p><p>其中前者主要就只有2层, 他把虚拟的网络通过桥接的方式连接到物理网络上, 然后依赖物理网络上的第三层服务(路由). 至于后者, 使用到的技术就是NAT, 所以显然, 这个网络选项是含有第三层服务的.</p><p>接下来就来看看Openstack的网络组件Neutron的相关, 这个服务主要包含三个组件:</p><ul><li>neutron-server 用于接受和路由访问请求到合适的Openstack网络插件</li><li>Openstack Networking plug-ins and agents 这个就是上面提到的网络插件了, 比如思科, vSwitch, Linux bridging, VMware NSX等等; 这里常见的agent例如第三层代理, DHCP等等</li><li>Messaging Queue 最后一个就不用过多介绍了, 主要负责agent和server之间的消息传递.</li></ul><p>现在我们来说说关于neutron和Openstack网络一些概念, 作为一个网络服务就是需要提供对于网络, 子网, 路由器等等的对象抽象. 对于一个给定的网络, 需要设立至少一个外部网络, 这个外部网络不仅仅是一个虚拟定义网络, 而是一个在Openstack范围之外可以访问到的物理的外部网络, 只要是在这么一个外部的网络中, 任何人都可以物理的访问到. 除了外部网络 , 每一个Neutron定义的网络还需要有一至多个内部网络, 这些软件定义网络直接连接到虚拟机, 在这么一个网络中, 只有给定这些网络和子网的虚拟机之间可以通过这些网络直接访问. </p><p>另外, 在Openstack的网络概念中, 还有一个叫做安全组的东西. 熟悉吧, 我们在腾讯云阿里云操作云主机的时候就遇到这个概念了, 所谓安全组其实就是防火墙规则, 一个虚拟机可以被关联到一至多个安全组.</p><p>对于Neutron网络中的另一个重要组成部分 – 插件, 每一个网络插件都有他自己的概念, 因此这种就只能遇到在说了.</p><h3 id="Neutron的配置"><a href="#Neutron的配置" class="headerlink" title="Neutron的配置"></a>Neutron的配置</h3><p><strong>巨大的坑: 主机名不能带下划线!</strong></p><p>这种事情给你就应该在一开始说一下嘛! 如果主机名携带下划线, 就会导致linuxbridge服务启动失败, 并且systemctl不会给你错误返回值! 需要你自己去看日志.</p><p>其他的照着官方那个文档做就没问题.</p><p>配置完了Nova和Neutron之后, 一个最小化的Openstack就完成了</p><p>接下来为了更方便的使用, 我们可以构建horizon.</p><h2 id="Horizon"><a href="#Horizon" class="headerlink" title="Horizon"></a>Horizon</h2><p>Horizon就是Openstack的前端dashboard了. 使用的Django进行的开发, 配置使用起来十分容易:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/dashboard1.png" alt="dashboard1"></p><p>但是现在还不能直接通过镜像启动实例, 因为我们还有一些必要的配置项没有搞. 但是现在这么一个基础的服务框架已经建立, 接下来因为时间和进度的关系, 我会暂时放下Openstack转而学习Docker的基础, 最后再来学习将两者统一起来的项目Zun或者Magnum.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Openstack </tag>
            
            <tag> Cloud Computing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识OpenStack_1</title>
      <link href="/2019/03/12/%E5%88%9D%E8%AF%86OpenStack_1/"/>
      <url>/2019/03/12/%E5%88%9D%E8%AF%86OpenStack_1/</url>
      
        <content type="html"><![CDATA[<p>由于毕业设计的选题选择了关于使用Openstack和Docker容器技术来构建一个高校云主机申请平台, 现在开始学习了解一下这个云计算框架 - openstack.</p><h2 id="扯点闲话"><a href="#扯点闲话" class="headerlink" title="扯点闲话"></a>扯点闲话</h2><p>关于Openstack大家都听说过, 这个项目是由NASA和Rackspace发起开源的一个云平台. 最早于2010年发布第一个版本. 关于Openstack的版本号, 是按照26个英文字母的顺序, 用这些字母开头的单词来作为版本号, 例如2010年的第一个版本叫做Austin, 接着是Bexar, Cactus, Diablo….目前最新的版本是R版, 即Rocky. 这一次的我们选择的版本是Q版本, Queen.名字挺好听的吧. 就是他了.</p><span id="more"></span><p>Openstack是一个很复杂和庞大的云计算框架, 不过与其说他是框架, 不如说它是多个项目综合起来的一个更大项目, 最初的Openstack, 仅仅只有最基础的两个服务, 分别是NASA贡献的计算代码Nova和Rackspace贡献的对象存储代码Swift. 到了现在已经有大大小小几十个项目了:</p><p><img src="https://www.openstack.org/software/images/map/openstack-map-v20180601.svg" alt="OpenStack Cloud landscape map"></p><p>这么多组件交互起来是个什么样子呢, 我们只在这里面选取一些必要的组件和一些比较重要的, 一共十二个, 他们交互起来的逻辑架构是这样的:</p><p><img src="https://docs.openstack.org/install-guide/_images/openstack-arch-kilo-logical-v1.png" alt="Logical architecture"></p><p>还是蛮复杂的. </p><p>接下来的几篇关于Openstack的文章, 我们会从单个项目进行入手, 这篇文章我们来看看Openstack的两个核心组件 – Keystone和Glance.</p><h2 id="Keystone"><a href="#Keystone" class="headerlink" title="Keystone"></a>Keystone</h2><p>为什么所有人都要从这个组件说起? 因为这是一个进行统一的身份验证, token的发放和校验, 服务列表, 还有包括用户权限的定义. 几乎所有的Openstack服务都要经过Keystone, 来获取操作的权限和身份识别. 简单说来, 这是一个<code>Identity Sevice</code>.</p><p>官方文档对这么一个服务的表述是: </p><blockquote><p> The OpenStack Identity service provides a single point of integration for managing authentication, authorization, and a catalog of services.</p></blockquote><p>不仅是Openstack的服务要和Keystone打交道, 就连用户第一个打交道的服务就是它, 除了进行鉴权, Keystone还可以进行服务发现, 从而使得其他的服务能够知道有哪些其他服务正在部署. </p><p>Keystone自己的维护了一个小型的数据库, 但是他也可以和诸多外部的系统进行交互, 例如memcached, mysql, LDAP等等. </p><p>接着在实际了解到keystone之前, 我们要先来介绍概念了.</p><p><strong><code>Credential</code></strong> 这个玩意的英文原意就是证书, 凭证之类的意思 (相较于Certificate, 这个偏非官方非正式一点). 在这里, 这个东西指能够证明用户身份的数据, 例如, 用户名和密码, 用户名和API KEY, 或者是权限服务提供的鉴权token.</p><p><strong><code>Endpoint</code></strong> 这个东西挺好理解的, 很多Web框架里面也有这个概念. 这东西就是指一个网络可访问的地址, 通常就是我们所熟知的URL, 翻译过来就是服务的端点, 也就是访问这些服务的入口.</p><p><strong><code>Region</code></strong> 这个东西就是指一个鉴权服务API V3的实体(官网解释), 看不懂什么意思, 没关系后面有解释. 就代表是一个通用的Openstack部署划分的区域, 说白了就是部署的另外一套Openstack, 他们使用同一个Identity服务, 并且我们还可以进行再去region中再加上一个sub-region, 形成树状结构. 通常情况下, 划分region都是地理上的, 比如说不同的机房, 就会被划分不同的region, 例如: <code>us-east</code>, <code>hk-001</code>之类的. 这个玩意我们叫做区域.</p><p><strong><code>Token</code></strong> 很简单啦. 就是一串字母数字组成的字符串. 就像这样子:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;project_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;d0238da87b624a63a1132886db6f2dc5&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;expires&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2019-03-12T03:27:26+0000&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;user_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0625920ca5934f9fa2e47249b03e3d1b&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gAAAAABchxkOKHqMF890O3Pl_8_ItvrutNPcOgZd0Y18QSv447O4_r17UpQxttXW4NIrTx-t9q5a5OOUkPvq8t704Odsicq9UM6Wr6HSGG7gcYRFymzXr5ZQLiRlNeGHVVQV7mBfbJXKXRg5Of5-yEgY5O-eyEWxMQ4kQJO7zjgpCEbsQMgHvwA&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>又出现了两个概念, <code>project</code>和<code>user</code>. 在说到这个之前, 我们再说一个刚刚就已经提到过的概念:</p><p><strong><code>Service</code></strong> 就是Openstack中的一个服务, 比如我们现在正在说的Keystone, 还有例如计算服务Nova这些, 能够提供一个或者多个<code>endpoint</code>, 使得用户能够访问到资源和进行操作.</p><p>接下来我们介绍一组概念, 分别是<code>User</code>, <code>Role</code>, <code>Project</code>, <code>Domain</code>.</p><p>初次接受这一组概念可能有点迷糊, 多看看就好了.</p><p>在一些低版本的课程中, (2016年之前的版本), 会有一个叫做租户的概念, 说是一个用户组的意思, 这个概念在M版本(2016)之后逐渐的被弱化, 现在已经没有了, 取而代之的就是上面的Project概念. </p><p><strong><code>Project</code></strong> 这个就是用来分组和隔离资源或者权限对象的一个容器. 说的直白点就是命名空间一样的概念. </p><p><strong><code>Domain</code></strong> 这个东西就是在Project之上的一个更大的空间, 包括了多个project和users, 定义了一个鉴权实体的管理边界(这样说不知道你们能不能明白)</p><p><strong><code>User</code><strong>和</strong><code>Role</code></strong> 这两个概念我们放在一起来解释, 先来看这个图吧:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/user%26role.png" alt="user&amp;role"></p><p>可以看到, 用户就相当于是一个人, 系统或者服务的表示形式, 用户可以被<code>project</code>来contain, 而<code>role</code>就是一组来执行特定操作的用户权限的形态, 用户可以和role来进行关联, 当用户进行操作的时候, 服务会去寻找用户所关联上的role是啥, 然后判定可进行的操作范围. 另外, 就像上图所展示的, 不同Project的同一个用户也可以拥有不同的角色.</p><p>以上就是关于Keystione的诸多概念了. 大体上的感觉就像这样子:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/keystone_concept.png" alt="keystone_concept"></p><p>随手用visio画的, 看看就好.</p><p>关于Keystone的安装和基本部署, 官方文档都写的十分详细了(起码CentOS 7版本是这样子的), 所以照着做下来就不会有大问题. 我也没有踩到什么坑. 倒是下面的Glance踩到了坑.</p><h2 id="Glance"><a href="#Glance" class="headerlink" title="Glance"></a>Glance</h2><p>说完了Keystone, 我们再来说下一个服务. 为了创建一个虚拟机, 我们需要一个image映像才可以, 而glance就是</p><p>这么一个用于虚拟机映像的发现注册和获取的服务.glance支持使用文件后端(simple fs),或者是使用对象文件存储系统以及诸多外部存储系统.</p><p>Glance包含这些组件:</p><ul><li>glance-api</li><li>glance-registry – (该组件已经在Q版本中标记为DEPRECATED, 并且将在S版本中去除)</li><li>database</li><li>Storage repository for image files</li><li>Metadata definition service</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@control_node ~]<span class="comment"># openstack image list</span></span><br><span class="line">+--------------------------------------+--------+--------+</span><br><span class="line">| ID                                   | Name   | Status |</span><br><span class="line">+--------------------------------------+--------+--------+</span><br><span class="line">| 057ff68c-0d24-404b-9a3f-d017058c0262 | cirros | active |</span><br><span class="line">+--------------------------------------+--------+--------+</span><br></pre></td></tr></table></figure><p>Glance所维护的映像文件都会被赋予一个唯一的ID, 并且这些映像会有这些状态: </p><ul><li>Queued: 镜像ID已经保留, 但是镜像还没有上传</li><li>Saving: 镜像正在被上传</li><li>Active: 镜像已经可以使用</li><li>Killed: 镜像损坏或者不可用</li><li>Deleted: 镜像被删除</li></ul><p>对于磁盘映像文件的支持, glance除了支持亚马逊定义的三种image格式之外, 还支持很多市面上普遍的格式, 例如无结构的raw格式, vhd, vmdk, vdi, iso, qcow2. 其中得益于qcow2的动态增加文件大小和云系统的相性不错, 比较常用.</p><p>接着我们说说在Glance配置的时候踩到的坑:</p><p>配置的时候你会看到官方文档这样的给示例: (api和registery配置文件都是这样的)</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[keystone_authtoken]</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">auth_uri</span> = http://controller:<span class="number">5000</span></span><br><span class="line"><span class="attr">auth_url</span> = http://controller:<span class="number">5000</span></span><br><span class="line"><span class="attr">memcached_servers</span> = controller:<span class="number">11211</span></span><br><span class="line"><span class="attr">auth_type</span> = password</span><br><span class="line"><span class="attr">project_domain_name</span> = Default</span><br><span class="line"><span class="attr">user_domain_name</span> = Default</span><br><span class="line"><span class="attr">project_name</span> = service</span><br><span class="line"><span class="attr">username</span> = glance</span><br><span class="line"><span class="attr">password</span> = GLANCE_PASS</span><br></pre></td></tr></table></figure><p>但实际上, 这里的<code>auth_url</code>根本就已经被废弃掉了. 另外很多配置项也是已经消失不见了, 在Q版本的配置文件中, 有一个叫做**<code>www_authenticate_uri</code>**的配置选项, 你可以把这个当做上面示例给的<code>auth_uri</code>, 这个配置项的意义其实就是公共(public)验证服务的的endpoint.</p><p>但是, 搞笑的是, 你还不能不配这个已经被废弃掉的值, 如果没有给它赋值, 即使数据库都成功写入了. 当启动服务的时候会因为缺少这个<code>auth_url</code>配置, 疯狂报错然后就退出.</p><p>所以最后在这个section需要配置的选项有:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[keystone_authtoken]</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">www_authenticate_uri</span> = http://controller:<span class="number">5000</span></span><br><span class="line"><span class="attr">auth_url</span> = http://controller:<span class="number">5000</span></span><br><span class="line"><span class="attr">memcached_servers</span> = controller:<span class="number">11211</span></span><br><span class="line"><span class="attr">auth_type</span> = password</span><br></pre></td></tr></table></figure><p>然后就可以尝试启动服务和使用了.</p><p>以上就是关于Opensatck中权限组件和映像服务的相关说明了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Openstack </tag>
            
            <tag> Cloud Computing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KVM初识</title>
      <link href="/2018/12/15/KVM%E5%88%9D%E8%AF%86/"/>
      <url>/2018/12/15/KVM%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>  看完了Xen, 接下来再来接触一下不使用hypervisor的KVM虚拟化技术.</p><span id="more"></span><h2 id="KVM概述"><a href="#KVM概述" class="headerlink" title="KVM概述"></a>KVM概述</h2><p>KVM就是<code>Kernel-based Virtualization </code>. 基于内核的虚拟化, 我们之前已经通过使用Xen这种类型一虚拟化来实现虚拟化环境, 通过Dom0虚拟机来实现IO设备模拟交互.</p><p>KVM是通过实现一个内核接口来进行虚拟机管理的, KVM作为一个内核模块, 当我们装载了之后整个Linux内核就会变成一个HyperVisor了. 因此当创建了一个虚拟机之后, 在操作系统中被抽象成了一个进程, 我们甚至可以通过<code>ps</code>来看到他们, 那关闭一个虚拟机咋做? 很简单, 直接<code>kill</code>就完事了. 在KVM出现之后, 由于他和内核的相性使得Linux直接抛弃了原先的Xen, 实装了KVM到内核模块中, 至于一些支持Xen和KVM的管理工具, 就被砍去了对Xen的部分功能.</p><p>对于KVM而言, 硬件辅助虚拟技术(HVM)也是必要的, 因此我们需要在虚拟机测试的环境下开启硬件虚拟化. KVM在我们的<code>/dev</code>目录下有一个专门的文件, <code>/dev/kvm</code>. 当我们想要创建虚拟机的时候, 就向这个文件发送请求即可, 他会和我们的KVM内核模块打交道. 现在来想象一下, 在装载了KVM并且新建一个虚拟机之后, 假设这还是一个Linux虚拟机, 那么他也会有自己的用户空间和内核空间, 这就比较麻烦, 我们知道有内核模式和用户模式, 此时我们引入了一个新的模式叫做宾客模式(guest mode). 也就是这个虚拟机对应的用户空间的模式名. </p><p>由此, 在我们载入KVM模块之后, 我们的系统就会有三种运行模式了:</p><ul><li>内核模式: 虚拟机的内核模式</li><li>用户模式: 代表GuestOS执行I&#x2F;O类操作, host的用户模式</li><li>来宾模式: GuestOS的非I&#x2F;O操作, 该模式可以说成是虚拟机的用户模式</li></ul><p>此时我们的Host的内核就扮演成Hypervisor的角色了.</p><p>除了上面提到的<code>/dev/kvm</code>, 另外一个重要的KVM组件就是我们之前也见过的qemu进程. 先来说说<code>/dev/kvm</code>. 我们知道这个东西是KVM的一个入口, 作为一个字符设备来存在, 可以通过<code>ioctl()</code>系统调用来完成VM创建, 启动, 分配内存, 读写VCPU的寄存器等等. 而qemu, 工作在用户空间, 主要用于实现模拟PC机的IO设备.</p><p>KVM可以使用Linux的大内存页(Huge Page), 也支持将分配给虚拟机的内存进行swap交换. 另外, KVM还可以使用KSM(Kernel Same-page Merging), 合并相同的内存页.</p><p>接着我们来说说KVM的设备驱动, 首先是IO设备的完全虚拟化, 很简单了这就是模拟硬件. 而对于IO设备的半虚拟化, 我们需要在GuestOS中安装驱动, 叫做virtio.</p><p>KVM优点很多, 但也有一些局限性, 例如KVM的过载使用(overcommit), 还有虚拟机的时钟, 由于VCPU的存在就会导致时间同步出错. </p><h2 id="KVM的工具栈"><a href="#KVM的工具栈" class="headerlink" title="KVM的工具栈"></a>KVM的工具栈</h2><p>除了上面说的Qemu, 另外一组KVM的工具栈就是使用libvirt的virsh. 在qemu中我们主要使用qemu-kvm和qemu-img这两个工具. 而libvirt支持在GUI和CLI两种模式下的, 使用到的工具也不尽相同. 我们从Qemu开始.</p><h3 id="Qemu"><a href="#Qemu" class="headerlink" title="Qemu"></a>Qemu</h3><p>我们QEMU主要提供一下几个部分:</p><ul><li>处理器模拟器</li><li>仿真IO设备</li><li>关联模拟设备到真实设备</li><li>调试器</li><li>与模拟器交互的用户接口</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> KVM </tag>
            
            <tag> Virtualization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xen虚拟化初识</title>
      <link href="/2018/12/05/Xen%E8%99%9A%E6%8B%9F%E5%8C%96%E5%88%9D%E8%AF%86/"/>
      <url>/2018/12/05/Xen%E8%99%9A%E6%8B%9F%E5%8C%96%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>稍微复习了一下操作系统, 从今天真正开始接触虚拟化相关.</p><span id="more"></span><h2 id="虚拟化技术的分类"><a href="#虚拟化技术的分类" class="headerlink" title="虚拟化技术的分类"></a>虚拟化技术的分类</h2><p>当前虚拟化技术有这些:</p><ul><li>模拟: Emulation, 其中最著名的一个模拟器就是QEMU, PearPC和Bochs.<ul><li>模拟的最大特性就是上层运行的系统架构可以和下层或者说宿主的系统架构完全不同, 例如我们在x86平台上运行的ARM的安卓模拟器</li></ul></li><li>完全虚拟化, Full Virtualization, 或者说Native Virtualization<ul><li>这种虚拟化架构要求上层的Guest和Host同样的架构, 同样也正因为这种架构使得指令集的虚拟化更加简单(因为CPU的指令集架构完全相同)</li><li>通过HVM硬件辅助虚拟化来提升性能.</li><li>VMware研发的BT技术(二进制翻译)</li></ul></li><li>半虚拟化, Para-Virtualization, 最著名的解决方案是XEN, UML(User-Mode Linux)<ul><li>通过HyperVisor的来进行Hyper Call进行调用, 这要求虚拟化的Guest OS的内核适应, 明确知道自己是运行在虚拟化环境下.</li></ul></li><li>OS级别的虚拟化 ( 容器级别的虚拟化 )<ul><li>这一种虚拟化没有VMM, 只是将用户空间进行切割. 最著名的就是Docker啦, 还有OpenVZ, LXC(Linux Container)</li></ul></li><li>库级别的虚拟化, 例如Wine</li><li>应用程序级别的虚拟化, 例如JVM, PVM(Python)</li></ul><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/%E4%B8%80%E5%9E%8B%E8%99%9A%E6%8B%9F%E5%8C%96.png" alt="一型虚拟化"></p><p>将我们的HyperVisor直接安装在硬件上(就是说宿主机没有OS), 这种叫做1型虚拟化. </p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/%E4%BA%8C%E5%9E%8B%E8%99%9A%E6%8B%9F%E5%8C%96.png" alt="二型虚拟化"></p><p>将HyperVisor作为一个进程运行在操作系统上, 这是2型虚拟化.</p><p>这就很显然了. 1型虚拟化肯定是性能上更好的, 而2型的优点在于, 存在一个典型的操作系统, 比较灵活, 而且支持虚拟机的嵌套.</p><h2 id="Xen"><a href="#Xen" class="headerlink" title="Xen"></a>Xen</h2><p>接着我们来看看Xen这个东西, 这玩意是由剑桥大学开发的. 原本的设计目标是为了在单机上跑128个虚拟机.</p><p>Xen是个HyperVisor, 直接运行在硬件上. 我们原来说过, 为了能够操作虚拟机, 包括创建删除等等, 我们一定需要一个管理接口才可以. Xen的特殊之处在于, 他只虚拟化了计算机五大部件的其中两个, 也就是CPU和内存, 对于IO设备, Xen并没有做虚拟化. 我们知道, 操作系统为了能够使用到硬件, 一定是需要驱动程序的. 而这些驱动程序通常由硬件厂商进行开发. 而某些硬件只为了windows进行开发, 例如显卡. Linux的驱动就少之又少了, 所以说, 能针对X环境进行开发的又能有多少呢. 而CPU和内存这种组件由内核直接驱动(作为通信的必要).</p><p>所以, Xen所虚拟化出来的第一个虚拟机, 这个虚拟机是Xen的一个工作辅助, 首先能够为用户提供一个管理接口, 为了能够管理, 这个虚拟机就需要拥有特别的权限才行. 这个虚拟机的内核是一个需要能够驱动各种IO设备的内核, 而Xen就是通过这个虚拟机的内核来进行IO设备的通信的. 也就是说, 其他的虚拟机的IO调用, 通过访问第一个虚拟机来进行. 这些虚拟机的IO设备是通过第一个虚拟机的软件来<strong>模拟</strong>的, 而这个软件通常就是我们刚刚所提到的: <strong>QEMU</strong>. </p><p>Xen的说法是, 每一个虚拟机被称为<code>Domain0</code>, 而第一个虚拟机就被称为<code>Privileged Domain</code>, 也叫做<code>Dom0</code>. 其他被<code>Dom0</code>管理的虚拟机就被称作<code>DomainU</code>, 或者说<code>Unprivileged Domain</code>. 无论启动多少个<code>DomU</code>, 他们都被称为DomU, 只不过他们会拥有一个唯一的ID, 被叫做<code>DomainID</code>.</p><p>根据运行环境的不同, Xen可以有多种虚拟化方案. </p><p>最首先的就是直接跑一个半虚拟化的环境(PV), 向我们之前说的, 这种技术要求内核需要做适应. 在硬件存在虚拟化辅助的情况下, Xen也可以使用全虚拟化(HVM), 这需要借助Intel的VT或者AMD-V的硬件扩展. 另外, 为了提升性能, Xen还可以将一个全虚拟化的虚拟机使用一些特殊的半虚拟化设备驱动跑起来(PV on HVM), 这样就可以对一些只支持全虚拟化的操作系统进行优化, 在这种情况下, CPU是HVM模式运行, IO设备是PV模式运行.</p><h3 id="Xen的硬件虚拟化"><a href="#Xen的硬件虚拟化" class="headerlink" title="Xen的硬件虚拟化"></a>Xen的硬件虚拟化</h3><p>现在我们来说说对于Xen, 一些硬件的虚拟化方案. </p><p>首先对于CPU和内存就比较好说了. 对于每一个虚拟机上的CPU, 我们可以使用Xen HyperVisor的一个线程或者进程就好了, 假设我们开了10台拥有双核CPU的虚拟机, 映射下来, 其实就相当于是20个HyperVisor的线程.</p><p>而内存就是将物理内存上的分片(可能连续可能分散)划分到虚拟机上然后把它们当做是(对于虚拟机而言的)一段连续的内存空间(相当于是物理内存) ,至于如何再去使用那就是虚拟机自己的事情了.</p><p>ok, CPU和内存就比较好解决了, 现在我们来说说关于硬盘的虚拟化. 刚刚我们提到了对于IO设备, Xen的解决方法是使用第一个虚拟机来进行通信, 那么假设我们现在通过硬盘映像文件作为虚拟机的物理磁盘的话, 就需要在<code>DOM0</code>的用户空间借助QEMU虚拟出控制器芯片来欺骗虚拟机, 这里虚拟出来的控制器型号自然会是那种比较通用的. 那么接下来我们来进行一次梳理:</p><ol><li>虚拟机发送写请求, 进行系统调用</li><li>内核驱动程序向设备发送信号(这里的设备是DOM0的QEMU虚拟的), 进行转换</li><li>由于控制器的指令不一定一样, DOM0需要再次向内核发送系统调用进行转换</li><li>写物理设备</li></ol><p>可以看出来, 这里进行了两次的系统调用, 这样子的话就会显得比较繁琐并且降低性能. 为此, 一种解决方法是使用分段的处理方法, 通过前半段来简化第1, 2两步. 我们直接告诉虚拟机这个设备是虚拟的, 这样就可以省略掉硬件信号的转化和寻道等等过程. 这样就要求我们需要一个配套的前半段和后半段来进行通信.</p><p>除了这个问题, 当出现多个虚拟机同时发送大量的IO请求的时候, 所有的真实的物理读写都发生在我们真实的物理硬件上, 这样的压力是很大的. 为此, Xen解决这个问题的方案是, 通过设计一个缓冲环, 一个虚拟机的请求到了之后就在这个环上排着, 当环的空间没有了之后(也就是排满了), 下一次的请求就会被阻塞, 告诉请求者设备繁忙.</p><p> 硬盘如此, 网卡等类似设备也是差不多的做法.</p><h3 id="Xen的几种虚拟化技术"><a href="#Xen的几种虚拟化技术" class="headerlink" title="Xen的几种虚拟化技术"></a>Xen的几种虚拟化技术</h3><ul><li>Xen的半虚拟化(PV)技术</li></ul><p>我们说过, 半虚拟化要求Guest主机的内核必须知晓自己运行在虚拟化环境, 并且不要求CPU有虚拟化支持. Linux的2.6.24+的版本就可以运行在DomU中.</p><ul><li>HVM技术</li></ul><p>依赖于Intel的VT技术或者AMD的AMD-V, 还要依赖QEMU来模拟IO设备, 几乎所有支持此X86平台的OS都可在DomU中运行.</p><ul><li>PV on HVM技术</li></ul><p>就像我们刚刚说的, CPU在HVM的模式下运行, 而IO设备在PV环境中运行. 只要OS能够驱动PV接口类型的IO设备.</p><h3 id="Xen的管理工具栈"><a href="#Xen的管理工具栈" class="headerlink" title="Xen的管理工具栈"></a>Xen的管理工具栈</h3><p><img src="https://wiki.xen.org/images/thumb/c/c5/ToolStacks.png/799px-ToolStacks.png" alt="ToolStacks.png"></p><p>上面的这张图就是我们进行Xen操作的相关接口, 其中XAPI&#x2F;XE是Xen的子项目, 而XL是一个基于libxenlight的轻量级命令行管理工具, 这个工具现在是Xen默认自行携带的. 至于Libvirt是由红帽推出的一整套解决虚拟化API的工具, 通过在虚拟机上运行一个<code>libvirtd</code>进程来进行通信, 所以不仅可以管理Xen, 也可以是KVM等等, 通过virsh来进行交互.</p><h2 id="在虚拟机上安装并使用Xen"><a href="#在虚拟机上安装并使用Xen" class="headerlink" title="在虚拟机上安装并使用Xen"></a>在虚拟机上安装并使用Xen</h2><p>首先说明, 因为我手头没有物理机, 所以只能使用虚拟机来做实验, 值得一提的是, 在这种情况下, 我们在默认的虚拟机配置上只能使用半虚拟化技术, 而使用的Vmware平台可以通过将虚拟CPU的VT-x打开来实现在虚拟机上的HVM模式.</p><p>这个配置就是Vmware的这里: </p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vmware%E8%99%9A%E6%8B%9F%E5%8C%96CPU%E9%85%8D%E7%BD%AE.png" alt="vmware虚拟化CPU配置"></p><p>另外由于我们运行的这个是个DomU, 还需要运行Dom0, 所以建议将内存稍微分配的大一点.</p><p>这里使用的到的内核版本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-master ~]<span class="comment"># lsb_release -a</span></span><br><span class="line">LSB Version::core-4.1-amd64:core-4.1-noarch</span><br><span class="line">Distributor ID:CentOS</span><br><span class="line">Description:CentOS Linux release 7.4.1708 (Core) </span><br><span class="line">Release:7.4.1708</span><br><span class="line">Codename:Core</span><br></pre></td></tr></table></figure><p>安装Xen环境很简单, 只需要下载使用<code>centos-release-xen</code>这个包, 然后直接安装<code>xen</code>即可.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-xen</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install xen</span><br></pre></td></tr></table></figure><p>接着通过安装生成的脚本进行引导的设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/grub-bootxen.sh</span><br></pre></td></tr></table></figure><blockquote><p> 如果做到这一步之后你的grub菜单里没有出现xen的菜单入口 , 那么你可以还需要更新一下内核. 另外据说CentOS6存在一个Bug, 那就是grub菜单的initramfs没有写, 需要手动写一下.</p></blockquote><p>这些做完之后直接重启机器就可以看到Xen的启动菜单了,  登陆进去可以来验证一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-master ~]<span class="comment"># uname -r</span></span><br><span class="line">4.9.127-32.el7.x86_64</span><br><span class="line">[root@VM-master ~]<span class="comment"># xl list</span></span><br><span class="line">Name                                        ID   Mem VCPUsStateTime(s)</span><br><span class="line">Domain-0                                     0  1024     4     r-----     350.4</span><br></pre></td></tr></table></figure><p>Dom0已经存在了.</p><p>来看一下这个输出信息, 其中Name就是当前虚拟机的名称, ID就是这个虚拟机的唯一标识. 如果这个虚拟机被删除, 下一个创建的仍然会继续累加的, Mem和VCPUs就是这个虚拟机的内存和虚拟CPU的情况. Time就是当前运行的时长.</p><p>值得说的, 是这个状态信息, Xen的虚拟机有这些状态:</p><ul><li>r: running, 正在运行(占据内存)</li><li>b: blocked, 被阻塞</li><li>p: pause, 暂停. 注意这个暂停和我们Vmware的Suspend不是一回事. 暂停的虚拟机, 他的内存空间仍然还在占据, 而不像VMware的挂起, 那是将运行环境转移到了硬盘的.</li><li>s: stop, 停止</li><li>c: crashed, 崩溃</li><li>d: dying, 正在关闭的过程中</li></ul><p>这个<code>xl</code>有很多的子命令, 当我们列出来的时候有一个警告:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING: xl now has better capability to manage domain configuration, avoid using this <span class="built_in">command</span> when possible</span><br></pre></td></tr></table></figure><p>也就是说, 在管理域的时候, 尽量避开使用命令, 而是通过配置来处理.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xl full list of subcommands:</span><br><span class="line"></span><br><span class="line"> create              Create a domain from config file &lt;filename&gt;</span><br><span class="line"> config-update       Update a running domain&#x27;s saved configuration, used when rebuilding the domain after reboot.</span><br><span class="line">WARNING: xl now has better capability to manage domain configuration, avoid using this command when possible</span><br><span class="line"> list                List information about all/some domains</span><br><span class="line"> destroy             Terminate a domain immediately</span><br><span class="line"> shutdown            Issue a shutdown signal to a domain</span><br><span class="line"> reboot              Issue a reboot signal to a domain</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>其中这里的destroy就相当于是直接拔掉电源.</p><h3 id="创建一个新的虚拟机"><a href="#创建一个新的虚拟机" class="headerlink" title="创建一个新的虚拟机"></a>创建一个新的虚拟机</h3><p>创建新的虚拟机需要使用到一个配置文件, 这个配置文件的默认语法可以通过<code>man xl.cfg</code>来获取.</p><p>常规的一些配置如下:</p><ol><li>name 域的名字, 这个每一个都需要是独一无二的(must be unique)</li><li>type 指明虚拟机的类型, 过去的指令叫做builder(xm的)<ul><li>generic</li><li>hvm</li><li>pvh</li></ul></li><li>vcpus: 虚拟的CPU个数</li><li>maxcpus: 最大的虚拟CPU个数</li><li>cpus: 虚拟CPU可以运行在其上面的物理CPU列表</li><li>memory: 内存大小</li><li>maxmem: 可以使用的最大内存空间</li><li>on_*: 各种事件, 就像我们的触发器一样, 下面的除了on_reboot的处理是restart, 其他默认的处理都是destroy<ol><li>on_poweroff</li><li>on_reboot</li><li>on_watchdog</li><li>on_crash</li></ol></li><li>uuid: DomU的唯一标识</li><li>disk: 一个DISK_SPEC_STRING数组, 指明磁盘设备的列表</li><li>vif: 一个NET_SPEC_STRING数组, 指明网络接口的列表</li><li>vfb: 一个VFB_SPEC_STRING的数组, 指明半虚拟化的帧缓冲(framebuffer)设备列表, 这个设备其实就是我们常见的VGA视频输出设备.</li><li>pci: 一个PCI_SPEC_STRING数组, 指明IO透传设备</li></ol><p>接下来我们来说一下关于如何制定一个磁盘到DomU.</p><p>按照刚刚说的, 这是一个数组, 其中<code>DISK_SEPC_STRING</code>可以有多种格式, 其中过一种比较常见的是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;&lt;target&gt;,&lt;format&gt;,&lt;vdev&gt;,&lt;access&gt;&quot;, &quot;&quot;, &quot;&quot;, ...]</span><br></pre></td></tr></table></figure><p>其中<code>target</code>是指磁盘映像文件的路径或者是设备文件的路径, <code>format</code>标识磁盘格式, 如果是映像文件可能会有多种格式, 例如, 我们Vmware使用的是vmdk, VirtualBox使用的是vdi, 还有默认dd工具打包出来的raw格式.</p><blockquote><p>可以通过<code>qemu-img</code>来打包, 支持的格式有:</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Supported formats: vvfat vpc vmdk vhdx vdi ssh sheepdog rbd raw host_cdrom host_floppy host_device file qed qcow2 qcow parallels nbd iscsi gluster dmg tftp ftps ftp https http cloop bochs blkverify blkdebug</span><br></pre></td></tr></table></figure><p>vdev是在指定这个设备在DomU中被识别成的硬件类型, 支持<code>hd[x], xvd[x], sd[x]</code> 其中, xvd是xen virtual disk. 最后一个access指定访问的权限, 这个就很简单了: <code>ro, r: 只读; rw, w: 读写</code> 默认的权限设置除了cdrom都是读写.</p><p>举个例子, 一种合法的硬盘配置如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disk=[<span class="string">&quot;images/xen/linux.img,raw,xvda,rw&quot;</span>]</span><br></pre></td></tr></table></figure><p>接下来我们就来使用busybox和qemu-img来创建一个DomU试试!</p><p>先来创建一个磁盘映像文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-master ~]<span class="comment"># qemu-img create -f raw /images/xen/busybox.img 2G</span></span><br><span class="line">Formatting <span class="string">&#x27;/images/xen/busybox.img&#x27;</span>, <span class="built_in">fmt</span>=raw size=2147483648 </span><br><span class="line">[root@VM-master ~]<span class="comment"># ls /images/xen/</span></span><br><span class="line">busybox.img</span><br><span class="line">[root@VM-master ~]<span class="comment"># ls /images/xen/ -lh</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 2.0G Dec  9 23:01 busybox.img</span><br><span class="line">[root@VM-master ~]<span class="comment"># du -h /images/xen/busybox.img </span></span><br><span class="line">0/images/xen/busybox.img</span><br></pre></td></tr></table></figure><p>这是一个稀疏类型的磁盘映像文件. 最大的大小是2G, 只不过当前是空的, 我们直接进行格式化.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-master ~]<span class="comment"># mke2fs -t ext2 /images/xen/busybox.img </span></span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">/images/xen/busybox.img is not a block special device.</span><br><span class="line">Proceed anyway? (y,n) y</span><br><span class="line">Discarding device blocks: <span class="keyword">done</span>                            </span><br><span class="line">Filesystem label=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Fragment size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">131072 inodes, 524288 blocks</span><br><span class="line">26214 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=536870912</span><br><span class="line">16 block <span class="built_in">groups</span></span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">32768, 98304, 163840, 229376, 294912</span><br><span class="line"></span><br><span class="line">Allocating group tables: <span class="keyword">done</span>                            </span><br><span class="line">Writing inode tables: <span class="keyword">done</span>                            </span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span> </span><br><span class="line"></span><br><span class="line">[root@VM-master ~]<span class="comment"># du -sh /images/xen/busybox.img </span></span><br><span class="line">33M/images/xen/busybox.img</span><br></pre></td></tr></table></figure><p>接下来我们就通过busybox来快速的创建一个根文件系统:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-master busybox]<span class="comment"># ls _install/</span></span><br><span class="line">bin  linuxrc  sbin  usr</span><br><span class="line">[root@VM-master busybox]<span class="comment"># mount -o loop /images/xen/busybox.img  /mnt/</span></span><br><span class="line">[root@VM-master busybox]<span class="comment"># ls /mnt/</span></span><br><span class="line">lost+found</span><br><span class="line">[root@VM-master busybox]<span class="comment"># cp -a _install/* /mnt/</span></span><br><span class="line">[root@VM-master busybox]<span class="comment"># cd /mnt/</span></span><br><span class="line">[root@VM-master mnt]<span class="comment"># ls</span></span><br><span class="line">bin  linuxrc  lost+found  sbin  usr</span><br><span class="line">[root@VM-master mnt]<span class="comment"># mkdir proc sys dev etc var boot home</span></span><br><span class="line">[root@VM-master mnt]<span class="comment"># ll</span></span><br><span class="line">total 56</span><br><span class="line">drwxr-xr-x 2 root root  4096 Dec  9 23:16 bin</span><br><span class="line">drwxr-xr-x 2 root root  4096 Dec  9 23:19 boot</span><br><span class="line">drwxr-xr-x 2 root root  4096 Dec  9 23:19 dev</span><br><span class="line">drwxr-xr-x 2 root root  4096 Dec  9 23:19 etc</span><br><span class="line">drwxr-xr-x 2 root root  4096 Dec  9 23:19 home</span><br><span class="line">lrwxrwxrwx 1 root root    11 Dec  9 23:16 linuxrc -&gt; bin/busybox</span><br><span class="line">drwx------ 2 root root 16384 Dec  9 23:03 lost+found</span><br><span class="line">drwxr-xr-x 2 root root  4096 Dec  9 23:19 proc</span><br><span class="line">drwxr-xr-x 2 root root  4096 Dec  9 23:16 sbin</span><br><span class="line">drwxr-xr-x 2 root root  4096 Dec  9 23:19 sys</span><br><span class="line">drwxr-xr-x 4 root root  4096 Dec  9 23:16 usr</span><br><span class="line">drwxr-xr-x 2 root root  4096 Dec  9 23:19 var</span><br></pre></td></tr></table></figure><p>接下来我们就要进行内核和ramfs的创建, 我们可以直接使用本机的, 做个链接就行了.</p><p>最后生成的xl配置文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-master xen]# cat busybox </span><br><span class="line"># =====================================================================</span><br><span class="line"># Example PV Linux guest configuration</span><br><span class="line"># =====================================================================</span><br><span class="line">#</span><br><span class="line"># This is a fairly minimal example of what is required for a</span><br><span class="line"># Paravirtualised Linux guest. For a more complete guide see xl.cfg(5)</span><br><span class="line"></span><br><span class="line"># Guest name</span><br><span class="line">name = &quot;busybox&quot;</span><br><span class="line"></span><br><span class="line"># 128-bit UUID for the domain as a hexadecimal number.</span><br><span class="line"># Use &quot;uuidgen&quot; to generate one if required.</span><br><span class="line"># The default behavior is to generate a new UUID each time the guest is started.</span><br><span class="line">#uuid = &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&quot;</span><br><span class="line"></span><br><span class="line"># Kernel image to boot</span><br><span class="line">kernel = &quot;/boot/vmlinuz&quot;</span><br><span class="line"></span><br><span class="line"># Ramdisk (optional)</span><br><span class="line">ramdisk = &quot;/boot/initramfs&quot;</span><br><span class="line"></span><br><span class="line"># Kernel command line options</span><br><span class="line">extra = &quot;selinux=0 init=/bin/sh&quot;</span><br><span class="line"></span><br><span class="line"># Initial memory allocation (MB)</span><br><span class="line">memory = 256</span><br><span class="line"></span><br><span class="line"># Maximum memory (MB)</span><br><span class="line"># If this is greater than `memory&#x27; then the slack will start ballooned</span><br><span class="line"># (this assumes guest kernel support for ballooning)</span><br><span class="line">maxmem = 256</span><br><span class="line"></span><br><span class="line"># Number of VCPUS</span><br><span class="line">vcpus = 2</span><br><span class="line"></span><br><span class="line"># Network devices</span><br><span class="line"># A list of &#x27;vifspec&#x27; entries as described in</span><br><span class="line"># docs/misc/xl-network-configuration.markdown</span><br><span class="line">#vif = [ &#x27;&#x27; ]</span><br><span class="line"></span><br><span class="line"># Disk Devices</span><br><span class="line"># A list of `diskspec&#x27; entries as described in</span><br><span class="line"># docs/misc/xl-disk-configuration.txt</span><br><span class="line">disk = [ &#x27;/images/xen/busybox.img,raw,xvda,rw&#x27; ]</span><br><span class="line">root = &quot;/dev/xvda ro&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后就通过这个配置文件进行创建就行了, 命令像这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xl -v create /etc/xen/busybox</span><br></pre></td></tr></table></figure><p>在后面可以加上<code>-n</code>进行dry-run.</p><hr><p>隔了好久更新的分割线, 受不了在CentOS7上搞这个Xen了. 太麻烦了. </p><p>问题主要出在那个QEMU的前后端模拟上, 这个Hypervisor的模块服务总是加载失败. 这个<code>xen_scsi_processor</code>总是提示No such device. 这个东西就应该编译进内核! 官方的解决办法简直了, 不搞了.</p><p>我去CentOS6了.</p><hr><p>终于! 在CentOS6上终于跑起来了, 我们的虚拟机!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># xl list</span></span><br><span class="line">Name                                        ID   Mem VCPUsStateTime(s)</span><br><span class="line">Domain-0                                     0  1024     4     r-----    1359.9</span><br><span class="line">[root@localhost ~]<span class="comment"># xl create /etc/xen/busybox </span></span><br><span class="line">Parsing config from /etc/xen/busybox</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进入终端看一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># xl console busybox</span></span><br><span class="line">[    0.000000] Linux version 4.9.127-32.el6.x86_64 (mockbuild@c1bj.rdu2.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-23) (GCC) ) <span class="comment">#1 SMP Mon Sep 17 13:48:11 UTC 2018</span></span><br><span class="line">[    0.000000] Command line: root=/dev/xvda ro selinux=0 init=/bin/sh</span><br><span class="line">...(omitted)</span><br><span class="line">[    0.000000] Booting paravirtualized kernel on Xen</span><br><span class="line">[    0.000000] Xen version: 4.6.6-12.el6 (preserve-AD)</span><br><span class="line">...(omitted)</span><br><span class="line">[    2.781378] dracut: Mounted root filesystem /dev/xvda</span><br><span class="line">[    2.911023] dracut: Switching root</span><br><span class="line">/bin/sh: can<span class="string">&#x27;t access tty; job control turned off</span></span><br><span class="line"><span class="string">/ # ls</span></span><br><span class="line"><span class="string">bin         dev         home        lost+found  sbin        usr</span></span><br><span class="line"><span class="string">boot        etc         linuxrc     proc        sys         var</span></span><br><span class="line"><span class="string">/ # uname -a</span></span><br><span class="line"><span class="string">Linux (none) 4.9.127-32.el6.x86_64 #1 SMP Mon Sep 17 13:48:11 UTC 2018 x86_64 GNU/Linux</span></span><br><span class="line"><span class="string">/ # </span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>从虚拟机的终端切换到我们的主机只需要使用<code>Ctrl+]</code>就可以了.</p><h3 id="虚拟机网络"><a href="#虚拟机网络" class="headerlink" title="虚拟机网络"></a>虚拟机网络</h3><p>接下来我们为我们的虚拟机加上网络功能.</p><p>磁盘一样, 我们的网卡配置格式也和磁盘基本类似, 就是使用一些指定网卡参数配置的数组来创建虚拟网卡设备, 常见的网络属性有这些:</p><ul><li>mac, 指明MAC地址, Xen的前缀是(00:16:3e).</li><li>bridge&#x3D;&lt; bridge &gt;: 指定此网络接口在Dom0上被关联到哪个设备上.</li><li>model&#x3D;&lt; MODEL &gt;: 指定模拟的网卡模型, 可以是rt18139, 也可以是e1000啥的.</li><li>vifname: 接口名称, 仅仅在Dom0中.</li><li>script: 创建接口的接口.</li><li>ip: 指定IP地址, 会注入到DomU中</li><li>rate, 指明设备的传输速率. 通常为”#UNIT&#x2F;s” <ul><li>GB, MB, KB, B for bytes.</li><li>Gb, Mb, Kb, b for bits.</li></ul></li></ul><p>现在我们就先通过修改配置文件的方式来创建一个桥.</p><p>我们修改配置文件到这个样子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@xen_node ~]<span class="comment"># cd /etc/sysconfig/network-scripts/</span></span><br><span class="line">[root@xen_node network-scripts]<span class="comment"># cat ifcfg-xenbr0 </span></span><br><span class="line">DEVICE=<span class="string">&quot;xenbr0&quot;</span></span><br><span class="line">BOOTPROTO=<span class="string">&quot;static&quot;</span></span><br><span class="line">IPADDR=<span class="string">&quot;192.168.16.200&quot;</span></span><br><span class="line">NETMASK=<span class="string">&quot;255.255.255.0&quot;</span></span><br><span class="line">GATEWAY=<span class="string">&quot;192.168.16.254&quot;</span></span><br><span class="line">NM_CONTROLLED=<span class="string">&quot;no&quot;</span></span><br><span class="line">ONBOOT=<span class="string">&quot;yes&quot;</span></span><br><span class="line">TYPE=<span class="string">&quot;Bridge&quot;</span></span><br><span class="line">DNS1=223.5.5.5</span><br><span class="line">[root@xen_node network-scripts]<span class="comment"># cat ifcfg-eth0 </span></span><br><span class="line">DEVICE=<span class="string">&quot;eth0&quot;</span></span><br><span class="line">BOOTPROTO=<span class="string">&quot;static&quot;</span></span><br><span class="line">HWADDR=<span class="string">&quot;00:0C:29:BD:62:0E&quot;</span></span><br><span class="line">NM_CONTROLLED=<span class="string">&quot;no&quot;</span></span><br><span class="line">TYPE=<span class="string">&quot;Ethernet&quot;</span></span><br><span class="line">ONBOOT=<span class="string">&quot;yes&quot;</span></span><br><span class="line">BRIDGE=xenbr0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里有个问题, 一定要注意关闭NetworkManager, 接着重启网络服务, 这么一个网桥就搭建好了.</p><p>使用命令建桥的过程也差不多, 我们需要使用brctl命令.</p><p>简单的几个步骤就可以创建了,</p><ul><li>首先取掉当前网卡的地址</li><li>接着新建一个网桥</li><li>给新建的网桥绑定设备和网络信息(建议开启生成树)</li><li>大功告成!</li></ul><p>过程展示就像下面的那样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">[root@xen_node network-scripts]<span class="comment"># ifconfig eth0 0</span></span><br><span class="line">[root@xen_node network-scripts]<span class="comment"># ifconfig </span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:0C:29:BD:62:0E  </span><br><span class="line">          inet6 addr: fe80::20c:29ff:febd:620e/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:461 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:378 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:51417 (50.2 KiB)  TX bytes:48884 (47.7 KiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:16 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:16 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:992 (992.0 b)  TX bytes:992 (992.0 b)</span><br><span class="line"></span><br><span class="line">[root@xen_node network-scripts]<span class="comment"># brctl show</span></span><br><span class="line">bridge namebridge <span class="built_in">id</span>STP enabledinterfaces</span><br><span class="line">[root@xen_node network-scripts]<span class="comment"># brctl addbr xenbr0</span></span><br><span class="line">[root@xen_node network-scripts]<span class="comment"># brctl show</span></span><br><span class="line">bridge namebridge <span class="built_in">id</span>STP enabledinterfaces</span><br><span class="line">xenbr08000.000000000000no</span><br><span class="line">[root@xen_node network-scripts]<span class="comment"># brctl addif xenbr0 eth0</span></span><br><span class="line">[root@xen_node network-scripts]<span class="comment"># brctl show</span></span><br><span class="line">bridge namebridge <span class="built_in">id</span>STP enabledinterfaces</span><br><span class="line">xenbr08000.000c29bd620enoeth0</span><br><span class="line">[root@xen_node network-scripts]<span class="comment"># brctl stp xenbr0 on</span></span><br><span class="line">[root@xen_node network-scripts]<span class="comment"># ifconfig xenbr0 192.168.16.200/24 up</span></span><br><span class="line">[root@xen_node network-scripts]<span class="comment"># ifconfig </span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:0C:29:BD:62:0E  </span><br><span class="line">          inet6 addr: fe80::20c:29ff:febd:620e/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:478 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:379 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:52803 (51.5 KiB)  TX bytes:48944 (47.7 KiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:16 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:16 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:992 (992.0 b)  TX bytes:992 (992.0 b)</span><br><span class="line"></span><br><span class="line">xenbr0    Link encap:Ethernet  HWaddr 00:0C:29:BD:62:0E  </span><br><span class="line">          inet addr:192.168.16.200  Bcast:192.168.16.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::20c:29ff:febd:620e/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:21 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:0 (0.0 b)  TX bytes:3692 (3.6 KiB)</span><br><span class="line"></span><br><span class="line">[root@xen_node network-scripts]<span class="comment"># ping 192.168.16.254</span></span><br><span class="line">PING 192.168.16.254 (192.168.16.254) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.16.254: icmp_seq=1 ttl=128 time=1.94 ms</span><br><span class="line">64 bytes from 192.168.16.254: icmp_seq=2 ttl=128 time=0.280 ms</span><br><span class="line">64 bytes from 192.168.16.254: icmp_seq=3 ttl=128 time=0.280 ms</span><br><span class="line">64 bytes from 192.168.16.254: icmp_seq=4 ttl=128 time=0.218 ms</span><br><span class="line">^C</span><br><span class="line">--- 192.168.16.254 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3126ms</span><br><span class="line">rtt min/avg/max/mdev = 0.218/0.679/1.940/0.728 ms</span><br></pre></td></tr></table></figure><p>那么在我们的虚拟机中, 可能这个网卡就算我们填写了配置文件也没有作用的, 原因就是因为我们的busybox文件系统中没有响应的网卡驱动, 因此我们需要从本机中把响应的驱动模块丢进去, 然后在虚拟机中哥把这些模块insert才能有用.</p><p>当然新版本的有可能是自动装载模块的, 这就没问题了, 打开虚拟机直接就能看到网卡.</p><p>另外, 当我们的虚拟机启动了网络之后, 我们的Supervisor会多出来一个新的网络适配器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@xen_node network-scripts]<span class="comment"># ip link</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast master xenbr0 state UP qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:bd:62:0e brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: pan0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 7e:4d:a1:bf:e5:c3 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: xenbr0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:bd:62:0e brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: vif1.0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq master xenbr0 state UP qlen 32</span><br><span class="line">    <span class="built_in">link</span>/ether fe:ff:ff:ff:ff:ff brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><p>也就是那个<code>vif1.0</code>这是个啥, 我们之前说过, Xen使用的前后端IO设备. 这个就是那个后半段设备. 为啥有一个1.0的后缀, 因为我们当前的虚拟机ID是1:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@xen_node network-scripts]<span class="comment"># xl list</span></span><br><span class="line">Name                                        ID   Mem VCPUsStateTime(s)</span><br><span class="line">Domain-0                                     0  1022     4     r-----     297.8</span><br><span class="line">busybox                                      1   256     1     -b----       3.5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么我们的前后端是否可以进行通信呢, 来看一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@xen_node network-scripts]<span class="comment"># brctl show</span></span><br><span class="line">bridge namebridge <span class="built_in">id</span>STP enabledinterfaces</span><br><span class="line">pan08000.000000000000no</span><br><span class="line">xenbr08000.000c29bd620enoeth0</span><br><span class="line">vif1.0</span><br></pre></td></tr></table></figure><p>确实是桥接到我们的xenbr0上的, 接下来我们就来装载一个网络地址来试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ifconfig -a</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:16:3E:63:95:71  </span><br><span class="line">          BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">/ <span class="comment"># ifconfig eth0 192.168.16.201 up</span></span><br><span class="line">/ <span class="comment"># ifconfig </span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:16:3E:63:95:71  </span><br><span class="line">          inet addr:192.168.16.201  Bcast:192.168.16.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::216:3eff:fe63:9571/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:125 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:5 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:12713 (12.4 KiB)  TX bytes:418 (418.0 B)</span><br><span class="line"></span><br><span class="line">/ <span class="comment"># ping 192.168.16.254</span></span><br><span class="line">PING 192.168.16.254 (192.168.16.254): 56 data bytes</span><br><span class="line">64 bytes from 192.168.16.254: <span class="built_in">seq</span>=0 ttl=128 time=1.937 ms</span><br><span class="line">64 bytes from 192.168.16.254: <span class="built_in">seq</span>=1 ttl=128 time=0.470 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通了!</p><h3 id="让虚拟机拥有自己的内核"><a href="#让虚拟机拥有自己的内核" class="headerlink" title="让虚拟机拥有自己的内核"></a>让虚拟机拥有自己的内核</h3><p>我们之前的虚拟机创建, 是通过使用本机(也就是Hypervisor)的vmlinuz和initramfs, 并且使用的根文件目录是通过busybox实现的. </p><p>现在我们让虚拟机能够自行引导自己的内核, 由于一个完整的系统容量还是有点大, 这边还是使用busybox来进行根文件系统的模拟, 但是这一次我们要使用<code>pygrub</code>来进行引导, 并且让虚拟机使用自己的内核.</p><p>首先我们要先来说个loop设备的管理工具, <code>losetup</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@xen_node ~]<span class="comment"># losetup --help</span></span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"> losetup loop_device                             give info</span><br><span class="line"> losetup -a | --all                              list all used</span><br><span class="line"> losetup -d | --detach &lt;loopdev&gt; [&lt;loopdev&gt; ...] delete</span><br><span class="line"> losetup -f | --find                             find unused</span><br><span class="line"> losetup -c | --set-capacity &lt;loopdev&gt;           resize</span><br><span class="line"> losetup -j | --associated &lt;file&gt; [-o &lt;num&gt;]     list all associated with &lt;file&gt;</span><br><span class="line"> losetup [ options ] &#123;-f|--find|loopdev&#125; &lt;file&gt;  setup</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -e | --encryption &lt;<span class="built_in">type</span>&gt; <span class="built_in">enable</span> data encryption with specified &lt;name/num&gt;</span><br><span class="line"> -h | --<span class="built_in">help</span>              this <span class="built_in">help</span></span><br><span class="line"> -o | --offset &lt;num&gt;      start at offset &lt;num&gt; into file</span><br><span class="line">      --sizelimit &lt;num&gt;   loop limited to only &lt;num&gt; bytes of the file</span><br><span class="line"> -p | --pass-fd &lt;num&gt;     <span class="built_in">read</span> passphrase from file descriptor &lt;num&gt;</span><br><span class="line"> -r | --read-only         setup read-only loop device</span><br><span class="line">      --show              <span class="built_in">print</span> device name (with -f &lt;file&gt;)</span><br><span class="line"> -v | --verbose           verbose mode</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们要通过这个来进行qemu创建出的磁盘映像进行分区和文件系统的创建.</p><p>首先还是先创建映像:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xen_node ~]<span class="comment"># qemu-img create -f raw /images/xen/busybox2.img 2G</span></span><br><span class="line">Formatting <span class="string">&#x27;/images/xen/busybox2.img&#x27;</span>, <span class="built_in">fmt</span>=raw size=2147483648 </span><br></pre></td></tr></table></figure><p>接着和我们的loop建立关联:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xen_node ~]<span class="comment"># losetup -a</span></span><br><span class="line">[root@xen_node ~]<span class="comment"># losetup /dev/loop0 /images/xen/busybox2.img </span></span><br><span class="line">[root@xen_node ~]<span class="comment"># losetup -a</span></span><br><span class="line">/dev/loop0: [0802]:782261 (/images/xen/busybox2.img)</span><br></pre></td></tr></table></figure><p>接着我们就可以对<code>loop0</code>进行分区操作了, 分区操作很简单, 就略过了, 分区结束之后写入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xen_node mapper]<span class="comment"># kpartx -av /dev/loop0</span></span><br><span class="line">add map loop0p1 (253:0): 0 112392 linear /dev/loop0 63</span><br><span class="line">add map loop0p2 (253:1): 0 2120580 linear /dev/loop0 112455</span><br></pre></td></tr></table></figure><p>接下来我们对两个分区进行格式化:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xen_node ~]<span class="comment"># ls /dev/mapper/</span></span><br><span class="line">control  loop0p1  loop0p2</span><br><span class="line">(格式化略...)</span><br></pre></td></tr></table></figure><p>OK, 离胜利很近了, 接下来我们写入必要的文件, 我们就使用CentOS6自带的<code>2.6.32</code>版本的内核:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@xen_node ~]<span class="comment"># cp /boot/vmlinuz-2.6.32-754.9.1.el6.x86_64 /mnt/boot/vmlinuz</span></span><br><span class="line">[root@xen_node ~]<span class="comment"># cp /boot/initramfs-2.6.32-754.9.1.el6.x86_64.img /mnt/boot/initramfs.img</span></span><br><span class="line">[root@xen_node ~]<span class="comment"># grub-install --root-directory=/mnt/ /dev/loop0 </span></span><br><span class="line">Probing devices to guess BIOS drives. This may take a long time.</span><br><span class="line">/dev/loop0 does not have any corresponding BIOS drive.</span><br><span class="line">[root@xen_node ~]<span class="comment"># ls /mnt/boot/</span></span><br><span class="line">grub  initramfs.img  lost+found  vmlinuz</span><br></pre></td></tr></table></figure><p>接下来创建我们的<code>grub.conf</code>文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@xen_node ~]# cat /mnt/boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout=5</span><br><span class="line">title BusyBox(Kernel-2.6.32)</span><br><span class="line">root (hd0,0)</span><br><span class="line">kernel /vmlinuz root=/dev/xvda1 selinux=0 init=/bin/sh console=tty</span><br><span class="line">initrd /initramfs.img</span><br></pre></td></tr></table></figure><p>接着还是我们的busybox来构建文件系统, 完成了之后我们就可以开始写虚拟机的配置文件了.</p><blockquote><p>对了, 这个时候别忘记了拆除loop和img映像文件的关联, 另外, 拆除之前, 要先umount</p></blockquote><p>这里我们需要一个叫做<code>pygrub</code>的引导程序, 它会随着我们的xen环境一同被安装</p><p>新版本的配置文件可以把kernel, initramfs, extra_cmd, root等等参数都注释掉了, 只需要额外再写一个<code>bootloader</code>指向我们的<code>pygrub</code>就行了.</p><p>启动虚拟机, 直接附加console, 我们就能看到这个grub的引导页面了.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/pygrub_1.png" alt="pygrub_1"></p><p>但是, 这里似乎存在问题, 那就是console会报错, 看样子是应该配置一下虚拟显卡等等. 暂时还没有研究, 就先跳过了.</p><h2 id="使用libvirt来管理Xen虚拟机"><a href="#使用libvirt来管理Xen虚拟机" class="headerlink" title="使用libvirt来管理Xen虚拟机"></a>使用libvirt来管理Xen虚拟机</h2><p>除了使用xl, 我们还可以使用libvirt这个工具栈, 为了使用libvirt. 我们需要在虚拟机中运行libvirtd进程就可以进行远程的管理了. </p><p>通过安装<code>libvirt</code>这个包, 并且和xen搭配的daemon也可以安装上.</p><p>安装完成后会生成一个叫做<code>virsh</code>的客户端程序, 我们就是通过使用这个来进行操作的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@xen_node ~]<span class="comment"># virsh list</span></span><br><span class="line"> Id    Name                           State</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> 0     Domain-0                       running</span><br><span class="line"></span><br><span class="line">[root@xen_node ~]<span class="comment"># virsh nodeinfo</span></span><br><span class="line">CPU model:           x86_64</span><br><span class="line">CPU(s):              4</span><br><span class="line">CPU frequency:       2400 MHz</span><br><span class="line">CPU socket(s):       1</span><br><span class="line">Core(s) per socket:  2</span><br><span class="line">Thread(s) per core:  1</span><br><span class="line">NUMA cell(s):        1</span><br><span class="line">Memory size:         2096632 KiB</span><br></pre></td></tr></table></figure><p>如果你运行这个命令出现了错误:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xen_node ~]<span class="comment"># virsh list</span></span><br><span class="line">error: failed to connect to the hypervisor</span><br><span class="line">error: Failed to connect socket to <span class="string">&#x27;/var/run/libvirt/libvirt-sock&#x27;</span>: No such file or directory</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那是因为没有启动服务, 启动一下服务就可以了, 这和MySQL类似, 也是一个使用socket来通信的程序.</p><p>更多的关于<code>virsh</code>这个工具, 我们之后还会用到, 就先这样子了. ( 而且Xen似乎并不是很好用哈哈</p>]]></content>
      
      
      
        <tags>
            
            <tag> Virtualization </tag>
            
            <tag> Xen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL用户权限查询缓存与索引</title>
      <link href="/2018/10/17/MySQL%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%92%8C%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/"/>
      <url>/2018/10/17/MySQL%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%92%8C%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>接下来就来看一下MySQL对于用户权限的管理相关.</p><span id="more"></span><h2 id="MySQL中的用户和权限"><a href="#MySQL中的用户和权限" class="headerlink" title="MySQL中的用户和权限"></a>MySQL中的用户和权限</h2><p>首先来说说MySQL中的对于通常所说的权限可以分成用户和用户权限两个概念. 对于MySQL来说, 就算由一个用户可以登录进入, 他也有可能无法进行任何操作. 对于这样的权限我们可以划分成:</p><ul><li>库级别</li><li>表级别</li><li>字段级别</li></ul><p>这样, 通过操作这些级别的权限就可以指定用户是否有权限进行数据库的某些操作.</p><p>除了这些, 还有两种:</p><ul><li>管理类</li><li>程序类</li></ul><p>其中, 管理类的权限就是指的能否存在第三方用户去进行数据库的管理和一些维护操作. 而程序类权限就是说用户能否运行某些存储过程或者存储函数.</p><p>我们先从管理类权限说起吧.</p><h3 id="管理类权限"><a href="#管理类权限" class="headerlink" title="管理类权限"></a>管理类权限</h3><p>一个典型的管理权限就是进行临时表的创建, 一般临时表是不会具有持久性的, 但是他的查询效率要比普通的表高处一个数量级的, 所以一般我们可以使用临时表来存储一些临时的数据. 一个临时表, 一般需要16M大小的内存空间.</p><p>另外还有例如: 创建用户(CREATE USER), 进行文件导入导出(FILE), SUPER权限分配, 显示数据库, RELOAD, SHUTDOWN, REPLICATION SLAVE&#x2F;CLIENT做复制等等, 这些我们在后面也会再次提到的.  </p><h3 id="程序类权限"><a href="#程序类权限" class="headerlink" title="程序类权限"></a>程序类权限</h3><p>所谓程序就是指的一些存储过程代码段和一些函数, 当然还有一些触发器的代码.</p><p>当我们安装好MySQL之后, 会看到有一个元数据数据库, 现在我们可以看一下这个表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [mysql]<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_mysql           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> columns_priv              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> db                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> event                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> func                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> general_log               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> help_category             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> help_keyword              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> help_relation             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> help_topic                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> host                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ndb_binlog_index          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> plugin                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> proc                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> procs_priv                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> proxies_priv              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> servers                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_log                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tables_priv               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> time_zone                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> time_zone_leap_second     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> time_zone_name            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> time_zone_transition      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> time_zone_transition_type <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">user</span>                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="number">24</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>可以看到这里面有很多使用<code>priv</code>结尾的表, 这些表就是描述权限的, 除了一个特例, 就是<code>db</code>表, 这个是描述库级别的权限的.  包括一些用户的连接访问权限也会有描述.</p><p>首先我们划分授权表: 包括db, host, user. 这三者描述哪些用户可以通过哪些主机进行连接访问哪些数据库. 其实要是打开看一下的话就会知道了, db和host这两个表几乎是一样的, db比host多了2个字段, 也即是User和Event_priv这两个.</p><p>接下来我们说说如果管理员忘记了密码的解决方法:</p><p>一种可行的方法就是在启动mysqld进程的时候, 加上<code>--skip-grant-table</code>的选项. (建议在这个时候同时加上<code>--skip-networking</code>防止远程用户登录进入). 然后使用UPDATE直接修改密码, 接着关闭进程, 移除选项重新启动.</p><p>顺便我们来说说GRANT, 大家都知道这个命令可以进行用户权限的设定, 其实还可以通过他提供的选项进行一些更细致的设定, 例如:</p><p>现在我们创建一个用户test, 允许这个用户通过<code>172.16.9.*</code>的主机连接mysqld, 但是每秒钟的最大查询次数不得超过5次, 同时该账户的同时连接次数不得超过3次.</p><p>创建的语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [mysql]<span class="operator">&gt;</span> <span class="keyword">grant</span> usage <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;172.16.9.%&#x27;</span> <span class="keyword">with</span>  MAX_QUERIES_PER_HOUR <span class="number">18000</span> MAX_USER_CONNECTIONS <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>之前我们曾经简单的描述了一下关于MySQL的查询缓存. 除了有查询引擎自行实现的表级别或者是其他什么的缓存, MySQL的服务端也自行实现了一个查询缓存. 这个查询缓存的是SELECT语句所执行之后得到的结果集数据. 这么设计的一个问题就是如果查询的目标表数据发生变化的话, 这个查询缓存就会立即失效, 也就是说有可能出现刚刚缓存结束还没有被命中就已经失效了. 所以这样就反而影响了整体的查询效率.</p><p>另外, 这个SELECT缓存的数据集, MySQL如何判断缓存命中了呢? 第一是通过查询语句的哈希值, 其中哈希值考虑到的因素包括: 查询本身, 要查询的数据库, 客户端使用的协议版本等等, 都会纳入哈希生成的条件.</p><p>这也就是说, 查询语句在任何字符上的不同, 都会导致缓存不能命中. (所以说要规范SQL的写法, 或者是养成自己习惯). 另外, 就像我们之前说的, 如果查询中包含自己的自定义的函数, 存储过, 可临时表或者包含列权限的表, 是不会被缓存的. 如果查询中包含随机值, 例如时间(now()), 查询的结果也不会被缓存, 因为这样缓存了也没有作用.</p><p>另外, 查询缓存是根据使用情况进行动态的改变的, 这也就必然引入了关于内存碎片的问题, 既然会产生碎片就需要进行整理, 这也就带来了额外的开销. 当然了, 只要缓存带来的性能提升大于额外的开销就是可以接受的.</p><p>那么到底我们查询缓存的收益是大于这个额外的开销的呢? 还记得我们之前查看的关于缓存的相关变量参数嘛:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(<span class="keyword">none</span>)]<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%query%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                <span class="operator">|</span> <span class="keyword">Value</span>              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> expensive_subquery_limit     <span class="operator">|</span> <span class="number">100</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ft_query_expansion_limit     <span class="operator">|</span> <span class="number">20</span>                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> have_query_cache             <span class="operator">|</span> YES                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> long_query_time              <span class="operator">|</span> <span class="number">10.000000</span>          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_alloc_block_size       <span class="operator">|</span> <span class="number">8192</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_cache_limit            <span class="operator">|</span> <span class="number">1048576</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_cache_min_res_unit     <span class="operator">|</span> <span class="number">4096</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_cache_size             <span class="operator">|</span> <span class="number">0</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_cache_strip_comments   <span class="operator">|</span> OFF                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_cache_type             <span class="operator">|</span> <span class="keyword">ON</span>                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_cache_wlock_invalidate <span class="operator">|</span> OFF                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_prealloc_size          <span class="operator">|</span> <span class="number">8192</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_query_log               <span class="operator">|</span> OFF                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_query_log_file          <span class="operator">|</span> VM<span class="operator">-</span>master<span class="operator">-</span>slow.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+--------------------+</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中有一个<code>query_cache_min_res_unit</code>, 这个表示的是缓存的最小资源单元, 如果结果小于4K, 是不予缓存的. 如果这个值调整的过小, 能够减少浪费, 但是必然会导致更频繁的内存分配操作, 如果调整的较大, 会导致浪费(碎片变得更多). </p><p>而<code>query_cache_limit</code>表示的是MySQL所缓存的最大查询结果. </p><p>除了这些全局变量, 还有一些状态变量可以用来评估当前的缓存状态, 也就是我们之前所看到的:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(<span class="keyword">none</span>)]<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Qcache%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Qcache_free_blocks      <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_free_memory      <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_hits             <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_inserts          <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_lowmem_prunes    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_not_cached       <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_queries_in_cache <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Qcache_total_blocks     <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>另外还有一个统计当前的查询总数的: <code>Com_select</code>. 因此我们可以计算当前的缓存命中率: <code>Qcache_hits / (Qcache_hits+Com_select)</code>.</p><h2 id="索引和explain"><a href="#索引和explain" class="headerlink" title="索引和explain"></a>索引和explain</h2><p>之前虽然简单的说了一下MySQL中的索引, 但是在这里我们再来详细的说一说.</p><p>我们说索引建立的最基本的法则就是需要在经常被使用到的字段上, 或者说是被用作查询条件的字段上. 在MySQL中, 一般的索引类型都是B树类型的. 但是即使都是B树索引, 不同的存储引擎实现上都是不一样的. 有些可能会进行索引的压缩.</p><p>鉴于B树数据结构的特性, 并且由于采用了左前缀索引的方案, 使得MySQL特别适合:</p><ul><li>进行全值匹配, 精确查找</li><li>匹配最左前缀, 只精确匹配开头部分</li><li>匹配范围数据, 精确匹配某一列并范围匹配另一列</li><li>只访问索引的查询</li></ul><p>既然有适合的, 就有不适合使用B-Tree索引的场合, 例如:</p><ul><li>如果不从最左列开始, 索引就是无效的</li><li>不能跳过索引中的列, 如果我们的索引是一个组合的, 多键索引.</li><li>如果查询中的某个列(左侧的列)是范围查询, 右侧的列都无法使用索引优化, 只能将左侧的结果进行扫描筛选.</li></ul><p>MySQL除了B树索引, 还有另外一个, 即哈希索引. 其实这个就比较简单了, 这个索引将所有的字段进行哈希计算, 并且再分成一级哈希头, 二级哈希头等等. 但是我们知道哈希的特性, 如果元数据发生改变. 他的哈希值也会发生巨大的改变, 不仅如此, 哈希索引不适合进行顺序查询, 因为无法进行数据的排序, 而且模糊匹配也不容易做. 那么哈希索引最适合的查询是哪一种? 当然就是进行列的精确匹配了. <strong>注: 在MySQL中, 只有Memory存储引擎支持显示Hash索引.</strong></p><p>另外, 除了B树和哈希索引, 第三种索引就是空间索引, 只有MyISAM存储引擎支持这种索引. 最后一种要说的就是全文索引(FULLTEXT), 在文本中查找关键字. </p><p>全文索引更多的应该通过搜索引擎实现, 需要分析全部文本进行权重排序, 这种涉及到很多复杂的算法和排序构建以及运算量, 这里就不说了.</p><p>那么! 我到底为啥要使用索引呢? </p><p>首先, 索引可以降低服务需要扫描的数据量, 减少了IO次数. 其次, 索引可以帮助服务器避免排序和使用临时表. 另外还有一点, 所以可以帮助将随机IO改为顺序IO, 当然这里所说的是传统的机械硬盘. 随机和顺序IO对固态来说没啥大的影响.</p><p>那么说了这么多, 我们如何才能高性能的使用索引呢? </p><ul><li>独立使用列, 尽量避免其参与到运算中, 一旦使用了运算就会忽略索引</li><li>左前缀索引, 索引构建在左侧的N个字符. 这个字符数量的选择是需要评估的<ul><li><code>RELATED</code>索引选择性: 不重复的索引值和数据表的记录总数的比值</li></ul></li><li>多列索引, 有些时候单独的三个索引可能会比一个三列的组合索引更好, 根据具体的查询业务做定夺</li><li>选择合适的索引列次序, 将选择性最高的放在左侧</li></ul><p>在使用索引的过程中是可能出现冗余和重复的, 例如下面的这样子:</p><p>建立两个索引, 分别是(Name)和(Name, Age)此时的(Name)单键索引就是一个冗余的重复索引, 因为我们完全可以使用后面的组合索引, 因为是最左侧匹配. 另外, 例如这样子的两个索引: (Age)和(Age, Name).在需要进行年龄的范围查询的时候就不是重复的了. 因为后面的组合索引是用不到的. </p><p>那么怎么知道索引到底有没有使用到呢?对了, 就使用之前的EXPALIN来分析就行了.</p><p>我们只要把SELECT执行语句放到EXPLAIN的后面, 就可以获取到查询执行计划信息了. 这是什么东西? 其实就是MySQL查询优化器如何执行查询的, 不过, 说到底这也是一个查询计划, 实际上的查询过程可能也是和这个结果又出入的.</p><p>我们之前曾经使用过这个explain, 显示的信息有这些:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> explain <span class="keyword">select</span> course <span class="keyword">from</span> courses <span class="keyword">where</span> CourseID<span class="operator">=</span><span class="number">2</span>\G</span><br><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> explain <span class="keyword">select</span> course <span class="keyword">from</span> courses <span class="keyword">where</span> CourseID<span class="operator">=</span><span class="number">2</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: courses</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: <span class="keyword">PRIMARY</span></span><br><span class="line">          key: <span class="keyword">PRIMARY</span></span><br><span class="line">      key_len: <span class="number">2</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">        Extra: </span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中, id表示当前的查询语句中, select语句的编号. 复杂类型的查询有三种, 包括简单子查询, 用于FROM的子查询, 联合查询: UNION. 其中只要使用到了UNION, 就一定会引入一张额外的匿名临时表.</p><p>而第二列, select_type就表示的是查询的类型, 如果是简单的查询, 就是SIMPLE. 而对应上面说的几种复杂查询的, 分别有:</p><ul><li>SUBQUERY: 表示不用FROM的简单子查询</li><li>DERIVED: 表示用于FROM的子查询</li><li>UNION: 表示UNION语句的第一个之后的SELECT语句</li><li>UNION_RESULT: 表示UNION之后的匿名临时表</li></ul><p>来试试:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> explain <span class="keyword">select</span> Name <span class="keyword">from</span> students <span class="keyword">union</span> <span class="keyword">select</span> Name <span class="keyword">from</span> teachers\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: <span class="keyword">PRIMARY</span></span><br><span class="line">        <span class="keyword">table</span>: students</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: <span class="keyword">NULL</span></span><br><span class="line">          key: name_index</span><br><span class="line">      key_len: <span class="number">152</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">25</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> index</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">2</span></span><br><span class="line">  select_type: <span class="keyword">UNION</span></span><br><span class="line">        <span class="keyword">table</span>: teachers</span><br><span class="line">         type: <span class="keyword">ALL</span></span><br><span class="line">possible_keys: <span class="keyword">NULL</span></span><br><span class="line">          key: <span class="keyword">NULL</span></span><br><span class="line">      key_len: <span class="keyword">NULL</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">4</span></span><br><span class="line">        Extra: </span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">3.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="keyword">NULL</span></span><br><span class="line">  select_type: <span class="keyword">UNION</span> <span class="keyword">RESULT</span></span><br><span class="line">        <span class="keyword">table</span>: <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span></span><br><span class="line">         type: <span class="keyword">ALL</span></span><br><span class="line">possible_keys: <span class="keyword">NULL</span></span><br><span class="line">          key: <span class="keyword">NULL</span></span><br><span class="line">      key_len: <span class="keyword">NULL</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="keyword">NULL</span></span><br><span class="line">        Extra: </span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就是使用到了UNION的情况.</p><p>接着table很简单了, 就是查询关联到的表的名字. <code>type</code>表示的是关联的类型, 说通俗一点就是MySQL是如何查询表中的行的方式, 有这些:</p><ul><li>ALL: 表示的是全表扫描</li><li>index: 根据索引的次序进行全表扫描, 如果在Extra中列出了<code>Using index</code>表示使用了覆盖索引.</li><li>range: 范围扫描, 从索引中的某一个点到另一个点</li><li>ref: 也是索引访问, 但是他是根据索引返回表中匹配的某个单值的所有行</li><li>eq_ref</li><li>const, system</li></ul><p>后面的结果也都很简单, possible_keys表示查询的时候可能使用到的索引 key就是查询中使用了的索引 而key_len表示在索引中使用的字节数, row表示为了找到目标所扫描的行数, 最后的extra就是一些额外的信息.</p><p>额外的信息直接读就能明白, 有:</p><ul><li>Using index: 将会使用索引, 避免访问表</li><li>Using where: 在存储引擎层次进行检索, 在进行一次过滤</li><li>Using temporary: 将会使用临时表</li><li>Using filesort: 对结果进行一个外部的索引排序</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库</title>
      <link href="/2018/10/07/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2018/10/07/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>再来学习一遍数据库, 这一次稍微学习深入一点.</p><span id="more"></span><h2 id="数据库系统的简单回顾"><a href="#数据库系统的简单回顾" class="headerlink" title="数据库系统的简单回顾"></a>数据库系统的简单回顾</h2><p>我们这一次主要关注的还是关系型数据库, 也就是RDBMS.  对于数据库应用程序一般都是C&#x2F;S架构的, 而他们使用的数据交换协议一般都是专有协议. 说道关系型数据库, 就一定要说到关系模型了, 也就是二维关系的表(行,列). </p><p>当然数据库中也不仅仅只有表, 还包括例如叫做的索引的组件, 索引其实就是把表中特定字段的结果抽取出来, 根据某种组织形式来把他们组织起来. 常用的比如平衡树等等.</p><p>除了索引, 还有视图这个概念, 视图其实就是虚拟的表, 其实就是一个存储下来的查询语句, 当下次遇到查询的时候可以直接使用视图进行子查询.</p><p>当然一个更重要的概念自然就是SQL本身了, SQL的全称是结构查询语言, 主要分成DDL, DML. SQL的开发商也提供了SQL的编程接口和一些内置的函数, 用户也可以自定义一些存储过程, 包括一些触发器的编写.</p><p>从数据的角度来看, 我们有一个三层模型:</p><ul><li>物理层: 磁盘</li><li>逻辑层: 数据库内建组件</li><li>视图层: 看到的表(用户所看到的, 可能不同, 可能不全)</li></ul><h2 id="MySQL和MariaDB"><a href="#MySQL和MariaDB" class="headerlink" title="MySQL和MariaDB"></a>MySQL和MariaDB</h2><p>我们之前介绍过MariaDB, 他跟MySQL的发布路线不太一样, 但是每当MySQL发布新功能之后, MariaDB都会根据社区力量, 引入社区的代码来提供新功能. 尽管他们的一部分功能实现不一样, 基本功能上他们是兼容的. 在调用接口上也是兼容的.</p><p>MySQL采取的一种十分巧妙的方式, 即插件式存储引擎. 有些存储引擎是商用的, 即使用需要付费, 有些是开源的. 另外, MySQL是多线程单进程的模式, 其中一类线程是连接线程, 另外一类是守护线程. 这种模型使得MySQL对于多核心和大内存不是很能利用起来.</p><p>MySQL的配置文件是属于集中式的配置模式, 一个配置文件可以为mysql的各个应用提供配置信息.</p><p>关于一些安装MySQL之后的一些惯常动作, 我们再来说一次:</p><ol><li>为所有的root用户设定密码, 当然也可以删除不需要的root用户, 需要注意的是别忘记flush权限表.</li><li>删除所有的匿名用户, 可以直接使用DROP命令搞定.</li><li>建议关闭主机名反解功能, 修改配置文件增加<code>skip_name_resolve</code></li></ol><p>在我们安装MySQL之后, 会在默认的数据库中看到一个加做<code>mysql</code>的数据库, 这个就是元数据数据库, 包含一些程序运行所需要的数据.</p><p>我们MySQL无论是服务端程序还是客户端在启动的时候都会携带大量的变量, 这些变量有的可以在运行的时候进行修改, 并且立即生效, 有的参数不支持, 只能通过修改配置文件的形式并且重启服务端程序来进行生效. 并且MySQL也引入了作用域的概念, 有的参数是全局的不可改变, 有的则是为每一个用户提供单独的设置, 这些变量叫做会话变量. </p><p>设置变量的值的方法很简单, 直接在命令行中<code>SET</code>就行了, 这样默认修改的变量是会话变量, 一旦用户会话中断再次进行访问的时候, 这些变量就又变成配置文件所约束的值了. 如果想要修改全局变量, 则需要在<code>SET</code>后面加上<code>GLOBAL</code>.</p><p>另外还有一种叫做状态变量的数据, 这一种变量通常都是记录的MySQL的运行信息, 一般也不可以进行修改.</p><h3 id="MySQL的数据类型和SQL接口"><a href="#MySQL的数据类型和SQL接口" class="headerlink" title="MySQL的数据类型和SQL接口"></a>MySQL的数据类型和SQL接口</h3><p>我们现在使用的SQL语法都是在ANSI SQL中进行的标准定义, 就好像我们的C语言规范也是ANSI C一样.除了约束SQL的语法之外, ANSI SQL-03也同时规范了一些数据类型, 例如:</p><ul><li>字符类型</li><li>数值型</li><li>日期时间型</li><li>内建类型</li></ul><p>你可能会说为啥没有布尔型, 因为布尔其实说到底就还是特殊的数值类型, 而二进制类型其实就也是特殊的长字符串类型.(BLOB其实就是Binary Large OBject)</p><p>其中每一种大类型又分成好多根据长度划分的不同大小的数据类型. 例如我们熟悉的定长数据类型和不定长数据类型. 而数值类型又可以分成精准数值和近似数值类型. 日期时间型又可以分成日期类型,时间类型,日期时间类型,时间戳等等.</p><p>在MySQL中有两种内建的类型, 分别是ENUM和SET, 其实就是单选和多选的选项数据格式, 可以使用字符串也可以使用索引来写入值. 有关上述的数据类型的修饰符就不在这里说了.</p><p>对于MySQL, 有一个SQL模式的概念. 通过定义MySQL的SQL模式, 可以定义mysqld对约束的响应行为. 修改方式其实很简单, 可以直接修改全局变量然后对于下一次的新session产生效果, 对于已经产生的会话不会产生影响. 如果对当前的会话生效可以直接修改会话变量.这个在上面就说过了.</p><p>那么问题来了, 到底什么是SQL mode呢?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(<span class="keyword">none</span>)]<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;sql_mode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> sql_mode      <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认的值是空的, 如果想要修改, 常用的三种模式是:</p><ul><li>TRADITIONAL</li><li>STRICT_TRANS_TABLES</li><li>STRICT_ALL_TABLES</li></ul><p>其实支持的多达数十个之多.</p><p>例如我们来做个试验:</p><p>首先我们创建一个数据表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(<span class="keyword">none</span>)]<span class="operator">&gt;</span> use test;</span><br><span class="line">Database changed</span><br><span class="line">MariaDB [test]<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> t1 (id <span class="type">int</span> unsigned auto_increment <span class="keyword">primary</span> key <span class="keyword">not</span> <span class="keyword">null</span>, name <span class="type">char</span>(<span class="number">5</span>) <span class="keyword">not</span> <span class="keyword">null</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.05</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来我们来填充数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1 (name) <span class="keyword">values</span> (<span class="string">&#x27;yes&#x27;</span>),(<span class="string">&#x27;2long4char(5)&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">2</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">MariaDB [test]<span class="operator">&gt;</span> <span class="keyword">show</span> warnings;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Level   <span class="operator">|</span> Code <span class="operator">|</span> Message                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Warning <span class="operator">|</span> <span class="number">1265</span> <span class="operator">|</span> Data truncated <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------+-------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [test]<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> yes   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="number">2</span>long <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到出现了一个警告, 我们插入的值超过了<code>char5</code>所规定的的5个字符长度, 但是并没有MySQL并没有报错只是显示了警告, 当我们查询值的时候也会发现, 超过长度的值也被自动剪掉了.</p><p>如果说我们修改SQL模式会变成效果呢, 来试试:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t1 (name) <span class="keyword">values</span> (<span class="string">&#x27;2long4char(5)&#x27;</span>);</span><br><span class="line">ERROR <span class="number">1406</span> (<span class="number">22001</span>): Data too long <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看, 直接就会报错了. 其他的SQL模式在MySQL的官方网站上都会有说明.</p><p>关于SQL接口, 因为是有过基础的. 所以就跳过这一部分, 但是还是简单的说一下, 我们的SQL主要分成两种, 一种叫做DDL, 即数据定义语言, 另外一种叫做DML. 即数据修改语言. 其中DDL主要负责各种数据库组件的建立删除修改, 而DML则负责进行数据的插入修改查找删除. 关于在数据库中一个频繁出现的概念 - 二维关系表, 我们在设计的时候需要遵循一定的规范, 也就是范式. 当然具体是根据业务模型来进行设计的, 范式不是绝对的.</p><p>我们来说说索引, 索引是建立在经常用于查询条件的字段上. MySQL的默认索引是B树&#x2F;B+树, 由于索引的实现实际上是由存储引擎进行的, 所以不同的存储引擎实现的索引类型是不一样的.</p><p>根据索引项对应的记录是不是所有的记录项, 可以分成稠密索引和稀疏索引, 根据实现类型(数据组织结构), 我们可以分成B+索引, hash索引, R树索引, FULLTEXT索引, 根据索引和数据是否存储在一个位置, 可以分成聚集索引和非聚集索引(通过指针), 还有简单索引(单键)和组合索引.</p><p>我们来看一下刚刚创建的表的信息:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">like</span> <span class="string">&#x27;t1&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           Name: t1</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: <span class="number">10</span></span><br><span class="line">     Row_format: Compact</span><br><span class="line">           <span class="keyword">Rows</span>: <span class="number">2</span></span><br><span class="line"> Avg_row_length: <span class="number">8192</span></span><br><span class="line">    Data_length: <span class="number">16384</span></span><br><span class="line">Max_data_length: <span class="number">0</span></span><br><span class="line">   Index_length: <span class="number">0</span></span><br><span class="line">      Data_free: <span class="number">10485760</span></span><br><span class="line"> Auto_increment: <span class="number">3</span></span><br><span class="line">    Create_time: <span class="number">2018</span><span class="number">-10</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">25</span>:<span class="number">19</span></span><br><span class="line">    Update_time: <span class="keyword">NULL</span></span><br><span class="line">     Check_time: <span class="keyword">NULL</span></span><br><span class="line">      <span class="keyword">Collation</span>: latin1_swedish_ci</span><br><span class="line">       Checksum: <span class="keyword">NULL</span></span><br><span class="line"> Create_options: </span><br><span class="line">        Comment: </span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中显示了当前分配的空间大小, 自增的id, 创建时间, 最后一次的更新时间, 检查时间等等.</p><h2 id="MySQL的架构-索引和视图"><a href="#MySQL的架构-索引和视图" class="headerlink" title="MySQL的架构, 索引和视图"></a>MySQL的架构, 索引和视图</h2><p><img src="https://hexopic.s3.ap-northeast-1.amazonaws.com/mysql_arch.png" alt="mysql_arch"></p><p>我们先来看一下这个MySQL的架构图, 我们说这是一个C&#x2F;S架构的应用程序, 所以最上面自然就有接受客户端连接的连接器, 这也是使用的MySQL的驱动. 当我们通过这些连接器连接进入MySQL之后, 会获得一个连接会话. 这个连接会话其实也是可以分成长连接或者短连接的. 我们说过, MySQL是单进程多线程的, 所以就需要分发连接线程给用户, 这就有一个Connection Pool也就是连接池. 用户通过这个连接会话发送SQL到MySQL的SQL接口, 于是这个接口就是一个完备的SQL解释器, 这里分析的是用户发送的SQL的语法正确与否, 如果没有问题就会进入下一个分析器, 这个分析器不负责检查语法方面的问题, 他所作的是关于查询的内容方面的分析, 例如, 查询的用户是否有查询数据的权限以及查询的翻译等等. 分析之后生成的查询路径(查询路由)被丢到下面的一层, 也就是分析那一条路是最近的, 开销最低, 通过评估进行优化.甚至于, 这个优化器会进行SQL的重写.接着就交给了存储引擎, 由存储引擎. 然后这些存储引擎寻找到目标磁盘块, 将他们加载到内存中. 这些存储引擎是没有写入权限的, 所以他需要依托于内核, 通过内存空间来进行改写.</p><p>通过上面的架构图, 我们大概可以获得MySQL的数据文件类型:</p><ul><li>数据文件, 索引文件</li><li>日志: 重做日志, 撤销日志, 二进制日志, 错误日志, 查询日志, 慢查询日志</li></ul><p>关于MySQL的索引, 我们之前稍微的整理了一下几种索引类型, 其实在真实的查找过程中, 我们的索引也是分等级的, 因为直接扫描全部的索引也是一个消耗资源的耗时操作, 所以就再添加一个稀疏的索引用来检索索引, 从而在查询结果的时候先快速的拿到对应的索引的位置, 接着通过索引所指向的硬盘块读取进内存从而拿到结果.</p><p>接下来, 我们说一个MySQL中的索引概念, 叫做 – <strong>左前缀索引</strong>.</p><p>这是个什么玩意呢, 我们知道, 一个varchar类型的字符串数据最长可以达到65535个字符.这就导致如果将所有的字符串继续匹配的话, 会很麻烦. 因此MySQL只选取这字符串的前半段(例如: 只取前50个), 然后将他们组织成索引. 但是这样就造成了一个结果, 那就是我们进行查询的尽量不要做形如这样的查询: <code>LIKE %abc%</code>. 因为左前缀索引是不能找到满足这样条件的字符串的, 要查询的是一个中间数据, 但是只组织了左半数据的索引是做不到的. 所以, 在进行查询的时候, 尽量不要在左边加上<code>%</code>.</p><p>接下来我们读取一个SQL脚本来做个测试, 这个脚本可以在<a href="https://yaoxuannn.com:8080/hellodb.sql">这里</a>得到. </p><p>我们可以先用学生表来做个试验, 首先看下这张表的相关信息和他的索引:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> <span class="keyword">show</span> indexes <span class="keyword">from</span> students\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">        <span class="keyword">Table</span>: students</span><br><span class="line">   Non_unique: <span class="number">0</span></span><br><span class="line">     Key_name: <span class="keyword">PRIMARY</span></span><br><span class="line"> Seq_in_index: <span class="number">1</span></span><br><span class="line">  Column_name: StuID</span><br><span class="line">    <span class="keyword">Collation</span>: A</span><br><span class="line">  <span class="keyword">Cardinality</span>: <span class="number">25</span></span><br><span class="line">     Sub_part: <span class="keyword">NULL</span></span><br><span class="line">       Packed: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">Null</span>: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> StuID<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+-----+--------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> StuID <span class="operator">|</span> Name      <span class="operator">|</span> Age <span class="operator">|</span> Gender <span class="operator">|</span> ClassID <span class="operator">|</span> TeacherID <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+-----+--------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span> Xie Yanke <span class="operator">|</span>  <span class="number">53</span> <span class="operator">|</span> M      <span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span>        <span class="number">16</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+-----+--------+---------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以看到,当前表设置的主键是<code>StuID</code>, 然后我们通过这个主键查找可以找到对应的记录. 事实上, 对于MySQL而言, 有个命令<code>EXPLAIN</code>可以来显示这个命令的执行过程:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> StuID<span class="operator">=</span><span class="number">3</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: students</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: <span class="keyword">PRIMARY</span></span><br><span class="line">          key: <span class="keyword">PRIMARY</span></span><br><span class="line">      key_len: <span class="number">4</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">        Extra: </span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到, 显示的结果是, 使用我们的主键就找到了, 仅仅使用了1行. 这就证明这个是从索引中抓取的. 接下来我们试试如果使用别的字段作为筛选条件的话会是什么样子的:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> Name<span class="operator">=</span><span class="string">&#x27;Xie Yanke&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: students</span><br><span class="line">         type: <span class="keyword">ALL</span></span><br><span class="line">possible_keys: <span class="keyword">NULL</span></span><br><span class="line">          key: <span class="keyword">NULL</span></span><br><span class="line">      key_len: <span class="keyword">NULL</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">25</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这一次就没有可以参考的索引了, 所以就只能扫描全表来获取结果了. 可以看出来扫描了25行然后使用where条件才获取到.</p><p>现在我们再来验证一下上面说的MySQL的左前缀索引的效果, 我们先给Name字段加上一个索引, 接着再通过模糊匹配来试试:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> <span class="keyword">create</span> index name_index <span class="keyword">on</span> students(Name);</span><br><span class="line">Query OK, <span class="number">25</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">25</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> <span class="keyword">show</span> indexes <span class="keyword">from</span> students\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">        <span class="keyword">Table</span>: students</span><br><span class="line">   Non_unique: <span class="number">0</span></span><br><span class="line">     Key_name: <span class="keyword">PRIMARY</span></span><br><span class="line"> Seq_in_index: <span class="number">1</span></span><br><span class="line">  Column_name: StuID</span><br><span class="line">    <span class="keyword">Collation</span>: A</span><br><span class="line">  <span class="keyword">Cardinality</span>: <span class="number">25</span></span><br><span class="line">     Sub_part: <span class="keyword">NULL</span></span><br><span class="line">       Packed: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">Null</span>: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">        <span class="keyword">Table</span>: students</span><br><span class="line">   Non_unique: <span class="number">1</span></span><br><span class="line">     Key_name: name_index</span><br><span class="line"> Seq_in_index: <span class="number">1</span></span><br><span class="line">  Column_name: Name</span><br><span class="line">    <span class="keyword">Collation</span>: A</span><br><span class="line">  <span class="keyword">Cardinality</span>: <span class="keyword">NULL</span></span><br><span class="line">     Sub_part: <span class="keyword">NULL</span></span><br><span class="line">       Packed: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">Null</span>: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建完成了, 这样创建的默认的索引类型都是B树索引. 接着我们来试试查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> Name <span class="keyword">like</span> &quot;Xi%&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+-----+--------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span> StuID <span class="operator">|</span> Name      <span class="operator">|</span> Age <span class="operator">|</span> Gender <span class="operator">|</span> ClassID <span class="operator">|</span> TeacherID <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+-----+--------+---------+-----------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">7</span> <span class="operator">|</span> Xi Ren    <span class="operator">|</span>  <span class="number">19</span> <span class="operator">|</span> F      <span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span>      <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">22</span> <span class="operator">|</span> Xiao Qiao <span class="operator">|</span>  <span class="number">20</span> <span class="operator">|</span> F      <span class="operator">|</span>       <span class="number">1</span> <span class="operator">|</span>      <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span> Xie Yanke <span class="operator">|</span>  <span class="number">53</span> <span class="operator">|</span> M      <span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span>        <span class="number">16</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+-----+--------+---------+-----------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> Name <span class="keyword">like</span> &quot;Xi%&quot;\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: students</span><br><span class="line">         type: <span class="keyword">range</span></span><br><span class="line">possible_keys: name_index</span><br><span class="line">          key: name_index</span><br><span class="line">      key_len: <span class="number">152</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">3</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> index <span class="keyword">condition</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> Name <span class="keyword">like</span> &quot;%Xi%&quot;\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: students</span><br><span class="line">         type: <span class="keyword">ALL</span></span><br><span class="line">possible_keys: <span class="keyword">NULL</span></span><br><span class="line">          key: <span class="keyword">NULL</span></span><br><span class="line">      key_len: <span class="keyword">NULL</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">25</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们没有在左边加上通配符的时候. 查询的使用还是通过索引来进行的, 然而如果加上了, 就会扫描全表.</p><p>接着我们再来看一下视图, 视图是关系型数据库中的一个概念, 但是在MySQL中对于视图的支持没那么好, 视图其实就是一个虚表, 他的数据仍然来源于基表(就是创建视图的那个表), 所以说如果想要在视图上插入数据, 是需要参照基表的约束的, 但是几乎没有人会去这么做, 创建一个视图很简单:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">view</span> test <span class="keyword">as</span> <span class="keyword">select</span> StuID, Name, Age <span class="keyword">from</span> students;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_hellodb <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="operator">|</span> classes           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> coc               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> courses           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> scores            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> students          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> teachers          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> test              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> toc               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们就可以看到这个视图了, 那么怎么区分视图和表的呢?</p><p>我们可以通过查看表的状态来看:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">like</span> &quot;test&quot;\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           Name: test</span><br><span class="line">         Engine: <span class="keyword">NULL</span></span><br><span class="line">        Version: <span class="keyword">NULL</span></span><br><span class="line">     Row_format: <span class="keyword">NULL</span></span><br><span class="line">           <span class="keyword">Rows</span>: <span class="keyword">NULL</span></span><br><span class="line"> Avg_row_length: <span class="keyword">NULL</span></span><br><span class="line">    Data_length: <span class="keyword">NULL</span></span><br><span class="line">Max_data_length: <span class="keyword">NULL</span></span><br><span class="line">   Index_length: <span class="keyword">NULL</span></span><br><span class="line">      Data_free: <span class="keyword">NULL</span></span><br><span class="line"> Auto_increment: <span class="keyword">NULL</span></span><br><span class="line">    Create_time: <span class="keyword">NULL</span></span><br><span class="line">    Update_time: <span class="keyword">NULL</span></span><br><span class="line">     Check_time: <span class="keyword">NULL</span></span><br><span class="line">      <span class="keyword">Collation</span>: <span class="keyword">NULL</span></span><br><span class="line">       Checksum: <span class="keyword">NULL</span></span><br><span class="line"> Create_options: <span class="keyword">NULL</span></span><br><span class="line">        Comment: <span class="keyword">VIEW</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个视图不会具备表的信息, 你只会在注释里面看到有写.</p><p>可以正常的在视图中继续查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> StuID<span class="operator">=</span><span class="number">22</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+-----+</span></span><br><span class="line"><span class="operator">|</span> StuID <span class="operator">|</span> Name      <span class="operator">|</span> Age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+-----+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">22</span> <span class="operator">|</span> Xiao Qiao <span class="operator">|</span>  <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+-----+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> StuID<span class="operator">=</span><span class="number">22</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: students</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: <span class="keyword">PRIMARY</span></span><br><span class="line">          key: <span class="keyword">PRIMARY</span></span><br><span class="line">      key_len: <span class="number">4</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">        Extra: </span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>但是实际上, 我们的结果还是从<code>students</code>表中获取的.</p><h2 id="MySQL的查询操作"><a href="#MySQL的查询操作" class="headerlink" title="MySQL的查询操作"></a>MySQL的查询操作</h2><p>了解MySQL的查询操作就是了解他的查询执行路径, 我们先来看一下:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/MySQL_query_arch.png" alt="MySQL查询过程"></p><p>最左上就是我们的客户端了, 通过C&#x2F;S协议来访问到我们的MySQL服务器端. 通过连接线程在缓冲池中寻找, 如果能够命中Cache, 直接结束查询过程, 相当于是剩下了后面的所有资源消耗, 可想而知这是多么大的收益!</p><p>不过, 查询缓存也只是在一些特定条件下才会有用, 例如一个最典型的例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(<span class="keyword">none</span>)]<span class="operator">&gt;</span> <span class="keyword">select</span> now();</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> now()               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2018</span><span class="number">-10</span><span class="number">-16</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">34</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样的值是没有缓存的必要的, 因为每次查询都不一样.</p><p>有关这个查询的后半部分, 我们在之前的MySQL的架构中说了, 这里就不在赘述了. 但是我们依然可以总结出查询的路径:</p><blockquote><p>查询缓存 -&gt; 解析器 -&gt; 预处理器 -&gt; 优化器 -&gt; 查询执行引擎 -&gt; 存储引擎</p></blockquote><p>说到查询, 不得不提到的就是<code>SELECT</code>查询语句了, 一个完整的SELECT语句执行下来, 是从FROM先开始的, FROM说明选择查询的表, 接着where表明需要满足那些条件, 分析完where之后就会进行分组GROUP BY, 接着通过HAVING进行分组的聚合, 接着还可以通过ORDERBY来进行排序, 接着就根据select指明的列进行投影, 之后再根据LIMIT所指明的范围对结果进行移除.</p><p>在MySQL的交互式SHELL命令行中, 我们可以看到完整的SELECT查询语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Name: <span class="string">&#x27;SELECT&#x27;</span></span><br><span class="line">Description:</span><br><span class="line">Syntax:</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span> <span class="operator">|</span> DISTINCTROW ]</span><br><span class="line">      [HIGH_PRIORITY]</span><br><span class="line">      [STRAIGHT_JOIN]</span><br><span class="line">      [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]</span><br><span class="line">      [SQL_CACHE <span class="operator">|</span> SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]</span><br><span class="line">    select_expr [, select_expr ...]</span><br><span class="line">    [<span class="keyword">FROM</span> table_references</span><br><span class="line">    [<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">    [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;col_name <span class="operator">|</span> expr <span class="operator">|</span> position&#125;</span><br><span class="line">      [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>], ... [<span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>]]</span><br><span class="line">    [<span class="keyword">HAVING</span> where_condition]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;col_name <span class="operator">|</span> expr <span class="operator">|</span> position&#125;</span><br><span class="line">      [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>], ...]</span><br><span class="line">    [LIMIT &#123;[<span class="keyword">offset</span>,] row_count <span class="operator">|</span> row_count <span class="keyword">OFFSET</span> <span class="keyword">offset</span>&#125;]</span><br><span class="line">    [<span class="keyword">PROCEDURE</span> procedure_name(argument_list)]</span><br><span class="line">    [<span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;file_name&#x27;</span></span><br><span class="line">        [<span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">        export_options</span><br><span class="line">      <span class="operator">|</span> <span class="keyword">INTO</span> DUMPFILE <span class="string">&#x27;file_name&#x27;</span></span><br><span class="line">      <span class="operator">|</span> <span class="keyword">INTO</span> var_name [, var_name]]</span><br><span class="line">    [<span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="operator">|</span> LOCK <span class="keyword">IN</span> SHARE MODE]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以添加前面一些查询选项, 来实现一些功能, 例如: <code>DISTINCT</code>就是在做数据去重, 重复的数据会被舍弃. 还有SQL_CACHE和SQL_NO_CACHE分别表示显示指定存储查询结果是否丢到缓存中. 在我们的MySQL的服务器变量叫做<code>query_cache_type</code>. 只有当这个值为ON的时候, 查询缓存才是打开的. 看一下相关的变量:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hellodb]<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;query%&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                <span class="operator">|</span> <span class="keyword">Value</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> query_alloc_block_size       <span class="operator">|</span> <span class="number">8192</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_cache_limit            <span class="operator">|</span> <span class="number">1048576</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_cache_min_res_unit     <span class="operator">|</span> <span class="number">4096</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_cache_size             <span class="operator">|</span> <span class="number">0</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_cache_strip_comments   <span class="operator">|</span> OFF     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_cache_type             <span class="operator">|</span> <span class="keyword">ON</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_cache_wlock_invalidate <span class="operator">|</span> OFF     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query_prealloc_size          <span class="operator">|</span> <span class="number">8192</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+---------+</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>并且, SELECT的结果缓存符合条件的时候就会进行缓存. 另外, 还可以使用<code>DEMAND</code>来要求MySQL进行显式缓存, 也就是说, 需要用户手动的显式指定需要缓存的数据, 但是如果数据的数据类型不符合缓存的数据类型, 就依然不能进行. 当然了, 在我们进行查询的时候加上<code>SQL_NO_CACHE</code>的话就都不会进行缓存了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat集群部署</title>
      <link href="/2018/09/25/Tomcat%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
      <url>/2018/09/25/Tomcat%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>初步了解了单机Tomcat的配置. 接下来我们就来看一下Tomcat负载均衡集群的配置吧.</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>说到了集群就一定会说到的问题就是关于会话保持的问题了, 我们也可以把这个问题叫做会话黏性, 常规的方式例如: 进行源地址IP绑定, 还有基于cookie的方式. 这两种方式的一个显而易见的问题就是关于当我们的后端服务器重启或者是宕机的时候就会导致所有的session丢失. 这个时候我们就要做session的持久化或者是使用session集群和session服务器, 常见的是基于kv的数据库比如memcached和redis.</p><p>我们先来使用nginx做前端load balancer和tomcat配合搭建LB Tomcat, 接着使用Apache加上tomcat实现一样的效果. </p><p>接着我们使用tomcat自己的LB实现来搭建tomcat负载均衡集群, 最后再加上一个memcache session服务器.</p><h2 id="Nginx和Apache实现负载均衡的TC"><a href="#Nginx和Apache实现负载均衡的TC" class="headerlink" title="Nginx和Apache实现负载均衡的TC"></a>Nginx和Apache实现负载均衡的TC</h2><p>这次一共使用3台主机, 其中一个作为负载均衡器, 安装httpd和nginx, 后端放两台tomcat主机, 配置上基本和上一个保持一致. 唯一的不同点是作为测试的jsp页面一个写的是node1一个写的是node2, 并且将主机名设定成了web1.wyx.com和web2.wyx.com.</p><p>接着, 将默认的主机设置成为这两个我们自定义主机.</p><p>tomcat的配置到这里就基本结束了, 接下来来配置一下nginx, 其实就是我们之前配置的反向代理, 很简单的. 直接贴下配置:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~* \.(jsp|do)$</span> &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://tcservers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">upstream</span> tcservers &#123;</span><br><span class="line">    <span class="attribute">server</span> web1.wyx.com:<span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server</span> web2.wyx.com:<span class="number">8080</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认的负载均衡算法就是轮询所以当我们进行访问测试的时候就是一个接一个的出现.</p><p>但是我们说, 一个稍微好一点的架构是在每一个tomcat的前面加上一个httpd , 接着通过nginx的负载均衡到这些Apache主机上, 有这些Apache主机进行tomcat的访问, 最后返回结果.</p><p>如果是通过apache来构建tomcat集群的话, 我们有三种方案, 一种是使用http协议进行访问, 一种是使用之前说的ajp协议. 上面的这两种都需要使用到mod_proxy模块, 而子模块不同而已. 第三种方案叫做使用一个叫做<code>mod_jk</code>的模块来实现. 不过这个模块仅仅支持AJP协议并且httpd没有自行携带. 需要我们到官方的站点上进行源代码的下载自行编译. 另外, 我们之前提到过, httpd其实也是可以做负载均衡的, 这依赖一个模块叫做<code>proxy_balancer_module</code>. 这个模块一般来说也是自行携带的, 不需要再另行安装.</p><p>对于上面的第三种, 我们就暂时忽略了, 主要来看看前两的使用.</p><p>我们在上一次的Tomcat配置学习的时候, 曾经使用httpd做前端服务器进行了代理, 但是当时只是跟着配置了一下, 对于一些代理的apache指令并不知道是什么东西, 现在来说明一下.</p><p><strong>ProxyPreserve {On|Off}</strong>: 该选项表示是否将请求报文中的Host发送给后端的代理服务器, 这个选项在之前的实验中我也尝试过了.</p><p><strong>ProxyRequests {On|Off}</strong>: 这个选项表示是否开启Apache的正向代理功能, 要求mod_proxy_http模块必须启用.</p><p><strong>ProxyPassReverse</strong>: 用于让apacje调整HTTP重定向报文中的Location, Content-Location和URI标签所对应的URL. 在反向代理环境中需要打开这个选项来避免重定向报文绕过proxy服务器.</p><p><strong>ProxyVia {On|Off|Full|Block}</strong>: 用来控制是否在请求的首部中加上<code>Via</code>头部, 默认的值是<code>Off</code>. <code>Full</code>表示每一个Via的头部都会加上Apache服务器的版本号信息, <code>Block</code>表示每一个代理的请求报文中的<code>Via</code>都会被移除.</p><p><strong>ProxyPass [Path] !|url [key&#x3D;value key&#x3D;value]</strong>: 这个指令是用来将后端服务器某个URL与当前服务器的虚拟路径关联起来作为提供服务的路径. 说白了就是进行反向代理, 这也就是说, 当这个选项打开的时候, <code>ProxyRequests</code>必须关闭(废话啦).  <em>需要注意的一点是, 如果这个地方的路径后面写上了<code>/</code>那么URL的结尾也必须加上<code>/</code>. 或者都不写</em></p><blockquote><p>ProxyPass常用的一些属性有<code>min</code>, <code>max</code>分别表示后端服务器的最小和最大连接池容量. <code>loadfactor</code>定义负载均衡的权重相当于是Nginx的<code>weight</code>. <code>retry</code>表示apache得到错误响应之后等到的重试时长, 单位是s.</p></blockquote><p>如果上面的Proxy是使用<code>balance://</code>开头的 ( 这说明是一个负载均衡器, 这种感觉就好像我们在使用Ngixn反向代理功能的时候写的upstream服务器组 ), 那么我们还可以加上以下的属性:</p><blockquote><p>lbmethod: 很好理解吧. 就是负载均衡使用的调度方法, 默认的方法是<code>byrequests</code>, 也就是根据权重将统计请求个数进行调度, 还有<code>bytraffic</code>, 执行基于权重的流量计数调度, <code>bybusyness</code>通过考量每个后端服务器的当前负载进行调度.</p><p>maxattempts: 放弃请求执行故障转移的次数, 最大值不能超过节点的个数.</p><p>nofailover: 是否进行故障转移, 如果在我们后端服务器有进行SESSION绑定的话, 就不应该进行转移, 因为这样会损坏用户的session.</p><p>stickysession: 设置调度器session名字, 根据web程序语言的不同, 设置成为JSESSIONID或者PHPSESSIONID.</p></blockquote><p>比如一个示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Proxy</span> <span class="attr">balancer:</span>//<span class="attr">hotcluster</span>&gt;</span></span><br><span class="line">    BalancerMember http://web1.wyx.com loadfactor=1</span><br><span class="line">    BalancerMember http://web2.wyx.com loadfactor=2</span><br><span class="line">    ProxySet lbmethod=bytraffic</span><br><span class="line"><span class="tag">&lt;/<span class="name">Proxy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里就定义好了一个负载均衡集群, 那么怎么让他们生效呢? 我们在虚拟主机的配置文件中这样定义:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">proxy</span> <span class="attr">balancer:</span>//<span class="attr">lbcluster</span>&gt;</span></span><br><span class="line">    BalancerMember ajp://192.168.16.100:8009 loadfactor=10</span><br><span class="line">    BalancerMember ajp://192.168.16.101:8009 loadfactor=10</span><br><span class="line"><span class="tag">&lt;/<span class="name">proxy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *<span class="attr">:80</span>&gt;</span></span><br><span class="line">    ServerName www.wyx.com</span><br><span class="line">    ProxyVia On</span><br><span class="line">    ProxyRequests Off</span><br><span class="line">    ProxyPreserveHost On</span><br><span class="line">    <span class="tag">&lt;<span class="name">Proxy</span> *&gt;</span></span><br><span class="line">        Require all granted</span><br><span class="line">    <span class="tag">&lt;/<span class="name">Proxy</span>&gt;</span></span><br><span class="line">    ProxyPass / balancer://lbcluster/</span><br><span class="line">    ProxyPassReverse / balancer://lbcluster/</span><br><span class="line">    <span class="tag">&lt;<span class="name">Location</span> /&gt;</span></span><br><span class="line">        Require all granted</span><br><span class="line">    <span class="tag">&lt;<span class="name">Location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样配置完成之后我们可以就先启动试试效果了, 和Nginx之前演示的效果类似, 现在 我们加上关于Session相关的配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">proxy</span> <span class="attr">balancer:</span>//<span class="attr">lbcluster</span>&gt;</span></span><br><span class="line">        BalancerMember ajp://192.168.16.100:8009 loadfactor=10 route=node1</span><br><span class="line">        BalancerMember ajp://192.168.16.101:8009 loadfactor=10 route=node2</span><br><span class="line">        ProxySet stickysession=JSESSIONID</span><br><span class="line"><span class="tag">&lt;/<span class="name">proxy</span>&gt;</span></span><br><span class="line">...(后面一致)</span><br></pre></td></tr></table></figure><p>这样再次访问几次, 就会出现访问到同一个后端服务器的现象了.</p><p>另外, 我们的<code>mod_proxy_http</code>其实也内置了一个负载均衡的web管理页面, 只需要简单的配置就可以使用了, 来看一下吧.</p><p>加上一个访问路径:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *<span class="attr">:80</span>&gt;</span></span><br><span class="line">        ServerName www.wyx.com</span><br><span class="line">        ProxyVia On</span><br><span class="line">        ProxyRequests Off</span><br><span class="line">        ProxyPreserveHost On</span><br><span class="line">        <span class="tag">&lt;<span class="name">Proxy</span> *&gt;</span></span><br><span class="line">                Require all granted</span><br><span class="line">        <span class="tag">&lt;/<span class="name">Proxy</span>&gt;</span></span><br><span class="line">        ProxyPass / balancer://lbcluster/</span><br><span class="line">        ProxyPassReverse / balancer://lbcluster/</span><br><span class="line">        <span class="tag">&lt;<span class="name">Location</span> /&gt;</span></span><br><span class="line">                Require all granted</span><br><span class="line">        <span class="tag">&lt;/<span class="name">Location</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Location</span> /<span class="attr">balancer-manager</span>&gt;</span></span><br><span class="line">                SetHandler balancer-manager</span><br><span class="line">                ProxyPass !</span><br><span class="line">                Require ip 192.168.16.1</span><br><span class="line">                Require all denied</span><br><span class="line">        <span class="tag">&lt;/<span class="name">Location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里加上了一个Location, 访问的效果就想这样:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/balancer-manager_example.png" alt="balancer-manager_example"></p><p>可以在这个页面进行一些简单的管理和状态监视.</p><h2 id="Session-Cluster"><a href="#Session-Cluster" class="headerlink" title="Session Cluster"></a>Session Cluster</h2><p>tomcat提供了一些会话管理组件, 主要有两种, 一个是标准会话管理器, 一个是持久会话管理器.</p><p>对于标准会话管理器, 使用的类是<code>org.apache.catalina.session.StandardManager</code>, 常用的三个属性是:</p><ul><li>maxActiveSessions: 最大允许的活动会话数量, 默认是-1, 也就是不限制</li><li>maxInactiveInterval: 非活动的会话超时时长, 默认是60s</li><li>pathname: 会话文件的保存目录 默认保存在webapp下的SESSIONS.ser文件中</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">classname</span>=<span class="string">“org.apache.catalina.session.StandardManager”</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxInactiveInterval</span>=<span class="string">7200</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 但是大部分的情况下, 我们使用的都是另外一个可以进行持久化保存的会话管理器(PersistantManager). 这个会话管理器可以将会话数据保存在持久存储中, 并且可以在服务器意外终止的时候重启启动的时候加载这些会话信息, 持久会话管理器支持将会话保存在文件存储或者JDBC中.</p><p>例如一个保存在文件中的示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.session.PersistantManager&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">saveOnRestart</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Store</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.session.FileStore&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">directory</span>=<span class="string">&quot;/data/tomcat-sessions&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Manager</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每一个用户的会话都会保存到上面制定的目录位置中, 命名为session_id.session, 并且后台线程会每隔一定时间进行检查(默认是60s).</p><p>上面是保存在文件中的, 刚刚说是可以使用JDBC存储的, 也就是说我们可以把上面的Store区域改成:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.session.PersistantManager&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">saveOnRestart</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Store</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.session.JDBCStore&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">driverName</span>=<span class="string">&quot;com.mysql.jdbc.driver&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql//localhost:3306/mydb?user=user_name;password=pw&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Manager</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外还有一个叫做<code>DeltaManager</code>的会话管理器, 这一种是将每一个tomcat节点通过一条总线连接起来, 接着通过多播方式进行session同步, 每一台主机上面都包含所有的session数据, 这样哪怕一台节点宕机了, session数据也依然在, 只要前端调度进行一次故障转移就行了. 但是由于使用的是多播的方式, 所以这就必然限制了集群的规模.</p><p>除了这些, 还有一个叫做<code>BackupManager</code>的东西.</p><p>官方文档上关于构建会话复制集群的说明在这里: <a href="http://tomcat.apache.org/tomcat-8.5-doc/cluster-howto.html">cluster-howto</a>. 但是要看好版本号, 不同版本的tomcat配置起来会有出入的.</p><p>直接使用官方网站上的配置说明就可以了: (可以根据情况修改一下组播地址和接受的IP地址)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Cluster</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">channelSendOptions</span>=<span class="string">&quot;8&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.ha.session.DeltaManager&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">expireSessionsOnShutdown</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">notifyListenersOnReplication</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Channel</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.tribes.group.GroupChannel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Membership</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.tribes.membership.McastService&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">address</span>=<span class="string">&quot;228.0.0.4&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">port</span>=<span class="string">&quot;45564&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">frequency</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">dropTime</span>=<span class="string">&quot;3000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Receiver</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.tribes.transport.nio.NioReceiver&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">address</span>=<span class="string">&quot;auto&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">port</span>=<span class="string">&quot;4000&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">autoBind</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">selectorTimeout</span>=<span class="string">&quot;5000&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">maxThreads</span>=<span class="string">&quot;6&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Sender</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.tribes.transport.ReplicationTransmitter&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Transport</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.tribes.transport.nio.PooledParallelSender&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Sender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Interceptor</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.tribes.group.interceptors.TcpFailureDetector&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Interceptor</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Channel</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.ha.tcp.ReplicationValve&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">filter</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Deployer</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.ha.deploy.FarmWarDeployer&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tempDir</span>=<span class="string">&quot;/tmp/war-temp/&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">deployDir</span>=<span class="string">&quot;/tmp/war-deploy/&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">watchDir</span>=<span class="string">&quot;/tmp/war-listen/&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">watchEnabled</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">ClusterListener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.ha.session.ClusterSessionListener&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Cluster</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意: 为了使得webapp可以被管理器进行分发, 必须要在web.xml中添加<code>distributable</code>元素</strong></p><p>这里还是像之前的实验一样, 只有两个节点. 配置结束之后查看一下两个节点的日志, 可以看到”:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">04-Oct-2018 17:28:24.520 INFO [Membership-MemberAdded.] org.apache.catalina.ha.tcp.SimpleTcpCluster.memberAdded Replication member added:[org.apache.catalina.tribes.membership.MemberImpl[tcp://&#123;192, 168, 16, 101&#125;:4000,&#123;192, 168, 16, 101&#125;,4000, alive=1036, securePort=-1, UDP Port=-1, id=&#123;-8 8 14 -62 107 -126 71 94 -107 116 88 49 9 -83 -91 -105 &#125;, payload=&#123;&#125;, command=&#123;&#125;, domain=&#123;&#125;]]</span><br></pre></td></tr></table></figure><p>已经加入了.</p><p>接着我们写一个JSP页面来方便观察实验效果:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;&lt;title&gt;TomcatA&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;&lt;font color=<span class="string">&quot;red&quot;</span>&gt;web1.wyx.com&lt;/font&gt;&lt;/h1&gt;</span><br><span class="line">    &lt;table align=<span class="string">&quot;centre&quot;</span> border=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;Session ID&lt;/td&gt;</span><br><span class="line">    &lt;% session.setAttribute(<span class="string">&quot;wyx.com&quot;</span>,<span class="string">&quot;wyx.com&quot;</span>); %&gt;</span><br><span class="line">        &lt;td&gt;&lt;%= session.getId() %&gt;&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;Created on&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;%= session.getCreationTime() %&gt;&lt;/td&gt;</span><br><span class="line">     &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>另外, apache也已经配置了最基本的负载均衡, 没有配置stickysession.</p><p>接着访问就会出现神奇的事情了, 虽然我们的主机在进行调度, 但是得到的session是一样的, 也就是说不同的主机处理了同一个会话.</p><h2 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h2><p>我们接下来引入memcached, 这是一个基于内存的使用key&#x2F;value高性能的数据缓存. 和redis最大的不同是, redis是store, 而memcached是cache. 也就是说, 这玩意不能用来进行存储, 不能持久化, 但是可以进行高性能的键值对缓存.</p><p> 之前说过我们软件系统存储数据有三种类型的, 分别是:</p><ul><li>结构化数据, 例如我们的RDBMS所管理的数据</li><li>半结构化数据, JSON, XML都是这一类数据</li><li>非结构化数据, 文件</li></ul><p>而我们的memcached只能存取最简单的数据类型, 那就是K-V存储. 他的应用场景在哪里呢? 比如说, 在一个存储百万条数据的MySQL数据库中进行查询, 会经过很多次的磁盘IO, 这就大大降低了查询的效率, 但是如果我们在查询之后能够把查询的结果缓存下来, 就可以直接在下一次的访问时直接返回结果而不需要再进行IO了.</p><p>那么这个数据我们该怎么使用memcached来进行缓存呢? 其实很简单, 计算出这一次查询SQL语句的哈希值, 然后将这个哈希值作为存储的键, 而查询的结果集也就是一个数据流作为存储的值就可以了.</p><p>其实, 我们的MySQL系统本身就是具有缓存系统的, 只不过当我们存在多个MySQL的时候, 就需要一个公共的缓存系统了. </p><p>memcached有这些特点:</p><ul><li>协议十分简单, 因为只需要进行数据的get和push, 并不需要一些复杂的操作</li><li>记录libevent事件处理</li><li>基于内存完成数据的存储, 基于的算法就是我们熟悉的LRU算法</li><li>memcacahed互不通信的集群</li></ul><p>至于安装也是十分简单的了, 直接使用yum进行安装就可以了, 并且看一下生成的文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-master ~]# rpm -ql memcached</span><br><span class="line">/etc/sysconfig/memcached</span><br><span class="line">/usr/bin/memcached</span><br><span class="line">/usr/bin/memcached-tool</span><br><span class="line">/usr/lib/systemd/system/memcached.service</span><br><span class="line">/usr/share/doc/memcached-1.4.15</span><br><span class="line">/usr/share/doc/memcached-1.4.15/AUTHORS</span><br><span class="line">/usr/share/doc/memcached-1.4.15/CONTRIBUTORS</span><br><span class="line">/usr/share/doc/memcached-1.4.15/COPYING</span><br><span class="line">/usr/share/doc/memcached-1.4.15/ChangeLog</span><br><span class="line">/usr/share/doc/memcached-1.4.15/NEWS</span><br><span class="line">/usr/share/doc/memcached-1.4.15/README.md</span><br><span class="line">/usr/share/doc/memcached-1.4.15/protocol.txt</span><br><span class="line">/usr/share/doc/memcached-1.4.15/readme.txt</span><br><span class="line">/usr/share/doc/memcached-1.4.15/threads.txt</span><br><span class="line">/usr/share/man/man1/memcached-tool.1.gz</span><br><span class="line">/usr/share/man/man1/memcached.1.gz</span><br></pre></td></tr></table></figure><p>就连省略都不需要了, 可以说是很简单了. 一个简单的配置文件, 一个主程序, 管理程序再加上服务脚本和文档就没了.</p><p>甚至说就连配置文件也是十分的简单:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-master ~]# cat /etc/sysconfig/memcached </span><br><span class="line">PORT=&quot;11211&quot;</span><br><span class="line">USER=&quot;memcached&quot;</span><br><span class="line">MAXCONN=&quot;1024&quot;</span><br><span class="line">CACHESIZE=&quot;64&quot;</span><br><span class="line">OPTIONS=&quot;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实就是一些环境变量.</p><p>直接启动服务就可以看到tcp&#x2F;udp的11211端口已经监听了.</p><p>我们可以使用telnet进行一些memcached的尝试:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-master ~]# telnet 127.0.0.1 11211</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">set mykey 0 60 11</span><br><span class="line">hello world</span><br><span class="line">STORED</span><br><span class="line">get mykey</span><br><span class="line">VALUE mykey 0 11</span><br><span class="line">hello world</span><br><span class="line">END</span><br><span class="line">(60s later)</span><br><span class="line">get mykey</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>简单的说明一下吧. set操作就是无条件的设置一个键, 当然也可以进行修改, get操作就是在获取值. 上面的意思是set一个键, 键的名字叫做mykey, 标号是0, 存活时间是60s, 长度是11个字节, 这个地方如果你设定的字节长度和实际你要存储的数据的长度不符合的话是会报错的.</p><p>接着一些其他的操作:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">set mykey 0 60 11     </span><br><span class="line">hello world</span><br><span class="line">STORED</span><br><span class="line">append mykey 0 60 1</span><br><span class="line">!</span><br><span class="line">STORED</span><br><span class="line">get mykey</span><br><span class="line">VALUE mykey 1 12</span><br><span class="line">hello world!</span><br><span class="line">END</span><br><span class="line">prepend mykey 0 60 2</span><br><span class="line">a </span><br><span class="line">STORED</span><br><span class="line">get mykey</span><br><span class="line">VALUE mykey 1 14</span><br><span class="line">a hello world!</span><br><span class="line">END</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过使用<code>append</code>和<code>prepend</code>可以在键的后面和前面添加值. 另外使用<code>delete</code>来删除, <code>stats</code>来查看当前的状态, <code>flush_all</code>来清除所有的, <code>incr</code>和<code>decr</code>来增加和减少. 基本的命令就这些了.</p><p>但是需要提醒一点的是, 可能在你删除了一个键之后发现似乎stats显示的总数没有变少, 但是当前数目变少了, 这是因为memcached使用的是惰性的存储模式, 也就是说, 删除的时候没有真正的删除而是加上了一个不可用的标识符.</p><p>这个地方使用的是命令行的形式, 在应用程序中, 使用memcached也很简单, 因为协议简单, 所以对接起来就也容易.</p><p>接下来我们来说说memcached对内存存储的工作模式. 它使用的是叫做<code>slab allocation</code>的也就是整理内存来进行复用的模式. 由于存储的内容大小不一样, 所以就先按照一些提前订好的大小分成组. 举个例子, 我先准备好2字节的内存空间(很多, 一大把), 4字节的(也有很多), 8字节的(还是很多)等等. 接着假设来了一个3字节的数据, 我们就把他丢进4字节的组中. 这一个4字节的内存空间, 我们叫做<code>chunk</code>, 而这一整个组我们叫做<code>slab class</code>.</p><p>这种感觉有点类似我们内存的分页(4K). 所以其实一个4Kb的内存页的内部, 分配给slab用于再次分割, 成为一个个chunk. 这种模式对于内存的回收重新利用就很方便. memcached规定最大的单个不能超过1M. 那么这些内存空间的大小该怎么去增长呢? 这个概念在memcached中叫做factor, 也就是增长因子, 默认的大小是1.25. 我们可以手动启动加上<code>-vv</code>参数来验证一下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-master ~]# memcached -u memcached -vv</span><br><span class="line">slab class   1: chunk size        96 perslab   10922</span><br><span class="line">slab class   2: chunk size       120 perslab    8738</span><br><span class="line">slab class   3: chunk size       152 perslab    6898</span><br><span class="line">slab class   4: chunk size       192 perslab    5461</span><br><span class="line">slab class   5: chunk size       240 perslab    4369</span><br><span class="line">slab class   6: chunk size       304 perslab    3449</span><br><span class="line">slab class   7: chunk size       384 perslab    2730</span><br><span class="line">slab class   8: chunk size       480 perslab    2184</span><br><span class="line">slab class   9: chunk size       600 perslab    1747</span><br><span class="line">slab class  10: chunk size       752 perslab    1394</span><br><span class="line">slab class  11: chunk size       944 perslab    1110</span><br><span class="line">slab class  12: chunk size      1184 perslab     885</span><br><span class="line">slab class  13: chunk size      1480 perslab     708</span><br><span class="line">slab class  14: chunk size      1856 perslab     564</span><br><span class="line">slab class  15: chunk size      2320 perslab     451</span><br><span class="line">slab class  16: chunk size      2904 perslab     361</span><br><span class="line">slab class  17: chunk size      3632 perslab     288</span><br><span class="line">slab class  18: chunk size      4544 perslab     230</span><br><span class="line">slab class  19: chunk size      5680 perslab     184</span><br><span class="line">slab class  20: chunk size      7104 perslab     147</span><br><span class="line">slab class  21: chunk size      8880 perslab     118</span><br><span class="line">slab class  22: chunk size     11104 perslab      94</span><br><span class="line">slab class  23: chunk size     13880 perslab      75</span><br><span class="line">slab class  24: chunk size     17352 perslab      60</span><br><span class="line">slab class  25: chunk size     21696 perslab      48</span><br><span class="line">slab class  26: chunk size     27120 perslab      38</span><br><span class="line">slab class  27: chunk size     33904 perslab      30</span><br><span class="line">slab class  28: chunk size     42384 perslab      24</span><br><span class="line">slab class  29: chunk size     52984 perslab      19</span><br><span class="line">slab class  30: chunk size     66232 perslab      15</span><br><span class="line">slab class  31: chunk size     82792 perslab      12</span><br><span class="line">slab class  32: chunk size    103496 perslab      10</span><br><span class="line">slab class  33: chunk size    129376 perslab       8</span><br><span class="line">slab class  34: chunk size    161720 perslab       6</span><br><span class="line">slab class  35: chunk size    202152 perslab       5</span><br><span class="line">slab class  36: chunk size    252696 perslab       4</span><br><span class="line">slab class  37: chunk size    315872 perslab       3</span><br><span class="line">slab class  38: chunk size    394840 perslab       2</span><br><span class="line">slab class  39: chunk size    493552 perslab       2</span><br><span class="line">slab class  40: chunk size    616944 perslab       1</span><br><span class="line">slab class  41: chunk size    771184 perslab       1</span><br><span class="line">slab class  42: chunk size   1048576 perslab       1</span><br><span class="line">&lt;26 server listening (auto-negotiate)</span><br><span class="line">&lt;27 server listening (auto-negotiate)</span><br><span class="line">&lt;28 send buffer was 212992, now 268435456</span><br><span class="line">&lt;29 send buffer was 212992, now 268435456</span><br><span class="line">&lt;28 server listening (udp)</span><br><span class="line">&lt;29 server listening (udp)</span><br><span class="line">&lt;28 server listening (udp)</span><br><span class="line">&lt;29 server listening (udp)</span><br><span class="line">&lt;28 server listening (udp)</span><br><span class="line">&lt;29 server listening (udp)</span><br><span class="line">&lt;28 server listening (udp)</span><br><span class="line">&lt;29 server listening (udp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过增加<code>-f</code>参数来指定, 可以修改这个增长因子.</p><p>接下来来看一下memcached的管理工具, 还是之前的<code>hello world</code>这个11字节的数据, 存储结束之后我们退出telnet然后使用<code>memcached-tools</code>来查看一下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-master ~]# memcached-tool 127.0.0.1</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"> Item_Size  Max_age   Pages   Count   Full?  Evicted Evict_Time OOM</span></span><br><span class="line">  1      96B        10s       1       1     yes        0        0    0</span><br><span class="line">[root@VM-master ~]# memcached-tool 127.0.0.1</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"> Item_Size  Max_age   Pages   Count   Full?  Evicted Evict_Time OOM</span></span><br><span class="line">  1      96B        84s       1       1     yes        0        0    0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到有数据了, 其中第一个<code>#</code>表示slab class的编号, 往上看, 1编号的slab大小就是96字节, 而11字节的数据就进入这个里面了, 后面的<code>Max_age</code>表示当前缓存对象的生存时间, <code>Pages</code>表示分配给slab的内存页数, <code>Count</code>表示slab内的记录数, <code>Full?</code>表示是否还有空闲的chunks.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cluster </tag>
            
            <tag> Tomcat </tag>
            
            <tag> Memcached </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat配置与应用</title>
      <link href="/2018/09/20/Tomcat%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2018/09/20/Tomcat%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>简单了解Tomcat之后, 我们来看看他的实际配置和相关的应用吧,</p><span id="more"></span><p>我们之前已经说过了, 对于Tomcat运行的核心配置文件就是<code>server.xml</code>.  各个层级组件的顺序是这样子的:</p><blockquote><p>server -&gt; service  -&gt; connector -&gt; engine -&gt; host -&gt; context</p></blockquote><p>我们还说过在部署的时候, tomcat启动一个jvm, 产生运行时区域, 主要就是堆和栈两个部分, 其中对象都保存在堆中.</p><h2 id="在CentOS7上部署使用Tomcat"><a href="#在CentOS7上部署使用Tomcat" class="headerlink" title="在CentOS7上部署使用Tomcat"></a>在CentOS7上部署使用Tomcat</h2><p>之前我们已经将相关的环境变量配置好了, 也成功的部署了Tomcat的默认页面, 现在我们来先看一下默认的页面的组织结构:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 host-manager]# tree .</span><br><span class="line">.</span><br><span class="line">├── images</span><br><span class="line">│   ├── add.gif</span><br><span class="line">│   ├── asf-logo.svg</span><br><span class="line">│   ├── code.gif</span><br><span class="line">│   ├── design.gif</span><br><span class="line">│   ├── docs.gif</span><br><span class="line">│   ├── fix.gif</span><br><span class="line">│   ├── tomcat.gif</span><br><span class="line">│   ├── update.gif</span><br><span class="line">│   └── void.gif</span><br><span class="line">├── index.jsp</span><br><span class="line">├── manager.xml</span><br><span class="line">├── META-INF</span><br><span class="line">│   └── context.xml</span><br><span class="line">└── WEB-INF</span><br><span class="line">    ├── jsp</span><br><span class="line">    │   ├── 401.jsp</span><br><span class="line">    │   ├── 403.jsp</span><br><span class="line">    │   └── 404.jsp</span><br><span class="line">    └── web.xml</span><br><span class="line"></span><br><span class="line">4 directories, 16 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个是默认tomcat页面的<code>host-manager</code>的目录结构 从中我们可以得到一个Java Web工程的目录组织结构.</p><p> 一个JavaWeb程序, 都有特定的组织形式, 层次性的目录结构, 从上面也可以看到了. 主要包含了servlet代码文件, jsp页面文件, 类文件, 部署描述符文件等等.</p><p>例如我们在上面看到的, <code>WEB-INF</code>, <code>META-INF</code> 这两个目录是完全大写的, 但是却并不一定是必须要有的, 不过基本上每一个JavaWeb程序都有这个. 其中, 前者是webapp的私有资源目录, 通常存放的是webapp自用的web.xml.而后者基本相似, 存放的是webapp的context.xml</p><p>显然的, 我们这两个目录是不能被访问到的. 另外, 还有<code>classes</code>, 用来存放webapp的私有类的, 以及<code>lib</code>, 这也是webapp的私有类, 但是是被打包成jar格式的类. 当然了, 还有一个webapp的主页, 也就是index.jsp了.</p><p>说完了webapp的组织结构, 接下来我们再来说一下webapp的几种归档格式.</p><ul><li>war webapp</li><li>jar  EJB的类</li><li>rar  资源适配器</li><li>ear  企业级应用程序</li></ul><p>以上就是关于Java的Webapp组织结构的相关了, 接下来我们就来手动添加一个测试应用程序, 步骤如下:</p><ol><li>创建一个webapp的特有的目录结构</li><li>提供webapp的各个文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 webapps]# mkdir myapp</span><br><span class="line">[root@VM-node0 webapps]# cd myapp/</span><br><span class="line">[root@VM-node0 myapp]# mkdir ./&#123;lib,classes,WEB-INF,META-INF&#125; -pv</span><br><span class="line">mkdir: created directory ‘./lib’</span><br><span class="line">mkdir: created directory ‘./classes’</span><br><span class="line">mkdir: created directory ‘./WEB-INF’</span><br><span class="line">mkdir: created directory ‘./META-INF’</span><br><span class="line">[root@VM-node0 myapp]# tree .</span><br><span class="line">.</span><br><span class="line">├── classes</span><br><span class="line">├── lib</span><br><span class="line">├── META-INF</span><br><span class="line">└── WEB-INF</span><br><span class="line"></span><br><span class="line">4 directories, 0 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来就是创建一些必要的文件.</p><p>来随便写一个:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;JSP Test Page&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;% out.println(<span class="string">&quot;Hello, World.&quot;</span>); %&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ok, 接下来我们就来直接访问一下. 默认配置的是自动部署的 我们先不要关心这方面的.</p><p>直接访问的结果:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/tomcat_test.png" alt="tomcat_test"></p><p>结果和我们设想的结果是一致的.</p><p>我们之前说过, webapp中的源文件会被翻译成Java代码和Class文件在<code>work</code>目录下, 我们去看一下吧.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 myapp]# pwd</span><br><span class="line">/usr/local/tomcat/work/Catalina/localhost/myapp</span><br><span class="line">[root@VM-node0 myapp]# tree .</span><br><span class="line">.</span><br><span class="line">└── org</span><br><span class="line">    └── apache</span><br><span class="line">        └── jsp</span><br><span class="line">            ├── index_jsp.class</span><br><span class="line">            └── index_jsp.java</span><br><span class="line"></span><br><span class="line">3 directories, 2 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>已经生成了对应的Java代码和类文件.</p><p>我们部署webapp应用, 其实就是将源文件放置于目标目录, 接着配置tomcat服务器是的能够给予context.xml文件中定义的路径来访问此webapp. 接着通过特有的类来将class loader装载到tomcat.</p><p>主要有两种方式, 也即是自动部署和手动部署, 其实手动部署还有两种, 一个是冷部署, 也就是把webapp复制倒指定位置, 接着再启动tomcat. 另外一个就是热部署, 通过一些manager的部署工具, ant, tcd等. </p><p>除了部署操作, 还有反部署, 重新部署, 停止, 启动等等几种和部署有关的操作. 其中稍微有点疑问的应该就是反部署操作了吧. 这个其实是说停止webapp, 并且从tomcat实例中拆除其部分文件和部署名.</p><h2 id="Tomcat的组件配置"><a href="#Tomcat的组件配置" class="headerlink" title="Tomcat的组件配置"></a>Tomcat的组件配置</h2><p>我们再来看一遍tomcat主配置文件的目录结构.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connector</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connector</span> /&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">engine</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">context</span> /&gt;</span></span><br><span class="line">                ...</span><br><span class="line">            <span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了上面的这些, 还有一些被嵌套的组件, 例如<code>Valve(阀门)</code>. 这个东西可以存在在任何容器类的组件中, 这个东西可以理解成是一种拦截器, 可以用来进行日志收集或者试请求拦截. 另外, 还有日志记录器<code>Logger</code>, 可以存放在Context之外的任何容器中, 用来定义日志是如何存储, 如何记录的. 除此之外, 还有一个用来进行用户身份认证的组件叫做<code>Realm</code>这个在之前也提到过.</p><h3 id="Server-xml"><a href="#Server-xml" class="headerlink" title="Server.xml"></a>Server.xml</h3><p>我们现在就打开<code>server.xml</code>来看一下, 首先还是先复制一份吧 然后更方便进行实验.</p><p>首先我们可以看到默认定义的Server实例, 后面跟上了一个端口和一个shutdown属性. 这是干嘛的? 相信聪明的你一定看出来了, 对. 这是销毁虚拟机的一个接口, 我们可以使用telnet连接过去之后, 输入<code>shutdown</code>属性所定义的语句, tomcat就会销毁虚拟机了, 来试试吧.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 tomcat]# ss -tnl</span><br><span class="line">State      Recv-Q Send-Q                              Local Address:Port                                             Peer Address:Port              </span><br><span class="line">LISTEN     0      100                                     127.0.0.1:25                                                          *:*                  </span><br><span class="line">LISTEN     0      128                                             *:22                                                          *:*                  </span><br><span class="line">LISTEN     0      100                                           ::1:25                                                         :::*                  </span><br><span class="line">LISTEN     0      1                                ::ffff:127.0.0.1:8005                                                       :::*                  </span><br><span class="line">LISTEN     0      100                                            :::8009                                                       :::*                  </span><br><span class="line">LISTEN     0      100                                            :::8080                                                       :::*                  </span><br><span class="line">LISTEN     0      128                                            :::22                                                         :::*                  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个是启动之后的情况, 我们可以看到监听本机的8005端口, 接下来使用telnet去连接并且发送对应的字符串:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 tomcat]# telnet 127.0.0.1 8005</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">SHUTDOWN</span><br><span class="line">Connection closed by foreign host.</span><br><span class="line">[root@VM-node0 tomcat]# ss -tnl</span><br><span class="line">State      Recv-Q Send-Q                              Local Address:Port                                             Peer Address:Port              </span><br><span class="line">LISTEN     0      100                                     127.0.0.1:25                                                          *:*                  </span><br><span class="line">LISTEN     0      128                                             *:22                                                          *:*                  </span><br><span class="line">LISTEN     0      100                                           ::1:25                                                         :::*                  </span><br><span class="line">LISTEN     0      128                                            :::22                                                         :::*                  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看 这样监听的套接字都被释放了, 事实上, 虚拟机都销毁了, 整个tomcat进程其实都没了.</p><p>再往下面看, 我们可以看到tomcat对用户认证相关的属性:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Editable user database that can also be used by</span></span><br><span class="line"><span class="comment">       UserDatabaseRealm to authenticate users</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">&quot;UserDatabase&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;org.apache.catalina.UserDatabase&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">description</span>=<span class="string">&quot;User database that can be updated and saved&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">factory</span>=<span class="string">&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">pathname</span>=<span class="string">&quot;conf/tomcat-users.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里定义了一个全局的命名资源, 创建了一个基于内存的用户数据库, 所对应的配置文件就是<code>conf/tomcat-user.xml</code>.</p><p>再往下走, 我们看到了第一个对于HTTP&#x2F;1.1协议版本的连接器:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在下面的注释中, 还有一个使用https也就是SSL&#x2F;TLS的连接器:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;</span></span><br><span class="line"><span class="comment">           maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;</span></span><br><span class="line"><span class="comment">           clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; /&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>在上面做销毁实例的实验中 我们注意到除了这个服务实例监听的8005端口和HTTP连接器监听的8080端口之外, 还有一个<code>8009</code>端口, 这个端口是干什么的呢? 向下看就可以看到了:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8009&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>就像上面注释写的, 这是一个AJP协议的连接器.</p><blockquote><p>AJP的全称是<code>Apache Jserv Protocol</code>. 这是一个定向包协议, 使用二进制格式来传输可读文本.</p></blockquote><p>接着向下就可以看到我们的Catalina的<code>Engine</code>了, 使用的默认host就是下面定义的<code>localhost</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">prefix</span>=<span class="string">&quot;localhost_access_log.&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.txt&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里省略了注释的部分, 这里的host定义了使用的webapp的目录名称和一些部署选项,例如: 是否自动部署, 解包WAR等. host内部就是我们说的<code>valve</code>, 定义了一个日志的存储格式和存储类型<code>.txt</code></p><h4 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h4><p>在绝大多数的应用场景中, 我们都不会把Tomcat直接面向客户提供服务, 虽然官方说Tomcat是使用event模型开发的. 那么搭配反向代理使用的时候就需要配置一下连接器组件了.</p><p>假设我们的前端服务器是Apache的话, 我们可以使用AJP协议进行通信, 这样更高效. 甚至, 在这种情况下, 我们可以直接关闭HTTP的连接器防止用户直接越过前端服务器访问到. 基本上我们的连接器类型分以下的3种:</p><ul><li>HTTP连接器</li><li>SSL连接器</li><li>AJP连接器</li></ul><p>如果是HTTP类型的连接器, 必须要配置的属性是<code>port</code>, 协议默认就是http, 这就意味着 我们在定义AJP连接器的时候需要定义<code>protocol</code>. 除这两之外, 常用的属性还有:</p><ul><li>address: 连接器定义的监听地址, 默认是0.0.0.0</li><li>maxThreads: 最大并发连接, 默认是200</li><li>redirectPort: HTTP和HTTPS的转发端口, 如果连接器支持的协议是HTTP但是收到了HTTPS请求的话, 就会转发到这个接口.</li><li>connectionTimeout: 顾名思义了, 等到客户端发送请求的超时时长</li><li>enableLookups: 是否进行DNS解析, 默认是true. 这十分耗时间, 一般都会设置成为false</li><li>acceptCount: 设置等待队列的最大长度. 在tomcat所有的处理线程都处于繁忙状态的时候, 新发来的请求就会放置于这个队列中.</li></ul><p>一个SSL连接器的示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8443&quot;</span> <span class="attr">maxThreads</span>=<span class="string">&quot;150&quot;</span> <span class="attr">minSpareThreads</span>=<span class="string">&quot;25&quot;</span> <span class="attr">maxSpareThreads</span>=<span class="string">&quot;75&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">enableLookups</span>=<span class="string">&quot;false&quot;</span> <span class="attr">acceptCount</span>=<span class="string">&quot;100&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;0&quot;</span> <span class="attr">scheme</span>=<span class="string">&quot;https&quot;</span> <span class="attr">secure</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">clientAuth</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sslProtocol</span>=<span class="string">&quot;TLS&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>提个醒, 这里我们还没有配置使用的证书和密钥, tomcat仅仅支持<code>JKS</code>, <code>PKCS11</code> or <code>PKCS12</code>这三种格式的密钥存储格式, 也就是说我们需要先把之前的证书和密钥重新导入进去, 使用形如这样的cmd:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -in mycert.crt -inkey mykey.key</span><br><span class="line">                       -out mycert.p12 -name tomcat -CAfile myCA.crt</span><br><span class="line">                       -caname root -chain</span><br></pre></td></tr></table></figure><blockquote><p>过了很久之后的补充, 通过这种方式我没有正确的配置好SSL访问, 但是连接器是启动了, 8443端口是在监听状态了. 通过查阅了<a href="http://tomcat.apache.org/tomcat-8.5-doc/ssl-howto.html">官方文档</a>, 使用另外一种<code>Apr</code>的方式配置好了, 当然前提是下载了一个so组件, <code>tomcat-native</code>. 在下面贴上一个能够使用的:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8443&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxThreads</span>=<span class="string">&quot;150&quot;</span> <span class="attr">SSLEnabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">scheme</span>=<span class="string">&quot;https&quot;</span> <span class="attr">secure</span>=<span class="string">&quot;true&quot;</span> <span class="attr">SSLenabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">SSLCertificateFile</span>=<span class="string">&quot;conf/tomcat.crt&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">SSLCertificateKeyFile</span>=<span class="string">&quot;conf/key.pem&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">SSLProtocol</span>=<span class="string">&quot;TLSv1+TLSv1.1+TLSv1.2&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">SSLVerifyClient</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Connector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的前提是本机需要安装<code>tomcat-native</code>包</p><h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><p>engine是servlet的运行实例, 他只有三个常用的属性, <code>defaultHost</code>, 默认的虚拟主机实例, <code>name</code>: engine组件的名字, 用于日志和错误信息记录时区别不同的引擎. 最后一个是<code>jvmRoute</code>, 是用来进行集群搭建时用作路由的.</p><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>虚拟主机, 常用的属性有<code>appBase</code>, 就是这个host的webapp目录. <code>autoDeploy</code> 是否进行自动部署, <code>unpackWARs</code> 是否对WAR格式的文档进行解包.</p><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>类似Apache中的路径别名, 一个Context定义用来表示tomcat实例中的web应用程序. 常用的属性有:  <code>docBase</code>, 表示响应的webapp应用程序存放位置. &#96;&#96;reloadable&#96; 是否允许重新加载context相关的web应用程序类, 默认是false.</p><h4 id="Valve"><a href="#Valve" class="headerlink" title="Valve"></a>Valve</h4><p>之前我们就说过了, 这个东西像是一个过滤器,并且可以存在在很多组件之间, 按照Valve定义的次序来决定生效的次序.</p><p>我们有很多种不同的Valve:</p><ul><li>AccessLogValve: 访问日志</li><li>ExtendedAccessValve: 扩展功能的访问日志</li><li>JDBCAccessLogValve: 通过JDBC将访问日志发送到数据库中</li><li>RemoteAddrValve: 远程地址的访问控制</li><li>RemoteHostValve: 远程主机名称的访问控制</li><li>….</li></ul><p>等等.</p><p>一个使用访问控制的Valve示例就像这样子:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</span> <span class="attr">allow</span>=<span class="string">&quot;127\.0\.0\.1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这样子配置就会只允许本机访问了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 conf]# curl -I 192.168.16.100:8080</span><br><span class="line">HTTP/1.1 403 </span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Fri, 21 Sep 2018 09:48:40 GMT</span><br><span class="line"></span><br><span class="line">[root@VM-node0 conf]# curl -I 127.0.0.1:8080</span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Fri, 21 Sep 2018 09:48:48 GMT</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LNMT-amp-LAMT"><a href="#LNMT-amp-LAMT" class="headerlink" title="LNMT &amp; LAMT"></a>LNMT &amp; LAMT</h2><p>首先我们在前端加上一个Nginx实现反向代理.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.16.100:8080/;</span><br><span class="line"><span class="comment">#   root   &quot;/usr/share/nginx/html&quot;;</span></span><br><span class="line"><span class="comment">#   index  index.html index.htm;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就很简单了. 稍微细致一点的话就像这样:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">index</span>  index.jsp index.html;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> <span class="regexp">~* \.(jsp|do)$</span> &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://192.168.16.100:8080/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用Nginx, 我们还有一个选择就是使用httpd. 在使用Apache的选择上 我们就可以使用之前说的AJP协议而不是HTTP协议了. AJP是一个二进制协议, 相较于文本传输的HTTP性能要更好一点. </p><p>要想使用AJP, 要求我们的HTTPD加载模块, 我们来看一下当前加载的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]# httpd -M</span><br><span class="line">...(omitted)</span><br><span class="line"> proxy_ajp_module (shared)</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>这里就装载了我们的ajp协议的代理协议模块. 当然 为了能够开启这个模块, 我们首先需要开开启总反代模块<code>proxy_module</code></p><p>接着我们在配置文件中确认一下:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]# cat /etc/httpd/conf.modules.d/00-proxy.conf </span><br><span class="line"># This file configures all the proxy modules:</span><br><span class="line">LoadModule proxy_module modules/mod_proxy.so</span><br><span class="line">LoadModule lbmethod_bybusyness_module modules/mod_lbmethod_bybusyness.so</span><br><span class="line">LoadModule lbmethod_byrequests_module modules/mod_lbmethod_byrequests.so</span><br><span class="line">LoadModule lbmethod_bytraffic_module modules/mod_lbmethod_bytraffic.so</span><br><span class="line">LoadModule lbmethod_heartbeat_module modules/mod_lbmethod_heartbeat.so</span><br><span class="line">LoadModule proxy_ajp_module modules/mod_proxy_ajp.so</span><br><span class="line">LoadModule proxy_balancer_module modules/mod_proxy_balancer.so</span><br><span class="line">LoadModule proxy_connect_module modules/mod_proxy_connect.so</span><br><span class="line">LoadModule proxy_express_module modules/mod_proxy_express.so</span><br><span class="line">LoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so</span><br><span class="line">LoadModule proxy_fdpass_module modules/mod_proxy_fdpass.so</span><br><span class="line">LoadModule proxy_ftp_module modules/mod_proxy_ftp.so</span><br><span class="line">LoadModule proxy_http_module modules/mod_proxy_http.so</span><br><span class="line">LoadModule proxy_scgi_module modules/mod_proxy_scgi.so</span><br><span class="line">LoadModule proxy_wstunnel_module modules/mod_proxy_wstunnel.so</span><br></pre></td></tr></table></figure><p>确实是启用了模块, 接着我们就可以进行配置一下了: (在虚拟主机中配置)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *<span class="attr">:80</span>&gt;</span></span><br><span class="line">        ServerName test.wyx.com</span><br><span class="line">        ProxyVia On</span><br><span class="line">        ProxyRequests Off</span><br><span class="line">        ProxyPreserveHost On</span><br><span class="line">        <span class="tag">&lt;<span class="name">Proxy</span> *&gt;</span></span><br><span class="line">                Require all granted</span><br><span class="line">        <span class="tag">&lt;/<span class="name">Proxy</span>&gt;</span></span><br><span class="line">        ProxyPass / http://192.168.16.100:8080/</span><br><span class="line">        ProxyPassReverse / http://192.168.16.100:8080/</span><br><span class="line">        <span class="tag">&lt;<span class="name">Location</span> /&gt;</span></span><br><span class="line">                Require all granted</span><br><span class="line">        <span class="tag">&lt;<span class="name">Location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着我们就可以尝试访问了.(顺便贴一下关于Tomcat主机的配置相关)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;test.wyx.com&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;/data/webapps&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;ROOT&quot;</span> <span class="attr">reloadable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">&quot;localhost_access_log&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.txt&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个是在原来的默认Host下面增加的一个, host的名字和上面的ServerName保持一致, 这样会有什么作用呢?</p><p>当我们访问<code>192.168.16.100</code>的时候, 代理出现的页面就是默认的那个Tomcat的首页, 但是当我们访问<code>test.wyx.com</code>的时候, 呈现在我们眼前的就是当前上面配置的那个自定义的jsp页面. 这是因为我们在代理的时候保留了host主机.</p><p>至于AJP协议的使用, 直接在上面的<code>ProxyPass</code>那个地方把协议改成ajp就OK了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java技术体系和tomcat初识</title>
      <link href="/2018/09/14/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E5%92%8Ctomcat%E5%88%9D%E8%AF%86/"/>
      <url>/2018/09/14/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E5%92%8Ctomcat%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>拖了一个学期结果到最后还是要来学习一下的东西…现在看来Java还是绕不过去的一个技术点啊. </p><blockquote><p>Write Once, Run Anywhere</p></blockquote><span id="more"></span><h2 id="来看看Java"><a href="#来看看Java" class="headerlink" title="来看看Java"></a>来看看Java</h2><p>如果说我们把编程语言分成两类: 系统级别和应用级别开发的话, 归属到系统级别的有C, C++, go, erlang等等. 而另外应用级别开发的, 我们可以把C#, Java, Python, Ruby, Perl这些放进去. 对于Ruby, Perl这些, 他们有自己的解释器, 而对于Java和python而言, 这一层面上有一点细微的不同, 他们的解释器或者说虚拟机, 更加底层. 这些虚拟机为这些语言提供了库级别的一些虚拟化.  </p><p>说道Java, 想到的第一点关键字可能就是动态网站. 这里我们所说的动态网站有两种, 一种是客户端动态, 也就是下载源码到本地, 接着借由用户所安装的编译器或者是执行组件来在本地进行加载, 另外一种就是我们的服务端动态网站. 这一种涉及到了一个协议叫做<code>CGI</code> 也就是通用网关接口. 并且同时, 他还引入了webapp server的概念, 例如, 能够运行jsp的容器有: tomcat, jboss, jetty 运行PHP的php-fpm等等.</p><p>Java也就是一种一个应用型语言, 最初是由SUN公司开发的. 并且Java语言诞生的缘由其实是为了开发机顶盒. 在上世纪90年代, web服务器技术正在兴起, 而HTML这种静态内容就显得不是这么满意, 于是这个环境下, 就希望能够获得一些动态的展示效果, 而Java一次编译到处运行的特点就显得十分合适, 只要安装了Java虚拟机, 就可以运行Java程序. </p><p>但是, 这种情况下, 如果有人开发了一些恶意的程序试图劫持客户机的话, 是十分容易就会成功的, 因此这种Applet技术就很快的没有了.  由客户端运行不行, 但是由服务端就行了啊. 所以后来这种技术又重新被使用了起来.</p><p>在1995年, 发布了Java的第一个版本Java1.0. 一年后发布了第一个版本的Java开发包, 即JDK. 并且包含了一个JVM, 但是这里的JVM性能低下启动速度缓慢, 此时包中包含了除了上面的JVM, 还包括Applet和AWT.</p><p>Sun把Java分成了三个方向, 这个时候Java是第二版所以就是Java 2. 而这三个就是我们熟知的: <code>J2EE</code>, <code>J2SE</code>, <code>J2ME</code>. 这其中最失败就是最后一个, 也就是移动端. 事实上, 我们现在使用的Java虚拟机, 并不是上面出现的那个JVM, 我们把上面的那个虚拟机命名为<code>Sun Classic VM</code>. 我们现在使用的虚拟机主要是由HotSpot所研发的.</p><p>到了2006年, Sun开源了Java技术, 遵循GPL规范, 并且建立了OpenJDK组织来管理这些代码. 到JDK1.7两者基本没有实质性的变化. 我们在Linux所下载的JDK版本其实就是OpenJDK版本的. </p><h2 id="Java体系结构"><a href="#Java体系结构" class="headerlink" title="Java体系结构"></a>Java体系结构</h2><p>对于我们今天要说的Java体系结构, 主要有这些:</p><ul><li>Java编程语言</li><li>Java Class文件格式</li><li>Java API</li><li>Java VM</li></ul><p>对于Java代码而言, 我们为了能够运行, 需要一个编译器的帮助, 将我们所编写的源代码编译成字节码文件, 也叫做Java类文件, 这些我们自己编写源代码生成的类文件可能也会需要引入java一些内置的类, 这些类也同样都是class文件. 接着我们的jvm同样引入这些字节码文件(其实就是api), 一起放在执行引擎里运行, 最后还是需要调用C库和系统调用来实现各项功能.</p><p>考虑到不同操作系统的运行库不一样, 并且还有很多系统调用层面上的差异, 我们的Java API也是需要调用不同的本地方法的. 这样看来, Java的API就更像是一个<strong>翻译官</strong>. </p><p>接下来我们就来看一下JVM的一些核心组成部分, 我们知道作为一个加载运行类文件肯定是要有一个<code>boot loader</code>和执行引擎的. 如果我们运行多个Java程序, 他们所使用的Java虚拟机都是一样的, 这些程序运行所需要的内存空间都是由JVM申请和管理的, 这也就意味着, 我们在写Java程序的时候是不需要考虑到内存空间的组织的, 但是对于Java程序而言, 由于这些内存空间的操作是由JVM来进行的, 也就是说程序员不要进行内存的管理. JVM有自己的垃圾回收机制, 主要面向堆空间, 因为我们的对象创建都在堆内存中.</p><p>那么这个虚拟机运行时主要分成两种模式: 守护线程和非守护线程两种, 所有用户创建的都是作为非守护线程存在的, 只有那些类似垃圾回收机制的服务才是守护线程. 刚刚我们说了JVM的堆内存, 除了堆区域, JVM运行时区域还有别的:</p><ul><li>方法区: 线程共享, 用于存储被加载的类信息. 常量, 静态变量等等</li><li>Java栈: 这些就是线程私有的, 存放线程自己的局部变量等信息</li><li>PC寄存器: 线程独占的内存空间</li><li>本地方法栈</li></ul><p>不过扯了这么多, 其实最后是想说的是对于Java服务端应用的实现, 是通过将html标签硬编码到应用程序中, 也就是我们熟悉的<code>JSP</code>. 而服务端想要实现这种, 就一定需要Web Container的帮助.  </p><h3 id="JSP的运行过程"><a href="#JSP的运行过程" class="headerlink" title="JSP的运行过程"></a>JSP的运行过程</h3><p>首先来看这么一个过程图吧:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/jsp_processing.png" alt="jsp_processing"></p><p>首先客户发出请求, 请求达到我们的包含JSP容器的Web服务器的时候, 会去从磁盘上取得请求的源文件, 接着通过翻译将我们的jsp代码转换成为java源文件, 最后通过编译会得到字节码文件, 继而将字节码文件回到JSP容器中执行得到结果返回给客户端.</p><p>现在说来, 对于JSP容器的开源实现主要有三个, <code>Tomcat</code>, <code>Resin</code>和<code>jetty</code>. 其中就tomcat7.0,Jetty7和Resin3.1的比较, 相对来说Resin是性能最高的一个, 还支持负载均衡. 不过仅仅可用来做开源和学习目的. 而Jetty是相对来说性能最不好的那一个. </p><p>接下来我们就来进入今天的主题吧, 来了解下Tomcat.</p><h2 id="Tomcat初识"><a href="#Tomcat初识" class="headerlink" title="Tomcat初识"></a>Tomcat初识</h2><p>Tomcat包含了三个组件, 分别是迎来提供servlet容器的<code>Catalina</code>, 用来做HTTP协议的连接器的<code>Coyote</code>, 以及一个JSP引擎<code>Jasper</code>. 而Tomcat就是使用Java语言进行的开发. </p><p>接下来我们来看一下Tomcat的组成部分, 首先最外层的肯定就是Server组件, 接着内层是一个服务提供组件, 再向内层就是engine组件, 而每一个engine又可以包含多个Host组件, 每一个Host中就是各种上下文环境的配置了, 而之前说的连接器则可以连接Server, Service和Engine, 接受解析用户的请求, 接着映射到内部组件中.</p><p>由于Tomcat是使用Java语言进行开发的, 所以面向对象的思想会体现在Tomcat中. 例如, 我们上面说的Server就相当于是一个Tomcat实例, 每启动一个Tomcat就相当于是一个新的实例被生成.</p><p>Tomcat最核心的组件就是engine组件, 他是用来执行jsp或者servlet代码的, 但是由于engine无法去接受和处理用户的请求, 所以就需要一个连接器来实现, 但是这个连接器接受并且解析到了用户的请求但是确保没有办法把这个传达给Engine, 所以这个时候就有需要一个辅助的组件, 也就是Service. Service负责将连接器处理的结果传达给engine组件. 一个engine组件可以拥有多个连接器, 但是一个连接器只能跟一个engine建立关系. 正因为此, 每一个Service里面只能有一个engine组件. 最后还差一个Host组件, 这个东西可以近乎用httpd中的虚拟主机来理解. 至于Context就是类似httpd中的alias.</p><p>以上就是各个组件之间的关系. 每一个组件都使用<strong>类</strong>来实现.</p><p>使用大概XML格式的配置文件来表示的话就是:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connector</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connector</span> /&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">engine</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">context</span> /&gt;</span></span><br><span class="line">                ...</span><br><span class="line">            <span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这也就是配置文件的组织结构框架.</p><p>由于Tomcat是存在web server的, 所以支持standalone模式运行, 只不过说到底, tomcat需要维护内部的JSP代码运行, 如果还要再消耗资源来控制web服务器的并发的话, 是一件非常累的事情. ( 不过,tomcat的http server是使用Java内置的线程模型开发的, 所以并发效果还是可以的. 不过我们还是要专人专事的原则. ) 所以一般情况下, 我们使用反向代理的方式来运行. 例如在前端加上一个Nginx或者httpd. 更进阶的, 我们进行独立网络配置, 分开主机来进行, 只不过在这种时候, 我们就需要考虑之前说的关于session保持的问题了.</p><p>事实上, 上面说的三种运行模式, 就是tomcat支持的三种运行模式:</p><ul><li>standalone: 通过内置的web server来处理用户请求</li><li>proxy: 由专门的web server服务客户端的http请求<ul><li>in-process: 同一主机</li><li>network: 不同主机</li></ul></li></ul><h2 id="Tomcat安装和使用"><a href="#Tomcat安装和使用" class="headerlink" title="Tomcat安装和使用"></a>Tomcat安装和使用</h2><p>如果直接使用yum进行安装的话, 则使用的tomcat版本是7.0. 据说这个版本是目前比较稳定的一个. 如果嫌这个版本过于旧, 则可以到官方站点去下载二进制包直接解压使用. </p><p>需要说明的是, 由于tomcat是使用Java开发的, 因此我们还需要下载Java的开发工具包, 不过这都是很简单的了, 我们直接跳过吧. 但是给个小提醒, Linux下当然是可以进行多版本的Java共存的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]# cd /usr/java/</span><br><span class="line">[root@VM-node0 java]# ls -lh</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root  16 Sep 15 16:18 default -&gt; /usr/java/latest</span><br><span class="line">drwxr-xr-x 8 root root 258 Sep 15 16:18 jdk1.8.0_181-amd64</span><br><span class="line">lrwxrwxrwx 1 root root  28 Sep 15 16:18 latest -&gt; /usr/java/jdk1.8.0_181-amd64</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里有两个链接,  可以看到, 默认使用的就是最新版本的java, 而这个最新的指向就是我们安装的1.8版本. 另外, 和Windows一样, 你也需要配置环境变量, 我们在<code>/etc/profile.d</code>下面创建一个新的脚本文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/default</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>这里我们使用的是默认版本的Java, 你也可以指向最新的或者是指定版本的. </p><p>使用-version选项, 可以查看当前的Java版本和对应使用的虚拟机的版本. 例如我的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]# java -version</span><br><span class="line">java version &quot;1.8.0_181&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_181-b13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到使用的是混合模式的HotSpot虚拟机. </p><p>除此之外, 我们还需要配置一下Catalina的环境变量, 也就是<code>CATALINA_HOME</code>. 配置结束之后, 我们重读一下刚刚创建的两个新shell脚本, 之后就可以使用tomcat的一些内置脚本了, 例如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]# version.sh </span><br><span class="line">Using CATALINA_BASE:   /usr/local/tomcat</span><br><span class="line">Using CATALINA_HOME:   /usr/local/tomcat</span><br><span class="line">Using CATALINA_TMPDIR: /usr/local/tomcat/temp</span><br><span class="line">Using JRE_HOME:        /usr/java/default</span><br><span class="line">Using CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar</span><br><span class="line">Server version: Apache Tomcat/8.5.34</span><br><span class="line">Server built:   Sep 4 2018 22:28:22 UTC</span><br><span class="line">Server number:  8.5.34.0</span><br><span class="line">OS Name:        Linux</span><br><span class="line">OS Version:     3.10.0-862.11.6.el7.x86_64</span><br><span class="line">Architecture:   amd64</span><br><span class="line">JVM Version:    1.8.0_181-b13</span><br><span class="line">JVM Vendor:     Oracle Corporation</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这会显示当前tomcat的一些环境变量, 系统信息和使用的Java虚拟机版本.</p><p>除此之外, 我们可以使用一个统一的脚本通过传递参数来实现不同的功能, 这个脚本就是<code>catalina.sh</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 tomcat]# ls bin/</span><br><span class="line">bootstrap.jar  catalina-tasks.xml            configtest.bat  digest.bat        setclasspath.sh  startup.bat      tomcat-native.tar.gz  version.bat</span><br><span class="line">catalina.bat   commons-daemon.jar            configtest.sh   digest.sh         shutdown.bat     startup.sh       tool-wrapper.bat      version.sh</span><br><span class="line">catalina.sh    commons-daemon-native.tar.gz  daemon.sh       setclasspath.bat  shutdown.sh      tomcat-juli.jar  tool-wrapper.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以通过传递一个help参数来看看支持哪些:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 tomcat]# catalina.sh --help</span><br><span class="line">Using CATALINA_BASE:   /usr/local/tomcat</span><br><span class="line">Using CATALINA_HOME:   /usr/local/tomcat</span><br><span class="line">Using CATALINA_TMPDIR: /usr/local/tomcat/temp</span><br><span class="line">Using JRE_HOME:        /usr/java/default</span><br><span class="line">Using CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar</span><br><span class="line">Usage: catalina.sh ( commands ... )</span><br><span class="line">commands:</span><br><span class="line">  debug             Start Catalina in a debugger</span><br><span class="line">  debug -security   Debug Catalina with a security manager</span><br><span class="line">  jpda start        Start Catalina under JPDA debugger</span><br><span class="line">  run               Start Catalina in the current window</span><br><span class="line">  run -security     Start in the current window with security manager</span><br><span class="line">  start             Start Catalina in a separate window</span><br><span class="line">  start -security   Start in a separate window with security manager</span><br><span class="line">  stop              Stop Catalina, waiting up to 5 seconds for the process to end</span><br><span class="line">  stop n            Stop Catalina, waiting up to n seconds for the process to end</span><br><span class="line">  stop -force       Stop Catalina, wait up to 5 seconds and then use kill -KILL if still running</span><br><span class="line">  stop n -force     Stop Catalina, wait up to n seconds and then use kill -KILL if still running</span><br><span class="line">  configtest        Run a basic syntax check on server.xml - check exit code for result</span><br><span class="line">  version           What version of tomcat are you running?</span><br><span class="line">Note: Waiting for the process to end and use of the -force option require that $CATALINA_PID is defined</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后我们来看看Tomcat的目录结构吧, 大体上都是见名知意的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 tomcat]# tree . -L 1</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">├── BUILDING.txt</span><br><span class="line">├── conf</span><br><span class="line">├── CONTRIBUTING.md</span><br><span class="line">├── lib</span><br><span class="line">├── LICENSE</span><br><span class="line">├── logs</span><br><span class="line">├── NOTICE</span><br><span class="line">├── README.md</span><br><span class="line">├── RELEASE-NOTES</span><br><span class="line">├── RUNNING.txt</span><br><span class="line">├── temp</span><br><span class="line">├── webapps</span><br><span class="line">└── work</span><br><span class="line"></span><br><span class="line">7 directories, 7 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中, bin就是我们使用的脚本所在和启动时候需要使用到的类, lib就是他的类库,. 而conf则是配置文件存放目录, logs就是日志文件, webapps就是应用程序的默认部署目录, work则是将原始代码转化之后的存放目录, 每一次的源代码的变化就会导致这个目录内容的变化, 最后的temp就是临时文件目录.</p><p>直接通过<code>catalina.sh start</code>就可以启动tomcat, 默认的监听端口是8080, 所以你要保证别出现冲突了.</p><p>现在我们稍微来说一下关于Tomcat的配置文件, 至于更详细的配置我们下次再来说.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 tomcat]# tree conf/</span><br><span class="line">conf/</span><br><span class="line">├── Catalina</span><br><span class="line">│   └── localhost</span><br><span class="line">├── catalina.policy # 这个就是再执行安全管理的情况下加载的安全运行策略</span><br><span class="line">├── catalina.properties # 用于设定Java相关的参数和对于JVM的调优相关</span><br><span class="line">├── context.xml # 每一个webapp的默认配置, 如果在app自己的`WEB-INF`目录下没有自己的配置, 就会使用这个</span><br><span class="line">├── jaspic-providers.xml</span><br><span class="line">├── jaspic-providers.xsd</span><br><span class="line">├── logging.properties # 配置日志记录等</span><br><span class="line">├── server.xml # 主配置文件</span><br><span class="line">├── tomcat-users.xml # 对于用户认证的账号和密码配置</span><br><span class="line">├── tomcat-users.xsd</span><br><span class="line">└── web.xml # 为每个WebApp提供部署配置</span><br><span class="line"></span><br><span class="line">2 directories, 10 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Varnish的状态引擎和VCL</title>
      <link href="/2018/09/10/Varnish%E7%9A%84%E7%8A%B6%E6%80%81%E5%BC%95%E6%93%8E%E5%92%8CVCL/"/>
      <url>/2018/09/10/Varnish%E7%9A%84%E7%8A%B6%E6%80%81%E5%BC%95%E6%93%8E%E5%92%8CVCL/</url>
      
        <content type="html"><![CDATA[<p>接下来我们就来更加深入的来看一下Varnish的相关.</p><span id="more"></span><p>我们之前已经通过使用Varnish所提供的命令行工具进行了一些基本的配置. 并且还知道可以通过对<code>varnish.param</code>文件的配置来操作他启动的一些行为参数.</p><p>Varnish的缓存功能配置主要都是通过编译和执行vcl来进行操作的, 那么为了能够操作Varnish进行负载均衡, 是否进行对Backend服务器群的健康状态检测等等, 就需要通过VCL来进行定义了.</p><h2 id="状态引擎"><a href="#状态引擎" class="headerlink" title="状态引擎"></a>状态引擎</h2><p>VCL是一种域配置文件, 因此我们对VCL的配置操作对象就是很多类似我们代码块一样的东西, 只不过这里被叫做<strong>域</strong>. 这里我们就可以引入varnish的状态引擎了.</p><p>那么什么是状态引擎呢, 这个可以类比我们之前学习过的<code>netfilter</code>的钩子函数. 由于到达我们varnish的请求可能是请求静态资源的, 可能是请求动态资源的, 也有可能是非法访问, 还有可能是请求的方法不支持或者不允许. 这么多情况, 他们都需要不同的应对措施, 这个就是varnish的状态引擎.</p><p>首先我们来看一下V3版本的状态引擎吧:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/varnish_statusV3.png" alt="varnish_statusV3"></p><p>这个图是一个简化版本, 类似流程图一样的东西. 这里的每一个矩形都代表一个状态引擎.</p><p>从图中, 我们可以很清楚的看到, 当用户的请求达到时, 我们的<code>vcl_recv</code>引擎先来进行处理, 如果请求的对象是可以被缓存的,那么就会去到下一个状态引擎, 如果不能被缓存. 那就会变得很简单了, 请求将会直接到达<code>vcl_fetch</code>状态, 由这个引擎来负责去后端服务器来取得数据.最后交给<code>vcl_deliver</code>来返回给用户.</p><p>如果之前的状态是<code>vcl_hash</code>. Varnish就会在自己的缓存空间中进行寻找, 如果可以找到,  就会进入命中状态, 如果没有就是miss状态, 接着交给fetch状态引擎去后台服务器取得数据, 然后一边缓存到自己的空间中, 一边将结果返回给用户.</p><p>这里我们也可以看到, 各个引擎之间是存在相关性的, 前一个engine如果可以有多个下游engine, 则上游需要使用return来指明要转移的下游engine.</p><p> 接下来我们来看一下完全版的一个WORKFLOW:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/varnish_statusV4.png" alt="varnish_statusV4"></p><p>我们刚刚说过, 上一个engine使用return来返回下一个engine, 这里我们就能看到, 根据<code>vcl_recv</code>所返回的值不同, 到达的下一个engine也不一样. 例如说, 如果说用户发送过来的请求是不可缓存的, 那就没与必要去自己的缓存空间里寻找了, 于是就会返回pass, 直接到达<code>vcl_pass</code>. </p><blockquote><p>VCL的语法:</p><p>这里我们稍微穿插一点关于VCL语法的小东西: 对于每一个状态引擎, 我们通过使用<code>sub</code>关键字来声明, 例如说, 如果对<code>vcl_recv</code>进行操作, 就需要有类似下面的声明语句:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sub vcl_recv &#123;</span><br><span class="line"><span class="comment">// 这是注释</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 这里使用了双斜线来注释, 除此之外, 还可以通过<code>#</code>, <code>/* foo */</code>来实现单行和多行注释.</p><p>对于每一个Varnish的状态引擎, 都要很多内部定义好的内置变量供你调用, 这些变量他们的使用都是限制在状态里的(state-limited), 另外, vcl没有循环语句, 但是存在条件判断和分支语句.</p><p>通过在域中使用<code>return</code>函数来进行状态引擎的跳转. 除此之外, 还有很多内置函数, 具体就需要查阅官方的文档了.</p><p>操作符包括: <code>=, ==, ~, !, &amp;&amp;, ||</code>.</p></blockquote><p>现在我们来看一个典型的vcl配置:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sub vcl_recv &#123;</span><br><span class="line">    <span class="keyword">if</span>(req.restarts == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (req.http.x-forwarded-<span class="keyword">for</span>) &#123;</span><br><span class="line">            <span class="built_in">set</span> req.http-X-Forwarded-For = </span><br><span class="line">                req.http.X-Forwarded-For + <span class="string">&quot;,&quot;</span> + client.ip;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">set</span> req.http.X-Forwarded-For = client.ip;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (req.request != <span class="string">&#x27;GET&#x27;</span> &amp;&amp; req.request != <span class="string">&quot;HEAD&quot;</span> &amp;&amp;</span><br><span class="line">        req.request != <span class="string">&quot;PUT&quot;</span> &amp;&amp; req.request != <span class="string">&quot;POST&quot;</span> &amp;&amp;</span><br><span class="line">       req.request != <span class="string">&quot;POST&quot;</span> &amp;&amp; rq.request != <span class="string">&quot;TRACE&quot;</span> &amp;&amp;</span><br><span class="line">        req.request != <span class="string">&quot;OPTIONS&quot;</span> &amp;&amp; req.request != <span class="string">&quot;DELETE&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (pipe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (req.request != <span class="string">&quot;GET&quot;</span> &amp;&amp; req.request != <span class="string">&quot;HEAD&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (pass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (lookup);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该还是挺好看懂的吧. 设置变量的关键字就是<code>set</code>. </p><p>假如说现在我们的请求到达了上面vcl的最后一句<code>return (lookup)</code>, 也就是到达了下一个状态引擎<code>vcl_hash</code>, 这里会发生什么呢? 同样我们还是看一个示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sub vcl_hash &#123;</span><br><span class="line">    hash_data(req.url);</span><br><span class="line">    <span class="keyword">if</span> (req.http.post) &#123;</span><br><span class="line">        hash_data(req.http.host);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hash_data(server.ip);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算得到hash, 也即是缓存的键之后就可以去尝试命中缓存了.</p><p>接下来的过程就省略掉了, 我们直接来小结一下, 各个状态引擎的工作流:</p><ul><li>vcl_recv -&gt; vcl_hash -&gt; vcl_hit -&gt; vcl_deliver 理想的状态, 命中缓存</li><li>vcl_recv -&gt; vcl_hash -&gt; vcl_miss -&gt; vcl_fetch -&gt; vcl_deliver 请求的资源可以缓存但是没有命中缓存</li><li>vcl_recv -&gt; vcl_pass -&gt; vcl_fetch -&gt; vcl_deliver 请求的资源无法被缓存, 直接到后台服务器去取数据</li><li>vcl_recv -&gt; vcl_pipe 请求不能理解, 直接发送到后端服务器</li></ul><p>顺便一提, 我们这里列出来的状态引擎仍然不全, 这里列出来的只是前端处理的engine, 之前我们在说到varnish的子进程的时候, 提到过, 有一个专门负责和后台服务器进行交互的进程, 这个进程的状态引擎幼又包括: <code>vcl_backend_fetch</code>, <code>vcl_backend_response</code>, <code>vcl_backend_error</code>. 另外还有用来进行缓存删除的状态引擎: <code>vcl_synth</code>和<code>vcl_purge</code>.</p><p>最后, 我们来看一下官方给出的图:</p><p><img src="http://book.varnish-software.com/4.0/_images/detailed_fsm.svg" alt="Varnish_workflow"></p><p>接下来我们把官方给出的<code>vcl_recv</code>的示例拷贝到我们的配置文件中, 也即是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sub vcl_recv &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.method == <span class="string">&quot;PRI&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">/* We do not support SPDY or HTTP/2.0 */</span></span><br><span class="line">        <span class="keyword">return</span> (synth(<span class="number">405</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (req.method != <span class="string">&quot;GET&quot;</span> &amp;&amp;</span><br><span class="line">      req.method != <span class="string">&quot;HEAD&quot;</span> &amp;&amp;</span><br><span class="line">      req.method != <span class="string">&quot;PUT&quot;</span> &amp;&amp;</span><br><span class="line">      req.method != <span class="string">&quot;POST&quot;</span> &amp;&amp;</span><br><span class="line">      req.method != <span class="string">&quot;TRACE&quot;</span> &amp;&amp;</span><br><span class="line">      req.method != <span class="string">&quot;OPTIONS&quot;</span> &amp;&amp;</span><br><span class="line">      req.method != <span class="string">&quot;DELETE&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">/* Non-RFC2616 or CONNECT which is weird. */</span></span><br><span class="line">        <span class="keyword">return</span> (pipe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (req.method != <span class="string">&quot;GET&quot;</span> &amp;&amp; req.method != <span class="string">&quot;HEAD&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">/* We only deal with GET and HEAD by default */</span></span><br><span class="line">        <span class="keyword">return</span> (pass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (req.http.Authorization || req.http.Cookie) &#123;</span><br><span class="line">        <span class="comment">/* Not cacheable by default */</span></span><br><span class="line">        <span class="keyword">return</span> (pass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们复制一份配置文件, 然后使用varnish的命令行工具来进行载入:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vcl.list</span><br><span class="line">200        </span><br><span class="line">active          0 boot</span><br><span class="line"></span><br><span class="line">vcl.load test1 new.vcl</span><br><span class="line">200        </span><br><span class="line">VCL compiled.</span><br><span class="line">vcl.list</span><br><span class="line">200        </span><br><span class="line">active          0 boot</span><br><span class="line">available       0 test1</span><br><span class="line">                           </span><br><span class="line"><span class="meta prompt_">varnish&gt; </span><span class="language-bash">vcl.use test1</span></span><br><span class="line">200        </span><br><span class="line">VCL &#x27;test1&#x27; now active</span><br><span class="line">vcl.list </span><br><span class="line">200        </span><br><span class="line">available       0 boot</span><br><span class="line">active          0 test1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先我们使用<code>load</code>来编译这个VCL, 接着再声明我们使用它就行了. 还可以通过<code>show</code>命令来查看当前的VCL的内容.</p><p>但是这个默认行为我们更换之后还是没法看出效果, 现在我们来对<code>vcl_deliver</code>这个地方来进行一些设定:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sub vcl_deliver &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hits &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">set</span> resp.http.X-Cache = <span class="string">&quot;HIT&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">set</span> resp.http.X-Cache = <span class="string">&quot;MISS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加进去之后我们再通过load和use命令来使得新修改的vcl文件生效.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vcl.<span class="built_in">list</span></span><br><span class="line"><span class="number">200</span>        </span><br><span class="line">available       <span class="number">0</span> boot</span><br><span class="line">active          <span class="number">0</span> test1</span><br><span class="line"></span><br><span class="line">vcl.load test2 new.vcl</span><br><span class="line"><span class="number">200</span>        </span><br><span class="line">VCL compiled.</span><br><span class="line">vcl.use test2</span><br><span class="line"><span class="number">200</span>        </span><br><span class="line">VCL <span class="string">&#x27;test2&#x27;</span> now active</span><br><span class="line">vcl.<span class="built_in">list</span></span><br><span class="line"><span class="number">200</span>        </span><br><span class="line">available       <span class="number">0</span> boot</span><br><span class="line">available       <span class="number">0</span> test1</span><br><span class="line">active          <span class="number">0</span> test2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来我们来使用curl进行模拟请求, 现在后台Web服务器上新建一些客户端没有访问过的新页面:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 html]# for n in &#123;1..10&#125;; do echo &quot;&lt;h1&gt;Web Page $n on WebServer1&lt;/h1&gt;&quot; &gt; test$n.html; done</span><br><span class="line">[root@VM-node0 html]# ls</span><br><span class="line">forum  index.html  index.php  test10.html  test1.html  test2.html  test3.html  test4.html  test5.html  test6.html  test7.html  test8.html  test9.html  wordpress</span><br></pre></td></tr></table></figure><p>接下来就来使用curl进行请求,请求的效果如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]# curl -I 192.168.16.100:6081/index.html </span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Wed, 12 Sep 2018 01:25:26 GMT</span><br><span class="line">Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/5.4.16</span><br><span class="line">Last-Modified: Fri, 20 Oct 2017 16:27:33 GMT</span><br><span class="line">ETag: &quot;19-55bfcf32d89d7&quot;</span><br><span class="line">Content-Length: 25</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">X-Varnish: 32770 3</span><br><span class="line">Age: 6</span><br><span class="line">Via: 1.1 varnish-v4</span><br><span class="line">X-Cache: HIT</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">[root@VM-node1 ~]# curl -I 192.168.16.100:6081/test1.html</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Wed, 12 Sep 2018 01:25:39 GMT</span><br><span class="line">Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/5.4.16</span><br><span class="line">Last-Modified: Wed, 12 Sep 2018 01:23:29 GMT</span><br><span class="line">ETag: &quot;22-575a2701b26a4&quot;</span><br><span class="line">Content-Length: 34</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">X-Varnish: 7</span><br><span class="line">Age: 0</span><br><span class="line">Via: 1.1 varnish-v4</span><br><span class="line">X-Cache: MISS</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">[root@VM-node1 ~]# curl -I 192.168.16.100:6081/test1.html</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Wed, 12 Sep 2018 01:25:39 GMT</span><br><span class="line">Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/5.4.16</span><br><span class="line">Last-Modified: Wed, 12 Sep 2018 01:23:29 GMT</span><br><span class="line">ETag: &quot;22-575a2701b26a4&quot;</span><br><span class="line">Content-Length: 34</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">X-Varnish: 32772 8</span><br><span class="line">Age: 1</span><br><span class="line">Via: 1.1 varnish-v4</span><br><span class="line">X-Cache: HIT</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以很清晰的看到我们自定义的头部被添加到了响应头中, 并且第一次访问<code>test1.html</code>的时候, 我们的状态是没有命中的, 但是在第二次访问的时候我们就是命中缓存了. </p><h2 id="VCL参考"><a href="#VCL参考" class="headerlink" title="VCL参考"></a>VCL参考</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>来说明一下上面添加的<code>obj.hit</code>是什么意思呢, 很简单. 这个参数记录着请求的对象命中缓存的次数. 更多的对象和参数解释可以在下面的网站得到参考:</p><p><a href="https://varnish-cache.org/docs/4.1/reference/vcl.html#variables">Varnish参考-变量</a></p><p>我们接下来整理一下这些变量的类型有哪些, 以及这些变量都是如何抽象的:</p><ul><li>req: 就是用户发送过来的请求</li><li>bereq: 对后端服务器发送过去的请求</li><li>resp: 向用户发送的响应对象</li><li>bresp: 后端服务器发送过来的响应对象</li><li>storage: 对于我们从缓存存储空间的抽象</li><li>obj: 请求的对象</li><li>client: 用户和客户端</li><li>server: 就是varnish自己</li></ul><p>更多的信息还是直接在官方站点上进行参考. 这里我们就列举一些比较常用的属性在这里:</p><h4 id="bereq"><a href="#bereq" class="headerlink" title="bereq"></a>bereq</h4><p>bereq.http.HEADERS: 由Varnish发往backend server的请求报文的指定首部.</p><p>bereq.request: 请求方法</p><p>bereq.url: 所请求的目标URL</p><p>bereq.proto: 向后端服务器请求的协议版本</p><p>bereq.backend: 请求的后端主机</p><h4 id="beresp"><a href="#beresp" class="headerlink" title="beresp"></a>beresp</h4><p>beresp.proto: 后端服务器返回的协议版本</p><p>beresp.status: 响应状态吗</p><p>beresp.reason: 原因短语, 就是跟在我们的状态码之后的那个字符串</p><p>beresp.backend.ip: </p><p>beresp.backend.name:</p><p>beresp.http.HEADER: 从后端服务器所响应的报文的首部</p><p>beresp.ttl: 后端服务器响应的内容的剩余时间</p><h4 id="obj"><a href="#obj" class="headerlink" title="obj"></a>obj</h4><p>obj.hits: 对象的命中次数</p><p>obj.ttl:  对象的ttl值.</p><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>server.ip: </p><p>server.hostname:</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ban(expression)</span><br><span class="line"></span><br><span class="line">Invalidates all objects in cache that match the expression with the ban mechanism.</span><br><span class="line"></span><br><span class="line">hash_data(input)</span><br><span class="line"></span><br><span class="line">Adds an input to the hash input. In the built-in VCL hash_data() is called on the host and URL of the request. Available in vcl_hash.</span><br><span class="line"></span><br><span class="line">rollback()</span><br><span class="line"></span><br><span class="line">Restore req HTTP headers to their original state. This function is deprecated. Use std.rollback() instead.</span><br><span class="line"></span><br><span class="line">synthetic(STRING)</span><br><span class="line"></span><br><span class="line">Prepare a synthetic response body containing the STRING. Available in vcl_synth and vcl_backend_error.</span><br><span class="line"></span><br><span class="line">regsub(str, regex, sub)</span><br><span class="line"></span><br><span class="line">Returns a copy of str with the first occurrence of the regular expression regex replaced with sub. Within sub, \0 (which can also be spelled \&amp;) is replaced with the entire matched string, and \n is replaced with the contents of subgroup n in the matched string.</span><br><span class="line"></span><br><span class="line">regsuball(str, regex, sub)</span><br><span class="line"></span><br><span class="line">As regsub() but this replaces all occurrences.</span><br></pre></td></tr></table></figure><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>我们可以使用正则表达式进行字符模式的匹配, 例如这样的一个例子, 当用户访问某个特别的页面时, 即使我们存在缓存, 但是我还是不想让他调用缓存, 而是还是从后端服务器取得结果.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (req.url ~ <span class="string">&quot;^/test7.html$&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (pass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如这里, 我们使用一个<code>~</code>来声明下面的字符串是模式匹配, 这样造成的效果就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 conf]# curl -I 192.168.16.100:6081/test3.html</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Wed, 12 Sep 2018 03:08:45 GMT</span><br><span class="line">Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/5.4.16</span><br><span class="line">Last-Modified: Wed, 12 Sep 2018 01:23:29 GMT</span><br><span class="line">ETag: &quot;22-575a2701b26a4&quot;</span><br><span class="line">Content-Length: 34</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">X-Varnish: 32776</span><br><span class="line">Age: 0</span><br><span class="line">Via: 1.1 varnish-v4</span><br><span class="line">X-Cache: MISS of 192.168.16.100</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">[root@VM-node1 conf]# curl -I 192.168.16.100:6081/test3.html</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Wed, 12 Sep 2018 03:08:45 GMT</span><br><span class="line">Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/5.4.16</span><br><span class="line">Last-Modified: Wed, 12 Sep 2018 01:23:29 GMT</span><br><span class="line">ETag: &quot;22-575a2701b26a4&quot;</span><br><span class="line">Content-Length: 34</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">X-Varnish: 13 32777</span><br><span class="line">Age: 1</span><br><span class="line">Via: 1.1 varnish-v4</span><br><span class="line">X-Cache: HIT from 192.168.16.100</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">[root@VM-node1 conf]# curl -I 192.168.16.100:6081/test7.html</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Wed, 12 Sep 2018 03:10:14 GMT</span><br><span class="line">Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/5.4.16</span><br><span class="line">Last-Modified: Wed, 12 Sep 2018 01:23:29 GMT</span><br><span class="line">ETag: &quot;22-575a2701b26a4&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 34</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">X-Varnish: 32784</span><br><span class="line">Age: 0</span><br><span class="line">Via: 1.1 varnish-v4</span><br><span class="line">X-Cache: MISS of 192.168.16.100</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">[root@VM-node1 conf]# curl -I 192.168.16.100:6081/test7.html</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Wed, 12 Sep 2018 03:10:15 GMT</span><br><span class="line">Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/5.4.16</span><br><span class="line">Last-Modified: Wed, 12 Sep 2018 01:23:29 GMT</span><br><span class="line">ETag: &quot;22-575a2701b26a4&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 34</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">X-Varnish: 20</span><br><span class="line">Age: 0</span><br><span class="line">Via: 1.1 varnish-v4</span><br><span class="line">X-Cache: MISS of 192.168.16.100</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到效果了, 访问<code>test3.html</code>的时候一切正常, 但当我们访问到模式匹配的<code>test7</code>的时候, 就会一直pass了. 当然这只是对单文件的, 我们还可以对目录进行模式匹配, 从而达到对一个目录下的全部文件都跳过缓存.</p><p>另外, 我们还可以类似的方式取消一些特定资源的私有cookie标识, 例如某些公共的图片资源, 由于后台的应用服务器配置或者是后台程序的设定和代码存在问题导致这些图片的响应头部中被加入了<code>Set-Cookie</code>属性, 我么可以通过模式匹配找到这些文件然后清除掉这些头部, 来看一个示例吧.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (beresp.http.cache-control !~ <span class="string">&quot;s-maxage&quot;</span>) &#123; <span class="comment">//如果这个头部中的cache-control不包含s-max-age</span></span><br><span class="line">    <span class="keyword">if</span> (bereq.url ~ <span class="string">&quot;(?i)\.jpg$&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">set</span> beresp.ttl = <span class="number">3600</span>s;</span><br><span class="line">        unset beresp.http.Set-Cookie;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bereq.url ~ <span class="string">&quot;(?i)\.css$&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">set</span> beresp.ttl = <span class="number">600</span>s;</span><br><span class="line">        unset beresp.http.Set-Cookie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 当然这里如果通过设置flag的方式写会更加优雅一些不过算了</span></span><br></pre></td></tr></table></figure><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>我们之前就在说Varnish的时候说过, 这给东西同样支持负载均衡的设定, 这个设定需要一个我们之前没有说过的状态引擎 – <code>vcl_init</code></p><p>设定起来的样子就像这样: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vcl <span class="number">4.0</span>;</span><br><span class="line"></span><br><span class="line">backend b1 &#123;</span><br><span class="line">    .host = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    .port = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">backend b2 &#123;</span><br><span class="line">    .host = <span class="string">&quot;...&quot;</span>;</span><br><span class="line">    .port = <span class="string">&quot;...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub vcl_init &#123;</span><br><span class="line">    new cluster = directors.round_robin();</span><br><span class="line">    cluster.addbackend(b1, <span class="number">1.0</span>);</span><br><span class="line">    cluster.addbackend(b2, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub vcl_recv &#123;</span><br><span class="line">    <span class="built_in">set</span> req.backend_hint = cluster.backend(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用轮询的算法来进行调度.</p><p>这里我们稍微的扩展一下对后端服务器的设定, 除了我们说过的<code>host</code>和<code>port</code>之外, 还有其他的一些, 官网的介绍在这里可以看到<a href="https://varnish-cache.org/docs/4.1/reference/vcl.html#backend-definition">Backend-Definition</a>.</p><p>其中比较重要的是<code>probo</code>和<code>max_connections</code> 分别是对后端主机进行健康状态检测和并发连接的最大数量. 但是, 如果需要对后端主机进行健康状态检测, 我们是需要再来指定健康状态检测方式的, 通过使用<code>probe</code>块来指定:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">probe name &#123;</span><br><span class="line">    .attribute = <span class="string">&quot;value&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和指定后端服务器的方法十分类似, 这里也需要提供一个名字和它对应的属性有哪些. 至于这些属性, 在上面的介绍链接里就有, 大致包括一些, 阈值, 期待的状态码, 间隔时间, 超时时长, 请求的URL, 发出的请求是什么样子的等等.</p><p>现在我们就来小小的试一下, 现在我的后端服务器有两个, 分别是<code>192.168.16.101:8080</code>和<code>192.168.16.101:8888</code>. 这里就通过Apache HTTP服务器开启两个虚拟主机好了, 然后为了模拟第二台服务器挂掉的情况我打算通过修改防火墙规则来实现. 不知道可行不可行, 现在我就先去部署了哈哈.</p><p>OK, 现在的状态是, 我在一台主机上部署了web服务, 通过8080和8888两个端口来提供不同的Web服务. 现在我们通过配置Varnish来实现对后台两个服务的轮询访问和健康状态检查.</p><blockquote><p>稍微提示一下, Varnish4版本对于这些设定和之前的版本差别很大, 这里踩了很多坑才实现这么一个功能.为了能看到负载均衡效果, 你需要暂时跳过查找缓存的步骤, 这是因为如果请求的资源已经被缓存了, 就会等到缓存时间结束了之后才会进行负载均衡.</p><p>另外, 关于调度器的实现语法也已经有了很大的不同, 现在我们就来看一下.</p></blockquote><p>负载均衡和健康状态检测的效果实现配置在下面:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">backend webserver1 &#123;</span><br><span class="line">    .host = <span class="string">&quot;192.168.16.101&quot;</span>;</span><br><span class="line">    .port = <span class="string">&quot;8080&quot;</span>;</span><br><span class="line">    .probe = &#123;</span><br><span class="line">        .url = <span class="string">&quot;/index.html&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">backend webserver2 &#123;</span><br><span class="line">    .host = <span class="string">&quot;192.168.16.101&quot;</span>;</span><br><span class="line">    .port = <span class="string">&quot;8888&quot;</span>;</span><br><span class="line">    .probe = &#123;</span><br><span class="line">        .url = <span class="string">&quot;/index.html&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub vcl_init &#123;</span><br><span class="line">    new cluster = directors.round_robin();</span><br><span class="line">    cluster.add_backend(webserver1);</span><br><span class="line">    cluster.add_backend(webserver2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sub vcl_recv &#123;</span><br><span class="line">    <span class="built_in">set</span> req.backend_hint = cluster.backend();</span><br><span class="line">    <span class="keyword">if</span> (req.url ~ <span class="string">&quot;(?i)\.html$&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>(pass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里只是填写了必要的参数, 实现之后的效果就是在访问时候进行轮询切换, 除了<code>round_robin</code>算法, 同样可以使用<code>hash, random</code>等等. </p><p>这里访问时需要加上<code>/index.html</code>才可以达到轮询的效果, 这是因为只有这样才会达到if的条件判断, 进行下面的return语句, 才不会读取缓存.</p><p>看到这里, 你是不是觉得Varnish这样调度是没有意义的呀, 其实不是, 这里之所以先这样做, 是因为当我们持续访问<strong>同一个资源</strong>的时候, Varnish只会从一个位置的后端服务器去取资源, 但是如果向我们上面这样设定, 我们访问的<strong>同一个资源</strong>对于<code>Varnish</code>来说就是不同的资源了.</p><p>那么接下来我们再来做一个测试, 我们分别在两个backend server都生成test1-10页面, 来测试下效果.</p><p>测试效果就像这样子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo\Desktop</span><br><span class="line">λ curl 192.168.16.100:6081/test1.html</span><br><span class="line">WebPage1 on Web1.</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo\Desktop</span><br><span class="line">λ curl 192.168.16.100:6081/test2.html</span><br><span class="line">WebPage2 on Web2.</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo\Desktop</span><br><span class="line">λ curl 192.168.16.100:6081/test3.html</span><br><span class="line">WebPage3 on Web1.</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo\Desktop</span><br><span class="line">λ curl 192.168.16.100:6081/test4.html</span><br><span class="line">WebPage4 on Web2.</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo\Desktop</span><br><span class="line">λ curl 192.168.16.100:6081/test3.html</span><br><span class="line">WebPage3 on Web1.</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo\Desktop</span><br><span class="line">λ curl 192.168.16.100:6081/test2.html</span><br><span class="line">WebPage2 on Web2.</span><br></pre></td></tr></table></figure><p>如果是同一个资源, 由于命中了缓存, 所以自然得到的结果就会一致. 但是放来回访问不同的资源并且不是被缓存过的资源的话, 就会进行rr轮询了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Varnish </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Varnish初见</title>
      <link href="/2018/09/08/Varnish%E5%88%9D%E8%A7%81/"/>
      <url>/2018/09/08/Varnish%E5%88%9D%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<p>今天来了解下另一个缓存服务器应用 - Varnish.</p><span id="more"></span><p>先前我们了解过Nginx了, 这是一个性能强大的反向代理服务器, 另外通过一些插件还可以成为一个缓存服务器, 只不过它只能支持一些静态文件的缓存了, 而我们今天说的这个Varnish就是一个专业的Cache服务, 当然也可以作为代理使用.</p><h2 id="永远都有的概述"><a href="#永远都有的概述" class="headerlink" title="永远都有的概述"></a>永远都有的概述</h2><p>首先我们知道, 用户发送过来的请求在一个稍微好点的架构中, 都是先到达的我们的负载均衡器, 也就是Load Balancer. 接着根据用户所请求的资源的种类不同, 将会被负载均衡器送到不同的后端服务器组. 另外的, 用户所请求的资源主要是分成结构化数据和非结构化数据. 如果是结构化的数据, 我们会把数据存放在数据库中, 根据情况我们还会做数据库的读写分离, 所有读数据的请求都会被发到读数据库, 而所有的写请求都会被发送到写数据库, 这就是基本的读写分离了. </p><p>但是这样随之而来就会有一个问题, 应用程序如何知道该访问哪一个位置的数据库系统呢. 如果是硬编码到程序中这就显得耦合度很高了, 因此在这种情况下我们应该使用中间件来处理, 这个中间件可以理解成是一种查询路由或者连接池, 如果发送过来的请求超过了后台数据库系统的最大负载能力, 这个中间件还可以作为消息队列来放松后端数据库系统的压力.</p><p>如果是非结构化的数据就是被存储在文件系统上的, 这样就很大程度上会依赖磁盘的IO能力, 举个例子, 如果我们的数据是很大量的图片文件, 这种情况下的简单本地文件系统读取会造成很大的压力, 这种情况下, 我们可能会通过分布式, SAN存储网络等等来解决问题. </p><p>上面说的都是动态资源服务的一些情况, 而对于我们的HTML文本格式文档, JavaScript脚本文件, CSS层叠样式表等等, 他们都可以以较高的压缩比来进行压缩, 而且更新的频度都要比图片高. 在这种情况下, 他们应该和图片服务器组分割开来.</p><p>但是不管是这种文本格式文档还是图片静态资源 他们都可以被<strong>缓存</strong>从而提高服务效率, 并且减轻后台资源(文件系统)的压力</p><h2 id="缓存的概念"><a href="#缓存的概念" class="headerlink" title="缓存的概念"></a>缓存的概念</h2><p>对于<strong>缓存</strong>, 我们都知道数据和资源之所以可以缓存, 是因为程序的时间局部性和空间局部性. 并且被缓存的资源可以以非常快速的方式被访问到, 这是因为他们采用<code>Key-Value</code>的方式存储的. </p><p>另外由于我们的数据繁多, 不可能所有的数据都被缓存, 我们优先需要缓存的资源都是所谓的热点资源, 也就是那些会被访问的比较多的数据. 而且, 我们缓存的东西也是会过期的, 我们的缓存对象(Cache Object)是存在生命周期的. 当我们的缓存空间已经满了的时候, 自然需要把那些最旧的或者使用最小的缓存对象清掉然后替换成新的. 这里一般所用的都是LRU算法, 而且这种替换一般都是一个单独的进程来进行的. </p><p>同样的道理,  我们所缓存的数据一般情况下只需要缓存那些公共的数据, 对于用户的私有数据我们是不需要缓存的, 而且也不应该缓存.</p><p>接下来我们来看一下缓存的处理步骤:</p><blockquote><p>接受请求 –&gt; 解析请求 (提取请求中的URL和各种首部) –&gt; 查询缓存 –&gt; 新鲜度检测 –&gt; 创建响应报文 –&gt;  发送响应 –&gt; 记录日志</p></blockquote><h3 id="缓存新鲜度"><a href="#缓存新鲜度" class="headerlink" title="缓存新鲜度"></a>缓存新鲜度</h3><p>这里面有一个至关重要的一步叫做新鲜度检测. 在HTTP版本是1.0, 会使用到一个响应首部来检测(HTTP&#x2F;1.1中也有这个), 叫做Expire. 我们可以来随便访问一个网站看一下.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/http_expire.png" alt="http_expire"></p><p>这个是百度的logo, 可以看到高亮的部分就写了在10年后才会过期. 不过你应该也注意到了一个地方, 这里所使用的时间是个绝对的时间, 但是我们是存在时差这个东西的, 也就是说有可能一个新鲜度时间对用户来说由于时差的影响并不新鲜, 因此在HTTP&#x2F;1.1版本 中, 我们使用一个另外一个响应头部来得到缓存时间是多久, 那就是上面图中的<code>Cache-Control</code>. </p><p>这个属性的的一个典型的值就是像上面所使用的<code>max-age</code>. 我不需要来决定具体的过期时间了, 只要告诉客户端从当前开始, 这个资源有效的时间是多长时间(s). 至于到底什么时候会过期, 有客户端自己去计算就好了.</p><p>这里我们是从客户端的角度来看的, 其实在我们的缓存服务器和真实的资源服务器之间还存在一个有效性再验证: <code>revalidate</code>.  这里就会分成三种情况了:</p><ul><li>如果原始内容没有发生改变, 响应的主体部分不会被附带, 状态码是304 (Not modified)</li><li>如果内容发生了改变, 则正常响应, 响应码200</li><li>如果内容已经不存在于资源服务器上, 则会直接响应404. 接着缓存服务器也会删除cache object.</li></ul><p>另外, 还有一些我们在HTTP协议的学习中了解到的一些条件式请求头部:</p><ul><li>If-Modified-since: 基于请求的时间戳做验证</li><li>If-Unmodified-since</li><li>If-Match: 基于Etag来做验证, 这个Etag就像是一个文件校验码一样的概念, 上面的百度logo请求中也有这个属性</li><li>If-None-Match</li></ul><h2 id="Varnish初见"><a href="#Varnish初见" class="headerlink" title="Varnish初见"></a>Varnish初见</h2><p>接下来就到了我们的主角的登场了, 关于Varnish的初步印象, 你可以用Squid来认识它. 而Varnish和Squid的关系其实就类似我们之前所学的Nginx和Apache httpd的关系. 两者之间在性能上, Varnish要稍占优势而稳定性上, Squid要比Varnish更加稳定. Squid可以说是很老牌的缓存代理了, 而Varnish由于采用了比较新的缓存技术, 因此性能优越, 使用量也是不错的.</p><p>那么在引入了这样一个缓存组件进入我们的架构, 前端是一个负载均衡的调度器, 很显然这里就不能再使轮询之类的调度算法了, 因为这样下去的缓存几乎都是失效的.  一般情况下, 如果说我们的前端调度是HAproxy的话, 这里应该使用的调度算法显然应该使用URI来确保我们的缓存是有效的. </p><blockquote><p>另外, 还有更大型的缓存网络. 例如借助全局的DNS, 一个典型的例子就是我们的CDN和GSLB. CDN借由节点之间的内容缓存控制协议来实现在用户的请求到达我们的后端架构之前, 会先在一个缓存网络中进行查找, 每一个用户只会被路由到他最近的节点.</p></blockquote><p>我们来看看Varnish的架构图;</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/varnish_arch.png" alt="varnish_arch"></p><p>Varnish也同样使用DSL(domain-specific language, 领域特定语言)来进行配置, 这里就叫做VCL, 也就是Varnish Configuration Language. 可以看到Varnish 主要分成两个部分, 主进程:也叫做管理进程, 子进程, 也即是缓存进程, 首先是主进程通过读取我们所编写的Varnish配置文件通过VCL编译器将他们编译成C代码, 接着通过C编译器得到<code>*.so</code>. 然后叫做子进程来进行真正的缓存操作.</p><p>而主进程可以通过我们的命令行界面或者telnet, 或者Web接口. 说起来 这里我们只使用CLI的方式, telnet太不安全应该已经被废弃, 而Web界面是Varnish所提供的需要付费的组件.</p><p>对于Varnish所生成的日志文件, 我们可以从图的右侧看到, 有多种分析工具啥的. 值得一说的是: Varnish所生成的日志内存空间对于所有的子进程而言都是共享的, 并且这一段内存是一个环状的空间, 当最后一个日志填满了只会, 就会从头开始继续写入.</p><p>稍微小结一下就是, Varnish的主进程主要负责监控Varnish, 管理子进程, 初始化Varnish, 以及提供CLI接口.</p><p>而子进程分成以下这些组件:</p><ul><li>Accepter: 接收到的连接请求.</li><li>worker threads: 处理用户请求</li><li>Expiry: 清理缓存中的过期对象</li></ul><p>日志, 是一个共享的环状空间, 共享内存的大小一般默认是90MB, 前一部分是计数器, 后一部分请求相关的数据. </p><p>另外, 如果需要配置Varnish进行工作, 我们需要使用vcl来进行, 是一个基于域的简单编程语言.</p><p>Varnish的默认监听端口是<code>6081</code>.</p><h3 id="Varnish的安装"><a href="#Varnish的安装" class="headerlink" title="Varnish的安装"></a>Varnish的安装</h3><p>如果是CentOS7的话, 只要你配置了epel源, 就可以直接通过yum进行下载和安装, 下载的大版本应该是4版本的. </p><p>varnish之所以性能优越, 是因为他依赖了一个高效的并发<code>malloc</code>的软件包, 你可以看到关于这个软件包的相关介绍:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]# rpm -q --whatrequires jemalloc</span><br><span class="line">varnish-4.0.5-1.el7.x86_64</span><br><span class="line">[root@VM-node0 ~]# rpm -qi jemalloc</span><br><span class="line">Name        : jemalloc</span><br><span class="line">Version     : 3.6.0</span><br><span class="line">Release     : 1.el7</span><br><span class="line">Architecture: x86_64</span><br><span class="line">Install Date: Fri 07 Sep 2018 02:58:20 PM CST</span><br><span class="line">Group       : System Environment/Libraries</span><br><span class="line">Size        : 324797</span><br><span class="line">License     : BSD</span><br><span class="line">Signature   : RSA/SHA256, Wed 02 Apr 2014 02:28:23 AM CST, Key ID 6a2faea2352c64e5</span><br><span class="line">Source RPM  : jemalloc-3.6.0-1.el7.src.rpm</span><br><span class="line">Build Date  : Tue 01 Apr 2014 06:33:02 AM CST</span><br><span class="line">Build Host  : buildvm-24.phx2.fedoraproject.org</span><br><span class="line">Relocations : (not relocatable)</span><br><span class="line">Packager    : Fedora Project</span><br><span class="line">Vendor      : Fedora Project</span><br><span class="line">URL         : http://www.canonware.com/jemalloc/</span><br><span class="line">Summary     : General-purpose scalable concurrent malloc implementation</span><br><span class="line">Description :</span><br><span class="line">General-purpose scalable concurrent malloc(3) implementation.</span><br><span class="line">This distribution is the stand-alone &quot;portable&quot; implementation of jemalloc.</span><br></pre></td></tr></table></figure><p>接下来还是向往常一样, 我们来看看Varnis安装了啥:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]# rpm -ql varnish</span><br><span class="line">/etc/logrotate.d/varnish</span><br><span class="line">/etc/varnish</span><br><span class="line">/etc/varnish/default.vcl</span><br><span class="line">/etc/varnish/varnish.params</span><br><span class="line">/run/varnish.pid</span><br><span class="line">/usr/bin/varnishadm</span><br><span class="line">/usr/bin/varnishhist</span><br><span class="line">/usr/bin/varnishlog</span><br><span class="line">/usr/bin/varnishncsa</span><br><span class="line">/usr/bin/varnishstat</span><br><span class="line">/usr/bin/varnishtest</span><br><span class="line">/usr/bin/varnishtop</span><br><span class="line">/usr/lib/systemd/system/varnish.service</span><br><span class="line">/usr/lib/systemd/system/varnishlog.service</span><br><span class="line">/usr/lib/systemd/system/varnishncsa.service</span><br><span class="line">/usr/sbin/varnish_reload_vcl</span><br><span class="line">/usr/sbin/varnishd</span><br><span class="line">...(omitted)</span><br><span class="line">/var/lib/varnish</span><br><span class="line">/var/log/varnish</span><br></pre></td></tr></table></figure><p>可以看到它的配置文件是一个使用<code>*.vcl</code>来做结尾的文件, 还有一个以<code>*.params</code>结尾的文件. 这个文件是干什么的呢? </p><p>打开看一下就能明白了, 其实就是一个存储一些变量值的文件, 就类似我们Shell的环境变量一样. 我们打开他的启动服务unit看一下就能明白了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]# cat /usr/lib/systemd/system/varnish.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Varnish Cache, a high-performance HTTP accelerator</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If you want to make changes to this file, please copy it to</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/systemd/system/varnish.service and make your changes there.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This will override the file kept at /lib/systemd/system/varnish.service</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Enviroment variables may be found in /etc/varnish/varnish.params</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Maximum number of open files (<span class="keyword">for</span> <span class="built_in">ulimit</span> -n)</span></span><br><span class="line">LimitNOFILE=131072</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Locked shared memory (<span class="keyword">for</span> <span class="built_in">ulimit</span> -l)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default <span class="built_in">log</span> size is 82MB + header</span></span><br><span class="line">LimitMEMLOCK=82000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On systemd &gt;= 228 <span class="built_in">enable</span> this to avoid <span class="string">&quot;fork failed&quot;</span> on reload.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">TasksMax=infinity</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Maximum size of the corefile.</span></span><br><span class="line">LimitCORE=infinity</span><br><span class="line"></span><br><span class="line">EnvironmentFile=/etc/varnish/varnish.params</span><br><span class="line"></span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/var/run/varnish.pid</span><br><span class="line">PrivateTmp=true</span><br><span class="line">ExecStart=/usr/sbin/varnishd \</span><br><span class="line">-P /var/run/varnish.pid \</span><br><span class="line">-f $VARNISH_VCL_CONF \</span><br><span class="line">-a $&#123;VARNISH_LISTEN_ADDRESS&#125;:$&#123;VARNISH_LISTEN_PORT&#125; \</span><br><span class="line">-T $&#123;VARNISH_ADMIN_LISTEN_ADDRESS&#125;:$&#123;VARNISH_ADMIN_LISTEN_PORT&#125; \</span><br><span class="line">-S $VARNISH_SECRET_FILE \</span><br><span class="line">-u $VARNISH_USER -g $VARNISH_GROUP \</span><br><span class="line">-s $VARNISH_STORAGE \</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DAEMON_OPTS</span></span><br><span class="line"></span><br><span class="line">ExecReload=/usr/sbin/varnish_reload_vcl</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就制定了环境配置文件是<code>/etc/varnish/varnish.params</code>. 而后面启动的参数有很多都是从这个文件获取的, 也就是说我们通过改变这个环境变量配置文件来实现不同的启动参数.</p><h3 id="Varnish的缓存对象"><a href="#Varnish的缓存对象" class="headerlink" title="Varnish的缓存对象"></a>Varnish的缓存对象</h3><p>Varnish是如何存储他的缓存对象的呢? 我们接下来来了解一下.</p><p>我们已经知道Nginx的缓存机制是通过目录层级建立在文件系统上的. 键保存在内存中. 这种做法的一个显然易见的缺点是会占用大量的inode. 而Varnish是不同的, 他只是用了一个文件, 单个大文件的感觉. 这个文件中使用Varnish自己的存储方式来进行整理. 但是同样的, Varnish在运行过程中是绝对不可以进行重启的, 因为为了能够识别这个文件, 需要在内存中维护一些识别数据, 只要重启了之后, 所有的缓存对象都会失效, 也就是说这种方式是不支持持久机制的.</p><p>另外, Varnish还支持另外两种存储方式, 一种是基于内存的, 也就是使用malloc, 这种方式同样是不支持持久化的. 最后一种叫做<code>persistent</code>, 这个是存储在磁盘上的, 而且支持持久化, 有点类似之前的Nginx了, 但是这个功能在3版本 之前一直作为实验性功能不建议使用, 这种情况下, 对我们的磁盘IO能力就是一个考验了.</p><h3 id="配置Varnish"><a href="#配置Varnish" class="headerlink" title="配置Varnish"></a>配置Varnish</h3><p>对于Varnish的配置方式, 我们刚刚已经在上面说过了, 可以通过修改那个环境变量文件来达到配置的效果. 这个只是Varnish的一种配置方式, 除此之外, 我们还可以通过在命令行接口中, 进行一些运行时参数的修改. </p><p>另外, 还记得Varnish的vcl文件吗, 这个文件是用来进行Varnish缓存系统的一些缓存机制的 , 只不过, 使用这个文件一定要先编译, 之后才会生效, 同时你需要确保运行环境有gcc编译器才可以.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Main configuration file. You probably want to change it.</span></span><br><span class="line">VARNISH_VCL_CONF=/etc/varnish/default.vcl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default address and port to <span class="built_in">bind</span> to. Blank address means all IPv4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and IPv6 interfaces, otherwise specify a host name, an IPv4 dotted</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">quad, or an IPv6 address <span class="keyword">in</span> brackets.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VARNISH_LISTEN_ADDRESS=192.168.1.5</span></span><br><span class="line">VARNISH_LISTEN_PORT=6081</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Admin interface listen address and port</span></span><br><span class="line">VARNISH_ADMIN_LISTEN_ADDRESS=127.0.0.1</span><br><span class="line">VARNISH_ADMIN_LISTEN_PORT=6082</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Shared secret file <span class="keyword">for</span> admin interface</span></span><br><span class="line">VARNISH_SECRET_FILE=/etc/varnish/secret</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Backend storage specification, see Storage Types <span class="keyword">in</span> the varnishd(5)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">man page <span class="keyword">for</span> details.</span></span><br><span class="line">VARNISH_STORAGE=&quot;malloc,256M&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User and group <span class="keyword">for</span> the varnishd worker processes</span></span><br><span class="line">VARNISH_USER=varnish</span><br><span class="line">VARNISH_GROUP=varnish</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Other options, see the man page varnishd(1)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">DAEMON_OPTS=<span class="string">&quot;-p thread_pool_min=5 -p thread_pool_max=500 -p thread_pool_timeout=300&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个文件中, 我们可以看到监听地址, 端口, 管理CLI秘钥文件的, 存储方式等等的修改, 这里安装的版本默认使用了<code>malloc</code>的方式来进行缓存, 这个内存空间的大小是256M. 如果想改成文件方式该如何做呢 只要把这个参数的值修改成这个样子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VARNISH_STORAGE=&quot;file,/storage/data/varnish.bin,1G&quot;</span><br></pre></td></tr></table></figure><p>类似这样就行了, 不解释也能看得懂吧.</p><p>接下来就是vcl文件了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Marker to tell the VCL compiler that this VCL has been adapted to the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">new 4.0 format.</span></span><br><span class="line">vcl 4.0;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default backend definition. Set this to point to your content server.</span></span><br><span class="line">backend default &#123;</span><br><span class="line">    .host = &quot;127.0.0.1&quot;;</span><br><span class="line">    .port = &quot;8080&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub vcl_recv &#123;</span><br><span class="line">    # Happens before we check if we have this in cache already.</span><br><span class="line">    #</span><br><span class="line">    # Typically you clean up the request here, removing cookies you don&#x27;t need,</span><br><span class="line">    # rewriting the request, etc.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub vcl_backend_response &#123;</span><br><span class="line">    # Happens after we have read the response headers from the backend.</span><br><span class="line">    #</span><br><span class="line">    # Here you clean the response headers, removing silly Set-Cookie headers</span><br><span class="line">    # and other mistakes your backend does.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub vcl_deliver &#123;</span><br><span class="line">    # Happens when we have all the pieces we need, and are about to send the</span><br><span class="line">    # response to the client.</span><br><span class="line">    #</span><br><span class="line">    # You can do accounting or modifying the final object here.</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于VCL的更多信息我们之后再说, 现在我们来配置一下后端主机.</p><p>这里我把主机的地址改到了他自己的80端口, 接着我们先来启动Varnish. </p><p>varnish的默认端口是6081, 我们访问一下试试.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo\Desktop</span><br><span class="line">λ curl 192.168.16.100:6081 -v</span><br><span class="line">* Rebuilt URL to: 192.168.16.100:6081/</span><br><span class="line">*   Trying 192.168.16.100...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to 192.168.16.100 (192.168.16.100) port 6081 (#0)</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET / HTTP/1.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: 192.168.16.100:6081</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/7.55.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&lt; HTTP/1.1 200 OK</span></span><br><span class="line">&lt; Date: Sun, 09 Sep 2018 11:46:48 GMT</span><br><span class="line">&lt; Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/5.4.16</span><br><span class="line">&lt; Last-Modified: Fri, 20 Oct 2017 16:27:33 GMT</span><br><span class="line">&lt; ETag: &quot;19-55bfcf32d89d7&quot;</span><br><span class="line">&lt; Content-Length: 25</span><br><span class="line">&lt; Content-Type: text/html; charset=UTF-8</span><br><span class="line">&lt; X-Varnish: 65540 3</span><br><span class="line">&lt; Age: 65</span><br><span class="line">&lt; Via: 1.1 varnish-v4</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Accept-Ranges: bytes</span><br><span class="line">&lt;</span><br><span class="line">Sorry, under maintenance</span><br><span class="line">* Connection #0 to host 192.168.16.100 left intact</span><br></pre></td></tr></table></figure><p>可以看到, 访问正常进行了, 而且我们还能看到响应头中写了经由Varnish代理服务器, 而处理请求的是Apache httpd.</p><p>接下来我们保持Varnish的运行, 来看一下他的命令行管理工具.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]# varnishadm -h</span><br><span class="line">varnishadm: invalid option -- &#x27;h&#x27;</span><br><span class="line">usage: varnishadm [-n ident] [-t timeout] [-S secretfile] -T [address]:port command [...]</span><br><span class="line">-n is mutually exlusive with -S and -T</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们需要指定一下使用的秘钥文件位置和管理端口, 这里可以直接在后面发送相关的命令, 也可以不写进入交互式界面来进行操作. 现在就来试一下.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">root@VM-node0 ~]# varnishadm -S /etc/varnish/secret -T 127.0.0.1:6082</span><br><span class="line">200        </span><br><span class="line">-----------------------------</span><br><span class="line">Varnish Cache CLI 1.0</span><br><span class="line">-----------------------------</span><br><span class="line">Linux,3.10.0-862.11.6.el7.x86_64,x86_64,-smalloc,-smalloc,-hcritbit</span><br><span class="line">varnish-4.0.5 revision 07eff4c29</span><br><span class="line"></span><br><span class="line">Type &#x27;help&#x27; for command list.</span><br><span class="line">Type &#x27;quit&#x27; to close CLI session.</span><br><span class="line"></span><br><span class="line">help</span><br><span class="line">200        </span><br><span class="line">help [&lt;command&gt;]</span><br><span class="line">ping [&lt;timestamp&gt;]</span><br><span class="line">auth &lt;response&gt;</span><br><span class="line">quit</span><br><span class="line">banner</span><br><span class="line">status</span><br><span class="line">start</span><br><span class="line">stop</span><br><span class="line">vcl.load &lt;configname&gt; &lt;filename&gt;</span><br><span class="line">vcl.inline &lt;configname&gt; &lt;quoted_VCLstring&gt;</span><br><span class="line">vcl.use &lt;configname&gt;</span><br><span class="line">vcl.discard &lt;configname&gt;</span><br><span class="line">vcl.list</span><br><span class="line">param.show [-l] [&lt;param&gt;]</span><br><span class="line">param.set &lt;param&gt; &lt;value&gt;</span><br><span class="line">panic.show</span><br><span class="line">panic.clear</span><br><span class="line">storage.list</span><br><span class="line">vcl.show [-v] &lt;configname&gt;</span><br><span class="line">backend.list [&lt;backend_expression&gt;]</span><br><span class="line">backend.set_health &lt;backend_expression&gt; &lt;state&gt;</span><br><span class="line">ban &lt;field&gt; &lt;operator&gt; &lt;arg&gt; [&amp;&amp; &lt;field&gt; &lt;oper&gt; &lt;arg&gt;]...</span><br><span class="line">ban.list</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功了, 我们可以通过使用键入help来查看所有支持的命令.</p><p>一些比较基础的看一下就能明白的, 就直接过一下就好了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ping</span><br><span class="line">200        </span><br><span class="line">PONG 1536493933 1.0</span><br><span class="line">status</span><br><span class="line">200        </span><br><span class="line">Child in state running</span><br><span class="line">vcl.list</span><br><span class="line">200        </span><br><span class="line">active          0 boot</span><br><span class="line"></span><br><span class="line">vcl.load test /etc/varnish/default.vcl </span><br><span class="line">200        </span><br><span class="line">VCL compiled.</span><br><span class="line">vcl.list</span><br><span class="line">200        </span><br><span class="line">active          0 boot</span><br><span class="line">available       0 test</span><br><span class="line"></span><br><span class="line">vcl.use test</span><br><span class="line">200        </span><br><span class="line">VCL &#x27;test&#x27; now active</span><br><span class="line">vcl.list</span><br><span class="line">200        </span><br><span class="line">available       0 boot</span><br><span class="line">active          0 test</span><br><span class="line"></span><br><span class="line">vcl.use boot</span><br><span class="line">200        </span><br><span class="line">VCL &#x27;boot&#x27; now active</span><br><span class="line">vcl.discard test</span><br><span class="line">200        </span><br><span class="line"></span><br><span class="line">vcl.list</span><br><span class="line">200        </span><br><span class="line">active          0 boot</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面就是对vcl文件的编译载入使用以及删除的演示, 其实还是挺简单的.</p><p>接着往下, 我们可以通过<code>param</code>子命令来对一些运行参数进行修改, 并且可以通过<code>show</code>加上<code>-l</code>参数来查看所有配置选项详细的信息(很大量), 例如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">param.show thread_pool_max</span><br><span class="line">200        </span><br><span class="line">thread_pool_max</span><br><span class="line">        Value is: 5000 [threads] (default)</span><br><span class="line">        Default is: 5000</span><br><span class="line">        Minimum is: 100</span><br><span class="line"></span><br><span class="line">        The maximum number of worker threads in each pool.</span><br><span class="line"></span><br><span class="line">        Do not set this higher than you have to, since excess worker</span><br><span class="line">        threads soak up RAM and CPU and generally just get in the way</span><br><span class="line">        of getting work done.</span><br><span class="line"></span><br><span class="line">        Minimum is 10 threads.</span><br><span class="line"></span><br><span class="line">        NB: This parameter may take quite some time to take (full)</span><br><span class="line">        effect</span><br></pre></td></tr></table></figure><p>这就是显示这个配置选项的一些描述和值.</p><p>有关这个管理工具更多和VCL引擎, 我们之后再说.</p><h3 id="Varnish的日志"><a href="#Varnish的日志" class="headerlink" title="Varnish的日志"></a>Varnish的日志</h3><p>我们之前说Varnish有多个管理日志的工具, 现在就来直接查看一下效果吧.</p><ul><li>Varnishlog</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]# varnishlog</span><br><span class="line">*   &lt;&lt; BeReq    &gt;&gt; 8         </span><br><span class="line">-   Begin          bereq 7 fetch</span><br><span class="line">-   Timestamp      Start: 1536494709.508570 0.000000 0.000000</span><br><span class="line">-   BereqMethod    GET</span><br><span class="line">-   BereqURL       /</span><br><span class="line">-   BereqProtocol  HTTP/1.1</span><br><span class="line">-   BereqHeader    Host: 192.168.16.100:6081</span><br><span class="line">-   BereqHeader    Upgrade-Insecure-Requests: 1</span><br><span class="line">-   BereqHeader    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36</span><br><span class="line">-   BereqHeader    Sec-Metadata: cause=forced, destination=document, target=top-level, site=cross-site</span><br><span class="line">-   BereqHeader    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">-   BereqHeader    Accept-Language: en,zh;q=0.9,zh-CN;q=0.8,en-US;q=0.7</span><br><span class="line">-   BereqHeader    X-Forwarded-For: 192.168.16.1</span><br><span class="line">-   BereqHeader    Accept-Encoding: gzip</span><br><span class="line">-   BereqHeader    X-Varnish: 8</span><br><span class="line">-   VCL_call       BACKEND_FETCH</span><br><span class="line">-   VCL_return     fetch</span><br><span class="line">-   BackendClose   18 default(127.0.0.1,,80) toolate</span><br><span class="line">-   BackendOpen    18 default(127.0.0.1,,80) 127.0.0.1 34012 </span><br><span class="line">-   Backend        18 default default(127.0.0.1,,80)</span><br><span class="line">-   Timestamp      Bereq: 1536494709.508876 0.000305 0.000305</span><br><span class="line">-   Timestamp      Beresp: 1536494709.510254 0.001684 0.001379</span><br><span class="line">-   BerespProtocol HTTP/1.1</span><br><span class="line">-   BerespStatus   200</span><br><span class="line">-   BerespReason   OK</span><br><span class="line">-   BerespHeader   Date: Sun, 09 Sep 2018 12:05:09 GMT</span><br><span class="line">-   BerespHeader   Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/5.4.16</span><br><span class="line">-   BerespHeader   Last-Modified: Fri, 20 Oct 2017 16:27:33 GMT</span><br><span class="line">-   BerespHeader   ETag: &quot;19-55bfcf32d89d7&quot;</span><br><span class="line">-   BerespHeader   Accept-Ranges: bytes</span><br><span class="line">-   BerespHeader   Content-Length: 25</span><br><span class="line">-   BerespHeader   Content-Type: text/html; charset=UTF-8</span><br><span class="line">-   TTL            RFC 120 -1 -1 1536494710 1536494710 1536494709 0 0</span><br><span class="line">-   VCL_call       BACKEND_RESPONSE</span><br><span class="line">-   VCL_return     deliver</span><br><span class="line">-   Storage        malloc s0</span><br><span class="line">-   ObjProtocol    HTTP/1.1</span><br><span class="line">-   ObjStatus      200</span><br><span class="line">-   ObjReason      OK</span><br><span class="line">-   ObjHeader      Date: Sun, 09 Sep 2018 12:05:09 GMT</span><br><span class="line">-   ObjHeader      Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/5.4.16</span><br><span class="line">-   ObjHeader      Last-Modified: Fri, 20 Oct 2017 16:27:33 GMT</span><br><span class="line">-   ObjHeader      ETag: &quot;19-55bfcf32d89d7&quot;</span><br><span class="line">-   ObjHeader      Content-Length: 25</span><br><span class="line">-   ObjHeader      Content-Type: text/html; charset=UTF-8</span><br><span class="line">-   Fetch_Body     3 length stream</span><br><span class="line">-   BackendReuse   18 default(127.0.0.1,,80)</span><br><span class="line">-   Timestamp      BerespBody: 1536494709.510310 0.001740 0.000056</span><br><span class="line">-   Length         25</span><br><span class="line">-   BereqAcct      506 0 506 272 25 297</span><br><span class="line">-   End            </span><br><span class="line"></span><br><span class="line">*   &lt;&lt; Request  &gt;&gt; 7         </span><br><span class="line">-   Begin          req 6 rxreq</span><br><span class="line">-   Timestamp      Start: 1536494709.508290 0.000000 0.000000</span><br><span class="line">-   Timestamp      Req: 1536494709.508290 0.000000 0.000000</span><br><span class="line">-   ReqStart       192.168.16.1 4715</span><br><span class="line">-   ReqMethod      GET</span><br><span class="line">-   ReqURL         /</span><br><span class="line">-   ReqProtocol    HTTP/1.1</span><br><span class="line">-   ReqHeader      Host: 192.168.16.100:6081</span><br><span class="line">-   ReqHeader      Connection: keep-alive</span><br><span class="line">-   ReqHeader      Cache-Control: max-age=0</span><br><span class="line">-   ReqHeader      Upgrade-Insecure-Requests: 1</span><br><span class="line">-   ReqHeader      User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36</span><br><span class="line">-   ReqHeader      Sec-Metadata: cause=forced, destination=document, target=top-level, site=cross-site</span><br><span class="line">-   ReqHeader      Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">-   ReqHeader      Accept-Encoding: gzip, deflate</span><br><span class="line">-   ReqHeader      Accept-Language: en,zh;q=0.9,zh-CN;q=0.8,en-US;q=0.7</span><br><span class="line">-   ReqHeader      If-None-Match: &quot;19-55bfcf32d89d7&quot;</span><br><span class="line">-   ReqHeader      If-Modified-Since: Fri, 20 Oct 2017 16:27:33 GMT</span><br><span class="line">-   ReqHeader      X-Forwarded-For: 192.168.16.1</span><br><span class="line">-   VCL_call       RECV</span><br><span class="line">-   VCL_return     hash</span><br><span class="line">-   ReqUnset       Accept-Encoding: gzip, deflate</span><br><span class="line">-   ReqHeader      Accept-Encoding: gzip</span><br><span class="line">-   VCL_call       HASH</span><br><span class="line">-   VCL_return     lookup</span><br><span class="line">-   Debug          &quot;XXXX MISS&quot;</span><br><span class="line">-   VCL_call       MISS</span><br><span class="line">-   VCL_return     fetch</span><br><span class="line">-   Link           bereq 8 fetch</span><br><span class="line">-   Timestamp      Fetch: 1536494709.510330 0.002040 0.002040</span><br><span class="line">-   RespProtocol   HTTP/1.1</span><br><span class="line">-   RespStatus     200</span><br><span class="line">-   RespReason     OK</span><br><span class="line">-   RespHeader     Date: Sun, 09 Sep 2018 12:05:09 GMT</span><br><span class="line">-   RespHeader     Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/5.4.16</span><br><span class="line">-   RespHeader     Last-Modified: Fri, 20 Oct 2017 16:27:33 GMT</span><br><span class="line">-   RespHeader     ETag: &quot;19-55bfcf32d89d7&quot;</span><br><span class="line">-   RespHeader     Content-Length: 25</span><br><span class="line">-   RespHeader     Content-Type: text/html; charset=UTF-8</span><br><span class="line">-   RespHeader     X-Varnish: 7</span><br><span class="line">-   RespHeader     Age: 0</span><br><span class="line">-   RespHeader     Via: 1.1 varnish-v4</span><br><span class="line">-   VCL_call       DELIVER</span><br><span class="line">-   VCL_return     deliver</span><br><span class="line">-   Timestamp      Process: 1536494709.510346 0.002057 0.000016</span><br><span class="line">-   RespProtocol   HTTP/1.1</span><br><span class="line">-   RespStatus     304</span><br><span class="line">-   RespReason     Not Modified</span><br><span class="line">-   RespReason     Not Modified</span><br><span class="line">-   RespUnset      Content-Length: 25</span><br><span class="line">-   Debug          &quot;RES_MODE 0&quot;</span><br><span class="line">-   RespHeader     Connection: keep-alive</span><br><span class="line">-   Timestamp      Resp: 1536494709.511031 0.002742 0.000685</span><br><span class="line">-   Debug          &quot;XXX REF 2&quot;</span><br><span class="line">-   ReqAcct        605 0 605 307 0 307</span><br><span class="line">-   End            </span><br><span class="line"></span><br><span class="line">*   &lt;&lt; Session  &gt;&gt; 32770     </span><br><span class="line">-   Begin          sess 0 HTTP/1</span><br><span class="line">-   SessOpen       192.168.16.1 4716 :6081 192.168.16.100 6081 1536494709.487511 16</span><br><span class="line">-   SessClose      RX_TIMEOUT 5.095</span><br><span class="line">-   End            </span><br><span class="line"></span><br><span class="line">*   &lt;&lt; Session  &gt;&gt; 6         </span><br><span class="line">-   Begin          sess 0 HTTP/1</span><br><span class="line">-   SessOpen       192.168.16.1 4715 :6081 192.168.16.100 6081 1536494709.487469 14</span><br><span class="line">-   Link           req 7 rxreq</span><br><span class="line">-   SessClose      RX_TIMEOUT 5.095</span><br><span class="line">-   End            </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个是记录的比较详细的一个了.</p><ul><li>varnishncsa</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]# varnishncsa</span><br><span class="line">192.168.16.1 - - [09/Sep/2018:20:06:00 +0800] &quot;GET http://192.168.16.100:6081/ HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&quot;</span><br><span class="line">192.168.16.1 - - [09/Sep/2018:20:06:03 +0800] &quot;GET http://192.168.16.100:6081/ HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&quot;</span><br><span class="line">192.168.16.1 - - [09/Sep/2018:20:06:03 +0800] &quot;GET http://192.168.16.100:6081/ HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个日志显示的就和我们的httpd很相似, 也很简略.</p><ul><li>varnishstat</li></ul><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/varnishstat.png" alt="varnishstat"></p><p>这个结果也是即时刷新的.</p><ul><li>varnishtop</li></ul><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/varnishtop.png" alt="varnishtop"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Varnish </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware的虚拟网络拓扑原理</title>
      <link href="/2018/09/07/%E4%BD%BF%E7%94%A8VMware%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2018/09/07/%E4%BD%BF%E7%94%A8VMware%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>问题已经解决清楚, 下面记录的是我试图解决的一些过程.</p><p>顺便再来分享下过程中学习到的VMware各种上网模式的一些拓扑和原理</p><span id="more"></span><h2 id="从这个奇怪的问题切入"><a href="#从这个奇怪的问题切入" class="headerlink" title="从这个奇怪的问题切入"></a>从这个奇怪的问题切入</h2><p><strong>大前提: 宿主机连入Internet. 基本上的每一次操作都重启服务和虚拟机.</strong></p><p>问题是这样子的,  当前我的VMware虚拟网络配置是:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vmware_conf.png" alt="vmware_conf"></p><p>如你所见, 配置的IP地址段是<code>192.168.16.2-192.168.16.254</code>. 并且使用nat方式.</p><p>在命令行中能查看到这个虚拟网卡的相关信息, 能看到它的MAC地址是: <code>00-50-56-C0-00-08</code>.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ipconfig_conf.png" alt="ipconfig_conf"></p><p>接下来 我给我的CentOS7主机所配置的网卡就是上述的这一张, 如你所见:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/centos_conf.png" alt="centos_conf"></p><p>而主机的配置也是标准的配置文件 但是没有声明<code>HWADDR</code>, 在NetworkManager的管理:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/centos-ifcfg_conf.png" alt="centos-ifcfg_conf"></p><p>接下来一系列看起来很奇怪的事情就发生了.</p><p>首先我们通过tty登录进虚拟机, 查看下当前的一些网络属性:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/nmcli_conf.png" alt="nmcli_conf"></p><p>可以看到 当前的网关地址<code>192.168.16.1</code>对应的网卡地址(MAC)是<code>00-50-56-f8-7b-b1</code>. 而本机的MAC地址是<code>00-0c-29-d6-b2-26</code>. </p><blockquote><p>这里有一点疑问:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/netadapter_conf.png" alt="netadapter_conf"></p><p>我明明配置的本机网卡MAC地址是上图那样子的, 可是结果却不是 不知道是为什么.</p></blockquote><p>接着我们自然是想要测试一下是否可以连通Internet:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ping1_result.png" alt="ping1_result"></p><p>这个是百度的一个公网地址, 可以看到是没啥问题的. </p><p>接下来就有趣了, 我们通过宿主机上的Xshell来进行连接使用 毕竟通过远程连接操作起来更方便嘛~</p><p>然后登进去之后虚拟机就不能连通到Internet了 !</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ping2_result.png" alt="ping2_result"></p><p>经过一系列的尝试 我初步把问题定位在了ARP上, 因为连接前后发生的最大的变化就是网关地址的硬件地址:</p><p><code>来自未来: 这图炸了 找不到原图了, 懒得复现这个问题了...</code></p><p>你应该也发现了, 经过了宿主机的连接之后 新的网关地址的硬件地址变成了我们VMnet8的硬件地址:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/win_info.png" alt="win_info"></p><p>到这里有点神奇, 不过能确定的一点是, 这个VMnet8能够使得我们的宿主机和虚拟机进行通信, 但是虚拟机自己的internet连接并不是通过VMnet8来实现的. </p><p>不过到这里, 通过之前学到的一些网络排错知识, 已经知道问题的所在了, 那就是IP地址重复了, 换句话说, 我们的网关地址配置和宿主机的IP地址重合了, 这就导致arp的结果发生错乱以及MAC地址重写导致虚拟机无法把数据包发送出去了.</p><p>经过将网关地址修改成另外一个值, 我们成功解决了这一个看起来有点奇怪的问题.</p><h2 id="VMware的虚拟网络拓扑和原理"><a href="#VMware的虚拟网络拓扑和原理" class="headerlink" title="VMware的虚拟网络拓扑和原理"></a>VMware的虚拟网络拓扑和原理</h2><p>那么经过这次的问题之后, 自然我们得知道VMware是怎么控制虚拟机的网络拓扑的. 现在就VMware的三种连接方式来说下吧!</p><h3 id="Host-only"><a href="#Host-only" class="headerlink" title="Host-only"></a>Host-only</h3><p>这一种看起来是最简单的一种, 从host-only模式来先说!</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vmware_hostonly.png" alt="vmware_hostonly"></p><p>在这种模式下,  我们的虚拟机以及配置的DHCP服务器全部都连接到由VMware所维护的一个虚拟交换机上, 可以看到, 在Windows网络适配器管理里面看到的那张VMnet1网卡其实就是隔断主机网络和VMware虚拟机网络的屏障了, 各个虚拟机通过VMnet1与主机进行通信, 但是没有办法通过连接主机网卡来访问互联网.</p><p>那么你可能会有疑问, 如果我们配置成Host-only模式, 但是我们通过某种手段来把主机的网卡和VMnet1网卡进行桥接, 换句话说就是将主机网卡共享给VMnet1, 那我们的主机不是就可以向我们的主机一样 连通Internet了吗!</p><p>没错, 这确实可行, 而且其实这几乎就是VMware的NAT实现方式, 只不过有一点点的小不同.</p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vmware_nat.png" alt="vmware_nat"></p><p>依然, 在NAT模式下, 虚拟机们还是连通道一个虚拟交换机上, 而这一次和之前不同的是, 我们多了一个虚拟的用来实现NAT功能的模块, 不仅如此, 这个模块与宿主机的网卡相连接, 从而可以让虚拟机通过这条连接访问到互联网, 值得注意的是, <strong>虚拟机和主机的通信仍然是依靠那个VMnet网卡来进行的.</strong></p><p>随后我们再来看一下最易实现的一种网络连接方式 – 桥接</p><h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h3><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vmware_bridge.png" alt="vmware_bridge"></p><p>看! 当我们使用桥接的时候, 其实就是简单的在我们宿主机的网卡和我们虚拟交换机之间搭建了一条虚拟网桥来共享数据连接, 在这种模式下, 虚拟机访问宿主机和访问外网都通过这个网桥来进行.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python源码阅读小结</title>
      <link href="/2018/07/08/Python%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/07/08/Python%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5079a46a3fd31912acea0aa2a57b4110a3b792baffa94f1c4c14afff4bac9e96">a8f5e86d600162da1fde886a0b0d95ae4c9861dd35cbe39143d9506f1002851ebae0664360a3febc5bb4013847a2adb62c1dab79def8cb817de8934ed2877ce3232a1d286d2c2c8fe05a31c5dbe4aebae4d1b0fe49c8405554502578c80c0a41e767114667dbc53aa077da1033ca84e0b56350120afb8a08269523eb7ff482bbfb76ff1803b74f70dead594e6743d423f97878a4eb6996acc08b69a62393e8a0d826f26b5f389588ba0862a7cf8027c884f9f00c082fd5092f3f70da2ed62c54f98b1cbc5af3400b1b6785a3144c9504dcf6c2ba0cc904a3593cefb5db6a2a6861ad704a3e036ab5720d1734151d2698aa78ad6a5b253c5cc5a1e8f660de7da1b44bc6532b2a61a5c9510336310274030200e0599886384166f0c826edd15888f8557347521c30517d84aa3f668b556bbb93fab1d9f1debac6fcfbd8b0d4ef92e2765c76e7833ac59a89bb22f7a15b17b493d8e88576396a129c3fbce7cc84e02a66212057cb97c52eb1182748059b84c7e293329663a6adac2e09d64e390ded6de3e2b50b77018a04a96b3a29ecc97421f1f3d2a97e8f15f1807780d9b3162814ecb97b3f9a3807351f17eb2575761f186f2ae994a01ccb158c1b5943558dea1b9368b33f308418c6abbfd57d13378c7912ffdc9949d63b8c6ef38c164093f3dd36d8cc9a20fadf1dd5f3f61a4ca115b26a2c92d2de0592eaf39872a1c3beb08be06effe51b053df9d7ac60046e4d06553d9efdd954b4144337285d3c1f92d107ca44a333e51190dd05989e6f51c95278784c04607fbc937fbfdbfbb5f4abb0adf1c65dd4bdfc9f54c151b83202114dcc81f263f4c54bd678cc6fd13b5b40f861dcc9e472866bb0c94e351b780f7312d99dc9b05b431b5fc5a7b9513fe2a01008ac6925072f19ae3b5698287e444325c18b5539f6a3a167f58d26d3d27ca06cceb0de771a6170e8eab1b0a6f0319cd076232c9ffb4e99e05ab47ff60a534ab3457ad5553b81cebb9f955dc5476c69b6467664d03e31cce3a2c98f0f69b7bc3994de756ab7740edab8ffafef0c4d18539cb07870d53e80e74a0d7623a0a5831b4124a1813abaa0074201a1550402a70c9ec4700bf3068d0e6c6c95c7daf35e1d61680ffe389dc1e3f9c78156001bc7cfda5db001625a87d0a9a6c9e3d61001b273c3a7dc08283a0878034fd877351d9ba3323dd1d0071933932b77317fe6e9e1bbe531ec4bc97d8ee988ffa1d4015acbc368e922c50677f62158ed200b5f60a0137b7618e68105d71ecce971eb310f159e8b678fe1022e8bbb7fd41bb19c71e0ff501cf7f9b20fcece8fe7a19a5d0b54502804334c31003b58cf00d90b1a42c051a73b3ddc32ac6ddc5d7a6c2be120c12c1735a859e790519734092db99f1b81987e508d44a08ee20a5d2a3a5e9de0ce606ef4cb846738a1f303751ffabf36bb28c8a5b9bccbf51d6f1e19c9f19a8821eb3e7afd16708976fe0fa6ae8d3d325e71891184ee6f42ef7644d74a90b0de79556bf426f31249d9bee6ee185598c836325c1e3833fc8efa01f1bec32a704b2723d825a2483b7b77a983f472f47c352dec768d31ddb52e3fc3d1e5b730bbd70be215f2c41c3cc60377016828397e1727bc0bc575162606514d16e8d0ceb411647f99e96bc2a54311b3e4d0568d3c601c4dcdeb0b75575a75d53e2e231b01119bcbf6795e7700d82766a95a6e90c35cd89f930bf75fddc799bfb7b84351c6f7713285238e7c5baeace46e90eca737da4b505694e73038a4f77a309182f2f8b7059ba6e0b7f413b7ecd42327df610d0ee8efb1d4050ee9387746f795d16d5355d80328a480db686d11178d71d287e9ccfbe024631db8e631782326d75a65524d08ae9c7e0546bd94b2ca9908dce581c1c7e2b9f160deb222f1b0151375b7b106e2e7ff3d94e8f1452986dfd62caf56a994aeee6814625d48975a9dbd0863220bffcd6402bdded8f756cf94ff0ac89c60c4c012f289b9de0377fe83a041729fd61d02417169686b2fc46080fd4000167bb0eb4eb5b10b3df82b08f173db085e7db1e0af3c948ecb8689478b430d7395f3504181374ce4daa1aa4c47b1efaf1a506faf7ff245ff8b8b316c47b093452e65df07ff03ca13443cd366dcbd8893c9fb855f61507cfdf911e0a90c6fb2d57eab4f15f9bf939b90f34e33d8760fba8c00cf9b7d64f0b19c3719e757e2430a27f2fb0ae4b631c3315fa94e0aea8790b4f34fa86321716958bacb0d95d8eb7200a97889c9e3af2217345b2923831b1b6e917b22bfe88217d6b72a87b4d558dacf2e40d33057c5c200e5e6472bad99a3ef5a1d0ab26db7e9ab0de7dcec03271a62ebfd7324853366e26d6ba6fc0af8ffeaeb52d2eac0990db4329d91c24961d8278eba354beebd3cc31545699c0e897131173f4f56f8eb8c7cf6542ece7a19a92124ac611c5c898c5b3b657d74db657c2abcc2a871991ed4e0090e726f4ca63faa5ee4a6cc5e1e9553ad02132e0f756f0eae1b42269bd89036b6a9f2af97338ec9cc827e1843bd538d30d79acc1d170d5c264271e3430bcd2853b2fa5a780bf905fbfa8d7eda76b33fa000fcf9bdc900181b6edeb845a3a59854b878290915cd56090162c0eb83e930256f4cb926a69965f9769607c7bf5fcd06772d5e1a73ffed38657b8ae82e0e1cfbf670c747f8e310e9aeab4c8385b531d204c3f1cbd97b61356c28fa4e26b7c256e6527f3fc7052fee029d8fc2f8d7e15bb642966d56722b796fbfad83fdf28f82e70bdf7cdb4153ed4c26e38923153eb09b9d734cb7d4f7507c66c8a4e89f5d0552ae1226546d82d2746eda91b799038e8e2a1f5d964f4934012f0b3ad476d53b1eed1d3645ef379aedb8bbb2f4587853eef0e37377217ef71993e0ed2088bc5c0fa0af00c3b6563797a7a3b7a9b8664d52f1338e5014716b85aabbec13678c90cfd32a720b20fe2f5a9451c905b260d3d7c93bf491c343a784996d19f842991fb61562b0ef15e258b84e295d7568c93885cf4df9a62e1b9ce68d3bd3f795b383271a05e55b5099dd397c4e3d18c4908d8b5840c8badb3f58173f6ccd83153e943c9d3788dbeba3ac8ac15d7cf269e8b2b775f8faf5a4c843f731c1f1882437ff985a276f47e1d41cf521ab143de29a26b9d56869954805b85b5468f87339ec5117fb6accd7af2e9e63d04b92c6c00baccf89bda38de4864d92b3f29f18e9f1f44f6916d2c1583eb1fb5726740f67074c4556a5dd559d42eab919ae3178f6d30ceb6f05d866f9997630bc88b9b51c748a7ca938ec7e97da75c1c31dd574ab364affef5bbfab7546e0f508fa2ddb8d77f16c37b30efdc4ae2c020a6967bf0e78a5939402e60bfef7e2437fd936e8caf8caf31573d989a389789c58245895b678439413d10d06216a49bef122471dadd5611f25fd3365ffd9e270eeda5b43a93ede0b61b1574ee10f5e306e6708ee38563525d2676111e6fd3b981f1b86c4b3e90e478c8775e86cc9289e35a8e6f257fb222e6f2c2114f6bf7880ceb0d6d78f885b920f39c475a0a294fbc046877eee674ac2b9914adbb9d854f6fcfcc90fa74932839fabd2857199748b1a1d606de451b1fab515e3cd0891c9257146ddbca15bc9c50853f5f8582685d489c839ce52e4dd5f9576910229faea66</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Source Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python的虚拟机框架(1)</title>
      <link href="/2018/05/12/Python%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A1%86%E6%9E%B6-1/"/>
      <url>/2018/05/12/Python%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A1%86%E6%9E%B6-1/</url>
      
        <content type="html"><![CDATA[<p>100篇文章啦 ! ! 给自己鼓个掌, 然后今天就让我们来看一下Python的虚拟机框架吧. 我们从整个虚拟机的执行环境来看起来, 接着从命名空间和作用域的角度来切入看下Python虚拟机的运行时环境.</p><p>废话不说了, 开始吧!</p><span id="more"></span><h2 id="Python的虚拟机基本认识"><a href="#Python的虚拟机基本认识" class="headerlink" title="Python的虚拟机基本认识"></a>Python的虚拟机基本认识</h2><p>说道这个虚拟机啊, 其实就和我们操作系统运行可执行程序差不多的设计. 以我们现在的x86运行可执行程序为例, 我们内存中会被组织成为一个个运行时栈, 随着一层层的调用关系, 一个个新的东西被压入栈.</p><p>这个所谓的<strong>东西</strong>. 其实也是有个名字的, 叫做<strong>帧</strong>. 我们知道esp代表的是栈指针, 那帧指针就是ebp. 举个例子, 当我们进行了一次函数调用的时候, 系统保存上一个帧的栈指针和帧指针, 当内层函数执行结束之后, 就会按照记录的位置<strong>返回</strong>回去.  从而使得程序的运行空间回到了调用者的那个帧. </p><p>Python的虚拟机执行, 和这个过程几乎无异. 我们在之前了解到了Python的字节码对象, 这个CodeObject包含了许多虚拟机执行字节码所需要的信息, 但是注意: CodeObject所包含的信息 都是<strong>静态</strong>的. 然而我们的程序执行是一个动态的过程, 一个静态的对象是无法携带动态信息的.</p><p>什么是动态的信息? 举个例子, 我们最常见的一个动态环境就是 — 作用域(命名空间)了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    i = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>上述代码作为一个可执行模块运行的时候, 会打印两次符号<code>i</code>的值, 但是这两个<code>i</code>的值是不一样的, 这是因为作用域不一样, 命名空间发生了切换, 所以同样的符号代表的东西不一样. 用之前我们对Python字节码和CodeObject的了解, 我们可以确定两个<code>print(i)</code>产生的字节码是一样, 同样的字节码, 执行的结果却不一样, 这就是因为引入了动态环境.</p><p>用上面的说法来说就是, 新的执行环境被创建就是说新的帧被创建并且压入到了执行栈中.</p><p>这么一个帧的抽象, 就是Python的帧对象 — <code>PyFrameObject</code></p><h2 id="认识帧对象"><a href="#认识帧对象" class="headerlink" title="认识帧对象"></a>认识帧对象</h2><p>现在就让我们来看一下这个帧对象的定义是什么样子的吧.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">f_back</span>;</span><span class="comment">/* previous frame, or NULL */</span></span><br><span class="line">    PyCodeObject *f_code;<span class="comment">/* code segment */</span></span><br><span class="line">    PyObject *f_builtins;<span class="comment">/* builtin symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_globals;<span class="comment">/* global symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_locals;<span class="comment">/* local symbol table (any mapping) */</span></span><br><span class="line">    PyObject **f_valuestack;<span class="comment">/* points after the last local */</span></span><br><span class="line">    <span class="comment">/* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.</span></span><br><span class="line"><span class="comment">       Frame evaluation usually NULLs it, but a frame that yields sets it</span></span><br><span class="line"><span class="comment">       to the current stack top. */</span></span><br><span class="line">    PyObject **f_stacktop;</span><br><span class="line">    PyObject *f_trace;<span class="comment">/* Trace function */</span></span><br><span class="line">...</span><br><span class="line">    PyThreadState *f_tstate;</span><br><span class="line">    <span class="type">int</span> f_lasti;<span class="comment">/* Last instruction if called */</span></span><br><span class="line">    <span class="comment">/* As of 2.3 f_lineno is only valid when tracing is active (i.e. when</span></span><br><span class="line"><span class="comment">       f_trace is set) -- at other times use PyCode_Addr2Line instead. */</span></span><br><span class="line">    <span class="type">int</span> f_lineno;<span class="comment">/* Current line number */</span></span><br><span class="line">    <span class="type">int</span> f_iblock;<span class="comment">/* index in f_blockstack */</span></span><br><span class="line">    PyTryBlock f_blockstack[CO_MAXBLOCKS]; <span class="comment">/* for try and loop blocks */</span></span><br><span class="line">    PyObject *f_localsplus[<span class="number">1</span>];<span class="comment">/* locals+stack, dynamically sized */</span></span><br><span class="line">&#125; PyFrameObject;</span><br></pre></td></tr></table></figure><p>初次这么一看还真的是有一点复杂, 除了那个固定的头部, 下一个就是串联这些帧的, 像链表一样把这些帧联系起来.</p><p>接着就是这个帧中的代码对象, 之后的就是<code>builtin</code>, <code>globals</code>, <code>locals</code>的命名空间. 所以现在我们稍微有点感觉了, 命名空间看起来其实就是一个字典. 关于命名空间我们再后面的小节继续看.</p><p>关于这个对象的头部, 是Python的可变长对象的固定头部, 这就说明这个帧对象的长度是发生变化的, 来看上面代码定义的最后一行. 通过注释我们也可以搞清楚 这个就是这个帧对象所维护的一块动态内存, 包括变量, 对象集合还有运行时栈. 而且不仅如此, 这个帧对象的里面还包括一个代码对象呢.  不同的代码对象在执行的时候所需要的栈空间是不一样的, 一个代码对象所需要的空间到底有多大, 只有当我们编译这个CodeObject的时候才能知道, 这也就是为什么帧对象也是一个可变对象.</p><p>现在就让我们近距离的接触一下这个对象吧, 尽管这是一个非常底层和私密的对象, 但是Python还是实现了一个C级别的方法, 可以让我们访问到这个对象, 来试试下面的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>global_value = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line"><span class="meta">... </span>    frame = sys._getframe()</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;Current function is %s&quot;</span> % frame.f_code.co_name)</span><br><span class="line"><span class="meta">... </span>    caller = frame.f_back</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;Caller function is %s&quot;</span> % caller.f_code.co_name)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;Caller&#x27;s local namespace: %s&quot;</span> % caller.f_locals)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;Caller&#x27;s global namespace: %s&quot;</span> % caller.f_globals.keys())</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line"><span class="meta">... </span>    local_value = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    g()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"><span class="meta">... </span>    f()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main()</span><br><span class="line">Current function <span class="keyword">is</span> g</span><br><span class="line">Caller function <span class="keyword">is</span> f</span><br><span class="line">Calle<span class="string">r&#x27;s local namespace: &#123;&#x27;</span>local_value<span class="string">&#x27;: 2&#125;</span></span><br><span class="line"><span class="string">Caller&#x27;</span>s <span class="keyword">global</span> namespace: dict_keys([<span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;sys&#x27;</span>, <span class="string">&#x27;global_value&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;main&#x27;</span>])</span><br></pre></td></tr></table></figure><p>;-) 很有趣吧 !</p><p> 那么现在我们来关注一个小细节, 这个frame所维护的动态内存到底是由哪些东西组成的呢? 我们进入到这个帧新建的函数中: ( 删除了大量代码 )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Py_ssize_t extras, ncells, nfrees;</span><br><span class="line">ncells = PyTuple_GET_SIZE(code-&gt;co_cellvars);</span><br><span class="line">nfrees = PyTuple_GET_SIZE(code-&gt;co_freevars);</span><br><span class="line">extras = code-&gt;co_stacksize + code-&gt;co_nlocals + ncells + nfrees;</span><br><span class="line">...</span><br><span class="line">extras = code-&gt;co_nlocals + ncells + nfrees;</span><br><span class="line">f-&gt;f_valuestack = f-&gt;f_localsplus + extras; <span class="comment">// 这个就是运行时栈的栈底</span></span><br><span class="line">f-&gt;f_stacktop = f-&gt;f_valuestack; <span class="comment">// 运行时栈的栈顶</span></span><br></pre></td></tr></table></figure><p>说明一下, code就是我们之前研究的代码对象 - CodeObject.  你会发现上面的代码中的<code>extra</code>出现了重复赋值, 其实啊, 第一次的<code>extra</code>就是frameobject所维护的动态内存大小, 至于第二次的那个, 是为了计算初始化的时候运行时栈的栈顶, 从而计算出后面的栈底和栈顶.</p><h2 id="Python的核心概念-—-命名空间"><a href="#Python的核心概念-—-命名空间" class="headerlink" title="Python的核心概念 — 命名空间"></a>Python的核心概念 — 命名空间</h2><p>我们在上面的访问帧对象的例子中展示了三个命名空间 - ( builtin, local, global ). 其实提到命名空间, 你一定想到了很多与之相关联的东西, 例如: 名字, 符号, 作用域这些. 接下来我们就来仔细的研究下这些和与之相关的话题吧.</p><p>说到命名空间 我们就从Python程序最基础的结构 - 模块开始说起. 我们知道, 对于一个不小的Python项目, 我们不会把代码都放在一个模块里面, 而是分多个<code>.py</code>文件进行抽象, 模块化, 从而达到代码的复用, 其实除了这些, 我们还做了一件事情, 那就是<strong>划分命名空间</strong>. 在我们的Coding过程中, 每次声明一个变量, 声明一个函数或者创建一个类的时候, 其实都会提供一个名字, 这个名字倒不是很重要, 他只是一个单纯的名字, 真正重要的是名字背后的对象. 而找到这个对象的唯一途径, 就是通过这个名字.</p><p>我们知道, Python程序的执行就是模块的加载, 而加载方式有两种, 一种就是通过我们执行<code>python main.py</code>这样的方式来加载主Module, 或者通过在模块中使用<code>import</code>关键字进行的动态加载, 而在执行动态加载的时候就会将模块中代码全部执行一遍.</p><p>对了 在这里提一下, 我们的代码是逐行执行的, 也就是说:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这样子的代码, 会先执行<code>def foo():</code>再执行<code>pass</code>, 其实你可能会觉得奇怪, 为啥<code>def foo()</code>这样的语句也是可以执行的, 其实如果我们向底层的方向看去就不会认为这是不可执行的语句啦.</p><p>事实上, 在Python中, <code>def foo():pass</code> 是一个<strong>赋值语句</strong>. 同样也是赋值语句的例子就是形如 <code>a = 10</code>.  他们在执行的时候都会和下面的过程想吻合:</p><ul><li>创建一个对象obj</li><li>将obj “赋给” 一个名字(或者是符号) name</li></ul><p>除了这种简单的, 还有类似<code>import XXX</code> , <code>class Bar()</code>这样子的, 也都是<strong>赋值语句</strong>. 既然我们把这个obj和name建立了<strong>映射</strong>, 就会存在一种<strong>约束</strong>关系. 而这种约束就存在于我们的命名空间中.</p><p>而我们之前在说帧对象的时候就说明了, 命名空间在Python虚拟机中是使用的PyDictObject来表示的, 向上面的例子, 存储起来就是: <code>(foo, function object), (a, 10)</code>. </p><p>那么既然存在这种属性赋值的语句, 自然就存在需要使用这些赋予的值的 <strong>属性引用</strong> 语句. 这些语句就类似: <code>import A, print(A.a)</code> 在这里, <code>A.a</code>就是在访问A模块(module)所定义的命名空间中的<code>a</code>属性.</p><p>注意哦, 这里我们讨论的是模块和模块之间的命名空间. 但是其实更复杂的是在模块中命名空间的相关规则. 其实你大概可以猜出来, 这种规则应该会嵌套的 !</p><h2 id="Python的核心概念-—-作用域"><a href="#Python的核心概念-—-作用域" class="headerlink" title="Python的核心概念 — 作用域"></a>Python的核心概念 — 作用域</h2><p>按照我们刚刚在上一个节说的规则, 创建约束, 放到命名空间中, 这样看起来是可行的. 来看这么一段代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">   <span class="built_in">print</span>(a) <span class="comment"># 输出100</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># 输出10</span></span><br></pre></td></tr></table></figure><p>如果说只要按照基本的规则, 这里输出的a应该值是一样的, 但是显然不是这样. 这就说明肯定是有两个约束被建立, 尽管他们的键是一样的! 但是这是不可能的, 因为一个字典的键不可能重复. 等等, 如果说有多个字典呢? </p><p>这里我们就可以引入Python的作用域的概念啦! 其实大家都了解的, 关于作用域, 上述代码中的函数定义就建立了一个作用域, 我们说的约束, 就是在这个作用域中才可以起到作用, 当我们进行作用域的切换的时候, 约束的作用也在变化. 那么问题就来了, 我们怎么知道一个约束的效果是怎么起作用的呢? 我们的Python源程序说到底是纯文本, 也就是说在我们写好这个程序的时候, 作用域的位置就已经可以确定了(静态的). </p><p>我们在上面的属性引用段落中, 使用了<code>A.a</code>这样子的语句, 这里就是明确指出使用A模块作用域中的<code>a</code>, 我们访问或者说引用的是A中的名字为a的对象. 但是说如果在B中也有一个a, 想要引用访问它, 我只需要写一个a就行了, 这就是<strong>直接引用</strong>. </p><p>那假如说在上面代码中, 函数foo的定义中, 没有a的定义, 也就是删去第3行的代码. 那么当我打印a的时候会发生什么? 在foo所生成的作用域中, 没有名字为a的对象, 这个时候 我们就要到上一个级别的, 也就是嵌套的作用域. 由此, Python使用的是<strong>最内嵌套作用域规则</strong>, 即: 一个赋值语句所带来的作用域对它内部的作用域依然可见, 除非被引进同样名字的另一个赋值语句所<strong>遮蔽</strong>.</p><h3 id="LGB规则和LEGB规则"><a href="#LGB规则和LEGB规则" class="headerlink" title="LGB规则和LEGB规则"></a>LGB规则和LEGB规则</h3><p>还记得我们一开始在帧对象的时候看到的几个命名空间吗: <code>locals, globals, builtins</code>. 所谓LGB, 其实就是说Python会沿着这个路线进行符号的检索, 所谓local, 就是类似我们一个函数所定义出来的区域, 而global就是一个模块的顶层命名空间, 最后, Python自己定义了一个最顶级的命名空间: builtin. 这里面就存在这我们的<code>range, dir, open</code>等等函数符号了.</p><p>有的时候, 我们的local和global可能会是一样的, 例如我们上面的代码, 第二个<code>print(a)</code>. 所对应的local和global就是一样的, 说到底, 其实就是帧对象中的<code>f_locals</code>和<code>f_globals</code>对应的是同一个PyDictObject了.</p><p>那么啥是LEGB, 这个E其实就是<code>enclosing</code>的意思, 其实就是<strong>闭包</strong>了, 很久之前我曾经写过关于Javascript的闭包问题. 其实这个地方是差不多的, 一个简单的例子就是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>显然, 上述代码执行之后打印的结果是2. 其实按照我们之前说的道理还是可以说通的, 因为作用域是静态的 bar的定义在foo里面, 所以显然foo的名字对bar也是可见的. 其实Python在处理的时候, 是把<code>a=2</code>这一句赋值语句所创建的约束, 和下面定义的<code>bar</code>函数对象绑定在了一起, 这个绑定的东西其实就是闭包.</p><h3 id="小测验"><a href="#小测验" class="headerlink" title="小测验"></a>小测验</h3><p>来看看到底有没有搞清楚这个神奇的作用域规则吧.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    </span><br><span class="line">foo()</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p>上面的代码执行会发生什么? </p><p>答案是: <strong>会抛出运行时异常.</strong></p><p>原因就在bar所企图打印的第一个a, 还没有被赋值. 因为即使我们在global中存在a, 但是我们在bar中依然定义了a这个名字, 尽管, 他还暂时没有被赋值, 但是我们已经在命名空间中把它写入了. 如果你不信, 我们可以来看一下这一段的字节码.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> dis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>src = <span class="built_in">open</span>(<span class="string">&quot;test.py&quot;</span>).read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>code = <span class="built_in">compile</span>(src, <span class="string">&quot;test.py&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>code.co_consts</span><br><span class="line">(<span class="number">10</span>, &lt;code <span class="built_in">object</span> foo at <span class="number">0x102aaf8a0</span>, file <span class="string">&quot;test.py&quot;</span>, line <span class="number">11</span>&gt;, <span class="string">&#x27;foo&#x27;</span>, &lt;code <span class="built_in">object</span> bar at <span class="number">0x102acf420</span>, file <span class="string">&quot;test.py&quot;</span>, line <span class="number">14</span>&gt;, <span class="string">&#x27;bar&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(code.co_consts[<span class="number">1</span>])</span><br><span class="line"> <span class="number">12</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_GLOBAL              <span class="number">1</span> (a)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(code.co_consts[<span class="number">3</span>])</span><br><span class="line"> <span class="number">15</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line"></span><br><span class="line"> <span class="number">16</span>           <span class="number">8</span> LOAD_CONST               <span class="number">1</span> (<span class="number">2</span>)</span><br><span class="line">             <span class="number">10</span> STORE_FAST               <span class="number">0</span> (a)</span><br><span class="line"></span><br><span class="line"> <span class="number">17</span>          <span class="number">12</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="built_in">print</span>)</span><br><span class="line">             <span class="number">14</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">             <span class="number">16</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">18</span> POP_TOP</span><br><span class="line">             <span class="number">20</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">22</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>可以看到, 在<code>foo</code>中和<code>bar</code>中的字节码根本不一样, 对于后者, 他所使用的是<code>LOAD_FAST</code>指令.</p><p>其实这里也就是我们在上面所说的<strong>遮蔽</strong>了.  但是有的时候, 我确实是需要先打印globals中的a, 接着想要再次赋值, 这怎么办呢?  没关系, 通过使用python提供的<code>global</code>关键字, 就可以达到效果了.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    </span><br><span class="line">foo()</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p>以上就是对Python的名字引用的基础讨论了, 除了名字引用, 我们还有属性引用, 但是属性引用, 就显得很简单了, 他只会在当前的名字的名字的作用域中进行搜索, 有就是有了, 没有就没有.</p><h2 id="Python虚拟机运行时环境初探"><a href="#Python虚拟机运行时环境初探" class="headerlink" title="Python虚拟机运行时环境初探"></a>Python虚拟机运行时环境初探</h2><p>我们之前讨论的都是执行环境, 而现在所涉及到的是叫做运行时环境. 在Python中, 通过模拟x86的栈帧来执行py程序. 那么整个程序是怎么开始执行的呢, 我们可以看一下在<code>ceval.c</code>中所定义的函数: <code>PyEval_EvalFrameEx</code>. 这是一个无比巨大的函数, 算上注释大概有2k+行, 其实本质上就是对Python虚拟机的实现, 实在是看不下去, 所以只能按照书中的, 简单的先看一下这个函数的整体架构和一些比较明显的动作.</p><p>首先, 肯定是初始化操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">co = f-&gt;f_code;</span><br><span class="line">names = co-&gt;co_names;</span><br><span class="line">consts = co-&gt;co_consts;</span><br><span class="line">fastlocals = f-&gt;f_localsplus;</span><br><span class="line">freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;</span><br><span class="line">first_instr = (<span class="type">unsigned</span> <span class="type">char</span>*) PyString_AS_STRING(co-&gt;co_code);</span><br><span class="line"><span class="comment">/* An explanation is in order for the next line.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   f-&gt;f_lasti now refers to the index of the last instruction</span></span><br><span class="line"><span class="comment">   executed.  You might think this was obvious from the name, but</span></span><br><span class="line"><span class="comment">   this wasn&#x27;t always true before 2.3!  PyFrame_New now sets</span></span><br><span class="line"><span class="comment">   f-&gt;f_lasti to -1 (i.e. the index *before* the first instruction)</span></span><br><span class="line"><span class="comment">   and YIELD_VALUE doesn&#x27;t fiddle with f_lasti any more.  So this</span></span><br><span class="line"><span class="comment">   does work.  Promise. */</span></span><br><span class="line">next_instr = first_instr + f-&gt;f_lasti + <span class="number">1</span>;</span><br><span class="line">stack_pointer = f-&gt;f_stacktop;</span><br><span class="line">assert(stack_pointer != <span class="literal">NULL</span>);</span><br><span class="line">f-&gt;f_stacktop = <span class="literal">NULL</span>;<span class="comment">/* remains NULL unless yield suspends frame */</span></span><br></pre></td></tr></table></figure><p>这里涉及到了我们之前所说的code对象和frame对象, 另外还做了一个超级重要的事情, 那就是初始化栈顶指针.我们可以看到这里面有三个变量: <code>first_instr</code>, <code>next_instr</code>, <code>f_lasti</code>. first所指向的, 就是这个字节码序列开始的地方, 而last永远指向上一条执行的指令位置, 至于next, 表示的就是下一条要指向的指令位置. 这些指针是怎么进行切换的呢, 我们来看 .</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ...</span><br><span class="line">        f-&gt;f_lasti = INSTR_OFFSET();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* line-by-line tracing support */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tstate-&gt;c_tracefunc != <span class="literal">NULL</span> &amp;&amp; !tstate-&gt;tracing) &#123;</span><br><span class="line"><span class="comment">/* see maybe_call_line_trace</span></span><br><span class="line"><span class="comment">   for expository comments */</span></span><br><span class="line">f-&gt;f_stacktop = stack_pointer;</span><br><span class="line"></span><br><span class="line">err = maybe_call_line_trace(tstate-&gt;c_tracefunc,</span><br><span class="line">    tstate-&gt;c_traceobj,</span><br><span class="line">    f, &amp;instr_lb, &amp;instr_ub,</span><br><span class="line">    &amp;instr_prev);</span><br><span class="line"><span class="comment">/* Reload possibly changed frame fields */</span></span><br><span class="line">JUMPTO(f-&gt;f_lasti);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_stacktop != <span class="literal">NULL</span>) &#123;</span><br><span class="line">stack_pointer = f-&gt;f_stacktop;</span><br><span class="line">f-&gt;f_stacktop = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="comment">/* trace function raised an exception */</span></span><br><span class="line"><span class="keyword">goto</span> on_error;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Extract opcode and argument */</span></span><br><span class="line"></span><br><span class="line">opcode = NEXTOP();</span><br><span class="line">oparg = <span class="number">0</span>;   <span class="comment">/* allows oparg to be stored in a register because</span></span><br><span class="line"><span class="comment">it doesn&#x27;t have to be remembered across a full loop */</span></span><br><span class="line"><span class="keyword">if</span> (HAS_ARG(opcode))</span><br><span class="line">oparg = NEXTARG();</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>一个for循环, 内部是一个巨大的switch&#x2F;case分支. 这里面出现了一些宏, 我们来看一下定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INSTR_OFFSET()((int)(next_instr - first_instr))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXTOP()(*next_instr++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXTARG()(next_instr += 2, (next_instr[-1]&lt;&lt;8) + next_instr[-2])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PEEKARG()((next_instr[2]&lt;&lt;8) + next_instr[1])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMPTO(x)(next_instr = first_instr + (x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMPBY(x)(next_instr += (x))</span></span><br></pre></td></tr></table></figure><p>其实这些就是在进行下一条指令指针的移动, Python在执行过程中会遇到不同的字节码指令, 接着就会会根据这些指令进行switch切换从而去实现不同的功能, 就是这样, 来进行程序的执行.</p><p>现在就清晰多了吧 ! ! 最后我们再来提及一下这里面的一个神奇的变量, 叫做: <code>why</code>.</p><p>这个是用来记录当指令执行遇到错误的时候, 也就是发生异常的时候 停止执行的原因是什么. 有这些:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Status code for main loop (reason for stack unwind) */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">why_code</span> &#123;</span></span><br><span class="line">WHY_NOT =<span class="number">0x0001</span>,<span class="comment">/* No error */</span></span><br><span class="line">WHY_EXCEPTION = <span class="number">0x0002</span>,<span class="comment">/* Exception occurred */</span></span><br><span class="line">WHY_RERAISE =<span class="number">0x0004</span>,<span class="comment">/* Exception re-raised by &#x27;finally&#x27; */</span></span><br><span class="line">WHY_RETURN =<span class="number">0x0008</span>,<span class="comment">/* &#x27;return&#x27; statement */</span></span><br><span class="line">WHY_BREAK =<span class="number">0x0010</span>,<span class="comment">/* &#x27;break&#x27; statement */</span></span><br><span class="line">WHY_CONTINUE =<span class="number">0x0020</span>,<span class="comment">/* &#x27;continue&#x27; statement */</span></span><br><span class="line">WHY_YIELD =<span class="number">0x0040</span><span class="comment">/* &#x27;yield&#x27; operator */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然说我们现在稍微清楚了一点关于栈帧的事情, 但是实际上从操作系统的层面上, 我们对执行的程序抽象其实是进程和线程. 那么对于这个, Python的运行模型是个什么样子呢? </p><p>同样, Python运行时也会至少存在一条主线程, 而Python也实现了对多线程的支持, 对于Python来说 我们上面说的那个虚拟机框架对于Python而言, 其实就是一个软CPU, 而所谓多线程的实现其实就是不断的切换使用这个软CPU.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Source Code </tag>
            
            <tag> Python VM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python源码阅读-虚拟机之Code对象和pyc探秘</title>
      <link href="/2018/03/20/Python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BCode%E5%AF%B9%E8%B1%A1%E5%92%8Cpyc%E6%8E%A2%E7%A7%98/"/>
      <url>/2018/03/20/Python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BCode%E5%AF%B9%E8%B1%A1%E5%92%8Cpyc%E6%8E%A2%E7%A7%98/</url>
      
        <content type="html"><![CDATA[<p>这是《Python源码剖析 — 深度探索动态语言核心技术》的阅读记录.</p><p>从这一篇开始, 我们就要和Python的虚拟机打交道了, 在开始本篇的正式内容之前, 我们先来讨论下Python程序的执行是怎样进行的吧.</p><p>众所周知, Python是一个解释型语言. 而我上个学期学习了《编译原理》这门课, 再加上书中的说明, 现在我想说,<strong>Python和Java, C#一样, 都是需要编译的语言.</strong></p><p>大家在写Python的时候都会知道, 在我们执行过一个python程序之后, 会出现一个<code>.pyc</code>文件. 这有没有想到什么? 没错, 有没有联想到Java的<code>.class</code>文件? 事实上, 我们Python的执行过程仍然是类似Java的, 先通过解释器(interpreter)进行<strong>编译</strong>, 生成<code>.pyc</code>文件, 这个文件中就是源程序的字节码集合, 接着, 通过虚拟机(virtual machine)进行一条条字节码的执行, 从而完成执行过程.</p><p>只不过, 这里的虚拟机和我们的JVM仍然是有区别的, 那就是Python的虚拟机要更上层一点, 也就是离机器底层更远一点.</p><p>接下来我们就从Python的Code对象开始看起.</p><span id="more"></span> <h2 id="PYC的起源"><a href="#PYC的起源" class="headerlink" title="PYC的起源"></a>PYC的起源</h2><p>在我们使用Python的编译器进行代码编译的时候, 会产生许多信息, 包含字符串, 常量, 一些特殊操作等等, 在编译过程中, 这些静态信息就会被编译器收集起来, 储存到一个地方. 这个地方是哪里呢? 现在我们要想的稍微动态一点了, 因为现在我们开始研究虚拟机了嘛, 这个虚拟机可是在你的程序运行的时候一直也在运行的, 所以说这些信息其实也是存储在一个动态的运行时对象身上的. 这个对象就是我们待会要说的<code>PyCodeObject</code>. 另外, 有的时候, 在我们结束Python程序的运行时, 会多出来一个叫做<code>.pyc</code>的文件, 这个文件就是我们的<code>PyCodeObject</code>对象的序列化.</p><p>所以其实说白了, 这个<code>.pyc</code>文件就是<code>PyCodeObject</code>对象在磁盘上的表现形式, 他们所代表的东西都是一样的. 这样做的一个好处就是, 在下一次执行Python程序的时候, 虚拟机可以通过读取这个文件从而直接在内存中build出Code对象.</p><h2 id="Code对象初探"><a href="#Code对象初探" class="headerlink" title="Code对象初探"></a>Code对象初探</h2><p>接下来我们就来看下这个<code>PyCodeObject</code>是个什么样子的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">int</span> co_argcount;<span class="comment">/* #arguments, except *args */</span></span><br><span class="line">    <span class="type">int</span> co_nlocals;<span class="comment">/* #local variables */</span></span><br><span class="line">    <span class="type">int</span> co_stacksize;<span class="comment">/* #entries needed for evaluation stack */</span></span><br><span class="line">    <span class="type">int</span> co_flags;<span class="comment">/* CO_..., see below */</span></span><br><span class="line">    PyObject *co_code;<span class="comment">/* instruction opcodes */</span></span><br><span class="line">    PyObject *co_consts;<span class="comment">/* list (constants used) */</span></span><br><span class="line">    PyObject *co_names;<span class="comment">/* list of strings (names used) */</span></span><br><span class="line">    PyObject *co_varnames;<span class="comment">/* tuple of strings (local variable names) */</span></span><br><span class="line">    PyObject *co_freevars;<span class="comment">/* tuple of strings (free variable names) */</span></span><br><span class="line">    PyObject *co_cellvars;      <span class="comment">/* tuple of strings (cell variable names) */</span></span><br><span class="line">    <span class="comment">/* The rest doesn&#x27;t count for hash/cmp */</span></span><br><span class="line">    PyObject *co_filename;<span class="comment">/* string (where it was loaded from) */</span></span><br><span class="line">    PyObject *co_name;<span class="comment">/* string (name, for reference) */</span></span><br><span class="line">    <span class="type">int</span> co_firstlineno;<span class="comment">/* first source line number */</span></span><br><span class="line">    PyObject *co_lnotab;<span class="comment">/* string (encoding addr&lt;-&gt;lineno mapping) */</span></span><br><span class="line">    <span class="type">void</span> *co_zombieframe;     <span class="comment">/* for optimization only (see frameobject.c) */</span></span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure><p>现在我们也不是很了解这些都是起到什么作用的, 所以就先不细看了. 不过一个Code对象到底代表什么呢? 是一段代码? 还是一个py文件?</p><p>事实上, Python编译器在对Python源文件进行编译的的时候, 是将一个代码块就抽象成一个Code对象的. 那么什么是一个代码块(Code Block), 这个概念在其他的语言里面也有哦, 虽然有的时候意思发生了一点改变, 在这里代码块的意思是一个<strong>命名空间</strong>就是一个代码块了, 简单的说可以认为一个作用域的出现就是一个代码块的出现了, 例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>这一段代码运行的时候就会产生3个代码对象, 一个对应整个Py源文件的, 一个是<code>class A</code>所带来的作用域, 一个是<code>def foo()</code>所带来的.</p><p>命名空间将会是我们之后还会观察的东西, 在Python中, 一个符号所代表的意义是取决于命名空间的, 一个又一个的命名空间所生成的<strong>命名空间链</strong>, 虚拟机在执行的过程中, 会消耗一定量的时间和资源在这个链中检索, 从而寻找符号所代表的意义或者对象是什么.</p><p>其实在Python中, 我们可以通过调用他设计的与C一级PyCodeObject对象的code对象来访问, 直接来试一下吧:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>source = <span class="built_in">open</span>(<span class="string">&quot;FloatRange.py&quot;</span>).read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>co = <span class="built_in">compile</span>(source, <span class="string">&quot;FloatRange.py&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(co)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;code&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(co)</span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__cmp__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;co_argcount&#x27;</span>, <span class="string">&#x27;co_cellvars&#x27;</span>, <span class="string">&#x27;co_code&#x27;</span>, <span class="string">&#x27;co_consts&#x27;</span>, <span class="string">&#x27;co_filename&#x27;</span>, <span class="string">&#x27;co_firstlineno&#x27;</span>, <span class="string">&#x27;co_flags&#x27;</span>, <span class="string">&#x27;co_freevars&#x27;</span>, <span class="string">&#x27;co_lnotab&#x27;</span>, <span class="string">&#x27;co_name&#x27;</span>, <span class="string">&#x27;co_names&#x27;</span>, <span class="string">&#x27;co_nlocals&#x27;</span>, <span class="string">&#x27;co_stacksize&#x27;</span>, <span class="string">&#x27;co_varnames&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> co.co_name</span><br><span class="line">&lt;module&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> co.co_filename</span><br><span class="line">FloatRange.py</span><br></pre></td></tr></table></figure><h2 id="pyc文件初探"><a href="#pyc文件初探" class="headerlink" title="pyc文件初探"></a>pyc文件初探</h2><p>现在我们就要来研究下pyc文件了, 在此之前我们必须获取一个pyc才行, 那么说干就干随便写一段Python代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><p>执行.</p><p>接下来找一找它生成的<code>__pycache__</code>中的 <code>.pyc</code>. 哎? 怎么没有? </p><p>事实上, 我们在日常的编码中也可以发现这个事情, 有点时候就会生成<code>__pycache__</code>有的时候就是没有. 至于原因, 或者说Python什么时候会生成pyc文件, 我简单的查了下知乎, 看了下文档. 大概就是:</p><p>**<code>.pyc</code>的产生, 不是为了提升执行速度而存在的. 他只是为了能够更快的<code>load</code>. 也就是说, 如果这个<code>.py</code>不是为了load而存在的, 他就不需要存在于硬盘上(毕竟存到硬盘上还是要时间的啊). **</p><p>什么样的<code>.py</code>会被load? 自然就是我们通过<code>import</code>进来的模块啥的, 那么我们再做一个实验:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line"><span class="comment"># File Name: A.py</span></span><br><span class="line"><span class="comment"># Author:Justin</span></span><br><span class="line"><span class="comment"># mail:justin13wyx@gmail.com</span></span><br><span class="line"><span class="comment"># Created Time: Sun Mar 25 13:13:06 2018</span></span><br><span class="line"><span class="comment"># ==============================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着在另一个:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line"><span class="comment"># File Name: B.py</span></span><br><span class="line"><span class="comment"># Author:Justin</span></span><br><span class="line"><span class="comment"># mail:justin13wyx@gmail.com</span></span><br><span class="line"><span class="comment"># Created Time: Sun Mar 25 13:13:29 2018</span></span><br><span class="line"><span class="comment"># ==============================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> A <span class="keyword">import</span> A</span><br><span class="line"></span><br><span class="line">instance_a = A()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时执行一下B.py就可以出发这个机制了, 你会看到熟悉的<code>__pycache__</code>和<code>A.cpython-36.pyc</code>. 因为A被load了.</p><p>其实在Python运行过程中, 如果遇到<code>import XXX</code>这样的语句, 就会先去设定好的路径里面找<code>XXX.pyc</code>或者<code>XXX.dll</code>. 如果说找到了, 就会先对比时间戳, 如果有必要就会重新生成. 如果没有, 就会先去编译<code>XXX.py</code> 再将编译生成的PyCodeObject中间结果创建成<code>.pyc</code>文件. 最后再加载生成的<code>.pyc</code>就像前面说的, 将从这个<code>.pyc</code>中PyCodeObject在内存中复制出来.</p><p>但是我们也可以手动的生成pyc或者pyo文件, 通过使用Python提供的编译工具:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  /tmp python</span><br><span class="line">Python <span class="number">3.6</span><span class="number">.3</span> (v3<span class="number">.6</span><span class="number">.3</span>:2c5fed86e0, Oct  <span class="number">3</span> <span class="number">2017</span>, <span class="number">00</span>:<span class="number">32</span>:08)</span><br><span class="line">[GCC <span class="number">4.2</span><span class="number">.1</span> (Apple Inc. build <span class="number">5666</span>) (dot <span class="number">3</span>)] on darwin</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> <span class="built_in">compile</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">&#x27;compile&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> py_compile</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>py_compile.<span class="built_in">compile</span>(<span class="string">&quot;./demo.py&quot;</span>)</span><br><span class="line"><span class="string">&#x27;./__pycache__/demo.cpython-36.pyc&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>这样就会生成<code>.pyc</code>了.</p><p>接下来就到了解开<code>.pyc</code>神秘面纱的时候了, 再次之前 我们必须要看看PyCodeObject有哪些域, 这样才可以理解pyc的格式.</p><p>还是把之前的Code对象的声明列出来, 这一次我们就写上每一个域的意义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">int</span> co_argcount;位置参数的个数</span><br><span class="line">    <span class="type">int</span> co_nlocals;局部变量的个数</span><br><span class="line">    <span class="type">int</span> co_stacksize;执行这个CodeBlock所需要的栈大小</span><br><span class="line">    <span class="type">int</span> co_flags;<span class="comment">/* CO_..., see below */</span></span><br><span class="line">    PyObject *co_code;字节码指令, 存在形式是PyStringObject</span><br><span class="line">    PyObject *co_consts;所有常量</span><br><span class="line">    PyObject *co_names;所有符号</span><br><span class="line">    PyObject *co_varnames;局部变量集合</span><br><span class="line">    PyObject *co_freevars;闭包的实现</span><br><span class="line">    PyObject *co_cellvars;局部变量, 仅仅用于内部嵌套函数</span><br><span class="line">    <span class="comment">/* The rest doesn&#x27;t count for hash/cmp */</span></span><br><span class="line">    PyObject *co_filename;该Code Block对应的.py文件中的起始行</span><br><span class="line">    PyObject *co_name;CodeBlock的名字</span><br><span class="line">    <span class="type">int</span> co_firstlineno;该CodeBlock对应的起始行</span><br><span class="line">    PyObject *co_lnotab;字节码指令和源代码行数的映射</span><br><span class="line">    <span class="type">void</span> *co_zombieframe;</span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure><p>有意思的是哪个字节码和源码行号的映射. Python不是简单的直接记录, 而是采取增量式的记录方式, 例如: <code>0, 1, 6, 1, 44, 5</code>这个的意思就是:</p><p>字节码偏移0位, 对应源代码第1行, 字节码偏移0+6位, 对应源代码第1+1行, 字节码偏移0+6+44位, 对应源代码1+1+5行.</p><p>OK, 现在就让我们来看下pyc到底是怎么被创建的吧.</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>首先我们来到<code>/Python/import.c</code>这个文件 (还记得吗, import触发pyc写入), 找到这个函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_compiled_module</span><span class="params">(PyCodeObject *co, <span class="type">char</span> *cpathname, <span class="type">time_t</span> mtime)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"></span><br><span class="line">fp = open_exclusive(cpathname);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (Py_VerboseFlag)</span><br><span class="line">PySys_WriteStderr(</span><br><span class="line"><span class="string">&quot;# can&#x27;t create %s\n&quot;</span>, cpathname);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PyMarshal_WriteLongToFile(pyc_magic, fp, Py_MARSHAL_VERSION);</span><br><span class="line"><span class="comment">/* First write a 0 for mtime */</span></span><br><span class="line">PyMarshal_WriteLongToFile(<span class="number">0L</span>, fp, Py_MARSHAL_VERSION);</span><br><span class="line">PyMarshal_WriteObjectToFile((PyObject *)co, fp, Py_MARSHAL_VERSION);</span><br><span class="line"><span class="keyword">if</span> (fflush(fp) != <span class="number">0</span> || ferror(fp)) &#123;</span><br><span class="line"><span class="keyword">if</span> (Py_VerboseFlag)</span><br><span class="line">PySys_WriteStderr(<span class="string">&quot;# can&#x27;t write %s\n&quot;</span>, cpathname);</span><br><span class="line"><span class="comment">/* Don&#x27;t keep partial file */</span></span><br><span class="line">fclose(fp);</span><br><span class="line">(<span class="type">void</span>) unlink(cpathname);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Now write the true mtime */</span></span><br><span class="line">fseek(fp, <span class="number">4L</span>, <span class="number">0</span>);</span><br><span class="line">assert(mtime &lt; LONG_MAX);</span><br><span class="line">PyMarshal_WriteLongToFile((<span class="type">long</span>)mtime, fp, Py_MARSHAL_VERSION);</span><br><span class="line">fflush(fp);</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">if</span> (Py_VerboseFlag)</span><br><span class="line">PySys_WriteStderr(<span class="string">&quot;# wrote %s\n&quot;</span>, cpathname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 Python唯一性的打开一个文件, 总之就是各种尝试排他性的打开文件.</p><p>接着就是关键部分了, 这个函数写入了三个关键信息到了pyc文件中, 分别是:</p><ul><li>幻数</li><li>时间信息</li><li>PyCodeObject</li></ul><p>所谓幻数, 其实就是一个约定好的整数值, 不同版本的Python会约定不同的幻数, 这其实就是为了保证兼容性的. </p><p>例如说, 当python尝试加载一个pyc文件中的CodeObject的时候, 会先检查文件中的幻数是否一致. 如果不一致就会拒绝加载. 那么为啥同样都是Python , 会出现不兼容的情况呢? 其实想来也很简单了. Python的版本迭代中, 字节码指令时会发生变化的, 可能旧版本的某些指令到了新版本, 发生了变化或者直接被舍弃了.</p><p>那么Python的幻数都是什么样子的呢, 我们可以在<code>import.c</code>文件中看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAGIC (62131 | ((long)<span class="string">&#x27;\r&#x27;</span>&lt;&lt;16) | ((long)<span class="string">&#x27;\n&#x27;</span>&lt;&lt;24))</span></span><br></pre></td></tr></table></figure><p>并且在上面的注释中, 我们可以看到当前版本Python所有的幻数的值.</p><p>接着这里, 我们会发现一个有意思的细节, 关于时间的写入, 先是写了一个0占了一个位置, 接着写完对象文件之后才去写入的真实时间戳. </p><p>关于Python写入这些数据到文件, 所有涉及到的函数和方法实现都存在在<code>marshal.c</code>这个文件中. 总结一下的话, 其实就是下面的这些:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> w_byte(c, p) <span class="keyword">if</span> (((p)-&gt;fp)) putc((c), (p)-&gt;fp); \</span></span><br><span class="line"><span class="meta">      <span class="keyword">else</span> <span class="keyword">if</span> ((p)-&gt;ptr != (p)-&gt;end) *(p)-&gt;ptr++ = (c); \</span></span><br><span class="line"><span class="meta">   <span class="keyword">else</span> w_more(c, p)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">w_long</span><span class="params">(<span class="type">long</span> x, WFILE *p)</span></span><br><span class="line">&#123;</span><br><span class="line">w_byte((<span class="type">char</span>)( x      &amp; <span class="number">0xff</span>), p);</span><br><span class="line">w_byte((<span class="type">char</span>)((x&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>), p);</span><br><span class="line">w_byte((<span class="type">char</span>)((x&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>), p);</span><br><span class="line">w_byte((<span class="type">char</span>)((x&gt;&gt;<span class="number">24</span>) &amp; <span class="number">0xff</span>), p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外, 对于Object写入, 源代码实在是太长了, 这里就不列出来了, 不过实现的逻辑倒是十分简单的, 就是对应不同的PythonObject类型, 传入不同参数的调用底层<code>w_byte</code>.</p><p>例如说, 当写入一个列表对象的时候, 就是将这个列表的内容写入到pyc中, 当加载的时候, 再根据这些数据进行列表对象的重新创建.</p><p>所以截取其中写入CodeObject的代码, 就是这个样子的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (PyCode_Check(v)) &#123;</span><br><span class="line">PyCodeObject *co = (PyCodeObject *)v;</span><br><span class="line">w_byte(TYPE_CODE, p);</span><br><span class="line">w_long(co-&gt;co_argcount, p);</span><br><span class="line">w_long(co-&gt;co_nlocals, p);</span><br><span class="line">w_long(co-&gt;co_stacksize, p);</span><br><span class="line">w_long(co-&gt;co_flags, p);</span><br><span class="line">w_object(co-&gt;co_code, p);</span><br><span class="line">w_object(co-&gt;co_consts, p);</span><br><span class="line">w_object(co-&gt;co_names, p);</span><br><span class="line">w_object(co-&gt;co_varnames, p);</span><br><span class="line">w_object(co-&gt;co_freevars, p);</span><br><span class="line">w_object(co-&gt;co_cellvars, p);</span><br><span class="line">w_object(co-&gt;co_filename, p);</span><br><span class="line">w_object(co-&gt;co_name, p);</span><br><span class="line">w_long(co-&gt;co_firstlineno, p);</span><br><span class="line">w_object(co-&gt;co_lnotab, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯 其实就是把他的属性都写了一遍.</p><p>当你在阅读源代码的时候, 你会发现这个文件中还有很多写入函数和方法, 而且他们都有一个共同点, 那就是他们会在写入真正的数据之前写入一个似乎是表示类型的宏进去.</p><p>这是在干什么? 我们知道, <code>w_byte</code>写入的是字节流, 这样做的一个最大的影响就是 所有的数据都是一个样的, Python无法从这些字节流中分析出这些内容是什么对象的. 这就是类型标识的作用, 通过写入这些约定的类型标识, 我们就可以重建对象.</p><p>关于这些类型, 也都定义在文件中了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_NULL<span class="string">&#x27;0&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_NONE<span class="string">&#x27;N&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_FALSE<span class="string">&#x27;F&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_TRUE<span class="string">&#x27;T&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_STOPITER<span class="string">&#x27;S&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_ELLIPSIS   <span class="string">&#x27;.&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_INT<span class="string">&#x27;i&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_INT64<span class="string">&#x27;I&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_FLOAT<span class="string">&#x27;f&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_BINARY_FLOAT<span class="string">&#x27;g&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_COMPLEX<span class="string">&#x27;x&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_BINARY_COMPLEX<span class="string">&#x27;y&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_LONG<span class="string">&#x27;l&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_STRING<span class="string">&#x27;s&#x27;</span></span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>关于数值写入, 是最简单的了, 只需要写入一下类型, 接着把数值丢进去就行了.</p><p>但是对于字符串,可能就会有一点麻烦了.</p><p>首先我们来关注一下和pyc交互的时候, 有个关键的结构体, 叫做<code>WFILE</code>. 简单的看, 就是一个对文件的简单的封装, 其中有一个域:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyObject *strings; <span class="comment">/* dict on marshal, list on unmarshal */</span></span><br></pre></td></tr></table></figure><p>根据后面的注释, 我们可以看出来, 在写入到pyc的时候, 这是一个字典对象, 当读出的时候, 这是一个列表对象.</p><p>可以在下面的代码看到, 在实际写入之前, 这个域就被创建了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyMarshal_WriteObjectToFile</span><span class="params">(PyObject *x, FILE *fp, <span class="type">int</span> version)</span></span><br><span class="line">&#123;</span><br><span class="line">WFILE wf;</span><br><span class="line">wf.fp = fp;</span><br><span class="line">wf.error = <span class="number">0</span>;</span><br><span class="line">wf.depth = <span class="number">0</span>;</span><br><span class="line">wf.strings = (version &gt; <span class="number">0</span>) ? PyDict_New() : <span class="literal">NULL</span>;</span><br><span class="line">wf.version = version;</span><br><span class="line">w_object(x, &amp;wf);</span><br><span class="line">Py_XDECREF(wf.strings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么接下来我们具体的看下在<code>w_object</code>函数中, 是怎么写入字符串的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (PyString_Check(v)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;strings &amp;&amp; PyString_CHECK_INTERNED(v)) &#123;</span><br><span class="line">        PyObject *o = PyDict_GetItem(p-&gt;strings, v);</span><br><span class="line">        <span class="keyword">if</span> (o) &#123;</span><br><span class="line">            <span class="type">long</span> w = PyInt_AsLong(o);</span><br><span class="line">            w_byte(TYPE_STRINGREF, p);</span><br><span class="line">            w_long(w, p);</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> ok;</span><br><span class="line">            o = PyInt_FromSsize_t(PyDict_Size(p-&gt;strings));</span><br><span class="line">            ok = o &amp;&amp;</span><br><span class="line">                PyDict_SetItem(p-&gt;strings, v, o) &gt;= <span class="number">0</span>;</span><br><span class="line">            Py_XDECREF(o);</span><br><span class="line">            <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">                p-&gt;depth--;</span><br><span class="line">                p-&gt;error = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            w_byte(TYPE_INTERNED, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        w_byte(TYPE_STRING, p);</span><br><span class="line">    &#125;</span><br><span class="line">    n = PyString_GET_SIZE(v);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; INT_MAX) &#123;</span><br><span class="line">        <span class="comment">/* huge strings are not supported */</span></span><br><span class="line">        p-&gt;depth--;</span><br><span class="line">        p-&gt;error = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    w_long((<span class="type">long</span>)n, p);</span><br><span class="line">    w_string(PyString_AS_STRING(v), (<span class="type">int</span>)n, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得我们之前在说String的时候, 提到的Intern机制吗, 这里又要用到了. 写入过程主要的分成了三个判断:</p><ul><li>非Intern字符串写入</li><li>Intern字符串的首次写入</li><li>Intern字符串的非首次写入</li></ul><p>我们先从最简单的来看, 那就是写入普通的字符串, 也就是非Intern的字符串.</p><p>就做了两件事情, 写入长度和写入字符串本身. 很简单.</p><p>问题主要是关于Interned的字符串的, 我们发现这个地方分成首次和非首次写入两种情况. 为什么要这么分类呢? 先不直接解答, 我们看一下非首次写入的Intern字符串, 处理起来很简单, 先是写入了类型信息, 接着是一个long值, 也就是从字典中年获得的值.</p><p>另外一种判断情况, 我们发现这里的很多操作都和上面提到的那个<code>strings</code>域有关系, 我们说这个东西在写入的时候是个字典, 那么这个字典到底写了什么内容? 来看一下代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ok;</span><br><span class="line">o = PyInt_FromSsize_t(PyDict_Size(p-&gt;strings));</span><br><span class="line">ok = o &amp;&amp;</span><br><span class="line">    PyDict_SetItem(p-&gt;strings, v, o) &gt;= <span class="number">0</span>;</span><br><span class="line">Py_XDECREF(o);</span><br><span class="line">...</span><br><span class="line">w_byte(TYPE_INTERNED, p);</span><br></pre></td></tr></table></figure><p>这里我们把错误处理也都略去了, 关键的代码其实就是这么一行:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyDict_SetItem(p-&gt;strings, v, o) &gt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>v是什么? 字符串本体, o是什么? 长度 其实也可以理解成是序号的概念. </p><p>这里主要的疑问就是为啥Python要这么设计, 这个序号有什么意义吗.</p><p>我们假设现在的字典里已经有了一个字符串, 为了解释方便就叫做string吧, 他的值是0, 接着又来了一个新的字符串, 叫做stringstring, 给它编号为1, 这个时候string又来了, 尽管我们之前曾经存了一个, 但是这个时候我又把它作为序号2加了进来, 先不说这里出现了键的冲突, 如果说这个string在之后又出现了多次, 那么这个<code>WFILE</code>的string就会充满很多对于的信息, 我们并不需要存储这么多的无用信息. 也就是说 这就是区分的原因, 当已经有过字典中可以查询到的时候, 不如直接就把这个字符串的某个标识符给拿过来, 最简单的标识符 就是顺序标记的<strong>序号</strong>了. 这就是这么个部分的大体思想.</p><p>就这么结束了? 并不是 , 还记得之前提到的这个神奇的域吗:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyObject *strings; /* dict on marshal, list on unmarshal */</span><br></pre></td></tr></table></figure><p>写入的时候是个字典, 读取的时候是个列表.</p><p>仔细想想, 这个序号 也只有在我们需要加载pyc构建对象的时候才会使用, 而这, 正好列表对象是可以支持索引的而字典是不可以的, 有没有一种巧妙的感觉?</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>当我们加载pyc的时候, 我们会进行下面的操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyMarshal_ReadObjectFromFile</span><span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">RFILE rf;</span><br><span class="line">PyObject *result;</span><br><span class="line">rf.fp = fp;</span><br><span class="line">rf.strings = PyList_New(<span class="number">0</span>);</span><br><span class="line">rf.depth = <span class="number">0</span>;</span><br><span class="line">rf.ptr = rf.end = <span class="literal">NULL</span>;</span><br><span class="line">result = r_object(&amp;rf);</span><br><span class="line">Py_DECREF(rf.strings);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 在这里我们把strings域变成了一个新的列表对象, 注意这个地方的对象已经不是WFILE了, 而是RFILE, 但是其实他们的结构几乎是一样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> WFILE RFILE; <span class="comment">/* Same struct with different invariants */</span></span><br></pre></td></tr></table></figure><p>多么直接!</p><p>这样就可以通过列表索引来直接获得位置上的字符串值了.</p><p>我们又考虑到了一个问题, 比如之前做测试的那一段简简单单的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>这里只会产生3个代码对象. 如果我们把A类的定义写在另外一个文件中, 并且在当前文件中进行引用. 这样就会产生一个pyc文件, 但是问题来了, 3个代码对象怎么load, 写入到pyc文件中的, 只有A一个CodeObject呀?</p><p>这里Python是这样设计的, 它将A代码块产生的codeobject写入到pyc时, 会将其他的两个代码对象作为值丢到<code>co_consts</code>这个域里面. 这样当进行加载的时候, 就会递归的进行load. 问题就这么解决了.</p><p>源文件中是如何进行嵌套的, 那么在pyc文件这种二进制文件中, 其实也是存在这样的嵌套结构的.</p><h2 id="初探字节码和pyc文件解析"><a href="#初探字节码和pyc文件解析" class="headerlink" title="初探字节码和pyc文件解析"></a>初探字节码和pyc文件解析</h2><p>现在就让我们来看看Python定义的字节码是什么样子的吧. 在<code>opcode.h</code>中定义了Python指定的字节码.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Instruction opcodes for compiled code */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STOP_CODE0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_TOP1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROT_TWO2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROT_THREE3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DUP_TOP4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROT_FOUR5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOP9</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>序号并不是一直连续的, 一共最后排到了143号, 当然一共就定义了104条字节码指令.</p><p>这些字节码, 有些需要参数传递, 有不需要, 这是怎么实现的呢.来看90号:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_ARGUMENT90<span class="comment">/* Opcodes from here have an argument: */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STORE_NAME90<span class="comment">/* Index in name list */</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAS_ARG(op) ((op) &gt;= HAVE_ARGUMENT)</span></span><br></pre></td></tr></table></figure><p>Python直接定义了一个宏, 用来判断是否是需要参数的, 只要是90号之后的都是需要参数的.</p><p>接着我们来尝试解析一个Pyc文件. 事实上, Python提供了解析的工具, 叫做<code>dis</code>. 我们可以直接调用试试:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> dis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>src = <span class="built_in">open</span>(<span class="string">&quot;test.py&quot;</span>).read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>co = <span class="built_in">compile</span>(src, <span class="string">&quot;test.py&quot;</span>, <span class="string">&quot;exec&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(co)</span><br><span class="line">  <span class="number">8</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (-<span class="number">1</span>)</span><br><span class="line">              <span class="number">3</span> LOAD_CONST               <span class="number">1</span> ((<span class="string">&#x27;A&#x27;</span>,))</span><br><span class="line">              <span class="number">6</span> IMPORT_NAME              <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">9</span> IMPORT_FROM              <span class="number">1</span> (A)</span><br><span class="line">             <span class="number">12</span> STORE_NAME               <span class="number">1</span> (A)</span><br><span class="line">             <span class="number">15</span> POP_TOP</span><br><span class="line"></span><br><span class="line"> <span class="number">10</span>          <span class="number">16</span> LOAD_CONST               <span class="number">2</span> (&lt;code <span class="built_in">object</span> foo at <span class="number">0x1060b76b0</span>, file <span class="string">&quot;test.py&quot;</span>, line <span class="number">10</span>&gt;)</span><br><span class="line">             <span class="number">19</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">22</span> STORE_NAME               <span class="number">2</span> (foo)</span><br><span class="line"></span><br><span class="line"> <span class="number">14</span>          <span class="number">25</span> LOAD_NAME                <span class="number">1</span> (A)</span><br><span class="line">             <span class="number">28</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">31</span> STORE_NAME               <span class="number">0</span> (a)</span><br><span class="line"></span><br><span class="line"> <span class="number">15</span>          <span class="number">34</span> LOAD_NAME                <span class="number">2</span> (foo)</span><br><span class="line">             <span class="number">37</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line">             <span class="number">40</span> POP_TOP</span><br><span class="line">             <span class="number">41</span> LOAD_CONST               <span class="number">3</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">44</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p><strong>注意, 我这里使用的python2.7版本, 不同版本编译出来的字节码可能不会一样.</strong></p><p>最左列是行数, 由于我之前有注释所以是从第8行开始的, 其实这个是代码的第一行. 对照着代码和这个字节码指令, 你会发现看起来也没有这么困难!</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Source Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python源码阅读-内建对象(-1)</title>
      <link href="/2018/03/15/Python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%BB%BA%E5%AF%B9%E8%B1%A1-5/"/>
      <url>/2018/03/15/Python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%BB%BA%E5%AF%B9%E8%B1%A1-5/</url>
      
        <content type="html"><![CDATA[<p>这是《Python源码剖析 — 深度探索动态语言核心技术》的阅读记录.</p><p>Python中的列表对象 - <code>PyDictObject</code>. 这就是我们研究的最后一个内建对象啦.</p><span id="more"></span><h2 id="超级散列表"><a href="#超级散列表" class="headerlink" title="超级散列表"></a>超级散列表</h2><p>我们都知道, 在最优的情况下, 散列表可以提供O(1)复杂度的搜索效率. 而dict对象正是使用了散列表这样的数据结构. 其实我个人觉得Python中的字典对象是一个较为复杂的对象了, 不过在后文中, 我打算更经常的称其为<strong>关联式容器</strong>.</p><p>所谓关联就是指字典中的那键值对映射, 那么我们就来看看Python中的这个关联容器的设计吧.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* Cached hash code of me_key.  Note that hash codes are C longs.</span></span><br><span class="line"><span class="comment"> * We have to use Py_ssize_t instead because dict_popitem() abuses</span></span><br><span class="line"><span class="comment"> * me_hash to hold a search finger.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Py_ssize_t me_hash;</span><br><span class="line">PyObject *me_key;</span><br><span class="line">PyObject *me_value;</span><br><span class="line">&#125; PyDictEntry;</span><br></pre></td></tr></table></figure><p>看下名字, 没错. 这个就是我们每次去除的一对键值对的实现. 一般都叫做<code>entry</code>, 有的时候也叫做<code>slot</code>. 可以看到, 包含一个键, 一个值, 还有键的hash值. 我们再第一次看Python的对象实现基石的时候就说过了, 所有的对象都可以使用PyObject*指针来引用, 这也就是为啥dict可以容纳所有的对象的原因. 当然, 存储hash的原因不言自明, 就是为了避免重复计算嘛~</p><p>为了能够更好的说明接下来的内容, 还是先说一些和散列表有关的话题. 当一个散列表的2&#x2F;3都已经被填充了的时候, 这个时候的冲突率会大大增加, 而Python选择的冲突解决方法是通过二次定址来寻找下一个可用的位置. 也就是说, 当哈希碰撞发生的时候, Python就会再进行一次计算来寻找下一个位置. 这样就会形成一个可能不是连续的<strong>冲突探测链</strong>. 通过这个探测链, 我们就可以寻找到冲突的元素的位置.</p><p>那么经过上面的, 我们接下来就要来说下这个键值对, 也就是<code>entry</code> 他一共有三种状态:</p><ul><li>Unused</li><li>Active</li><li>Dummy</li></ul><p>是不是有点像是进程的三态呢? 哈哈我开玩笑的. 当我们初始化生成一个<code>entry</code>的时候, 这个<code>entry</code>的键和值都是NULL 此时, 我们就说这个键值对是Unused.</p><p>接下来, 当我们给这个entry进行了键值对的填充之后, 它就会变成Active状态. 在这个状态下, 我们的key和value都不会是NULL的.</p><p>而Dummy态就有趣了, 并且和我们上面说的冲突探测链有关系. 当我们这个<code>entry</code>存储的键值对删除了之后, 这个entry就会变成Dummy态, 而不是直接成为Unused. 为什么? 如果说这个entry是位于我们的探测链上的, 就会直接导致后面的元素将无法被检索到. 也就是说, 这个处理方法就是一种典型的<strong>伪删除</strong>. 在搜索时, 我们可以得知这个entry已经被删除了, 但是可能后面的entry仍然是有效的, 就可以继续进行搜索.</p><p>那么我们实际使用的字典对象, 其实就是这么一堆Entry的集合嘛.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dictobject</span> <span class="title">PyDictObject</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">dictobject</span> &#123;</span></span><br><span class="line">PyObject_HEAD</span><br><span class="line">Py_ssize_t ma_fill;  <span class="comment">/* # Active + # Dummy */</span></span><br><span class="line">Py_ssize_t ma_used;  <span class="comment">/* # Active */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The table contains ma_mask + 1 slots, and that&#x27;s a power of 2.</span></span><br><span class="line"><span class="comment"> * We store the mask instead of the size because the mask is more</span></span><br><span class="line"><span class="comment"> * frequently needed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Py_ssize_t ma_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ma_table points to ma_smalltable for small tables, else to</span></span><br><span class="line"><span class="comment"> * additional malloc&#x27;ed memory.  ma_table is never NULL!  This rule</span></span><br><span class="line"><span class="comment"> * saves repeated runtime null-tests in the workhorse getitem and</span></span><br><span class="line"><span class="comment"> * setitem calls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PyDictEntry *ma_table;</span><br><span class="line">PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, <span class="type">long</span> hash);</span><br><span class="line">PyDictEntry ma_smalltable[PyDict_MINSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>ma_fill</code>是指从对象创建开始所处于(或曾经处于)Active状态的Entry数量, 而<code>ma_used</code>就像是前者的子集, 他只包含当前Active状态的entry. 先来最后一个成员, 就是那个<code>smalltable</code>, 一开始就是<code>PyDict_MINSIZE</code>的大小. 这个值在文件中定义的是8:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyDict_MINSIZE 8</span></span><br></pre></td></tr></table></figure><p>这个值就是为了避免malloc所带来的效率下降, 而8是Python多次实验之后得到的一个比较理想的值.</p><p>而整个对象的核心就是那个<code>ma_table</code>成员了. 它就是Dict的entry的那一大片内存的指针, 但是我们不是还有一个<code>ma_smalltable</code>这个玩意嘛. 对了 只要在没有到8个entry的时候就会指向这个smalltable的内存地址. 有了这样的一个机制, 就相当于是确保了<code>ma_table</code>不会成为NULL. 至于剩下的两个成员我们留在后面说.</p><h2 id="创建一个PyDictObject对象"><a href="#创建一个PyDictObject对象" class="headerlink" title="创建一个PyDictObject对象"></a>创建一个PyDictObject对象</h2><p>直接祭出代码吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyDict_New</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> dictobject *mp;</span><br><span class="line"><span class="keyword">if</span> (dummy == <span class="literal">NULL</span>) &#123; <span class="comment">/* Auto-initialize dummy */</span></span><br><span class="line">dummy = PyString_FromString(<span class="string">&quot;&lt;dummy key&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (dummy == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOW_CONVERSION_COUNTS</span></span><br><span class="line">Py_AtExit(show_counts);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num_free_dicts) &#123;</span><br><span class="line">mp = free_dicts[--num_free_dicts];</span><br><span class="line">assert (mp != <span class="literal">NULL</span>);</span><br><span class="line">assert (mp-&gt;ob_type == &amp;PyDict_Type);</span><br><span class="line">_Py_NewReference((PyObject *)mp);</span><br><span class="line"><span class="keyword">if</span> (mp-&gt;ma_fill) &#123;</span><br><span class="line">EMPTY_TO_MINSIZE(mp);</span><br><span class="line">&#125;</span><br><span class="line">assert (mp-&gt;ma_used == <span class="number">0</span>);</span><br><span class="line">assert (mp-&gt;ma_table == mp-&gt;ma_smalltable);</span><br><span class="line">assert (mp-&gt;ma_mask == PyDict_MINSIZE - <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mp = PyObject_GC_New(dictobject, &amp;PyDict_Type);</span><br><span class="line"><span class="keyword">if</span> (mp == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">EMPTY_TO_MINSIZE(mp);</span><br><span class="line">&#125;</span><br><span class="line">mp-&gt;ma_lookup = lookdict_string;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOW_CONVERSION_COUNTS</span></span><br><span class="line">++created;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">_PyObject_GC_TRACK(mp);</span><br><span class="line"><span class="keyword">return</span> (PyObject *)mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放眼望去, Python扔了很多assert进去. 眼尖的你可能瞬间就看到了<code>num_free_dicts</code>. 嘿嘿 恭喜你又猜到了后文的标题. 行吧, 废话就不说了, 我们还是来看代码吧.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyDict_New</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> dictobject *mp;</span><br><span class="line"><span class="keyword">if</span> (dummy == <span class="literal">NULL</span>) &#123; <span class="comment">/* Auto-initialize dummy */</span></span><br><span class="line">dummy = PyString_FromString(<span class="string">&quot;&lt;dummy key&gt;&quot;</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现, dummy其实是一个字符串对象, 毕竟 他只是用来作为一个指示标志. 然后就会从系统堆中申请一个Dict的内存空间, 它使用了两个宏, 一个宏套着另一个宏.</p><p>来看下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_NONZERO_DICT_SLOTS(mp) do &#123;\</span></span><br><span class="line"><span class="meta">(mp)-&gt;ma_table = (mp)-&gt;ma_smalltable;\</span></span><br><span class="line"><span class="meta">(mp)-&gt;ma_mask = PyDict_MINSIZE - 1;\</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMPTY_TO_MINSIZE(mp) do &#123;\</span></span><br><span class="line"><span class="meta">memset((mp)-&gt;ma_smalltable, 0, sizeof((mp)-&gt;ma_smalltable));\</span></span><br><span class="line"><span class="meta">(mp)-&gt;ma_used = (mp)-&gt;ma_fill = 0;\</span></span><br><span class="line"><span class="meta">INIT_NONZERO_DICT_SLOTS(mp);\</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br></pre></td></tr></table></figure><p>先来看上面的, 它就是把table指向那个默认的小table(8个entry), 接着设置我们之前说的<code>mask</code>为最小值-1. 其实, 我们的这个<code>mask</code>也可以被叫做<code>size</code>, 之所以没有这样命名, 我们后面再说.</p><p>接下来, 我们看下面的. 其实就是在初始化我们的table之前先初始化table内存和计数器.</p><p>最后来关注这么一个东西:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp-&gt;ma_lookup = lookdict_string;</span><br></pre></td></tr></table></figure><p>这个我们会在下一小节讨论. 这个就是PyDictObject的搜索策略. 这个ma_lookup, 就决定这字典对象在进行搜索entry的时候如果出现冲突的时候, 二次探测函数的具体实现.</p><h2 id="在PyDictObject中进行元素搜索"><a href="#在PyDictObject中进行元素搜索" class="headerlink" title="在PyDictObject中进行元素搜索"></a>在PyDictObject中进行元素搜索</h2><p>OK, 现在告诉你. 有两种进行搜索的方法:</p><ul><li>lookdict_string</li><li>lookdict</li></ul><p>而默认的就是我们在上面看到的<code>lookdict_string</code>. 不过从名字也可以看出来, 显然是<code>lookdict</code>更加通用, 而<code>lookdict_string</code>是<code>lookdict</code>的一个特例. 那么就从通用的搜索策略开始看起吧.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> dictentry *</span><br><span class="line"><span class="title function_">lookdict</span><span class="params">(dictobject *mp, PyObject *key, <span class="keyword">register</span> <span class="type">long</span> hash)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> i;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> perturb;</span><br><span class="line"><span class="keyword">register</span> dictentry *freeslot;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> mask = (<span class="type">size_t</span>)mp-&gt;ma_mask;</span><br><span class="line">dictentry *ep0 = mp-&gt;ma_table;</span><br><span class="line"><span class="keyword">register</span> dictentry *ep;</span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> cmp;</span><br><span class="line">PyObject *startkey;</span><br><span class="line"></span><br><span class="line">i = (<span class="type">size_t</span>)hash &amp; mask;</span><br><span class="line">ep = &amp;ep0[i];</span><br><span class="line"><span class="keyword">if</span> (ep-&gt;me_key == <span class="literal">NULL</span> || ep-&gt;me_key == key)</span><br><span class="line"><span class="keyword">return</span> ep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ep-&gt;me_key == dummy)</span><br><span class="line">freeslot = ep;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ep-&gt;me_hash == hash) &#123;</span><br><span class="line">startkey = ep-&gt;me_key;</span><br><span class="line">Py_INCREF(startkey);</span><br><span class="line">cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);</span><br><span class="line">Py_DECREF(startkey);</span><br><span class="line"><span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (ep0 == mp-&gt;ma_table &amp;&amp; ep-&gt;me_key == startkey) &#123;</span><br><span class="line"><span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ep;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* The compare did major nasty stuff to the</span></span><br><span class="line"><span class="comment"> * dict:  start over.</span></span><br><span class="line"><span class="comment"> * XXX A clever adversary could prevent this</span></span><br><span class="line"><span class="comment"> * XXX from terminating.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">return</span> lookdict(mp, key, hash);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">freeslot = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到, 这个函数返回的值当中存在自己的递归调用, 这就说明在找entry的过程中是, 根据寻找的位置, 是存在不同的处理的. 我们来从变量定义下面来开始看吧.</p><p>首先就是一个位与操作, 使用的是带搜索的字典的<code>mask</code>和传入的<code>hash</code>. 这样即可确保最后搜索不会超过这个这个字典对象所维护的entry数量, 而这个代表字典对象entry size的成员经常进行位与操作, 这就是命名为mask的原因.</p><p>通过位与操作, 我们就可以定位到冲突探测链的第一个entry. <strong>(?)</strong> 接着就开始了第一次的比较, 如果巧了比对成功或者遇到了一个Unused的entry, 就直接返回这个entry.</p><blockquote><p>这里 补充一下, 字典对象的搜索策略始终返回的不是NULL或者0或者-1啥的(除非子函数执行失败), 不论是否搜索到, 都会返回一个entry对象, 如果是匹配到了的, 那就会返回搜索需要的, 如果是没有匹配到的, 就会返回一个<code>me_value</code>值为NULL的entry.</p></blockquote><p>接着, 如果这第一个entry的状态是<code>dummy</code>,  我们就要把这个entry记录下, 让<code>freeslot</code>来指向它. 接下来为了能够更好的理解后面, 我们先来讨论下这里的相等是个什么意思:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">9876</span>] = <span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(l[<span class="number">9876</span>])</span><br><span class="line">Python</span><br></pre></td></tr></table></figure><p>有了前面的基础, 我们知道这里的两个9876肯定是两个不同的对象, 但是他们的值是相同的, 所以这里依然能够找到就是因为值相同, 这就是说如果仅仅就到我们分析的那个地方:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ep-&gt;me_key == <span class="literal">NULL</span> || ep-&gt;me_key == key)</span><br><span class="line">    <span class="keyword">return</span> ep;</span><br></pre></td></tr></table></figure><p>这里是不会相等的, 因为两个9876的引用是不一样的. 那么仍然能够正确返回的秘密就在后面了.</p><p>先来看下如果不是一个dummy状态的entry, 而是一个Active状态的entry的话是什么效果. 最先当然是检查hash是否相同, 如果hash不一致, 显然值也不可能是相同的了.</p><p>如果hash一致, 我们就继续进行比较, 这里调用了一个Python的比较函数, 并且使用<code>Py_EQ</code>宏来使得快速进行同类对象比较. 如果出现一些脏东西, 那么没办法了, 只能从头开始, 至于这个脏东西到底是什么, 什么情况下会发生, 我没搞清楚.</p><blockquote><p>找到了, 在这里有说明: <a href="https://bugs.python.org/issue14205">Issue14205</a> 大概的意思就是说在比较中如果出现值的变化会导致问题的出现. 另外会出现C的无限递归出现.</p></blockquote><p>那行了. 到目前为止, 我们已经摸清楚了搜索时deal with第一个entry的做法. 如果说第一个entry搞完了还是没有结果我们就要继续向后了. 来继续看:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* In the loop, me_key == dummy is by far (factor of 100s) the</span></span><br><span class="line"><span class="comment">   least likely outcome, so test for that last. */</span></span><br><span class="line"><span class="keyword">for</span> (perturb = hash; ; perturb &gt;&gt;= PERTURB_SHIFT) &#123;</span><br><span class="line">    i = (i &lt;&lt; <span class="number">2</span>) + i + perturb + <span class="number">1</span>;</span><br><span class="line">    ep = &amp;ep0[i &amp; mask];</span><br><span class="line">    <span class="keyword">if</span> (ep-&gt;me_key == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> freeslot == <span class="literal">NULL</span> ? ep : freeslot;</span><br><span class="line">    <span class="keyword">if</span> (ep-&gt;me_key == key)</span><br><span class="line">        <span class="keyword">return</span> ep;</span><br><span class="line">    <span class="keyword">if</span> (ep-&gt;me_hash == hash &amp;&amp; ep-&gt;me_key != dummy) &#123;</span><br><span class="line">        startkey = ep-&gt;me_key;</span><br><span class="line">        Py_INCREF(startkey);</span><br><span class="line">        cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);</span><br><span class="line">        Py_DECREF(startkey);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (ep0 == mp-&gt;ma_table &amp;&amp; ep-&gt;me_key == startkey) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* The compare did major nasty stuff to the</span></span><br><span class="line"><span class="comment"> * dict:  start over.</span></span><br><span class="line"><span class="comment"> * XXX A clever adversary could prevent this</span></span><br><span class="line"><span class="comment"> * XXX from terminating.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">            <span class="keyword">return</span> lookdict(mp, key, hash);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ep-&gt;me_key == dummy &amp;&amp; freeslot == <span class="literal">NULL</span>)</span><br><span class="line">        freeslot = ep;</span><br><span class="line">&#125;</span><br><span class="line">assert(<span class="number">0</span>);<span class="comment">/* NOT REACHED */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这里就要继续沿着冲突探测链继续向前进了. 首先还是要获得探测链下一个entry的位置, 如果是一个<code>Unused</code>的entry, 说明已经结束了, 把freeslot返回, 或者是返回Unused的entry, 总之返回的那个总是可以使用的, 键值对为NULL的.</p><p>接着就是分别检查引用和值是否相同 最后, 如果发现当前是个Dummy态的并且freeslot没有设置, 就把freeslot设置成这个Dummy态的entry. 直到搜索完, 这样 全部的搜索过程就结束了.</p><p>通用的逻辑看完了, 接下来来看下特例<code>lookdict_string</code>吧.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> dictentry *</span><br><span class="line"><span class="title function_">lookdict_string</span><span class="params">(dictobject *mp, PyObject *key, <span class="keyword">register</span> <span class="type">long</span> hash)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> i;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> perturb;</span><br><span class="line"><span class="keyword">register</span> dictentry *freeslot;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> mask = (<span class="type">size_t</span>)mp-&gt;ma_mask;</span><br><span class="line">dictentry *ep0 = mp-&gt;ma_table;</span><br><span class="line"><span class="keyword">register</span> dictentry *ep;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make sure this function doesn&#x27;t have to handle non-string keys,</span></span><br><span class="line"><span class="comment">   including subclasses of str; e.g., one reason to subclass</span></span><br><span class="line"><span class="comment">   strings is to override __eq__, and for speed we don&#x27;t cater to</span></span><br><span class="line"><span class="comment">   that here. */</span></span><br><span class="line"><span class="keyword">if</span> (!PyString_CheckExact(key)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOW_CONVERSION_COUNTS</span></span><br><span class="line">++converted;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">mp-&gt;ma_lookup = lookdict;</span><br><span class="line"><span class="keyword">return</span> lookdict(mp, key, hash);</span><br><span class="line">&#125;</span><br><span class="line">i = hash &amp; mask;</span><br><span class="line">ep = &amp;ep0[i];</span><br><span class="line"><span class="keyword">if</span> (ep-&gt;me_key == <span class="literal">NULL</span> || ep-&gt;me_key == key)</span><br><span class="line"><span class="keyword">return</span> ep;</span><br><span class="line"><span class="keyword">if</span> (ep-&gt;me_key == dummy)</span><br><span class="line">freeslot = ep;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ep-&gt;me_hash == hash &amp;&amp; _PyString_Eq(ep-&gt;me_key, key))</span><br><span class="line"><span class="keyword">return</span> ep;</span><br><span class="line">freeslot = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In the loop, me_key == dummy is by far (factor of 100s) the</span></span><br><span class="line"><span class="comment">   least likely outcome, so test for that last. */</span></span><br><span class="line"><span class="keyword">for</span> (perturb = hash; ; perturb &gt;&gt;= PERTURB_SHIFT) &#123;</span><br><span class="line">i = (i &lt;&lt; <span class="number">2</span>) + i + perturb + <span class="number">1</span>;</span><br><span class="line">ep = &amp;ep0[i &amp; mask];</span><br><span class="line"><span class="keyword">if</span> (ep-&gt;me_key == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> freeslot == <span class="literal">NULL</span> ? ep : freeslot;</span><br><span class="line"><span class="keyword">if</span> (ep-&gt;me_key == key</span><br><span class="line">    || (ep-&gt;me_hash == hash</span><br><span class="line">        &amp;&amp; ep-&gt;me_key != dummy</span><br><span class="line">&amp;&amp; _PyString_Eq(ep-&gt;me_key, key)))</span><br><span class="line"><span class="keyword">return</span> ep;</span><br><span class="line"><span class="keyword">if</span> (ep-&gt;me_key == dummy &amp;&amp; freeslot == <span class="literal">NULL</span>)</span><br><span class="line">freeslot = ep;</span><br><span class="line">&#125;</span><br><span class="line">assert(<span class="number">0</span>);<span class="comment">/* NOT REACHED */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有的键都是字符串类型的时候, 就会调用这个玩意. 自一开始就开始了类型检测, 如果发现不是严格等于字符串对象的话, 就会返回使用通用搜索策略.</p><p>基本的逻辑还是很相像的, 先获得第一个entry的位置, 接着开始分别比对Unused态, Dummy态, Active态, 并且设置恰当的freeslot. 接着就按照散列函数的定义这么一直比对下去就好了. 在这里就省略掉了大量错误捕获的代码, 因为我们不需要处理不明确的<code>PyObject* </code>而是确定的字符串对象了.</p><h2 id="插入和删除元素"><a href="#插入和删除元素" class="headerlink" title="插入和删除元素"></a>插入和删除元素</h2><p>在Python字典对象的设计中, 插入元素(或者更好的应该说是设置元素, 因为有可能会触发update[键相同])的函数是<code>PyDict_SetItem</code>. 这个函数调用了两个子函数: <code>insertdict</code>, <code>dictresize</code>.所以我们就先看下这两个.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">insertdict</span><span class="params">(<span class="keyword">register</span> dictobject *mp, PyObject *key, <span class="type">long</span> hash, PyObject *value)</span></span><br><span class="line">&#123;</span><br><span class="line">PyObject *old_value;</span><br><span class="line"><span class="keyword">register</span> dictentry *ep;</span><br><span class="line"><span class="keyword">typedef</span> PyDictEntry *(*lookupfunc)(PyDictObject *, PyObject *, <span class="type">long</span>);</span><br><span class="line"></span><br><span class="line">assert(mp-&gt;ma_lookup != <span class="literal">NULL</span>);</span><br><span class="line">ep = mp-&gt;ma_lookup(mp, key, hash);</span><br><span class="line"><span class="keyword">if</span> (ep == <span class="literal">NULL</span>) &#123;</span><br><span class="line">Py_DECREF(key);</span><br><span class="line">Py_DECREF(value);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ep-&gt;me_value != <span class="literal">NULL</span>) &#123;</span><br><span class="line">old_value = ep-&gt;me_value;</span><br><span class="line">ep-&gt;me_value = value;</span><br><span class="line">Py_DECREF(old_value); <span class="comment">/* which **CAN** re-enter */</span></span><br><span class="line">Py_DECREF(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ep-&gt;me_key == <span class="literal">NULL</span>)</span><br><span class="line">mp-&gt;ma_fill++;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">assert(ep-&gt;me_key == dummy);</span><br><span class="line">Py_DECREF(dummy);</span><br><span class="line">&#125;</span><br><span class="line">ep-&gt;me_key = key;</span><br><span class="line">ep-&gt;me_hash = (Py_ssize_t)hash;</span><br><span class="line">ep-&gt;me_value = value;</span><br><span class="line">mp-&gt;ma_used++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们执行上一节的搜索函数, 这样要么就是获得了Active状态的entry, 即将replace, 或者是Dummy以及Unused的, 对于前者, 我们直接改变<code>value</code>就可以了, 后者我们还要重新的设置一遍. 这就是后面主要做的事情.</p><p>现在我们回到<code>SetItem</code>身上, 来看看他是如何调用<code>insertdict</code>的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyDict_SetItem</span><span class="params">(<span class="keyword">register</span> PyObject *op, PyObject *key, PyObject *value)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> dictobject *mp;</span><br><span class="line"><span class="keyword">register</span> <span class="type">long</span> hash;</span><br><span class="line"><span class="keyword">register</span> Py_ssize_t n_used;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!PyDict_Check(op)) &#123;</span><br><span class="line">PyErr_BadInternalCall();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">assert(key);</span><br><span class="line">assert(value);</span><br><span class="line">mp = (dictobject *)op;</span><br><span class="line"><span class="keyword">if</span> (PyString_CheckExact(key)) &#123;</span><br><span class="line">hash = ((PyStringObject *)key)-&gt;ob_shash;</span><br><span class="line"><span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line">hash = PyObject_Hash(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">hash = PyObject_Hash(key);</span><br><span class="line"><span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">assert(mp-&gt;ma_fill &lt;= mp-&gt;ma_mask);  <span class="comment">/* at least one empty slot */</span></span><br><span class="line">n_used = mp-&gt;ma_used;</span><br><span class="line">Py_INCREF(value);</span><br><span class="line">Py_INCREF(key);</span><br><span class="line"><span class="keyword">if</span> (insertdict(mp, key, hash, value) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/* If we added a key, we can safely resize.  Otherwise just return!</span></span><br><span class="line"><span class="comment"> * If fill &gt;= 2/3 size, adjust size.  Normally, this doubles or</span></span><br><span class="line"><span class="comment"> * quaduples the size, but it&#x27;s also possible for the dict to shrink</span></span><br><span class="line"><span class="comment"> * (if ma_fill is much larger than ma_used, meaning a lot of dict</span></span><br><span class="line"><span class="comment"> * keys have been * deleted).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Quadrupling the size improves average dictionary sparseness</span></span><br><span class="line"><span class="comment"> * (reducing collisions) at the cost of some memory and iteration</span></span><br><span class="line"><span class="comment"> * speed (which loops over every possible entry).  It also halves</span></span><br><span class="line"><span class="comment"> * the number of expensive resize operations in a growing dictionary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Very large dictionaries (over 50K items) use doubling instead.</span></span><br><span class="line"><span class="comment"> * This may help applications with severe memory constraints.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!(mp-&gt;ma_used &gt; n_used &amp;&amp; mp-&gt;ma_fill*<span class="number">3</span> &gt;= (mp-&gt;ma_mask+<span class="number">1</span>)*<span class="number">2</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> dictresize(mp, (mp-&gt;ma_used &gt; <span class="number">50000</span> ? <span class="number">2</span> : <span class="number">4</span>) * mp-&gt;ma_used);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再调用插入之前发生了什么了? 其实很简单嘛, 就是在计算出哈希值好来调用插入字典函数, 接着如果出现了当前<code>fill &gt;= 2/3 size</code>的时候, 就要开始重新调整大小了, 这就是为了避免出现碰撞.</p><p>我们先简单看下字典resize的签名:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">dictresize</span><span class="params">(dictobject *mp, Py_ssize_t minused)</span></span><br></pre></td></tr></table></figure><p>主要就是后者, 这个就是保证字典正常的大小的最小值. 而这个值被设定成:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(mp-&gt;ma_used &gt; <span class="number">50000</span> ? <span class="number">2</span> : <span class="number">4</span>) * mp-&gt;ma_used</span><br></pre></td></tr></table></figure><p>2倍或者是4倍, 当Active状态的entry很大的时候(50000), Python就开始限制自己索取的内存量了. 具体是怎么改变的呢 我们来阅读下这个函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">dictresize</span><span class="params">(dictobject *mp, Py_ssize_t minused)</span></span><br><span class="line">&#123;</span><br><span class="line">Py_ssize_t newsize;</span><br><span class="line">dictentry *oldtable, *newtable, *ep;</span><br><span class="line">Py_ssize_t i;</span><br><span class="line"><span class="type">int</span> is_oldtable_malloced;</span><br><span class="line">dictentry small_copy[PyDict_MINSIZE];</span><br><span class="line"></span><br><span class="line">assert(minused &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the smallest table size &gt; minused. */</span></span><br><span class="line"><span class="keyword">for</span> (newsize = PyDict_MINSIZE;</span><br><span class="line">     newsize &lt;= minused &amp;&amp; newsize &gt; <span class="number">0</span>;</span><br><span class="line">     newsize &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">;</span><br><span class="line"><span class="keyword">if</span> (newsize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">PyErr_NoMemory();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get space for a new table. */</span></span><br><span class="line">oldtable = mp-&gt;ma_table;</span><br><span class="line">assert(oldtable != <span class="literal">NULL</span>);</span><br><span class="line">is_oldtable_malloced = oldtable != mp-&gt;ma_smalltable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (newsize == PyDict_MINSIZE) &#123;</span><br><span class="line"><span class="comment">/* A large table is shrinking, or we can&#x27;t get any smaller. */</span></span><br><span class="line">newtable = mp-&gt;ma_smalltable;</span><br><span class="line"><span class="keyword">if</span> (newtable == oldtable) &#123;</span><br><span class="line"><span class="keyword">if</span> (mp-&gt;ma_fill == mp-&gt;ma_used) &#123;</span><br><span class="line"><span class="comment">/* No dummies, so no point doing anything. */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We&#x27;re not going to resize it, but rebuild the</span></span><br><span class="line"><span class="comment">   table anyway to purge old dummy entries.</span></span><br><span class="line"><span class="comment">   Subtle:  This is *necessary* if fill==size,</span></span><br><span class="line"><span class="comment">   as lookdict needs at least one virgin slot to</span></span><br><span class="line"><span class="comment">   terminate failing searches.  If fill &lt; size, it&#x27;s</span></span><br><span class="line"><span class="comment">   merely desirable, as dummies slow searches. */</span></span><br><span class="line">assert(mp-&gt;ma_fill &gt; mp-&gt;ma_used);</span><br><span class="line"><span class="built_in">memcpy</span>(small_copy, oldtable, <span class="keyword">sizeof</span>(small_copy));</span><br><span class="line">oldtable = small_copy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">newtable = PyMem_NEW(dictentry, newsize);</span><br><span class="line"><span class="keyword">if</span> (newtable == <span class="literal">NULL</span>) &#123;</span><br><span class="line">PyErr_NoMemory();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make the dict empty, using the new table. */</span></span><br><span class="line">assert(newtable != oldtable);</span><br><span class="line">mp-&gt;ma_table = newtable;</span><br><span class="line">mp-&gt;ma_mask = newsize - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(newtable, <span class="number">0</span>, <span class="keyword">sizeof</span>(dictentry) * newsize);</span><br><span class="line">mp-&gt;ma_used = <span class="number">0</span>;</span><br><span class="line">i = mp-&gt;ma_fill;</span><br><span class="line">mp-&gt;ma_fill = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Copy the data over; this is refcount-neutral for active entries;</span></span><br><span class="line"><span class="comment">   dummy entries aren&#x27;t copied over, of course */</span></span><br><span class="line"><span class="keyword">for</span> (ep = oldtable; i &gt; <span class="number">0</span>; ep++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ep-&gt;me_value != <span class="literal">NULL</span>) &#123;<span class="comment">/* active entry */</span></span><br><span class="line">--i;</span><br><span class="line">insertdict_clean(mp, ep-&gt;me_key, (<span class="type">long</span>)ep-&gt;me_hash,</span><br><span class="line"> ep-&gt;me_value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ep-&gt;me_key != <span class="literal">NULL</span>) &#123;<span class="comment">/* dummy entry */</span></span><br><span class="line">--i;</span><br><span class="line">assert(ep-&gt;me_key == dummy);</span><br><span class="line">Py_DECREF(ep-&gt;me_key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* else key == value == NULL:  nothing to do */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_oldtable_malloced)</span><br><span class="line">PyMem_DEL(oldtable);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始就是获得更改之后的大小, 具体的方法就是一直翻倍, 只要没有超过那个<code>minsize</code>就一直这么做. 接着, 我们先备份就的table, 并且要知道此时是否还在使用smalltable. 接着, 如果获得的newsize就是8, 也就是说不需要继续分配内存了, 直接继续使用smalltable就可以了.然后就是直接进行一次memcpy就可以了. 否则我们就需要分配新的空间, 接着我们统一进行初始化操作, 另外设置内存, 使得这个字典对象变成一个全新的对象. 接着我们就可以把entry插回来, 如果是Active状态的 就使用一个精简版的<code>insertdict</code>来搞定. 如果是Dummy状态, 就直接把它的键值抹杀掉就好了, 因为他存在的意义就是保持探测链的连续. 最后, 为了防止内存泄露, 就清空那个外部table的内存了.</p><p>这就是全部的插入过程了.</p><p>接下来我们来看下删除操作, 删除操作要比插入操作简单清晰多了.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyDict_DelItem</span><span class="params">(PyObject *op, PyObject *key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> dictobject *mp;</span><br><span class="line"><span class="keyword">register</span> <span class="type">long</span> hash;</span><br><span class="line"><span class="keyword">register</span> dictentry *ep;</span><br><span class="line">PyObject *old_value, *old_key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!PyDict_Check(op)) &#123;</span><br><span class="line">PyErr_BadInternalCall();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">assert(key);</span><br><span class="line"><span class="keyword">if</span> (!PyString_CheckExact(key) ||</span><br><span class="line">    (hash = ((PyStringObject *) key)-&gt;ob_shash) == <span class="number">-1</span>) &#123;</span><br><span class="line">hash = PyObject_Hash(key);</span><br><span class="line"><span class="keyword">if</span> (hash == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">mp = (dictobject *)op;</span><br><span class="line">ep = (mp-&gt;ma_lookup)(mp, key, hash);</span><br><span class="line"><span class="keyword">if</span> (ep == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (ep-&gt;me_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">set_key_error(key);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">old_key = ep-&gt;me_key;</span><br><span class="line">Py_INCREF(dummy);</span><br><span class="line">ep-&gt;me_key = dummy;</span><br><span class="line">old_value = ep-&gt;me_value;</span><br><span class="line">ep-&gt;me_value = <span class="literal">NULL</span>;</span><br><span class="line">mp-&gt;ma_used--;</span><br><span class="line">Py_DECREF(old_value);</span><br><span class="line">Py_DECREF(old_key);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是获取Hash值, 接着根据获得的hash进行搜索, 如果没搜索到, 自然就是删除失败了, 如果搜索到了, 那就拿到了entry了, 这就好办了, 直接删除entry所维护的键值对, 并且通过减掉引用计数来抹杀掉他们. 另外一件重要的事情就是, 将这个entry标记成Dummy态.</p><h2 id="缓冲-池-怎么还来"><a href="#缓冲-池-怎么还来" class="headerlink" title="缓冲..池 (怎么还来?!"></a>缓冲..池 (怎么还来?!</h2><p>OK, Python同样为字典对象设置了缓冲池, 我们之前在看创建函数的时候也注意到了那个缓冲池对象.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFREEDICTS 80</span></span><br><span class="line"><span class="type">static</span> PyDictObject *free_dicts[MAXFREEDICTS];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num_free_dicts = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如果你记忆力足够好的话 你会发现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFREELISTS 80</span></span><br><span class="line"><span class="type">static</span> PyListObject *free_lists[MAXFREELISTS];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num_free_lists = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>没错, 这根本就和列表对象的缓冲池一模一样嘛. 其实就连实现机制都是差不多的, 那就是在析构函数中将这个字典对象所维护的所有键值对销毁之后将这个字典对象本身加入到缓冲池之中. 来看代码吧:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dict_dealloc</span><span class="params">(<span class="keyword">register</span> dictobject *mp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> dictentry *ep;</span><br><span class="line">Py_ssize_t fill = mp-&gt;ma_fill;</span><br><span class="line"> PyObject_GC_UnTrack(mp);</span><br><span class="line">Py_TRASHCAN_SAFE_BEGIN(mp)</span><br><span class="line"><span class="keyword">for</span> (ep = mp-&gt;ma_table; fill &gt; <span class="number">0</span>; ep++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ep-&gt;me_key) &#123;</span><br><span class="line">--fill;</span><br><span class="line">Py_DECREF(ep-&gt;me_key);</span><br><span class="line">Py_XDECREF(ep-&gt;me_value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mp-&gt;ma_table != mp-&gt;ma_smalltable)</span><br><span class="line">PyMem_DEL(mp-&gt;ma_table);</span><br><span class="line"><span class="keyword">if</span> (num_free_dicts &lt; MAXFREEDICTS &amp;&amp; mp-&gt;ob_type == &amp;PyDict_Type)</span><br><span class="line">free_dicts[num_free_dicts++] = mp;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">mp-&gt;ob_type-&gt;tp_free((PyObject *)mp);</span><br><span class="line">Py_TRASHCAN_SAFE_END(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这个字典每一个entry的键值对引用释放, 接着释放内存归还给系统堆, 接着就把这一只丢到缓冲池之中了.  另外在创建的时候, 如果这个缓冲池中有, 就直接拿来用了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (num_free_dicts) &#123;</span><br><span class="line">    mp = free_dicts[--num_free_dicts];</span><br><span class="line">    assert (mp != <span class="literal">NULL</span>);</span><br><span class="line">    assert (mp-&gt;ob_type == &amp;PyDict_Type);</span><br><span class="line">    _Py_NewReference((PyObject *)mp);</span><br><span class="line">    <span class="keyword">if</span> (mp-&gt;ma_fill) &#123;</span><br><span class="line">        EMPTY_TO_MINSIZE(mp);</span><br><span class="line">    &#125;</span><br><span class="line">    assert (mp-&gt;ma_used == <span class="number">0</span>);</span><br><span class="line">    assert (mp-&gt;ma_table == mp-&gt;ma_smalltable);</span><br><span class="line">    assert (mp-&gt;ma_mask == PyDict_MINSIZE - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>最后还是惯例的结论验证时间, 这一次我们在字典每次插入的时候打印出当前的字典状态, 并且尝试体验下dummy状态.为了防止大量的输出(因为Python自己就会有大量的字典插入操作), 所以我们只打印拥有特殊ID的字典(我自己定义的)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&quot;ID&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">9</span>] = <span class="number">9</span></span><br><span class="line">insert <span class="number">9</span></span><br><span class="line">  key : NULL<span class="number">9</span>NULLNULLNULL<span class="string">&#x27;ID&#x27;</span>NULLNULL</span><br><span class="line">value : NULL<span class="number">9</span>NULLNULLNULL<span class="string">&#x27;1&#x27;</span>NULLNULL</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">17</span>] = <span class="number">17</span></span><br><span class="line">insert <span class="number">17</span></span><br><span class="line">  key : NULL<span class="number">9</span>NULLNULLNULL<span class="string">&#x27;ID&#x27;</span>NULL<span class="number">17</span></span><br><span class="line">value : NULL<span class="number">9</span>NULLNULLNULL<span class="string">&#x27;1&#x27;</span>NULL<span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d[<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">17</span>] = <span class="number">16</span></span><br><span class="line">insert <span class="number">17</span></span><br><span class="line">  key : NULLdummyNULLNULLNULL<span class="string">&#x27;ID&#x27;</span>NULL<span class="number">17</span></span><br><span class="line">value : NULLNULLNULLNULLNULL<span class="string">&#x27;1&#x27;</span>NULL<span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d[<span class="number">17</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">17</span>] = <span class="number">17</span></span><br><span class="line">insert <span class="number">17</span></span><br><span class="line">  key : NULL<span class="number">17</span>NULLNULLNULL<span class="string">&#x27;ID&#x27;</span>NULLdummy</span><br><span class="line">value : NULL<span class="number">17</span>NULLNULLNULL<span class="string">&#x27;1&#x27;</span>NULLNULL</span><br></pre></td></tr></table></figure><p>这就是实验的效果, 这里9和17是会出现哈希碰撞的, 从实验结果也可以看出来的.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Source Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python源码阅读-内建对象(4)</title>
      <link href="/2018/03/13/Python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%BB%BA%E5%AF%B9%E8%B1%A1-4/"/>
      <url>/2018/03/13/Python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%BB%BA%E5%AF%B9%E8%B1%A1-4/</url>
      
        <content type="html"><![CDATA[<p>这是《Python源码剖析 — 深度探索动态语言核心技术》的阅读记录.</p><p>Python中的列表对象 - <code>PyListObject</code>.</p><span id="more"></span><h2 id="对象概述"><a href="#对象概述" class="headerlink" title="对象概述"></a>对象概述</h2><p>Python中的列表对象是可以结束各种类型的对象的, 例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.append(<span class="string">&quot;P&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.append([])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;P&#x27;</span>, []]</span><br></pre></td></tr></table></figure><p>这也就是说, 在Python的列表对象中, 存放的都是PyObject*类型的指针. 而这样的一个List显然是一个可变长对象, 并且还支持元素的操作: set, insert, delete等等. 对于这样的一个变长对象来说, 内存空间的维护就变得尤为重要了.</p><p>还是先从对象的定义开始看吧:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="comment">/* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */</span></span><br><span class="line">    PyObject **ob_item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ob_item contains space for &#x27;allocated&#x27; elements.  The number</span></span><br><span class="line"><span class="comment">     * currently in use is ob_size.</span></span><br><span class="line"><span class="comment">     * Invariants:</span></span><br><span class="line"><span class="comment">     *     0 &lt;= ob_size &lt;= allocated</span></span><br><span class="line"><span class="comment">     *     len(list) == ob_size</span></span><br><span class="line"><span class="comment">     *     ob_item == NULL implies ob_size == allocated == 0</span></span><br><span class="line"><span class="comment">     * list.sort() temporarily sets allocated to -1 to detect mutations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Items must normally not be NULL, except during construction when</span></span><br><span class="line"><span class="comment">     * the list is not yet visible outside the function that builds it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure><p>如我们所料, 是一个<code>PyObject_VAR_HEAD</code>可变对象头. 后面的指针就是指向列表中的元素的指针了.(因为Python设计列表对象和具体的元素是分离的, 他们之间就通过这个<code>**ob_item</code>来连接) 最后面的那个属性就很重要了, 通过注释我们就可以大概猜出来这个的作用. 如果说一个列表有10个元素, 那么这10个元素的大小应该就可以从这个<code>PyObject_VAR_HEAD</code>中的<code>ob_size</code>中得到, 为啥会需要一个叫做<code>allocated</code>的值来标明分配的内存大小呢? </p><p>稍微想想就可以搞懂了, 如果说我们采取插入一个元素就申请一个内存, 那效率也太低了. 因此, 我们总是会申请一大块内存, 将这个大块内存的容量记录在<code>allocated</code>这个值, 而<code>ob_size</code>记录的则是使用的内存大小.</p><p>这就是最基本的PyListObject内存管理策略.</p><h2 id="创建列表对象-维护和列表操作"><a href="#创建列表对象-维护和列表操作" class="headerlink" title="创建列表对象, 维护和列表操作"></a>创建列表对象, 维护和列表操作</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>那么就具体看下是怎么进行内存申请的吧:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyList_New</span><span class="params">(Py_ssize_t size)</span></span><br><span class="line">&#123;</span><br><span class="line">PyListObject *op;</span><br><span class="line"><span class="type">size_t</span> nbytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">PyErr_BadInternalCall();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">nbytes = size * <span class="keyword">sizeof</span>(PyObject *);</span><br><span class="line"><span class="comment">/* Check for overflow without an actual overflow,</span></span><br><span class="line"><span class="comment"> *  which can cause compiler to optimise out */</span></span><br><span class="line"><span class="keyword">if</span> (size &gt; PY_SIZE_MAX / <span class="keyword">sizeof</span>(PyObject *))</span><br><span class="line"><span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line"><span class="keyword">if</span> (num_free_lists) &#123;</span><br><span class="line">num_free_lists--;</span><br><span class="line">op = free_lists[num_free_lists];</span><br><span class="line">_Py_NewReference((PyObject *)op);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">op = PyObject_GC_New(PyListObject, &amp;PyList_Type);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">op-&gt;ob_item = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">op-&gt;ob_item = (PyObject **) PyMem_MALLOC(nbytes);</span><br><span class="line"><span class="keyword">if</span> (op-&gt;ob_item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">Py_DECREF(op);</span><br><span class="line"><span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(op-&gt;ob_item, <span class="number">0</span>, nbytes);</span><br><span class="line">&#125;</span><br><span class="line">op-&gt;ob_size = size;</span><br><span class="line">op-&gt;allocated = size;</span><br><span class="line">_PyObject_GC_TRACK(op);</span><br><span class="line"><span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是唯一的一个创建函数. 他需要接受一个长度. 接着就是检查参数传递的正确性, 是否出现溢出, 接着就要开始申请内存了. 中间的那些<code>free_list</code>我们先忽略掉, 直接看后面的内存申请. 我们申请<code>nbytes</code>大小的内存, 这个大小就是<code>size * sizeof(PyObject *)</code>. 接着使用0去填充我们的ob_item指向的内存区域, 并且为了日后的维护, 我们把这个新列表的大小和分配的内存大小赋值, <em>第一次创建的列表的ob_size和allocated的大小是一样的.</em> 后面的GC宏我们先忽略.</p><h3 id="设置元素"><a href="#设置元素" class="headerlink" title="设置元素"></a>设置元素</h3><p>得到了一个新的列表对象,接着就要向里面添加元素了. 调用的底层函数就是这个:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyList_SetItem</span><span class="params">(<span class="keyword">register</span> PyObject *op, <span class="keyword">register</span> Py_ssize_t i,</span></span><br><span class="line"><span class="params">               <span class="keyword">register</span> PyObject *newitem)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> PyObject *olditem;</span><br><span class="line"><span class="keyword">register</span> PyObject **p;</span><br><span class="line"><span class="keyword">if</span> (!PyList_Check(op)) &#123;</span><br><span class="line">Py_XDECREF(newitem);</span><br><span class="line">PyErr_BadInternalCall();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= ((PyListObject *)op) -&gt; ob_size) &#123;</span><br><span class="line">Py_XDECREF(newitem);</span><br><span class="line">PyErr_SetString(PyExc_IndexError,</span><br><span class="line"><span class="string">&quot;list assignment index out of range&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">p = ((PyListObject *)op) -&gt; ob_item + i;</span><br><span class="line">olditem = *p;</span><br><span class="line">*p = newitem;</span><br><span class="line">Py_XDECREF(olditem);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们进行<code>l[1] = &quot;a&quot;</code>这样的操作的时候, 就是在调用这个函数了, 首先还是会进行一下类型检查, 如果不是列表对象就会报错, 接着检查索引, 如果是超出列表范围就抛出IndexError异常. 这些都检查没问题了, 就可以开始进行赋值了,  首先, 我们把要被替换的那个位置的元素指针拿到, 接着先丢给另一个<code>olditem</code>代为存储, 然后就可以进行覆盖操作了. 接着把踢出来的那个元素的引用计数减一, 注意这里使用的是<code>XDECREF</code>.  这是因为有可能在空列表中插入元素的时候原来的元素就是NULL.</p><blockquote><p>XDECREF和DECREF的区别就是X版本会检查一下元素是否为NULL, 如果是就不做任何操作. 感觉就有点像是Redis中的NX和XX.</p></blockquote><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>可能你会觉得, 插入不就是设置元素嘛, 那就肯定可以重用接口了吧? 可惜并不能, 插入和设置的一个本质区别就是在插入的时候会导致<code>ob_item</code>的指向发生变化. 在底层实现, 插入使用的是这个函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">PyList_Insert</span><span class="params">(PyObject *op, Py_ssize_t where, PyObject *newitem)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!PyList_Check(op)) &#123;</span><br><span class="line">PyErr_BadInternalCall();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ins1((PyListObject *)op, where, newitem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实调用的是一个叫做<code>ins1</code>的函数, 来看下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">ins1</span><span class="params">(PyListObject *self, Py_ssize_t where, PyObject *v)</span></span><br><span class="line">&#123;</span><br><span class="line">Py_ssize_t i, n = self-&gt;ob_size;</span><br><span class="line">PyObject **items;</span><br><span class="line"><span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">PyErr_BadInternalCall();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == PY_SSIZE_T_MAX) &#123;</span><br><span class="line">PyErr_SetString(PyExc_OverflowError,</span><br><span class="line"><span class="string">&quot;cannot add more objects to list&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (list_resize(self, n+<span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (where &lt; <span class="number">0</span>) &#123;</span><br><span class="line">where += n;</span><br><span class="line"><span class="keyword">if</span> (where &lt; <span class="number">0</span>)</span><br><span class="line">where = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (where &gt; n)</span><br><span class="line">where = n;</span><br><span class="line">items = self-&gt;ob_item;</span><br><span class="line"><span class="keyword">for</span> (i = n; --i &gt;= where; )</span><br><span class="line">items[i+<span class="number">1</span>] = items[i];</span><br><span class="line">Py_INCREF(v);</span><br><span class="line">items[where] = v;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里传入的<code>op</code>已经可以确定是一个列表对象了. 首先还是进行的类型审查和溢出检查, 接着就是一个关键的步骤了, 那就是进行大小的重新变化:<code>list_resize</code>. 这里就是在确保列表对象有足够的内存来容纳插入的元素了. 那么我们就来具体的看下是如何进行resize的.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">list_resize</span><span class="params">(PyListObject *self, Py_ssize_t newsize)</span></span><br><span class="line">&#123;</span><br><span class="line">PyObject **items;</span><br><span class="line"><span class="type">size_t</span> new_allocated;</span><br><span class="line">Py_ssize_t allocated = self-&gt;allocated;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bypass realloc() when a previous overallocation is large enough</span></span><br><span class="line"><span class="comment">   to accommodate the newsize.  If the newsize falls lower than half</span></span><br><span class="line"><span class="comment">   the allocated size, then proceed with the realloc() to shrink the list.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (allocated &gt;= newsize &amp;&amp; newsize &gt;= (allocated &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">assert(self-&gt;ob_item != <span class="literal">NULL</span> || newsize == <span class="number">0</span>);</span><br><span class="line">self-&gt;ob_size = newsize;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This over-allocates proportional to the list size, making room</span></span><br><span class="line"><span class="comment"> * for additional growth.  The over-allocation is mild, but is</span></span><br><span class="line"><span class="comment"> * enough to give linear-time amortized behavior over a long</span></span><br><span class="line"><span class="comment"> * sequence of appends() in the presence of a poorly-performing</span></span><br><span class="line"><span class="comment"> * system realloc().</span></span><br><span class="line"><span class="comment"> * The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">new_allocated = (newsize &gt;&gt; <span class="number">3</span>) + (newsize &lt; <span class="number">9</span> ? <span class="number">3</span> : <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for integer overflow */</span></span><br><span class="line"><span class="keyword">if</span> (new_allocated &gt; PY_SIZE_MAX - newsize) &#123;</span><br><span class="line">PyErr_NoMemory();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">new_allocated += newsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (newsize == <span class="number">0</span>)</span><br><span class="line">new_allocated = <span class="number">0</span>;</span><br><span class="line">items = self-&gt;ob_item;</span><br><span class="line"><span class="keyword">if</span> (new_allocated &lt;= ((~(<span class="type">size_t</span>)<span class="number">0</span>) / <span class="keyword">sizeof</span>(PyObject *)))</span><br><span class="line">PyMem_RESIZE(items, PyObject *, new_allocated);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">items = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (items == <span class="literal">NULL</span>) &#123;</span><br><span class="line">PyErr_NoMemory();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">self-&gt;ob_item = items;</span><br><span class="line">self-&gt;ob_size = newsize;</span><br><span class="line">self-&gt;allocated = new_allocated;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 如果当前已经分配的内存大小要比新分配的大, 并且新分配的大小是比原来的1&#x2F;2还要大的 那么就不需要再分配了, 反而, 还要通过调整ob_size的值, 缩小范围. 后面就是在计算新分配的内存大小了, 新分配的大小是新大小&#x2F;8再加上3或许6. 接着我们先把当前列表的元素都搬出来, 然后进行新空间的搬运, 最后把属性重新维护, 这样resize的过程就结束了.</p><p>接着回到我们的<code>ins1</code>, 此时使用的就是负数索引了, 接着就是把边界约束了一下. 这样就确保任何输入都是合法的.</p><p>除了规定index的insert, 还有一个直接插入到最后的append, 来看看吧:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">listappend</span><span class="params">(PyListObject *self, PyObject *v)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (app1(self, v) == <span class="number">0</span>)</span><br><span class="line">Py_RETURN_NONE;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和Insert真是类似啊, 我们来看看这个<code>app1</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">app1</span><span class="params">(PyListObject *self, PyObject *v)</span></span><br><span class="line">&#123;</span><br><span class="line">Py_ssize_t n = PyList_GET_SIZE(self);</span><br><span class="line"></span><br><span class="line">assert (v != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (n == PY_SSIZE_T_MAX) &#123;</span><br><span class="line">PyErr_SetString(PyExc_OverflowError,</span><br><span class="line"><span class="string">&quot;cannot add more objects to list&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (list_resize(self, n+<span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">Py_INCREF(v);</span><br><span class="line">PyList_SET_ITEM(self, n, v);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的, 还是先继续rsize, 之后就简单了, 我们直接调用设置元素的API就可以了. 这个就比insert要简单的多.</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>PyListObject删除元素的方法在这里:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">listremove</span><span class="params">(PyListObject *self, PyObject *v)</span></span><br><span class="line">&#123;</span><br><span class="line">Py_ssize_t i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; self-&gt;ob_size; i++) &#123;</span><br><span class="line"><span class="type">int</span> cmp = PyObject_RichCompareBool(self-&gt;ob_item[i], v, Py_EQ);</span><br><span class="line"><span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (list_ass_slice(self, i, i+<span class="number">1</span>,</span><br><span class="line">   (PyObject *)<span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line">Py_RETURN_NONE;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">PyErr_SetString(PyExc_ValueError, <span class="string">&quot;list.remove(x): x not in list&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实流程很简单, 就是遍历整个列表然后和你要删除的元素进行挨个的比较, 如果一样就调用另外一个函数来真正删除元素, 如果说比较了所有的元素还是没有找到待删除的元素, 就会跑完循环然后抛出ValueError异常.</p><p>那么我们关注的重点显然就是那个删除元素的函数了, 实际上, 从注释我们可以知道, 这个函数是一个多用途的函数, 它不仅可以用来删除元素, 还可以进行列表元素的替换. 根据传递的参数是否为NULL来判定执行什么样的操作: (我们可以理解成是删除元素就是把某个位置的元素替换成空罢了)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a[ilow:ihigh] = v if v != NULL.</span><br><span class="line">del a[ilow:ihigh] if v == NULL.</span><br><span class="line"></span><br><span class="line">函数的签名是这样的: </span><br><span class="line">static int</span><br><span class="line">list_ass_slice(PyListObject *a, Py_ssize_t ilow, Py_ssize_t ihigh, PyObject *v)</span><br></pre></td></tr></table></figure><p>我们主要来看删除元素的操作步骤.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (v == <span class="literal">NULL</span>)</span><br><span class="line">n = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>首先如果我们传入的v参数是NULL的话, 就是执行删除操作, 这样就把替换列表元素的数量设置成0. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ilow &lt; <span class="number">0</span>)</span><br><span class="line">    ilow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ilow &gt; a-&gt;ob_size)</span><br><span class="line">    ilow = a-&gt;ob_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ihigh &lt; ilow)</span><br><span class="line">    ihigh = ilow;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ihigh &gt; a-&gt;ob_size)</span><br><span class="line">    ihigh = a-&gt;ob_size;</span><br><span class="line"></span><br><span class="line">norig = ihigh - ilow;</span><br><span class="line">assert(norig &gt;= <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>接着进行一波索引正确性和边界判断. 这里的<code>norig</code>就是即将发生变化的, 可以使即将被替换的, 也可以是即将被删除的. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">d = n - norig;</span><br><span class="line">item = a-&gt;ob_item;</span><br><span class="line">s = norig * <span class="keyword">sizeof</span>(PyObject *);</span><br><span class="line"><span class="keyword">if</span> (s &gt; <span class="keyword">sizeof</span>(recycle_on_stack)) &#123;</span><br><span class="line">    recycle = (PyObject **)PyMem_MALLOC(s);</span><br><span class="line">    <span class="keyword">if</span> (recycle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(recycle, &amp;item[ilow], s);</span><br></pre></td></tr></table></figure><p>接着我们把列表中的元素都提出来, 之后在开辟的回收空间(8个PyObject的大小)上把待删除的元素先复制到上面去.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123; <span class="comment">/* Delete -d items */</span></span><br><span class="line">    memmove(&amp;item[ihigh+d], &amp;item[ihigh],</span><br><span class="line">            (a-&gt;ob_size - ihigh)*<span class="keyword">sizeof</span>(PyObject *));</span><br><span class="line">    list_resize(a, a-&gt;ob_size + d);</span><br><span class="line">    item = a-&gt;ob_item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就是删除了, 始终记得删除的时候满足<code>ihigh-ilow = 1</code>.(看之前的调用参数).所以这就相当于是把后面的向前覆盖移动, 然后重新规划大小. 最后再把其余的元素重新赋值成NULL并且统一处理引用计数.</p><h2 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h2><p>最后还是来说说List对象的对象缓冲池吧.</p><p>在之前我们是见到过的, 就是那个叫做<code>free_lists</code>的玩意:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFREELISTS 80</span></span><br><span class="line"><span class="type">static</span> PyListObject *free_lists[MAXFREELISTS];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num_free_lists = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>我们在之前的创建对象那个地方忽略掉的, 就是这个缓冲池:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (num_free_lists) &#123;</span><br><span class="line">    num_free_lists--;</span><br><span class="line">    op = free_lists[num_free_lists];</span><br><span class="line">    _Py_NewReference((PyObject *)op);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    op = PyObject_GC_New(PyListObject, &amp;PyList_Type);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有在没有命中的时候才会进行创建. 当你在代码中寻找这个变量是如何被增加的时候, 你会定位到析构函数的上面:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">list_dealloc</span><span class="params">(PyListObject *op)</span></span><br><span class="line">&#123;</span><br><span class="line">Py_ssize_t i;</span><br><span class="line">PyObject_GC_UnTrack(op);</span><br><span class="line">Py_TRASHCAN_SAFE_BEGIN(op)</span><br><span class="line"><span class="keyword">if</span> (op-&gt;ob_item != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">/* Do it backwards, for Christian Tismer.</span></span><br><span class="line"><span class="comment">   There&#x27;s a simple test case where somehow this reduces</span></span><br><span class="line"><span class="comment">   thrashing when a *very* large list is created and</span></span><br><span class="line"><span class="comment">   immediately deleted. */</span></span><br><span class="line">i = op-&gt;ob_size;</span><br><span class="line"><span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">Py_XDECREF(op-&gt;ob_item[i]);</span><br><span class="line">&#125;</span><br><span class="line">PyMem_FREE(op-&gt;ob_item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num_free_lists &lt; MAXFREELISTS &amp;&amp; PyList_CheckExact(op))</span><br><span class="line">free_lists[num_free_lists++] = op;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">op-&gt;ob_type-&gt;tp_free((PyObject *)op);</span><br><span class="line">Py_TRASHCAN_SAFE_END(op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>呵. 列表对象被毁灭的时候不是直接被<code>杀掉</code>, 而是被放在了这个缓冲池中, 当以后再次需要它的时候, 才会让他<code>重生</code>. 而不需要重新创造.</p><p>但是你也可以看到, 我们仅仅留下了<code>op</code>, 也就是PyListObject, 至于他所包含的所有元素, 都释放掉了引用计数.</p><p>行吧, 接下来我们就来实际观察下Python对列表对象的内存管理吧.</p><h2 id="结论测试"><a href="#结论测试" class="headerlink" title="结论测试"></a>结论测试</h2><p>我们再源码中进行修改, 使得打印列表函数可以输出一些信息, 接着就开始测试, 我们这一次使用脚本来测试缓冲池(这是为了防止交互式环境对缓冲池数量的影响).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span> list1</span><br><span class="line">list2 = [<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span> list1</span><br><span class="line">list3 = [<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span> list1</span><br><span class="line"><span class="keyword">del</span> list3</span><br><span class="line"><span class="built_in">print</span> list1</span><br><span class="line"><span class="keyword">del</span> list2</span><br><span class="line"><span class="built_in">print</span> list1</span><br></pre></td></tr></table></figure><p>输出的结果是这样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@Ubuntu:/tmp/bin# ./python2.5 list_test</span><br><span class="line">Could not find platform dependent libraries &lt;exec_prefix&gt;</span><br><span class="line">Consider setting $PYTHONHOME to &lt;prefix&gt;[:&lt;exec_prefix&gt;]</span><br><span class="line">[]Allocated: 1, ob_size: 1; num_free_lists: 3</span><br><span class="line">[]Allocated: 1, ob_size: 1; num_free_lists: 2</span><br><span class="line">[]Allocated: 1, ob_size: 1; num_free_lists: 1</span><br><span class="line">[]Allocated: 1, ob_size: 1; num_free_lists: 2</span><br><span class="line">[]Allocated: 1, ob_size: 1; num_free_lists: 3</span><br></pre></td></tr></table></figure><p>请忽略其他奇怪的输出…能看到效果就好了.</p><p>随着元素的删除, 缓冲池的数量在增加. 并且在创建的时候 会直接从池子中取.</p><p>最后再看下那个resize的效果吧:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[]Allocated: <span class="number">1</span>, ob_size: <span class="number">1</span>; num_free_lists: <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[, ]Allocated: <span class="number">5</span>, ob_size: <span class="number">2</span>; num_free_lists: <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[, , ]Allocated: <span class="number">5</span>, ob_size: <span class="number">3</span>; num_free_lists: <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.append(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[, , , , , ]Allocated: <span class="number">9</span>, ob_size: <span class="number">6</span>; num_free_lists: <span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Source Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python源码阅读-内建对象(3)</title>
      <link href="/2018/03/10/Python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%BB%BA%E5%AF%B9%E8%B1%A1-3/"/>
      <url>/2018/03/10/Python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%BB%BA%E5%AF%B9%E8%B1%A1-3/</url>
      
        <content type="html"><![CDATA[<p>这是《Python源码剖析 — 深度探索动态语言核心技术》的阅读记录.</p><p>Python中的字符串对象 - <code>PyStringObject</code></p><span id="more"></span><p>在最一开始的概述中, 我们提到了Python中的字符串是不可变对象, 并且我们还知道这个字符串对象还是一个不定长对象. 也就是说, 除了前面说的整数对象这种定长对象分为可变和不可变, 不定长对象按照是否可变也分成可变和不可变.</p><p>不可变的字符串特性其实是很麻烦的, 这对于处理效率是个挑战, 例如我们常常说的字符串拼接, 就是一个效率较低的操作. 那么到底字符串对象在Python底层是如何存储的, 是不是也像整数对象那样, 有一个缓冲池之类的呢? 我们来看看吧.</p><h2 id="初探PyStringObject"><a href="#初探PyStringObject" class="headerlink" title="初探PyStringObject"></a>初探PyStringObject</h2><p>当然先去头文件中看看定义了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="type">long</span> ob_shash;</span><br><span class="line">    <span class="type">int</span> ob_sstate;</span><br><span class="line">    <span class="type">char</span> ob_sval[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariants:</span></span><br><span class="line"><span class="comment">     *     ob_sval contains space for &#x27;ob_size+1&#x27; elements.</span></span><br><span class="line"><span class="comment">     *     ob_sval[ob_size] == 0.</span></span><br><span class="line"><span class="comment">     *     ob_shash is the hash of the string or -1 if not computed yet.</span></span><br><span class="line"><span class="comment">     *     ob_sstate != 0 iff the string object is in stringobject.c&#x27;s</span></span><br><span class="line"><span class="comment">     *       &#x27;interned&#x27; dictionary; in this case the two references</span></span><br><span class="line"><span class="comment">     *       from &#x27;interned&#x27; to this object are *not counted* in ob_refcnt.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125; PyStringObject;</span><br></pre></td></tr></table></figure><p>源码中还给足了注释, 我们简单翻译一下就是这个样子: 这个<code>ob_shash</code>是这个string的哈希值, 为了节省重新计算的性能消耗和效率降低, 在计算之前是<code>-1</code>. <code>ob_sstate</code>这个玩意我们在后面再介绍.至于<code>ob_sval</code>一看名字也就猜到了, 是这个字符串具体的值. 但是你会疑问呀, 为啥只有一个长度啊? 其实这个东西是个字符指针, 指向一块内存. 也就是这个字符串真正的内容. 那么到底是多长呢, 看这个结构体的头部. 对了, 就是Python变长对象的通用头部, 里面的<code>ob_size</code>就是长度了. </p><p>另外, 我们知道在C中, 遇到<code>\0</code>就会认定字符串结束了, 但是Python中可不是这样. 所以说实际上的<code>ob_size</code>再加上1才是真正的字符串内存, 并且一个确定的事实是: <code>ob_sval[ob_size] == &#39;\0&#39;</code></p><p>顺带附送一个字符串hash函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">string_hash</span><span class="params">(PyStringObject *a)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> Py_ssize_t len;</span><br><span class="line"><span class="keyword">register</span> <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line"><span class="keyword">register</span> <span class="type">long</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a-&gt;ob_shash != <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> a-&gt;ob_shash;</span><br><span class="line">len = a-&gt;ob_size;</span><br><span class="line">p = (<span class="type">unsigned</span> <span class="type">char</span> *) a-&gt;ob_sval;</span><br><span class="line">x = *p &lt;&lt; <span class="number">7</span>;</span><br><span class="line"><span class="keyword">while</span> (--len &gt;= <span class="number">0</span>)</span><br><span class="line">x = (<span class="number">1000003</span>*x) ^ *p++;</span><br><span class="line">x ^= a-&gt;ob_size;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">-1</span>)</span><br><span class="line">x = <span class="number">-2</span>;</span><br><span class="line">a-&gt;ob_shash = x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为啥这么算 我就不懂了…</p><p>接着我们来看下字符串类型对象:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyString_Type = &#123;</span><br><span class="line">PyObject_HEAD_INIT(&amp;PyType_Type)</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="string">&quot;str&quot;</span>,</span><br><span class="line"><span class="keyword">sizeof</span>(PyStringObject),</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">char</span>),</span><br><span class="line">...</span><br><span class="line">&amp;string_as_number,<span class="comment">/* tp_as_number */</span></span><br><span class="line">&amp;string_as_sequence,<span class="comment">/* tp_as_sequence */</span></span><br><span class="line">&amp;string_as_mapping,<span class="comment">/* tp_as_mapping */</span></span><br><span class="line">...</span><br><span class="line">&amp;PyBaseString_Type,<span class="comment">/* tp_base */</span></span><br><span class="line">...</span><br><span class="line">string_new,<span class="comment">/* tp_new */</span></span><br><span class="line">PyObject_Del,                <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到字符串支持数字, 序列和字典的各种行为. 另外值得注意的一个地方 — 它的基类, 指向了一个叫做<code>PyBaseString</code>的类型对象.</p><h2 id="创建一个字符串对象"><a href="#创建一个字符串对象" class="headerlink" title="创建一个字符串对象"></a>创建一个字符串对象</h2><p>直接突入它最基本的创建函数, 来看下(还是有点长的, 我们慢慢分析吧):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyString_FromString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> size;</span><br><span class="line"><span class="keyword">register</span> PyStringObject *op;</span><br><span class="line"></span><br><span class="line">assert(str != <span class="literal">NULL</span>);</span><br><span class="line">size = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">if</span> (size &gt; PY_SSIZE_T_MAX) &#123;</span><br><span class="line">PyErr_SetString(PyExc_OverflowError,</span><br><span class="line"><span class="string">&quot;string is too long for a Python string&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span> &amp;&amp; (op = nullstring) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">null_strings++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">Py_INCREF(op);</span><br><span class="line"><span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span> &amp;&amp; (op = characters[*str &amp; UCHAR_MAX]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">one_strings++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">Py_INCREF(op);</span><br><span class="line"><span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">&#125;</span><br><span class="line">#### 我自己的分割线 ####</span><br><span class="line"><span class="comment">/* Inline PyObject_NewVar */</span></span><br><span class="line">op = (PyStringObject *)PyObject_MALLOC(<span class="keyword">sizeof</span>(PyStringObject) + size);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">PyObject_INIT_VAR(op, &amp;PyString_Type, size);</span><br><span class="line">op-&gt;ob_shash = <span class="number">-1</span>;</span><br><span class="line">op-&gt;ob_sstate = SSTATE_NOT_INTERNED;</span><br><span class="line">Py_MEMCPY(op-&gt;ob_sval, str, size+<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* share short strings */</span></span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">PyObject *t = (PyObject *)op;</span><br><span class="line">PyString_InternInPlace(&amp;t);</span><br><span class="line">op = (PyStringObject *)t;</span><br><span class="line">nullstring = op;</span><br><span class="line">Py_INCREF(op);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">PyObject *t = (PyObject *)op;</span><br><span class="line">PyString_InternInPlace(&amp;t);</span><br><span class="line">op = (PyStringObject *)t;</span><br><span class="line">characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">Py_INCREF(op);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看分割线上面的.首先检测是否为NULL, 如果不是就继续检查长度, 字符串的长度不能超过最大值, 这个最大值是一个和平台相关的值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PY_SSIZE_T_MAX ((Py_ssize_t)(((size_t)-1)&gt;&gt;1))</span></span><br></pre></td></tr></table></figure><p>这个值在我电脑上的测试结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9223372036854775807</span></span><br></pre></td></tr></table></figure><p>这个数值是多大呢? 这么说吧, 你的硬盘上全是字符串, 把他们一股脑全部丢过来都没有超过长度, 而且还绰绰有余.</p><p>接下来先分成两种情况: 长度为0的空串或者是长度为1的字符.</p><p>Python预先准备了一个空字符串对象<code>nullstring</code>, 这个对象一开始是NULL, 当接收到空字符串的创建需求的时候, 会给他开辟一块内存, 这样 当以后再有需要空字符串的创建需求的时候, 就通过这个<code>nullstring</code>来检测, 如果<code>nullstring</code>已经存在了, 就直接返回引用. 可以做一个这样的小实验:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">str</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">str</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="string">&#x27;0x10c83e508&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="string">&#x27;0x10c83e508&#x27;</span></span><br></pre></td></tr></table></figure><p>他们的内存指向是一样的.</p><p>如果长度是1, 那么和上面的空字符串处理几乎是一样的, Python维护了一个单字符的内存空间<code>characters</code>, 也就是<code>printf(&quot;UCHAR_MAX  = %u\n&quot;,  UCHAR_MAX);</code>这个语句输出的结果大小, 至于那个宏, 熟悉C的肯定都知道了, 定义在<code>limits.h</code>中.</p><p>接下来就来看分割线下面的部分.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">op = (PyStringObject *)PyObject_MALLOC(<span class="keyword">sizeof</span>(PyStringObject) + size);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">PyObject_INIT_VAR(op, &amp;PyString_Type, size);</span><br><span class="line">op-&gt;ob_shash = <span class="number">-1</span>;</span><br><span class="line">op-&gt;ob_sstate = SSTATE_NOT_INTERNED;</span><br><span class="line">Py_MEMCPY(op-&gt;ob_sval, str, size+<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* share short strings */</span></span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">    PyObject *t = (PyObject *)op;</span><br><span class="line">    PyString_InternInPlace(&amp;t);</span><br><span class="line">    op = (PyStringObject *)t;</span><br><span class="line">    nullstring = op;</span><br><span class="line">    Py_INCREF(op);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">    PyObject *t = (PyObject *)op;</span><br><span class="line">    PyString_InternInPlace(&amp;t);</span><br><span class="line">    op = (PyStringObject *)t;</span><br><span class="line">    characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">    Py_INCREF(op);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (PyObject *) op;</span><br></pre></td></tr></table></figure><p>为我们的字符串对象先分配内存, 之后根据<code>PyString_Type</code>的定义来进行初始化, 长度就是待创建的字符的长度. 接着初始化哈希为-1, 然后将<code>ob_sstate</code>加上了一个状态, 关于这个我们也先放一下. 继续向后面看, 我们把C类型的字符串赋值给PyStringObject的<code>ob_sval</code>, 当然还要加上最后的<code>\0</code> 此时就差不多了, 后面的那些我们先忽略.</p><blockquote><p>仔细算一下, 一开始申请内存的时候长度的计算. 我们知道C中的字符串的最后有一个<code>\0</code>.  而string标准库中的<code>strlen</code>是会把最后的<code>\0</code>减掉的, 这样的申请的内存空间就会缺少最后的<code>\0</code>. 那就不对了.</p><p>真的是这样吗? 在<code>PyStringObject</code>的定义中, 有一个char类型的指针, 指向真实的字符串内存. 如果把这个加上 那就对了. 其实真实的内存分配就是这个样子的:</p><p>比如”Python”这个字符串:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref type size hash state P(这个P就是val) [y t h o n \0] 加上的strlen(&quot;Python&quot;) = 6</span><br></pre></td></tr></table></figure></blockquote><p>这样计算的一个大前提就是, 传入的字符串必须是<code>\0</code>结束. 否则内存的申请就会出问题. 所以为了更灵活, 还有一个创建的函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyString_FromStringAndSize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, Py_ssize_t size)</span></span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><p>这里就不再需要使用<code>\0</code>结尾了, 但是要求就变成了这样了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(size &gt;= <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>其他的过程几乎就和前一个创建函数一样了.</p><h2 id="PyStringObject的Intern机制"><a href="#PyStringObject的Intern机制" class="headerlink" title="PyStringObject的Intern机制"></a>PyStringObject的Intern机制</h2><p>现在我们来把之前遗漏的地方补充一下, 也就是当字符串长度为0或者为1的时候, 发生的特殊动作. 也就是**<code>intern</code>**机制.</p><p>这个机制存在的意义是什么呢? 要搞清楚这个, 我们要先知道这个机制是干嘛的.</p><p>当我们在比较两个字符串是不是相等的时候, 是不是要确保每一个字符都一样呀. 另外, 如果是两个相等的字符串, 我是不是可以考虑把他们存在一个地方, 只要返回引用从而节省内存. 这个<code>Intern</code>机制就同时解决了这两个问题.</p><p><code>intern</code>机制使得在Python运行期间, 一个值对应一个<code>PyStringObject</code>对象, 如果值相同就会映射到同一个<code>PyStringObject</code>对象上. 从而节约宝贵的内存. 并且有趣的是, 这种机制同时为字符串判断提供了一个简便方法, 那就是直接比较他们是不是一个<code>PyObject*</code>指针指向就好了.</p><p>接下来我们来看看具体是怎么做的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">    PyObject *t = (PyObject *)op;</span><br><span class="line">    PyString_InternInPlace(&amp;t);</span><br><span class="line">    op = (PyStringObject *)t;</span><br><span class="line">    nullstring = op;</span><br><span class="line">    Py_INCREF(op);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">1</span> &amp;&amp; str != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    PyObject *t = (PyObject *)op;</span><br><span class="line">    PyString_InternInPlace(&amp;t);</span><br><span class="line">    op = (PyStringObject *)t;</span><br><span class="line">    characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">    Py_INCREF(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键的函数就是那个<code>PyString_InternInPlace</code>了, 来看下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyString_InternInPlace</span><span class="params">(PyObject **p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> PyStringObject *s = (PyStringObject *)(*p);</span><br><span class="line">PyObject *t;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">NULL</span> || !PyString_Check(s))</span><br><span class="line">Py_FatalError(<span class="string">&quot;PyString_InternInPlace: strings only please!&quot;</span>);</span><br><span class="line"><span class="comment">/* If it&#x27;s a string subclass, we don&#x27;t really know what putting</span></span><br><span class="line"><span class="comment">   it in the interned dict might do. */</span></span><br><span class="line"><span class="keyword">if</span> (!PyString_CheckExact(s))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (PyString_CHECK_INTERNED(s))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (interned == <span class="literal">NULL</span>) &#123;</span><br><span class="line">interned = PyDict_New();</span><br><span class="line"><span class="keyword">if</span> (interned == <span class="literal">NULL</span>) &#123;</span><br><span class="line">PyErr_Clear(); <span class="comment">/* Don&#x27;t leave an exception */</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">t = PyDict_GetItem(interned, (PyObject *)s);</span><br><span class="line"><span class="keyword">if</span> (t) &#123;</span><br><span class="line">Py_INCREF(t);</span><br><span class="line">Py_DECREF(*p);</span><br><span class="line">*p = t;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PyDict_SetItem(interned, (PyObject *)s, (PyObject *)s) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">PyErr_Clear();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* The two references in interned are not counted by refcnt.</span></span><br><span class="line"><span class="comment">   The string deallocator will take care of this */</span></span><br><span class="line">s-&gt;ob_refcnt -= <span class="number">2</span>;</span><br><span class="line">PyString_CHECK_INTERNED(s) = SSTATE_INTERNED_MORTAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始就进行了严格的类型审查, 甚至连string的子类也纳入考虑范围. 在确定了是PyStringObject之后, 就要判断他的intern状态了. 这个状态保存在什么地方呢? 对啦, 就是我们之前一直都在忽略的地方: <code>ob_sstate</code>. 最一开始创建对象的时候 先是给他赋了一个<code>SSTATE_NOT_INTERNED</code>的初始值, 这个其实就是0, 还有两个状态, 定义是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATE_NOT_INTERNED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATE_INTERNED_MORTAL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATE_INTERNED_IMMORTAL 2</span></span><br></pre></td></tr></table></figure><p>也就是说, 当没有intered的时候, if判断会返回False的. 所以在一开始的时候不会返回, 如果一个字符串对象已经获得了intern状态, 那么就会直接返回了.</p><p>好, 那我们继续. 到了检查一个叫做<code>intered</code>的玩意, 这是什么呢? 这个就是intern机制的一个核心元素了, 这个Python对象指针指向的字典储存了所有interned的字符串, 至于为什么说是个字典, 我们继续向后看.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyString_InternInPlace</span><span class="params">(PyObject **p)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (interned == <span class="literal">NULL</span>) &#123;</span><br><span class="line">interned = PyDict_New();</span><br><span class="line"><span class="keyword">if</span> (interned == <span class="literal">NULL</span>) &#123;</span><br><span class="line">PyErr_Clear(); <span class="comment">/* Don&#x27;t leave an exception */</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">t = PyDict_GetItem(interned, (PyObject *)s);</span><br><span class="line"><span class="keyword">if</span> (t) &#123;</span><br><span class="line">Py_INCREF(t);</span><br><span class="line">Py_DECREF(*p);</span><br><span class="line">*p = t;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PyDict_SetItem(interned, (PyObject *)s, (PyObject *)s) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">PyErr_Clear();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* The two references in interned are not counted by refcnt.</span></span><br><span class="line"><span class="comment">   The string deallocator will take care of this */</span></span><br><span class="line">s-&gt;ob_refcnt -= <span class="number">2</span>;</span><br><span class="line">PyString_CHECK_INTERNED(s) = SSTATE_INTERNED_MORTAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还未初始化我们的interned指针, 就会调用一个PyDictObject的New方法, 这个等我们到后面说到字典对象再细说吧. 反之现在就只需要知道是个字典就好了. 接着我们尝试从这个字典里面取出这个字符串对象, 如果真的存在, 进行引用计数的调整:</p><ul><li>字典中的那个interned引用计数加一</li><li>这个新的字符串对象的引用计数减一</li></ul><p>接着就是关键步骤了, 另这个指向字符串的指针的指针地址调整成字典中的那个指针地址. 最后返回.</p><blockquote><p>在这里我们插一句, 之前我们说intern机制是为了节约内存. 没错是节省了, 但不是像一开始说的是仅创建一个字符串对象. 对象还是会被创建的. 只不过在后面的检查中由于引用计数减了1变成了0导致被Python的垃圾回收机制销毁掉了. 难道就不能不创建这么一个麻烦的temp变量吗? 答案是, 不能. 原因就是因为整体的设计以及PyDict的接口设计. 最一开始我们就说过在Python中对象都是用<code>PyObject</code>这个头指针来引用的, 这样的话就一定需要一个Object才可以引用</p></blockquote><p>如果没有, 那自然就是加入到字典了, 这里正常应该是返回0, 如果出现异常则会返回-1. </p><p>那么想想看, 为啥插入之后要把引用计数-2? 来思考这样的问题哦, 在interned字典中的字符串是自带两个引用的, 也就是来自Key和Value. 而interned是陪伴Python程序一生的, 也就是说只要Python进程不终结, Python虚拟机还在运行, 这两个引用就会一直存在, 这肯定是不行的. 于是, interned中的引用不算做有效引用. 这就是-2的原因. 继续深入下去, 我们来看看析构方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">string_dealloc</span><span class="params">(PyObject *op)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (PyString_CHECK_INTERNED(op)) &#123;</span><br><span class="line"><span class="keyword">case</span> SSTATE_NOT_INTERNED:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SSTATE_INTERNED_MORTAL:</span><br><span class="line"><span class="comment">/* revive dead object temporarily for DelItem */</span></span><br><span class="line">op-&gt;ob_refcnt = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (PyDict_DelItem(interned, op) != <span class="number">0</span>)</span><br><span class="line">Py_FatalError(</span><br><span class="line"><span class="string">&quot;deletion of interned string failed&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SSTATE_INTERNED_IMMORTAL:</span><br><span class="line">Py_FatalError(<span class="string">&quot;Immortal interned string died.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">Py_FatalError(<span class="string">&quot;Inconsistent interned string state.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">op-&gt;ob_type-&gt;tp_free(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要看<code>SSTATE_INTERNED_MORTAL</code>这个判断就行了, 可以看到为了删除interned字典中的键值对, 直接就把引用计数变成3, 就像是复活一样嘿嘿.</p><p>最后, 作为intern机制的补充. 我们看到还有一个<code>SSTATE_INTERNED_IMMORTAL</code>状态. 这个状态和之前我们接触的那个有什么不同吗? 看名字也就知道了, 这种状态的字符串是和虚拟机寿命相同的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">PyString_InternImmortal</span><span class="params">(PyObject **p)</span></span><br><span class="line">&#123;</span><br><span class="line">PyString_InternInPlace(p);</span><br><span class="line"><span class="keyword">if</span> (PyString_CHECK_INTERNED(*p) != SSTATE_INTERNED_IMMORTAL) &#123;</span><br><span class="line">PyString_CHECK_INTERNED(*p) = SSTATE_INTERNED_IMMORTAL;</span><br><span class="line">Py_INCREF(*p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实关键的地方也就是那个引用计数的增加, 以及象征性的状态改变.</p><h2 id="字符缓冲池以及典型问题效率讨论"><a href="#字符缓冲池以及典型问题效率讨论" class="headerlink" title="字符缓冲池以及典型问题效率讨论"></a>字符缓冲池以及典型问题效率讨论</h2><p>接下来我们来看看Python对于字符的处理. 我们之前在说整数对象的时候, 说Python会为小整数开个缓冲对象池. 那么对于简单的字符, Python自然也采取了类似的处理. 我们之前其实已经提到过的, 就是<code>characters</code>, 这个缓冲池的大小就是<code>UCHAR_MAX</code>所定义的大小.</p><p>所以说, 当我们进行一个char长度的字符串(其实就是字符)的创建的时候, 会经过下面的过程:</p><ul><li>申请内存创建PyStringObject</li><li>对这个PyStringObject进行Intern操作</li><li>缓存到characters缓冲池中</li></ul><p>OK, 这个缓冲池的设计要比整数对象好理解多了; 现在我们来探讨一个典型问题 — 字符串拼接</p><p>你一定知道这样的结论, <strong>尽量使用str.join函数而不要使用<code>+</code>运算符进行字符串拼接</strong>. 但是为什么呢? 到底底层是什么样子的呢? 现在我们就从源代码层面来看看:</p><p>如果使用<code>+</code>运算符的话, 调用的函数是这个:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">string_concat</span><span class="params">(<span class="keyword">register</span> PyStringObject *a, <span class="keyword">register</span> PyObject *bb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> Py_ssize_t size;</span><br><span class="line"><span class="keyword">register</span> PyStringObject *op;</span><br><span class="line"><span class="keyword">if</span> (!PyString_Check(bb)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_USING_UNICODE</span></span><br><span class="line"><span class="keyword">if</span> (PyUnicode_Check(bb))</span><br><span class="line">    <span class="keyword">return</span> PyUnicode_Concat((PyObject *)a, bb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">PyErr_Format(PyExc_TypeError,</span><br><span class="line">     <span class="string">&quot;cannot concatenate &#x27;str&#x27; and &#x27;%.200s&#x27; objects&quot;</span>,</span><br><span class="line">     bb-&gt;ob_type-&gt;tp_name);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> b ((PyStringObject *)bb)</span></span><br><span class="line"><span class="comment">/* Optimize cases with empty left or right operand */</span></span><br><span class="line"><span class="keyword">if</span> ((a-&gt;ob_size == <span class="number">0</span> || b-&gt;ob_size == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">    PyString_CheckExact(a) &amp;&amp; PyString_CheckExact(b)) &#123;</span><br><span class="line"><span class="keyword">if</span> (a-&gt;ob_size == <span class="number">0</span>) &#123;</span><br><span class="line">Py_INCREF(bb);</span><br><span class="line"><span class="keyword">return</span> bb;</span><br><span class="line">&#125;</span><br><span class="line">Py_INCREF(a);</span><br><span class="line"><span class="keyword">return</span> (PyObject *)a;</span><br><span class="line">&#125;</span><br><span class="line">size = a-&gt;ob_size + b-&gt;ob_size;</span><br><span class="line"><span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">PyErr_SetString(PyExc_OverflowError,</span><br><span class="line"><span class="string">&quot;strings are too large to concat&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Inline PyObject_NewVar */</span></span><br><span class="line">op = (PyStringObject *)PyObject_MALLOC(<span class="keyword">sizeof</span>(PyStringObject) + size);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">PyObject_INIT_VAR(op, &amp;PyString_Type, size);</span><br><span class="line">op-&gt;ob_shash = <span class="number">-1</span>;</span><br><span class="line">op-&gt;ob_sstate = SSTATE_NOT_INTERNED;</span><br><span class="line">Py_MEMCPY(op-&gt;ob_sval, a-&gt;ob_sval, a-&gt;ob_size);</span><br><span class="line">Py_MEMCPY(op-&gt;ob_sval + a-&gt;ob_size, b-&gt;ob_sval, b-&gt;ob_size);</span><br><span class="line">op-&gt;ob_sval[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> (PyObject *) op;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哦对了, 这个是作为序列的行为, 所以你会在序列行为方法里面找到, 如果你在数字里面找的话是找不到的.</p><p>那我们来分析下吧.</p><p>27行之前的代码可以忽略掉了, 就是在做类型检查, 以及如果出现空字符串的特殊case的处理.后面的就是一般情况下了, 我们先计算两个字符串加起来的总长度, 接着就根据这个长度进行内存申请, 然后进行常规的初始化和hash略过计算以及Intern状态初始化, 接着执行两次内存拷贝, 就像是先把前面的贴在前面紧接着把后面的那个贴在后面. 最后把<code>\0</code>补充上, 就可以返回新对象了.</p><p><strong>注意 这个过程是每两个String对象加起来. 如果是多个字符串, 这个过程就要进行多次.</strong> 那么我们的<code>join</code>函数在干什么呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">string_join</span><span class="params">(PyStringObject *self, PyObject *orig)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *sep = PyString_AS_STRING(self);</span><br><span class="line"><span class="type">const</span> Py_ssize_t seplen = PyString_GET_SIZE(self);</span><br><span class="line">PyObject *res = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line">Py_ssize_t seqlen = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> sz = <span class="number">0</span>;</span><br><span class="line">Py_ssize_t i;</span><br><span class="line">PyObject *seq, *item;</span><br><span class="line"></span><br><span class="line">seq = PySequence_Fast(orig, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (seq == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">seqlen = PySequence_Size(seq);</span><br><span class="line"><span class="keyword">if</span> (seqlen == <span class="number">0</span>) &#123;</span><br><span class="line">Py_DECREF(seq);</span><br><span class="line"><span class="keyword">return</span> PyString_FromString(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (seqlen == <span class="number">1</span>) &#123;</span><br><span class="line">item = PySequence_Fast_GET_ITEM(seq, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (PyString_CheckExact(item) || PyUnicode_CheckExact(item)) &#123;</span><br><span class="line">Py_INCREF(item);</span><br><span class="line">Py_DECREF(seq);</span><br><span class="line"><span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There are at least two things to join, or else we have a subclass</span></span><br><span class="line"><span class="comment"> * of the builtin types in the sequence.</span></span><br><span class="line"><span class="comment"> * Do a pre-pass to figure out the total amount of space we&#x27;ll</span></span><br><span class="line"><span class="comment"> * need (sz), see whether any argument is absurd, and defer to</span></span><br><span class="line"><span class="comment"> * the Unicode join if appropriate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; seqlen; i++) &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> old_sz = sz;</span><br><span class="line">item = PySequence_Fast_GET_ITEM(seq, i);</span><br><span class="line"><span class="keyword">if</span> (!PyString_Check(item))&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_USING_UNICODE</span></span><br><span class="line"><span class="keyword">if</span> (PyUnicode_Check(item)) &#123;</span><br><span class="line"><span class="comment">/* Defer to Unicode join.</span></span><br><span class="line"><span class="comment"> * CAUTION:  There&#x27;s no gurantee that the</span></span><br><span class="line"><span class="comment"> * original sequence can be iterated over</span></span><br><span class="line"><span class="comment"> * again, so we must pass seq here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PyObject *result;</span><br><span class="line">result = PyUnicode_Join((PyObject *)self, seq);</span><br><span class="line">Py_DECREF(seq);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">PyErr_Format(PyExc_TypeError,</span><br><span class="line">     <span class="string">&quot;sequence item %zd: expected string,&quot;</span></span><br><span class="line">     <span class="string">&quot; %.80s found&quot;</span>,</span><br><span class="line">     i, item-&gt;ob_type-&gt;tp_name);</span><br><span class="line">Py_DECREF(seq);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">sz += PyString_GET_SIZE(item);</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">sz += seplen;</span><br><span class="line"><span class="keyword">if</span> (sz &lt; old_sz || sz &gt; PY_SSIZE_T_MAX) &#123;</span><br><span class="line">PyErr_SetString(PyExc_OverflowError,</span><br><span class="line"><span class="string">&quot;join() result is too long for a Python string&quot;</span>);</span><br><span class="line">Py_DECREF(seq);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate result space. */</span></span><br><span class="line">res = PyString_FromStringAndSize((<span class="type">char</span>*)<span class="literal">NULL</span>, sz);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="literal">NULL</span>) &#123;</span><br><span class="line">Py_DECREF(seq);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Catenate everything. */</span></span><br><span class="line">p = PyString_AS_STRING(res);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; seqlen; ++i) &#123;</span><br><span class="line"><span class="type">size_t</span> n;</span><br><span class="line">item = PySequence_Fast_GET_ITEM(seq, i);</span><br><span class="line">n = PyString_GET_SIZE(item);</span><br><span class="line">Py_MEMCPY(p, PyString_AS_STRING(item), n);</span><br><span class="line">p += n;</span><br><span class="line"><span class="keyword">if</span> (i &lt; seqlen - <span class="number">1</span>) &#123;</span><br><span class="line">Py_MEMCPY(p, sep, seplen);</span><br><span class="line">p += seplen;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Py_DECREF(seq);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有点长哈, 不过没关系. 我们还是可以把我们讨论的重点关系不大的代码踢走. 其实核心部分就是再做这样的事, 先计算间隔(填充符)的长度, 接着遍历整个列表, 把每一个item的长度加上来, 当然还有填充了. 接着<strong>一次性</strong>的生成结果长度的内存空间.</p><p>接着再次遍历, 这一次就是把每一个字符串扔到他该在的位置上, 最后把seq的引用计数减掉让垃圾处理机制把它干掉就行了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Source Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python源码阅读-内建对象(2)</title>
      <link href="/2018/03/08/Python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%BB%BA%E5%AF%B9%E8%B1%A1-2/"/>
      <url>/2018/03/08/Python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%BB%BA%E5%AF%B9%E8%B1%A1-2/</url>
      
        <content type="html"><![CDATA[<p>这是《Python源码剖析 — 深度探索动态语言核心技术》的阅读记录.</p><p>Python中的整数对象 - <code>IntObject</code></p><span id="more"></span><h2 id="IntObject对象"><a href="#IntObject对象" class="headerlink" title="IntObject对象"></a>IntObject对象</h2><p>之前我们说过Python对象分成定长和不定长的两种, 其中不定长对象就是对定长对象的一个扩展. 除了这样划分, 我们还可以划分成可变对象和不可变对象, 本节的<code>IntObject</code>就是不可变对象.</p><p>在<code>intobject.h</code>中可以看到:</p><blockquote><p>PyIntObject represents a (long) integer.  This is an immutable object;<br>an integer cannot change its value after creation.</p></blockquote><p>一旦创建, 值就是不可变的.</p><p>但是我们知道啊, 一个简单的程序都会伴随的大量的整数的创建, 改变, 消灭. 要是这样看的话, 根据Python的引用计数的垃圾回收机制, 那系统的堆访问岂不是会访问炸了? 虽然你可能曾经了解过了, 对于这个, Python所使用的机制是使用一个整数对象池, 这个对象池其实就是用做缓冲之用. 这种缓冲池的应用, 除了<code>IntObject</code>, 在其他的不可变对象, 也是存在的.</p><p>还是来看代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyInt_Type = &#123;</span><br><span class="line">PyObject_HEAD_INIT(&amp;PyType_Type)</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="string">&quot;int&quot;</span>,</span><br><span class="line"><span class="keyword">sizeof</span>(PyIntObject),</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">(destructor)int_dealloc,<span class="comment">/* tp_dealloc */</span></span><br><span class="line">(printfunc)int_print,<span class="comment">/* tp_print */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_getattr */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_setattr */</span></span><br><span class="line">(cmpfunc)int_compare,<span class="comment">/* tp_compare */</span></span><br><span class="line">(reprfunc)int_repr,<span class="comment">/* tp_repr */</span></span><br><span class="line">&amp;int_as_number,<span class="comment">/* tp_as_number */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_as_sequence */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_as_mapping */</span></span><br><span class="line">(hashfunc)int_hash,<span class="comment">/* tp_hash */</span></span><br><span class="line">        <span class="number">0</span>,<span class="comment">/* tp_call */</span></span><br><span class="line">        (reprfunc)int_repr,<span class="comment">/* tp_str */</span></span><br><span class="line">PyObject_GenericGetAttr,<span class="comment">/* tp_getattro */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_setattro */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_as_buffer */</span></span><br><span class="line">Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |</span><br><span class="line">Py_TPFLAGS_BASETYPE,<span class="comment">/* tp_flags */</span></span><br><span class="line">int_doc,<span class="comment">/* tp_doc */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_traverse */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_clear */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_richcompare */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_iter */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_iternext */</span></span><br><span class="line">int_methods,<span class="comment">/* tp_methods */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_members */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_getset */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_base */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_dict */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_descr_get */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_descr_set */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_dictoffset */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_init */</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">/* tp_alloc */</span></span><br><span class="line">int_new,<span class="comment">/* tp_new */</span></span><br><span class="line">(freefunc)int_free,           <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们把所有没有定义的属性移走之后, 剩下的就是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyInt_Type = &#123;</span><br><span class="line">...</span><br><span class="line">(destructor)int_dealloc,<span class="comment">/* tp_dealloc */</span></span><br><span class="line">(printfunc)int_print,<span class="comment">/* tp_print */</span></span><br><span class="line">...</span><br><span class="line">(cmpfunc)int_compare,<span class="comment">/* tp_compare */</span></span><br><span class="line">(reprfunc)int_repr,<span class="comment">/* tp_repr */</span></span><br><span class="line">&amp;int_as_number,<span class="comment">/* tp_as_number */</span></span><br><span class="line">...</span><br><span class="line">(hashfunc)int_hash,<span class="comment">/* tp_hash */</span></span><br><span class="line">...</span><br><span class="line">    (reprfunc)int_repr,<span class="comment">/* tp_str */</span></span><br><span class="line">PyObject_GenericGetAttr,<span class="comment">/* tp_getattro */</span></span><br><span class="line">...</span><br><span class="line">Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |</span><br><span class="line">Py_TPFLAGS_BASETYPE,<span class="comment">/* tp_flags */</span></span><br><span class="line">int_doc,<span class="comment">/* tp_doc */</span></span><br><span class="line">...</span><br><span class="line">int_methods,<span class="comment">/* tp_methods */</span></span><br><span class="line">...</span><br><span class="line">int_new,<span class="comment">/* tp_new */</span></span><br><span class="line">(freefunc)int_free,           <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们先来看看是怎么比较两个<code>IntObject</code>的大小的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">int_compare</span><span class="params">(PyIntObject *v, PyIntObject *w)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">long</span> i = v-&gt;ob_ival;</span><br><span class="line"><span class="keyword">register</span> <span class="type">long</span> j = w-&gt;ob_ival;</span><br><span class="line"><span class="keyword">return</span> (i &lt; j) ? <span class="number">-1</span> : (i &gt; j) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是简单的比较两个long数值. 是吧, 其实也没那么难.</p><p>但是我们要关注的其实是这个: <code>&amp;int_as_number</code>. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyNumberMethods int_as_number = &#123;</span><br><span class="line">(binaryfunc)int_add,<span class="comment">/*nb_add*/</span></span><br><span class="line">(binaryfunc)int_sub,<span class="comment">/*nb_subtract*/</span></span><br><span class="line">(binaryfunc)int_mul,<span class="comment">/*nb_multiply*/</span></span><br><span class="line">(binaryfunc)int_classic_div, <span class="comment">/*nb_divide*/</span></span><br><span class="line">(binaryfunc)int_mod,<span class="comment">/*nb_remainder*/</span></span><br><span class="line">(binaryfunc)int_divmod,<span class="comment">/*nb_divmod*/</span></span><br><span class="line">(ternaryfunc)int_pow,<span class="comment">/*nb_power*/</span></span><br><span class="line">    ....(omitted)</span><br></pre></td></tr></table></figure><p>这些就是函数指针就是整数对象所支持的函数方法, 其实也没有把所有的函数都实现, 但大部分都实现的了, 我们还是随便挑一个来看:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">int_add</span><span class="params">(PyIntObject *v, PyIntObject *w)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">long</span> a, b, x;</span><br><span class="line">CONVERT_TO_LONG(v, a);</span><br><span class="line">CONVERT_TO_LONG(w, b);</span><br><span class="line">x = a + b;</span><br><span class="line"><span class="keyword">if</span> ((x^a) &gt;= <span class="number">0</span> || (x^b) &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> PyInt_FromLong(x);</span><br><span class="line"><span class="keyword">return</span> PyLong_Type.tp_as_number-&gt;nb_add((PyObject *)v, (PyObject *)w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是先规范类型接着进行关键的加法运算, 接着判断是否出现加法溢出, 如果没有直接返回新的IntObject, 如果溢出就使用LongObject了, 这个就先不考虑了.  有趣的是这个<code>CONVERT_TO_LONG</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONVERT_TO_LONG(obj, lng)\</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (PyInt_Check(obj)) &#123;\</span></span><br><span class="line"><span class="meta">lng = PyInt_AS_LONG(obj);\</span></span><br><span class="line"><span class="meta">&#125;\</span></span><br><span class="line"><span class="meta"><span class="keyword">else</span> &#123;\</span></span><br><span class="line"><span class="meta">Py_INCREF(Py_NotImplemented);\</span></span><br><span class="line"><span class="meta">return Py_NotImplemented;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>这是一个宏, 其中又使用了一个宏:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Macro, trading safety for speed */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyInt_AS_LONG(op) (((PyIntObject *)(op))-&gt;ob_ival)</span></span><br></pre></td></tr></table></figure><p>这个宏上面的注释说用安全交换速度. 安全指的就是类型安全啦, 而在<code>intobject.c</code>中, 还有一个函数版本的转换函数: <code>PyInt_AsLong</code>. 这个函数就考虑的较多了, 更加安全. 当然了 这样的代价就是速度.</p><p>稍微向<code>int_as_number</code>的上面看看:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PyDoc_STRVAR(int_doc,</span><br><span class="line"><span class="string">&quot;int(x[, base]) -&gt; integer\n\</span></span><br><span class="line"><span class="string">\n\</span></span><br><span class="line"><span class="string">Convert a string or number to an integer, if possible.  A floating point\n\</span></span><br><span class="line"><span class="string">argument will be truncated towards zero (this does not include a string\n\</span></span><br><span class="line"><span class="string">representation of a floating point number!)  When converting a string, use\n\</span></span><br><span class="line"><span class="string">the optional base.  It is an error to supply a base when converting a\n\</span></span><br><span class="line"><span class="string">non-string. If the argument is outside the integer range a long object\n\</span></span><br><span class="line"><span class="string">will be returned instead.&quot;</span>);</span><br></pre></td></tr></table></figure><p>嚯, 这不就是我们在Python Shell中看的文档吗! 所以现在我们就知道了, Python直接将她的文档集成在语言的实现中 关于这个宏的定义, 出现在整个Python实现的元头文件(Python.h):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Define macros for inline documentation. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyDoc_VAR(name) static char name[]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyDoc_STRVAR(name,str) PyDoc_VAR(name) = PyDoc_STR(str)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WITH_DOC_STRINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyDoc_STR(str) str</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyDoc_STR(str) <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="创建一个IntObject"><a href="#创建一个IntObject" class="headerlink" title="创建一个IntObject"></a>创建一个IntObject</h2><p>现在就让我们来了解下Python对整数对象设计的缓冲池是怎样的. 我们已经知道Python对小整数对象设计了一个对象池. 现在提出三个问题:</p><ul><li>什么样的整数属于小整数?</li><li>对象池怎么实现的?</li><li>大整数怎么办?</li></ul><p>接下来我们就来回答这些, 在正式开启之前, 我们还是先来了解下一个IntObject创建方式有哪些.</p><p>在头文件中, 我们可以找到函数声明:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PyAPI_FUNC(PyObject *) PyInt_FromString(<span class="type">char</span>*, <span class="type">char</span>**, <span class="type">int</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_USING_UNICODE</span></span><br><span class="line">PyAPI_FUNC(PyObject *) PyInt_FromUnicode(Py_UNICODE*, Py_ssize_t, <span class="type">int</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">PyAPI_FUNC(PyObject *) PyInt_FromLong(<span class="type">long</span>);</span><br><span class="line">PyAPI_FUNC(PyObject *) PyInt_FromSize_t(<span class="type">size_t</span>);</span><br><span class="line">PyAPI_FUNC(PyObject *) PyInt_FromSsize_t(Py_ssize_t);</span><br></pre></td></tr></table></figure><p>至于具体他们的实现 当然是可以在c文件中找到, 但是 只有了解到Python的整数对象在内存中的表现形式, 才可以去理解.</p><p>现在就来回答上面的三个问题, 首先第1问.</p><h3 id="小整数"><a href="#小整数" class="headerlink" title="小整数"></a>小整数</h3><p>什么样的整数才算小的? 这个当然是取决于使用场景. 在Python的世界中, 默认的小整数范围是从**<code>[-5, 257)</code>**的. 由于使用场景不同, 这个值是可以进行更改的, 在这里(intobject.c):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NSMALLPOSINTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLPOSINTS257</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NSMALLNEGINTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLNEGINTS5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NSMALLNEGINTS + NSMALLPOSINTS &gt; 0</span></span><br><span class="line"><span class="comment">/* References to small integers are saved in this array so that they</span></span><br><span class="line"><span class="comment">   can be shared.</span></span><br><span class="line"><span class="comment">   The integers that are saved are those in the range</span></span><br><span class="line"><span class="comment">   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> PyIntObject *small_ints[NSMALLNEGINTS + NSMALLPOSINTS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>也就是说, 你只要修改这两个宏所对应的值, 就可以实现自己定义小整数范围.  只要判断条件通过就会激活这个对象池, 也就是这个静态的<code>PyIntObject</code>数组.</p><h3 id="大整数"><a href="#大整数" class="headerlink" title="大整数"></a>大整数</h3><p>小整数的范围就这样了, 但是大整数不是说就不怎么使用了啊? 那怎么办? Python官方在空间和时间上做了平衡之后得到的解决方法是 - 提供一个单独的内存空间用来除了上面定义的小整数之外的整数使用. 这个内存空间就是一个新的结构, <code>_intblock</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_SIZE1000<span class="comment">/* 1K less typical malloc overhead */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BHEAD_SIZE8<span class="comment">/* Enough for a 64-bit pointer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_INTOBJECTS((BLOCK_SIZE - BHEAD_SIZE) / sizeof(PyIntObject))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> *<span class="title">next</span>;</span></span><br><span class="line">PyIntObject objects[N_INTOBJECTS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> <span class="title">PyIntBlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyIntBlock *block_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> PyIntObject *free_list = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><em>一个小疑问, 这里为啥不写在一起? 直接typedef不就行了? 可能只是代码风格问题吧</em></p><p>当然, 这么一个空间也是可以动态调整的, 只要修改之后重新编译一下就好了.</p><p>这就是装着整数对象的单向链表, 而<code>free_list</code>就是一开始指向这个链表表头的指针, 随着程序移动. 到了这里, 我们的这个小标题其实可以做个更改了, 它更应该叫做<strong>通用整数</strong>.</p><h3 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h3><p>行了, 我们现在就开始看创建函数吧:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line"><span class="title function_">PyInt_FromLong</span><span class="params">(<span class="type">long</span> ival)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> PyIntObject *v;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NSMALLNEGINTS + NSMALLPOSINTS &gt; 0</span></span><br><span class="line"><span class="keyword">if</span> (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) &#123;</span><br><span class="line">v = small_ints[ival + NSMALLNEGINTS];</span><br><span class="line">Py_INCREF(v);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line"><span class="keyword">if</span> (ival &gt;= <span class="number">0</span>)</span><br><span class="line">quick_int_allocs++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">quick_neg_int_allocs++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> (PyObject *) v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">#################我自己的分割线#####################<span class="meta">#</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (free_list == NULL) &#123;</span></span><br><span class="line"><span class="keyword">if</span> ((free_list = fill_free_list()) == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Inline PyObject_New */</span></span><br><span class="line">v = free_list;</span><br><span class="line">free_list = (PyIntObject *)v-&gt;ob_type;</span><br><span class="line">PyObject_INIT(v, &amp;PyInt_Type);</span><br><span class="line">v-&gt;ob_ival = ival;</span><br><span class="line"><span class="keyword">return</span> (PyObject *) v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来, 如果小整数的对象池被激活并且需要创建的整数对象就在对象池里面, 那么就会直接从那里面取出来用. 这就很简单了, 但是如果不是在里面或者对象池没有被激活, 那么就会走下面的函数过程了. 来分析下:</p><p>如果当前还没有分配, 就先创建我们的int block. 这个行为不仅出现在最一开始的<code>fill_free_list</code>调用上, 在所有的空闲内存(for intblock)没有的时候, free_list会重新变成NULL, 那个时候调用<code>fill_free_list</code>就又会进行分配了.</p><p>这个创建的过程是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyIntObject *</span><br><span class="line"><span class="title function_">fill_free_list</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">PyIntObject *p, *q;</span><br><span class="line"><span class="comment">/* Python&#x27;s object allocator isn&#x27;t appropriate for large blocks. */</span></span><br><span class="line">p = (PyIntObject *) PyMem_MALLOC(<span class="keyword">sizeof</span>(PyIntBlock));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> (PyIntObject *) PyErr_NoMemory();</span><br><span class="line">((PyIntBlock *)p)-&gt;next = block_list;</span><br><span class="line">block_list = (PyIntBlock *)p;</span><br><span class="line"><span class="comment">/* Link the int objects together, from rear to front, then return</span></span><br><span class="line"><span class="comment">   the address of the last int object in the block. */</span></span><br><span class="line">p = &amp;((PyIntBlock *)p)-&gt;objects[<span class="number">0</span>];</span><br><span class="line">q = p + N_INTOBJECTS;</span><br><span class="line"><span class="keyword">while</span> (--q &gt; p)</span><br><span class="line">q-&gt;ob_type = (<span class="keyword">struct</span> _typeobject *)(q<span class="number">-1</span>);</span><br><span class="line">q-&gt;ob_type = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> p + N_INTOBJECTS - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分配整个通用整数对象池的内存空间, 如果malloc失败, 报错处理. 如果malloc成功就可以继续了, 先忽略掉后面的那两行 我们来看注释下面的. 接下来, 我们把IntObject数组的第一个元素贴到这个内存区域的头部, 把另一个指针q调整到这个对象池的最末尾+1的位置, 此时p指针指向头部第一个元素(也就是objects[0]). Then, 开始从后向前的移动q指针, 每一次移动都把对象池后面的那个整数对象的ob_type指向它前一个整数对象的ob_type直到q指针和p指针碰面, 也就是同时指向首位. 接着将第一个整数对象的ob_type设置成NULL. 这样就算是完成了, 最后返回这个对象池的最后一个元素的内存地址.</p><p>看到这里, 你可能会觉得有点疑惑, 尤其是ob_type那里, 为什么要这么做呢? 别急, 让我们继续往下看, 你会发现这一段代码的巧妙之处.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Inline PyObject_New */</span></span><br><span class="line">v = free_list;</span><br><span class="line">free_list = (PyIntObject *)v-&gt;ob_type;</span><br><span class="line">PyObject_INIT(v, &amp;PyInt_Type);</span><br><span class="line">v-&gt;ob_ival = ival;</span><br><span class="line"><span class="keyword">return</span> (PyObject *) v;</span><br></pre></td></tr></table></figure><p>之前在说对象池的时候就介绍过了, free_list相当于是对象池的对象指针, 那么每一次返回一个整数, 我们都需要把这个指针进行移动. 那么如何进行移动呢? 看上面的代码就可以知道了: <strong>我们只需要把ob_type传递给free_list就行了.</strong> </p><p>怎么样 是不是十分巧妙 数组中的每一个元素通过这个ob_type属性就这样巧妙的串起来了!</p><p>接着我们想象一下, 这个对象池一直在被填充直到free_list指针指向了最前面 也就是刚刚的<code>object[0]</code>的位置. 这个地方的ob_type是NULL! 没错, 此时就认为是对象池满了, 那怎么办? 当然是重新激活一个新的通用整数对象池了.</p><p>那原来的对象池怎么处理呢? 这就是之前我们忽略过去的那两行:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((PyIntBlock *)p)-&gt;next = block_list;</span><br><span class="line">block_list = (PyIntBlock *)p;</span><br></pre></td></tr></table></figure><p>这就是在把原来的整数对象池连接到了新的对象池的后面.</p><h2 id="使用对象池"><a href="#使用对象池" class="headerlink" title="使用对象池"></a>使用对象池</h2><p>好了, 现在我们已经清楚整数对象是怎么被创造出来的. 接下来来考虑这么一个问题: 如果说现在有两个对象池, 第一个已经被填满了, 第二个尚有空间. 在这个时候第一个对象池有IntObject被删掉了, 也就是流出了一个空闲内存. 那么我该怎么知道并且在下一次创建的时候使用到这个空间呢? 我们来看看析构函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">int_dealloc</span><span class="params">(PyIntObject *v)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (PyInt_CheckExact(v)) &#123;</span><br><span class="line">v-&gt;ob_type = (<span class="keyword">struct</span> _typeobject *)free_list;</span><br><span class="line">free_list = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">v-&gt;ob_type-&gt;tp_free((PyObject *)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的判断宏其实就是在看传入的Object的ob_type是不是PyInt_Type, 先不管他. 来看后面, Python将这个被删除的对象连接到了由ob_type作为指针所连接的链表上.接着再把这个表示下一个空闲内存的指针移动到了这里. 就是十分的自然!</p><p>如果不是整数类型, 就会调用那个对象所指向的tp_free方法了.</p><h2 id="小整数对象池的初始化"><a href="#小整数对象池的初始化" class="headerlink" title="小整数对象池的初始化"></a>小整数对象池的初始化</h2><p>小整数对象池又是怎么被初始化的呢, 答案就在初始化函数中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_PyInt_Init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">PyIntObject *v;</span><br><span class="line"><span class="type">int</span> ival;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> NSMALLNEGINTS + NSMALLPOSINTS &gt; 0</span></span><br><span class="line"><span class="keyword">for</span> (ival = -NSMALLNEGINTS; ival &lt; NSMALLPOSINTS; ival++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (!free_list &amp;&amp; (free_list = fill_free_list()) == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* PyObject_New is inlined */</span></span><br><span class="line">v = free_list;</span><br><span class="line">free_list = (PyIntObject *)v-&gt;ob_type;</span><br><span class="line">PyObject_INIT(v, &amp;PyInt_Type);</span><br><span class="line">v-&gt;ob_ival = ival;</span><br><span class="line">small_ints[ival + NSMALLNEGINTS] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到基本过程和上面的创建通用整数对象池十分相像. 只不过这里是具体的数值了.</p><h2 id="Python整数对象结论测试"><a href="#Python整数对象结论测试" class="headerlink" title="Python整数对象结论测试"></a>Python整数对象结论测试</h2><p>学完了这一节, 到底是不是这样呢? 我们来实际上做个测试: 修改源代码重新编译, 看看到底是怎样的.</p><p>主要的修改目标就是打印函数, 输出更多信息来使得我们了解到底层:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = <span class="type">int</span>(<span class="number">-1234</span>)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">Address of <span class="number">-1234</span>: <span class="number">0x14f1408</span></span><br><span class="line">Address of free_list: <span class="number">0x14f1438</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; b = <span class="type">int</span>(<span class="number">-123</span>)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">Address of <span class="number">-123</span>: <span class="number">0x14f1438</span></span><br><span class="line">Address of free_list: <span class="number">0x14f1420</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; del b</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">Address of <span class="number">-1234</span>: <span class="number">0x14f1408</span></span><br><span class="line">Address of free_list: <span class="number">0x14f1438</span></span><br></pre></td></tr></table></figure><p>这就是我们修改源码编译之后的效果, 可以看到事实就是如此, b的内存位置就是a的free_list的位置, 而当我们删除b了之后, 空闲指针又重新指向了b缺失的位置.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Source Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python源码阅读—内建对象(1)</title>
      <link href="/2018/03/07/Python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%BB%BA%E5%AF%B9%E8%B1%A1-1/"/>
      <url>/2018/03/07/Python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%86%85%E5%BB%BA%E5%AF%B9%E8%B1%A1-1/</url>
      
        <content type="html"><![CDATA[<p>这是《Python源码剖析 — 深度探索动态语言核心技术》的阅读记录.</p><p>概述和内建对象的基石 - <code>PyObject</code></p><span id="more"></span><p>我自认为我是没有能力可以完整的阅读并且理解这本书的, 因此可能不会完全覆盖这本书的全部内容, 并且理解可能会有偏差或者错误. 不过还是尽力而为吧, 初步将本篇阅读记录划成这么几个部分:</p><ul><li>Python的内建对象:<ul><li>基石对象 — PyObject</li><li>整数</li><li>字符串</li><li>List</li><li>Dict</li><li>…</li></ul></li><li>Python运行机制 — 虚拟机初探</li><li>Python虚拟机控制流</li><li>Python虚拟机的函数机制</li><li>Python虚拟机的类机制</li><li>Python模块加载机制</li><li>Python多线程机制</li><li>Python内存管理机制</li></ul><p>后期在学习中再根据进度做修改. </p><p>当然源码是一定要下载下来的~我们来看下结构:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/python_src_tree.png" alt="python_src_tree.png"></p><p>其中, <code>Include</code>这样的命名大家都知道了, 是用来放头文件的. <code>Lib</code>就是我们熟悉的那些Python标准库的源码了, 他们都是使用Python写的, 另外一个目录: <code>Modules</code>同样也是放一些模块的, 只不过这里的都是使用C语言写的, 目的不言自明. <code>Parser</code>就是Python解释器中的词法分析和语法分析, 其中还有些自动生成Python语言的词法和语法分析器, 类似YACC.<code>Python</code>, 都用自己的名字来命名了, 这个目录就十分重要了, 包含了Python的编译器和执行引擎. 另外<code>PCbuild</code>和<code>PCbuild8</code>这两个玩意是VS的工程了, 由于我是在Mac上操作的, 所以就忽略掉了.</p><p>那就不说多了, 直接开始吧!</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>先来撇清楚一个概念, 我们都知道Python是个面向对象的编程语言, 而这里内建对象的<strong>对象</strong>. 和面向<strong>对象</strong>的<strong>对象</strong>是两个截然不同的概念. 在Python中, 存在许多类型, 例如上面列举的int, string, List, Dict等等. 这些都实现了<strong>类</strong>的功能, 有意思的是, 这些类型, 他们也是类; 即是说: 类型本身也是类. 除了这些内置的, 我们还可以使用<code>class A(object)</code>这样的语句进行自定类型的声明和创建相应的实例. 我们都知道Python是使用ANSI C实现的, 那么这些对象是怎么在C中表示的呢?</p><p>其实不仅仅是Python, 其他很多基于C实现的面向对象语言都是使用的结构体来存储一个类所包含的信息的. 也就是说, 所谓类, 也就无非是C中的结构体在堆上申请的一块内存. 在Python中, 对象的创建是按照固定的内存大小创建的. 但我们都知道我们是可以随意的给一个对象加上各种属性的, 这是怎么搞的? </p><p>其实是这样, 这些对象都在自己的固定内存中维护一个指向一个可变大小的内存区域的指针. 那你可能要问了, 为啥不直接制定可变大小的对象区域? 其实这个答案很简单, 如果是这样 那么连续创建的两个对象在前一个对象需要增加大小的时候, 第二个是需要移动的, 如果第二个后面还有其他的对象, 还需要继续移动下去, 为第一个对象提供内存空间, 这就很麻烦了.</p><h2 id="PyObject"><a href="#PyObject" class="headerlink" title="PyObject"></a>PyObject</h2><p>现在我们来看一下头文件中的<code>object.h</code>, 他定义了Python对象机制中的核心对象 — <strong><code>PyObject</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">PyObject_HEAD</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>而这其中, 藏了一个宏, 我们来看下具体内容是啥:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_HEAD\</span></span><br><span class="line"><span class="meta">_PyObject_HEAD_EXTRA\</span></span><br><span class="line"><span class="meta">Py_ssize_t ob_refcnt;\</span></span><br><span class="line"><span class="meta">struct _typeobject *ob_type;</span></span><br></pre></td></tr></table></figure><p>其中第一个宏, 向上追溯的话其实是一个DEBUG开关, 只有打开DEBUG的话才会有定义, 所以我们可以忽略掉. 而第二个<code>Py_ssize_t</code>, 是Python为了更好的支持64位机器, 在2.5版本中进行的修改, 原本是<code>int</code>, 这个<code>ssize_t</code>, 学习C语言的同学应该是知道的, 在32位的机器上仍然是原本的<code>int</code>, 而在64位的机器上等同于<code>long int</code>. </p><p>那么搞到最后, 我们的PyObject其实就是这个样子啦:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> ob_refcnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>猜猜看, 这个int变量是干什么用的? 看名字大概可以猜出来的. 对, 这就是基于引用计数机制的内存回收实现了, 这个变量就是用来记录引用的, 当该变量变成0的时候, 变量就会从堆中删除.</p><p>另外一个呢? 叫做ob_type, 嗯 没错. 这个东西就是用来定义类型信息的, 标明对象的类型是什么.</p><p>接着我们先切换到另一个头文件:<code>intobject.h</code>, 你会看到这个: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">long</span> ob_ival;</span><br><span class="line">&#125; PyIntObject;</span><br></pre></td></tr></table></figure><p>除了包含一个<code>PyObject</code>以外, 他还有一个<code>long</code>值, 这个变量就是int的值保存的地方.</p><p>除此之外, 还有很多<code>XXXobject.h</code>就定义了各种类型的Python类型对象, 各自包含了各自需要的属性.</p><p>int比较好办, 那么string呐. 我们知道int在C中是可以直接赋个值的, 但是string就不行了, 因为string在C中是数个char数组的表示, 那么维护一个字符串变量该怎么操作呢? 除此之外, 还有很多变量是类似string的, 他们都需要维护一个变长的属性, 例如List, Dict等等.</p><p>因此, 我们声明一个可变长Python对象: (回到<code>object.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">PyObject_VAR_HEAD</span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure><p>我们来看看这个宏展开是个啥:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_VAR_HEAD\</span></span><br><span class="line"><span class="meta">PyObject_HEAD\</span></span><br><span class="line"><span class="meta">Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span></span><br></pre></td></tr></table></figure><p>其实就是一个PyObject再加上一个<code>ob_size</code>, 也就相当于是一个拓展. 正如注释中说的那样, 这个变量是用来记录这个变长对象容纳了多少个元素, 即<strong>元素的个数</strong>.</p><p>现在你大概也就知道为啥我们把<code>PyObject</code>叫做对象中的基石了, 因为不论是什么类型的变量, 他们的开头都是一个<code>PyObject</code>头部, 也许你突然就知道了为啥宏叫做<code>_HEAD</code>了, 对呀. <em><em>在Python内部, 所有的对象都拥有PyObject对象头部, 也就是说, 我们可以使用PyObject</em> 指针引用任意对象.</em>*</p><p>OK, 让我们继续. 一个很重要的问题, 对象是用来创建的, 创建就必然是需要进行内存的申请的 显然这个申请的空间大小是一个重要的元信息, 那它保存在哪里呢? 回过头来看看, 我们有一个部分还没看:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> ob_refcnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>是了, 就是那个<code>_typeobject</code>. 这个东西的定义就可怕了, 是个85行的结构体, 截取一下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">PyObject_VAR_HEAD</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *tp_name; <span class="comment">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span></span><br><span class="line">Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line">...(omitted)</span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure><p>通过注释, 我们大概可以了解到, 这个对象包含了大量的函数指针, 就上面截取的部分, 我们可以看到定义了类型的名字, 可以打印来进行内部的调试等, 另外还有用于分配内存的内存大小数值和元素大小数值.</p><p>其实呢, 这个巨大的<code>PyTypeObject</code>就是Python中<strong>类</strong>的实现. 所以自然在这里就不展开了, 我们继续来看, 关于对象创建的概述.</p><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>当我们在Python中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">int</span>(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>这样便创建了一个值是10的int类型对象. 这个对象是怎么创建出来的?</p><p>实际上, Python有两种创建方式:</p><ul><li>C API - 范型API</li><li>类型相关API</li></ul><p>对于第一种C API, 可以使用在任何Python对象上, 你只要调用就好, 内部会自动选择相应的函数. 创建一个对象就形如这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyObject* intObj = PyObject_New(PyObject, &amp;PyInt_Type);</span><br></pre></td></tr></table></figure><p>而第二种就略有局限性, 面向<em>类型</em>. 所以就形如这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyObject* intObj = PyInt_FromLong(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><blockquote><p>定义是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyAPI_FUNC(PyObject *) PyInt_FromLong(<span class="type">long</span>);</span><br></pre></td></tr></table></figure></blockquote><p>但是我们知道如果是自己声明的类, 同样可以进行创建, Python不可能准备用于创建用户自定义类的上述那种API, 那是怎么做到创建的呢? </p><p>在之前那个<code>PyTypeObject</code>中, 定义了一个属性:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br></pre></td></tr></table></figure><p>这个base类指针就指向当前这个类型的创建时参考的基类. 下面我们把创建对象会用到一些东西筛选出来用来说明:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Py_ssize_t tp_basicsize</span><br><span class="line">newfunc tp_new;</span><br><span class="line">initproc tp_init;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br></pre></td></tr></table></figure><p>首先会调用<code>tp_new</code>这个创建函数, 如果是内置好的, 就会直接调用了. 但是如果是自定义, 这个函数指针实际上是NULL(在你也没有定义的时候), 这个时候就会去找<code>tp_base</code>指针所指向的那个基类的<code>tp_new</code>操作. 总之最后总会在<code>object</code>中找到这个, 接着根据<code>tp_basicsize</code>记录的信息进行内存的申请, 之后就会调用<code>tp_init</code>来初始化对象. </p><p>关于这里我是用JavaScript的原型链来理解的, 理念上大概是一样的.</p><h2 id="对象的行为-x2F-方法"><a href="#对象的行为-x2F-方法" class="headerlink" title="对象的行为&#x2F;方法"></a>对象的行为&#x2F;方法</h2><p>另外, 在Python中整数int对象是可以进行加减乘除的, 显然这个功能应该是定义在里面的, 具体的位置在哪里呢? 我们可以在<code>PyTypeObject</code>的定义中找到:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Method suites for standard classes */</span></span><br><span class="line"></span><br><span class="line">PyNumberMethods *tp_as_number;</span><br><span class="line">PySequenceMethods *tp_as_sequence;</span><br><span class="line">PyMappingMethods *tp_as_mapping;</span><br></pre></td></tr></table></figure><p>这是三个方法组, 要找计算相关, 想必是看第一个指针了, 我们来看下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* For numbers without flag bit Py_TPFLAGS_CHECKTYPES set, all</span></span><br><span class="line"><span class="comment">   arguments are guaranteed to be of the object&#x27;s type (modulo</span></span><br><span class="line"><span class="comment">   coercion hacks -- i.e. if the type&#x27;s coercion function</span></span><br><span class="line"><span class="comment">   returns other types, then these are allowed as well).  Numbers that</span></span><br><span class="line"><span class="comment">   have the Py_TPFLAGS_CHECKTYPES flag bit set should check *both*</span></span><br><span class="line"><span class="comment">   arguments for proper type and implement the necessary conversions</span></span><br><span class="line"><span class="comment">   in the slot functions themselves. */</span></span><br><span class="line"></span><br><span class="line">binaryfunc nb_add;</span><br><span class="line">binaryfunc nb_subtract;</span><br><span class="line">binaryfunc nb_multiply;</span><br><span class="line">binaryfunc nb_divide;</span><br><span class="line">...(omitted)</span><br><span class="line">&#125; PyNumberMethods;</span><br></pre></td></tr></table></figure><p>喏, 这就是基本的加减乘除函数了. 另外我们知道Python中有很多魔术方法, 例如以前说过的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="string">&#x27;key&#x27;</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;int&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> subscriptable</span><br></pre></td></tr></table></figure><p>报错说:<code>not subscriptable</code>. 这样的一个功能应该是字典才会具有的, 我们可以在<code>PyMappingMethods *tp_as_mapping</code>中找到.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">lenfunc mp_length;</span><br><span class="line">binaryfunc mp_subscript;</span><br><span class="line">objobjargproc mp_ass_subscript;</span><br><span class="line">&#125; PyMappingMethods;</span><br></pre></td></tr></table></figure><p>这里的<code>mp_subscript</code>就是了. 当我们使用<code>__getitem__</code>这个特殊的方法的时候, 其实就是在指定这个<code>mp_subscript</code>的行为. 也就是说, 为啥一个对象可以既具有数字还有字典的特性, 那就是因为Python在结构设计中同时加入了数字, 序列, 映射的方法组.</p><h2 id="类型-类型"><a href="#类型-类型" class="headerlink" title="类型:类型"></a>类型:类型</h2><p>我们知道在Python中有个有趣的东西:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span></span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">type</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>类型同样也有个类型, 这说明对象都有的类型本身也是一个对象, 其实刚刚在看<code>_typeobject</code>的时候就已经知道了, 因为他同样也有一个可变对象头部: <code>PyObject_VAR_HEAD</code>.</p><p>我们可以通过类型来描述一个对象是什么类型的, 但是如何描述一个类型的类型? 在<code>typeobject.c</code>中就可以找到了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyType_Type = &#123;</span><br><span class="line">PyObject_HEAD_INIT(&amp;PyType_Type)</span><br><span class="line"><span class="number">0</span>,<span class="comment">/* ob_size */</span></span><br><span class="line"><span class="string">&quot;type&quot;</span>,<span class="comment">/* tp_name */</span></span><br><span class="line"><span class="keyword">sizeof</span>(PyHeapTypeObject),<span class="comment">/* tp_basicsize */</span></span><br><span class="line"><span class="keyword">sizeof</span>(PyMemberDef),<span class="comment">/* tp_itemsize */</span></span><br><span class="line">...(omitted)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>喏, 这个<code>PyTypeType</code>就是Python类型机制的核心了, 而在上面的<code>&lt;type &#39;type&#39;&gt;</code>这个就是这个对象的C实现了. </p><p>还是用int来做例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyInt_Type = &#123;</span><br><span class="line">PyObject_HEAD_INIT(&amp;PyType_Type)</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="string">&quot;int&quot;</span>,</span><br><span class="line"><span class="keyword">sizeof</span>(PyIntObject),</span><br><span class="line">...(omitted)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们发现, 最前面还是那个宏, 看起来玄机在这里了, 来找一下定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_TRACE_REFS</span></span><br><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_HEAD_EXTRA\</span></span><br><span class="line"><span class="meta">struct _object *_ob_next;\</span></span><br><span class="line"><span class="meta">struct _object *_ob_prev;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_EXTRA_INIT 0, 0,</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_HEAD_EXTRA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_EXTRA_INIT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...(omitted)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_HEAD_INIT(type)\</span></span><br><span class="line"><span class="meta">_PyObject_EXTRA_INIT\</span></span><br><span class="line"><span class="meta">1, type,</span></span><br></pre></td></tr></table></figure><p>前面的<code>Py_TRACE_REFS</code>是只有在DEBUG调试的时候才会被设置的FLAG. 也就是说引用计数默认是1, 类型始终是type.</p><p>那么现在就可以来稍微完整的来说一下了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>一句简单的<code>int</code>, 实际上是在创建<code>PyIntObject</code>, 接着根据<code>PyIntObject</code>所指向的类型:<code>PyInt_Type</code> 而我们知道这些内置的类型都是指向Object的, 也就是这货:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyBaseObject_Type = &#123;</span><br><span class="line">PyObject_HEAD_INIT(&amp;PyType_Type)</span><br><span class="line"> <span class="number">0</span>,<span class="comment">/* ob_size */</span></span><br><span class="line"><span class="string">&quot;object&quot;</span>,<span class="comment">/* tp_name */</span></span><br><span class="line"><span class="keyword">sizeof</span>(PyObject),<span class="comment">/* tp_basicsize */</span></span><br><span class="line">    ...(omitted)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是仍然, 无论是Int还是Object, 最后始终都是回归到<code>PyType_Type</code>. 而<code>PyType_Type</code>的<code>ob_type</code>指针是指向自己的, 这就相当于是结束了指向过程.</p><p>我们一开始就说了, 所有的对象都是使用PyObject这个开头的, 也就是说, 一个PyObject类型的指针可以指向所有的对象, 但是去可以根据对象具体的属性来表现出不同的状态. 没错, 这就是多态性质的实现原理. 例如<code>Hash</code>函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span></span><br><span class="line"><span class="title function_">PyObject_Hash</span><span class="params">(PyObject *v)</span></span><br><span class="line">&#123;</span><br><span class="line">PyTypeObject *tp = v-&gt;ob_type;</span><br><span class="line"><span class="keyword">if</span> (tp-&gt;tp_hash != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> (*tp-&gt;tp_hash)(v);</span><br><span class="line"><span class="keyword">if</span> (tp-&gt;tp_compare == <span class="literal">NULL</span> &amp;&amp; RICHCOMPARE(tp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> _Py_HashPointer(v); <span class="comment">/* Use address as hash value */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* If there&#x27;s a cmp but no hash defined, the object can&#x27;t be hashed */</span></span><br><span class="line">PyErr_Format(PyExc_TypeError, <span class="string">&quot;unhashable type: &#x27;%.200s&#x27;&quot;</span>,</span><br><span class="line">     v-&gt;ob_type-&gt;tp_name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个函数, 在传入不同的PyObject的时候, 表现也不一样, 这就是基于前面的多态实现的. </p><p>顺便说一下, 我们知道Python的垃圾回收机制是基于引用计数的, 那么作为重要的核心对象 - 类型对象. 自然是像root in Linux一样, 是不受到这个规则约束的. 他永远不会被析构.</p><p>至于关于引用计数的相关, 我们可以在<code>object.h</code>中看到:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Py_INCREF(op) (\</span></span><br><span class="line"><span class="meta">_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA\</span></span><br><span class="line"><span class="meta">(op)-&gt;ob_refcnt++)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_DECREF(op)\</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA\</span></span><br><span class="line"><span class="meta">    --(op)-&gt;ob_refcnt != 0)\</span></span><br><span class="line"><span class="meta">_Py_CHECK_REFCNT(op)\</span></span><br><span class="line"><span class="meta"><span class="keyword">else</span>\</span></span><br><span class="line"><span class="meta">_Py_Dealloc((PyObject *)(op))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macros to use in case the object pointer may be NULL: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_XINCREF(op) <span class="keyword">if</span> ((op) == NULL) ; <span class="keyword">else</span> Py_INCREF(op)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_XDECREF(op) <span class="keyword">if</span> ((op) == NULL) ; <span class="keyword">else</span> Py_DECREF(op)</span></span><br></pre></td></tr></table></figure><p>一些增加计数, 减少计数的宏.</p><p>至此, Python内建对象的概述就这样了 下一节就来认真看看我们本节中拿来用例子的<code>IntObject</code>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Source Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络笔记存档</title>
      <link href="/2018/03/04/%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E5%AD%98%E6%A1%A3/"/>
      <url>/2018/03/04/%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E5%AD%98%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>好久没有更新了, 这只是个凑数的 ( 从而显得我十分勤快 滑稽)</p><p>这些笔记都来自 谢希仁 《计算机网络(第七版)》</p><span id="more"></span><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/IMG_1647.JPG" alt="数据链路层"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/IMG_1648.JPG" alt="网络层"></p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/IMG_1649.JPG" alt="网络层"></p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/IMG_1650.JPG" alt="网络层"></p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/IMG_1651.JPG" alt="传输层"></p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/IMG_1652.JPG" alt="传输层"></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/IMG_1653.JPG" alt="传输层"></p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/IMG_1654.JPG" alt="传输层"></p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/IMG_1655.JPG" alt="传输层"></p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/IMG_1656.JPG" alt="传输层"></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/IMG_1658.JPG" alt="应用层"></p><h2 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h2><p><a href="https://yaoxuannn.com/Network_Memo.pdf">PDF (7M)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite3与Python3</title>
      <link href="/2017/12/18/SQLite3%E4%B8%8EPython3/"/>
      <url>/2017/12/18/SQLite3%E4%B8%8EPython3/</url>
      
        <content type="html"><![CDATA[<p>SQLite是一个使用C语言编写的体积超小的嵌入式数据库, 一个数据库就是一个文件. 由于体积小并且迅速, 所以SQLite经常被嵌入到一些iOS或者Android的应用程序中. 这不, 在Python3的标准库中就嵌入了一个SQLite.</p><p>接下来我们就来说说这个小家伙以及怎么使用Python3的SQLite的标准库.</p><span id="more"></span><h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><p>很久之前我们就看过了Python3操作MySQL的操作, 现在SQLite和MySQL一样都是符合ACID的数据库, 但是稍微我们还是要了解一下他的. 来看看它有哪些神奇的特性和命令.</p><h3 id="SQLite的命令"><a href="#SQLite的命令" class="headerlink" title="SQLite的命令"></a>SQLite的命令</h3><p>SQLite提供了很多有用的命令, 这些命令都不使用分号<code>;</code>结尾, 却是使用.号<code>.</code>开头的.  我们来看一下都有哪些, 在shell的模式下, 使用<code>.help</code>命令就可以获得所有的SQLite命令.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; .help</span><br><span class="line">.auth ON|OFF           Show authorizer callbacks</span><br><span class="line">.backup ?DB? FILE      Backup DB (default &quot;main&quot;) to FILE</span><br><span class="line">.bail on|off           Stop after hitting an error.  Default OFF</span><br><span class="line">.binary on|off         Turn binary output on or off.  Default OFF</span><br><span class="line">.changes on|off        Show number of rows changed by SQL</span><br><span class="line">.check GLOB            Fail if output since .testcase does not match</span><br><span class="line">.clone NEWDB           Clone data into NEWDB from the existing database</span><br><span class="line">.databases             List names and files of attached databases</span><br><span class="line">.dbinfo ?DB?           Show status information about the database</span><br><span class="line">.dump ?TABLE? ...      Dump the database in an SQL text format</span><br><span class="line">                         If TABLE specified, only dump tables matching</span><br><span class="line">                         LIKE pattern TABLE.</span><br><span class="line">.echo on|off           Turn command echo on or off</span><br><span class="line">.eqp on|off|full       Enable or disable automatic EXPLAIN QUERY PLAN</span><br><span class="line">.exit                  Exit this program</span><br><span class="line">.explain ?on|off|auto? Turn EXPLAIN output mode on or off or to automatic</span><br><span class="line">.fullschema ?--indent? Show schema and the content of sqlite_stat tables</span><br><span class="line">.headers on|off        Turn display of headers on or off</span><br><span class="line">.help                  Show this message</span><br><span class="line">.import FILE TABLE     Import data from FILE into TABLE</span><br><span class="line">.imposter INDEX TABLE  Create imposter table TABLE on index INDEX</span><br><span class="line">.indexes ?TABLE?       Show names of all indexes</span><br><span class="line">                         If TABLE specified, only show indexes for tables</span><br><span class="line">                         matching LIKE pattern TABLE.</span><br><span class="line">.limit ?LIMIT? ?VAL?   Display or change the value of an SQLITE_LIMIT</span><br><span class="line">.log FILE|off          Turn logging on or off.  FILE can be stderr/stdout</span><br><span class="line">.mode MODE ?TABLE?     Set output mode where MODE is one of:</span><br><span class="line">                         ascii    Columns/rows delimited by 0x1F and 0x1E</span><br><span class="line">                         csv      Comma-separated values</span><br><span class="line">                         column   Left-aligned columns.  (See .width)</span><br><span class="line">                         html     HTML &lt;table&gt; code</span><br><span class="line">                         insert   SQL insert statements for TABLE</span><br><span class="line">                         line     One value per line</span><br><span class="line">                         list     Values delimited by .separator strings</span><br><span class="line">                         quote    Escape answers as for SQL</span><br><span class="line">                         tabs     Tab-separated values</span><br><span class="line">                         tcl      TCL list elements</span><br><span class="line">.nullvalue STRING      Use STRING in place of NULL values</span><br><span class="line">.once FILENAME         Output for the next SQL command only to FILENAME</span><br><span class="line">.open ?--new? ?FILE?   Close existing database and reopen FILE</span><br><span class="line">                         The --new starts with an empty file</span><br><span class="line">.output ?FILENAME?     Send output to FILENAME or stdout</span><br><span class="line">.print STRING...       Print literal STRING</span><br><span class="line">.prompt MAIN CONTINUE  Replace the standard prompts</span><br><span class="line">.quit                  Exit this program</span><br><span class="line">.read FILENAME         Execute SQL in FILENAME</span><br><span class="line">.restore ?DB? FILE     Restore content of DB (default &quot;main&quot;) from FILE</span><br><span class="line">.save FILE             Write in-memory database into FILE</span><br><span class="line">.scanstats on|off      Turn sqlite3_stmt_scanstatus() metrics on or off</span><br><span class="line">.schema ?PATTERN?      Show the CREATE statements matching PATTERN</span><br><span class="line">                          Add --indent for pretty-printing</span><br><span class="line">.separator COL ?ROW?   Change the column separator and optionally the row</span><br><span class="line">                         separator for both the output mode and .import</span><br><span class="line">.shell CMD ARGS...     Run CMD ARGS... in a system shell</span><br><span class="line">.show                  Show the current values for various settings</span><br><span class="line">.stats ?on|off?        Show stats or turn stats on or off</span><br><span class="line">.system CMD ARGS...    Run CMD ARGS... in a system shell</span><br><span class="line">.tables ?TABLE?        List names of tables</span><br><span class="line">                         If TABLE specified, only list tables matching</span><br><span class="line">                         LIKE pattern TABLE.</span><br><span class="line">.testcase NAME         Begin redirecting output to &#x27;testcase-out.txt&#x27;</span><br><span class="line">.timeout MS            Try opening locked tables for MS milliseconds</span><br><span class="line">.timer on|off          Turn SQL timer on or off</span><br><span class="line">.trace FILE|off        Output each SQL statement as it is run</span><br><span class="line">.vfsinfo ?AUX?         Information about the top-level VFS</span><br><span class="line">.vfslist               List all available VFSes</span><br><span class="line">.vfsname ?AUX?         Print the name of the VFS stack</span><br><span class="line">.width NUM1 NUM2 ...   Set column widths for &quot;column&quot; mode</span><br><span class="line">                         Negative values right-justify</span><br></pre></td></tr></table></figure><p>还是蛮多的, 不过常用的其实也就那些 我们来看一下, 关于输出(包括输出到标准输出的, 以及文件的)的:</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>.backup ?DB? FILE</td><td>备份 DB 数据库（默认是 “main”）到 FILE 文件</td></tr><tr><td>.dump ?TABLE?</td><td>以 SQL 文本格式转储数据库。如果指定了 TABLE 表，则只转储匹配 LIKE 模式的 TABLE 表</td></tr><tr><td>.header(s) ON OFF</td><td>开启或关闭头部显示。</td></tr><tr><td>.mode MODE</td><td>设置输出模式，MODE包括: ascii column csv html insert line list tabs tcl</td></tr><tr><td>.output FILENAME</td><td>发送输出到 FILENAME</td></tr><tr><td>.timer ON OFF</td><td>开启或者关闭定时器</td></tr><tr><td>.width NUM NUM</td><td>为column模式设置宽度.</td></tr><tr><td>.save FILENAME</td><td>将内存中的数据写入到文件( 其实还是.backup )</td></tr></tbody></table><p>接着是一些打开, 导入导出和列出类的:</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>.databases</td><td>列出数据库的名称及其所依附的文件</td></tr><tr><td>.import FILE TABLE</td><td>导入来自 FILE 文件的数据到 TABLE 表中</td></tr><tr><td>.indices ?TABLE?</td><td>显示所有索引的名称。如果指定了 TABLE 表，则只显示匹配 LIKE 模式的 TABLE 表的索引</td></tr><tr><td>.schema ?TABLE?</td><td>显示 CREATE 语句。如果指定了 TABLE 表，则只显示匹配 LIKE 模式的 TABLE 表。</td></tr><tr><td>.read FILENAME</td><td>执行 FILENAME 文件中的 SQL.</td></tr><tr><td>.open</td><td>打开一个数据库文件</td></tr><tr><td>.tables ?PATTERN?</td><td>列出匹配 LIKE 模式的表的名称</td></tr></tbody></table><p>退出可以使用<code>.quit</code>也可以使用<code>.exit</code>.</p><h3 id="数据库-x3D-文件"><a href="#数据库-x3D-文件" class="headerlink" title="数据库 &#x3D; 文件"></a>数据库 &#x3D; 文件</h3><p>由于SQLite不同于其他的关系型数据库, 它使用一个文件映射一个数据库的设计, 这就使得库级别的操作显得和其他的有点不一样.</p><p>例如, 创建数据库 其实就是打开文件, 而逻辑层面的数据库和物理层面的文件之间的连接就显得很重要了. 我们可以看到:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; .da</span><br><span class="line">seq  name             file</span><br><span class="line">---  ---------------  --------------------------</span><br><span class="line">0    main             /private/tmp/testdb</span><br></pre></td></tr></table></figure><p>这里main数据库就和对应的文件进行了连接. 对于SQLite来说, 数据库级别的操作, 最主要的就是这两个:</p><ul><li>ATTACH</li><li>DETACH</li></ul><p>我们刚刚说过了, 最重要的东西是<strong>连接</strong>, 那么就不存在删除数据库的操作了(因为就是一个文件, 实在不行你把文件删除就行了). </p><p>下面我们就来看看这两个数据库操作: </p><p><strong>附加</strong> </p><p>附加就是一个建立连接的过程, 我们可以再把已经建立连接的文件再和一个数据库进行连接, 也可以开新的文件.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; attach testdb as &quot;test&quot;;</span><br><span class="line">sqlite&gt; .databases</span><br><span class="line">seq  name             file</span><br><span class="line">---  ---------------  ----------------------------------------------------------</span><br><span class="line">0    main             /private/tmp/testdb</span><br><span class="line">2    test             /private/tmp/testdb</span><br></pre></td></tr></table></figure><p>但是main和temp数据库是不可以附加上去的, 因为他们已经在使用, 不仅如此, 你也不能分离他们.</p><p>如果是附加一个已经存在的数据库文件的话, 就相当于是添加了一个别名的感觉.</p><p><strong>分离</strong></p><p>所谓分离其实就是结束掉连接: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; .databases</span><br><span class="line">seq  name             file</span><br><span class="line">---  ---------------  ----------------------------------------------------------</span><br><span class="line">0    main             /private/tmp/testdb</span><br><span class="line">2    test             /private/tmp/testdb</span><br><span class="line">sqlite&gt; detach test;</span><br><span class="line">sqlite&gt; .data</span><br><span class="line">seq  name             file</span><br><span class="line">---  ---------------  ----------------------------------------------------------</span><br><span class="line">0    main             /private/tmp/testdb</span><br></pre></td></tr></table></figure><p>其实使用起来还是蛮简单的, 主要就是数据库变成了文件这一点一开始可能会有一点不适应.</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>再说到表操作之前, 我们先来说说SQLite中的数据类型.</p><h3 id="SQLite中的数据类型"><a href="#SQLite中的数据类型" class="headerlink" title="SQLite中的数据类型"></a>SQLite中的数据类型</h3><p>和其他很多的关系数据库不同, SQLite使用一个更加动态的数据类型系统, 一个数据使用多少空间和他本身的值相关, 而和容器的关系不大. SQLite一共提供了5中数据存储类:</p><ul><li>NULL: 就是一个NULL值</li><li>INTEGER: 一个带符号的整数, 根据值的大小可能是1, 2, 3, 4, 6, 8个字节的存储容量</li><li>REAL: 浮点型, 8字节的IEEE浮点数字</li><li>TEXT: 文本字符, 编码方式取决于数据库的编码(UTF-8, UTF-16BE 或者 UTF-16LE) <em>关于编码的相关可以查看我之前的文章 — <a href="https://yaoxuannn.com/2017/12/13/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/">字符编码笔记</a></em></li><li>BLOB: 是一个blob数据, 根据输入存储</li></ul><p>这些存储类就是SQLite最终存储的数据类型了. 除了这些数据存储类, sqlite还有一个叫做亲和类的存储概念. SQLite会根据数据的值来进行转换, 主要有这些类型:</p><ul><li>TEXT</li><li>NUMERIC</li><li>INTEGER</li><li>REAL</li><li>NONE</li></ul><p>转换规则是这样的: </p><p>TEXT会将数值型的数据转换成是文本数据, 根据数据类型对对应的亲和类型(这个对应表我们会在后面补充), SQLite引擎会进行相应的转换. 如果是NUMERIC, 那么SQLite就会尝试在不丢失信息的情况下将文本数据转换成为INTEGER或者REAL类型, 而INTEGER和REAL类型和NUMERIC的规则是一致的, 不同之处在于INTEGER在执行CAST表达式的时候有不同以及在REAL在转换的时候不会将”100.00”转换成为100. 如果是NONE就不做任何转换.</p><p>文本没有代码好懂啊…来转换一下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEXT: int -&gt; string</span><br><span class="line">NUMERIC: try &#123; string -&gt; integer/real &#125; except &#123; keep(string) &#125;</span><br><span class="line">NONE: None</span><br><span class="line">INTEGER: NUMERIC_INTEGER()</span><br><span class="line">REAL: NUMERIC_REAL()</span><br></pre></td></tr></table></figure><p>那么到底哪些类型的亲和类型是什么呢 我们来看这个表:</p><table><thead><tr><th>数据类型</th><th>亲和类型</th></tr></thead><tbody><tr><td>INT  INTEGER  TINYINT  SMALLINT  MEDIUMINT  BIGINT  UNSIGNED BIG  INT  INT2  INT8</td><td>INTEGER</td></tr><tr><td>CHARACTER(20)  VARCHAR(255)  VARYING CHARACTER(255)  NCHAR(55)  NATIVE CHARACTER(70)  NVARCHAR(100)  TEXT  BLOB</td><td>TEXT</td></tr><tr><td>BLOB 或者是  (不指定)</td><td>NONE</td></tr><tr><td>REAL DOUBLE  DOUBLE PRECISION  FLOAT</td><td>REAL</td></tr><tr><td>NUMERIC  DECIMAL(10,5)  BOOLEAN  DATE  DATETIME</td><td>NUMERIC</td></tr></tbody></table><p>举个小栗子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; create table type (</span><br><span class="line">   ...&gt; id int,</span><br><span class="line">   ...&gt; name int</span><br><span class="line">   ...&gt; );</span><br><span class="line">sqlite&gt; insert into type values(&quot;jus&quot;, &quot;jus&quot;);</span><br><span class="line"># 没有报错</span><br><span class="line">sqlite&gt; select * from type;</span><br><span class="line">id          name</span><br><span class="line">----------  ----------</span><br><span class="line">jus         jus</span><br><span class="line"># 这根本就不是INT!!!</span><br></pre></td></tr></table></figure><p>这里我们的SQLite在尝试转换成INTEGER或者REAL的过程中失败了, 所以就变成了TEXT存储类了.</p><p>这就是说 我们所制定的类型可能并不会按照按照制定的所存储, 这就要求我们在插入表的时候要仔细的过滤数据了.</p><p>简单了解之后我们就可以开始尝试表级别的操作了.</p><h3 id="创建-删除"><a href="#创建-删除" class="headerlink" title="创建 删除"></a>创建 删除</h3><p>创建表的语法基本和你了解到的是一个样子的, 也没什么好说的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; create table if not exists student(</span><br><span class="line">   ...&gt; id int primary key not null,</span><br><span class="line">   ...&gt; name text not null,</span><br><span class="line">   ...&gt; age int not null,</span><br><span class="line">   ...&gt; active int(1) not null</span><br><span class="line">   ...&gt; );</span><br><span class="line">sqlite&gt; .schema student</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">id int primary key not null,</span><br><span class="line">name text not null,</span><br><span class="line">age int not null,</span><br><span class="line">active int(1) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>使用<code>.schema</code>命令来查看表的结构.</p><p>删除表的话, 就直接drop掉就可以了. 但是我们如果想要保留表结构只是清空数据的话, 在MySQL中是使用的<code>truncate</code>, 但是在SQLite中, 是没有这个的实现的. 如果想只清空数据的话, 就还是只能使用<code>delete</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; delete from TABLE;</span><br></pre></td></tr></table></figure><p>另外, 当我们需要修改已经常见的表的时候, 在SQLite中是不能修改已经存在的表结构的, 你只可以进行名称修改和添加:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; alter table test rename to testdb;</span><br><span class="line">sqlite&gt; alter table testdb add column age int not null default 0;</span><br></pre></td></tr></table></figure><h3 id="插入-查找-修改-删除"><a href="#插入-查找-修改-删除" class="headerlink" title="插入 查找 修改 删除"></a>插入 查找 修改 删除</h3><p>插入, 查找, 修改和删除的语法基本符合通常的SQL语句语法, 故不再赘述. 但是在这一部分我们补充下面两个小技巧: 我们知道一些命令只能在sqlite提示符中使用, 如果是在编程环境中怎么或者例如<code>.schema</code>的结果呢?</p><p>事实上, 在sqlite中维护着一个叫做<code>sqlite_master</code>的表, 这个表中涵盖了当前数据库中的索引, 表的信息.</p><p>来看一下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; .mode csv</span><br><span class="line">sqlite&gt; select * from sqlite_master;</span><br><span class="line">type,name,tbl_name,rootpage,sql</span><br><span class="line">table,student,student,4,&quot;CREATE TABLE student(</span><br><span class="line">id int primary key not null,</span><br><span class="line">name text not null,</span><br><span class="line">age int not null,</span><br><span class="line">active int(1) not null</span><br><span class="line">)&quot;</span><br><span class="line">index,sqlite_autoindex_student_1,student,5,</span><br><span class="line">table,testdb,testdb,2,&quot;CREATE TABLE &quot;&quot;testdb&quot;&quot; (</span><br><span class="line">id integer primary key autoincrement not null,</span><br><span class="line">name text not null</span><br><span class="line">, age int not null default 0)&quot;</span><br><span class="line">table,sqlite_sequence,sqlite_sequence,3,&quot;CREATE TABLE sqlite_sequence(name,seq)&quot;</span><br></pre></td></tr></table></figure><p>这就是说, 我们在以后想要获得表的结构的话, 通过在这个表中进行查找操作就可以了.</p><p>另外, 在上面的这个表中我们看到了一个叫做<code>sqlite_seq</code>的表, 当你启动了<code>autoincrement</code>的时候, 这个表就会被自动创建然后记录当前这个递增的大小, 这也就是说你是可以通过操作这个表的数据值来控制自增量的.</p><p>假设我们的表中数据LIKE THIS:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select * from test;</span><br><span class="line">id          name        age</span><br><span class="line">----------  ----------  ----------</span><br><span class="line">1           Justin      20</span><br><span class="line">2           Selena      23</span><br><span class="line">3           Selena      21</span><br></pre></td></tr></table></figure><p>有两个重复记录, 那么这个时候我们可以使用**<code>distinct</code>**关键字, 来进行去重:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select distinct name from test;</span><br><span class="line">name</span><br><span class="line">----------</span><br><span class="line">Justin</span><br><span class="line">Selena</span><br></pre></td></tr></table></figure><h3 id="子句"><a href="#子句" class="headerlink" title="子句"></a>子句</h3><p>SQLite的子句包括下面这些:</p><ul><li>WHERE子句</li><li>LIKE子句</li><li>GLOB子句</li><li>LIMIT子句</li><li>ORDER BY子句</li><li>GROUP BY子句</li><li>HAVING子句</li></ul><p>其中我们只说一下GLOB子句, 其他的都和基础SQL一样的使用.</p><p>GLOB说来也很简单, 基本上和LIKE子句一样的使用方法, 不同的是, 通配符变成了遵循UNIX规范的<code>*</code>和<code>?</code>来分别表示<code>%</code>和<code>_</code>, 也就是0,1或者多个数字或者字符以及单一的数字或者字符.</p><h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><p>SQLite同样可以使用子查询, 连接和合并</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是为了更快的检索数据的特殊的表. 创建索引语法是这样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure><p>但是如果你的表太小或者是一个需要频繁更新和插入的表的话就不建议使用索引了, 因为这样反而会使得它降低性能.</p><p>我们向student表中插入了10000条数据来检测索引带来的性能提升:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select id from student order by id desc limit 1;</span><br><span class="line">id</span><br><span class="line">----------</span><br><span class="line">10001</span><br><span class="line">sqlite&gt; .timer on</span><br><span class="line">sqlite&gt; select * from student where name = &quot;James Frost&quot;;</span><br><span class="line">id          name                  age         gender      active</span><br><span class="line">----------  --------------------  ----------  ----------  ----------</span><br><span class="line">5020        James Frost           16          1           1</span><br><span class="line">Run Time: real 0.001 user 0.000907 sys 0.000081</span><br><span class="line">sqlite&gt; .timer off</span><br><span class="line">sqlite&gt; create index student_index on student(name);</span><br><span class="line">sqlite&gt; .timer on</span><br><span class="line">sqlite&gt; select * from student (indexed by student_index) where name = &quot;James Frost&quot;;</span><br><span class="line">id          name                  age         gender      active</span><br><span class="line">----------  --------------------  ----------  ----------  ----------</span><br><span class="line">5020        James Frost           16          1           1</span><br><span class="line">Run Time: real 0.000 user 0.000094 sys 0.000051</span><br></pre></td></tr></table></figure><p>可以看出来性能确实是有个不小的提升. 可以在查询语句中加入<code>indexed by</code>来说明使用哪一个索引来进行查询.</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>同样我们之前就说过SQLite是符合ACID的, 所以自然是支持事务的, 控制事务的三个语句:</p><ul><li>BEGIN TRANSACTION(BEGIN)</li><li>ROLLBACK</li><li>COMMIT(END TRANSACTION)</li></ul><h2 id="Python的SQLITE库"><a href="#Python的SQLITE库" class="headerlink" title="Python的SQLITE库"></a>Python的SQLITE库</h2><p>Python的sqlite库是从Python2.5之后的版本就有了, 在整套API中, 我们主要关注的就是两个对象: Connection和Cursor.</p><h3 id="模块-sqlite3"><a href="#模块-sqlite3" class="headerlink" title="模块 sqlite3"></a>模块 sqlite3</h3><p>首先, 我们还是从模块入手, sqlite3模块提供的使用率最高的方法就是<code>connect</code>, 其实这个方法就是返回一个Connection对象, 通过在这个方法中传递参数来控制一些连接的全局属性, 例如: 是否开启自动commit模式, 是否使用url进行连接, 连接超时时长等等.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">db = sqlite3.connect(<span class="string">&#x27;file:path/to/database?mode=ro&#x27;</span>, uri=<span class="literal">True</span>, isolation_level=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>这样就可以指明文件路径, 如果想要在<strong>内存</strong>中进行写入操作的话, 打开<code>:memory:</code>就可以了. 另外Connection对象有一个控制事务的属性是一个叫做隔离等级的属性: <code>isolation_level</code>, 当他设置成为None的时候就表明是自动提交的模式, 其余都需要使用者手动的执行commit操作. 默认情况下, 在执行一个DML语句的时候就会默认打开一个事务.</p><p>另外, 在3.6之后的版本 之后可以通过访问Connection的只读bool属性<code>in_transaction</code>来获得当前的事务状态.</p><p>接下里我们还要说一下Python中的数据类型和SQLite中的数据类型的互相转化:</p><table><thead><tr><th>Python type</th><th>SQLite type</th></tr></thead><tbody><tr><td><code>None</code></td><td><code>NULL</code></td></tr><tr><td><code>int</code></td><td><code>INTEGER</code></td></tr><tr><td><code>float</code></td><td><code>REAL</code></td></tr><tr><td><code>str</code></td><td><code>TEXT</code></td></tr><tr><td><code>bytes</code></td><td><code>BLOB</code></td></tr></tbody></table><p>如果是从SQLite到Python是这样的:</p><table><thead><tr><th>SQLite type</th><th>Python type</th></tr></thead><tbody><tr><td><code>NULL</code></td><td><code>None</code></td></tr><tr><td><code>INTEGER</code></td><td><code>int</code></td></tr><tr><td><code>REAL</code></td><td><code>float</code></td></tr><tr><td><code>TEXT</code></td><td>depends on <code>text_factory</code>, <code>str</code> by default</td></tr><tr><td><code>BLOB</code></td><td><code>bytes</code></td></tr></tbody></table><h3 id="类-Connection"><a href="#类-Connection" class="headerlink" title="类 Connection"></a>类 Connection</h3><p>除了上面提到的几个属性, Connection还可以使用<code>total_changes</code>来获得从连接打开到调用为止被操作的总行数. 回到上面说的事务, 事务管理的任务都在Connection这对象身上, 通过下面两个(基本和SQL保持一致的):</p><ul><li>commit()</li><li>rollback()</li></ul><p>而当不需要使用的时候别忘记关闭连接, 使用<code>close()</code>, 如果在非自动提交的模式下使用了close()而没有commit的, 之前的修改会丢失的, 这点要注意.</p><p>通过这个Connection对象 我们还可以获得当前数据库的dump信息, 直接使用connection.iterdump方法就可以返回一个迭代器, 通过迭代就可以获得在shell中使用<code>.dump</code>一样的原始SQL信息.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">&#x27;existing_db.db&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dump.sql&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> con.iterdump():</span><br><span class="line">        f.write(<span class="string">&#x27;%s\n&#x27;</span> % line)</span><br></pre></td></tr></table></figure><p>和数据库交互的总重要的一步就是进行SQL语句的执行了.</p><p>我们可以直接使用Connection对象执行 但是这实际上调用的还是下面说的Cursor对象的执行方法, (官方文档是这么说的: 不标准的快捷方式 - nonstandard shortcut )和其他很多DBAPI一样, 包含着这些:</p><ul><li>execute: 执行一个SQL语句, 可以使用占位符(包括?形式和:name命名形式)</li><li>executemany: 执行几个相同但是参数不一样的SQL语句, 通过传递生成器来进行迭代的执行</li><li>executescript: 直接像在执行rawSQL一样, 传递SQL脚本, 直接执行多条SQL语句</li></ul><p>代码表示我们在后面的Cursor对象中再说.</p><p>那么怎么拿到一个Cursor对象, 就使用Connection的cursor方法就可以了.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cur = conn.cursor()</span><br></pre></td></tr></table></figure><h3 id="类-Cursor"><a href="#类-Cursor" class="headerlink" title="类 Cursor"></a>类 Cursor</h3><p>Cursor对象无非就是做两个事情, 执行SQL和取得结果集. 先来看看Connection真正调用的三个执行方法是怎么样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">&quot;:memory:&quot;</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">&quot;create table people (name_last, age)&quot;</span>)</span><br><span class="line"></span><br><span class="line">who = <span class="string">&quot;Yeltsin&quot;</span></span><br><span class="line">age = <span class="number">72</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is the qmark style:</span></span><br><span class="line">cur.execute(<span class="string">&quot;insert into people values (?, ?)&quot;</span>, (who, age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># And this is the named style:</span></span><br><span class="line">cur.execute(<span class="string">&quot;select * from people where name_last=:who and age=:age&quot;</span>, &#123;<span class="string">&quot;who&quot;</span>: who, <span class="string">&quot;age&quot;</span>: age&#125;)</span><br></pre></td></tr></table></figure><p>而execute方法只可以执行单独的一条SQL语句. 假设一个场景是需要插入多条数据, 那么我们就可以考虑使用excutemany这个函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">char_generator</span>():</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> string.ascii_lowercase:</span><br><span class="line">        <span class="keyword">yield</span> (c,)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">&quot;:memory:&quot;</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">&quot;create table characters(c)&quot;</span>)</span><br><span class="line"></span><br><span class="line">cur.executemany(<span class="string">&quot;insert into characters(c) values (?)&quot;</span>, char_generator())</span><br></pre></td></tr></table></figure><p>最后一种执行方法, 就是直接将sql脚本传入的形式, 文档依然将这种声明成是不标准的简便方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">&quot;:memory:&quot;</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.executescript(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    create table person(</span></span><br><span class="line"><span class="string">        firstname,</span></span><br><span class="line"><span class="string">        lastname,</span></span><br><span class="line"><span class="string">        age</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    create table book(</span></span><br><span class="line"><span class="string">        title,</span></span><br><span class="line"><span class="string">        author,</span></span><br><span class="line"><span class="string">        published</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    insert into book(title, author, published)</span></span><br><span class="line"><span class="string">    values (</span></span><br><span class="line"><span class="string">        &#x27;Dirk Gently&#x27;&#x27;s Holistic Detective Agency&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;Douglas Adams&#x27;,</span></span><br><span class="line"><span class="string">        1987</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>那么, 好了 现在我能够像数据库传递SQL了, 那么获取结果呢, 同样也有三种方式:</p><ul><li>fetchone: 获取一个结果(一个row), 如果没有结果了就会返回None</li><li>fetchmany: 抓取size个结果, size的大小取决于调用时传递的参数, 或者是cursor对象的<code>arraysize</code>属性, 如果没有数据就返回一个空的列表</li><li>fetchall: 获取所有的结果集</li></ul><p>再说一下Cursor的关闭问题, 关闭的好处在于: 释放资源, 将这个游标标记成是不可用的, 这样当我们尝试使用的时候就可以通过错误捕获来增强程序的健壮性. 反正就是关闭了吧.</p><p>之前说了可以听过cursor对象的arraysize属性来设置抓取的数量(虽然我觉得修改这个值并不如在fetchmany的参数中传递更好), 那么Cursor对象还有那些属性呢?</p><ul><li>rowcount<ul><li>这个属性尽管sqlite3模块有实现, 但是在原生的数据库中却没有很好的实现, 导致这个值的获取变得奇奇怪怪的 在3.6.5的版本前, 如果执行了<code>DELECT from table</code>这样的不带条件的 rowcount就会被设置成0</li></ul></li><li>lastrowid<ul><li>只读属性, 返回最后操作的行的rowid, 只有在执行了INSERT和REPLACE并且是使用的execute函数才会被设置, 并且对REPLACE的支持实在3.6的版本中加入的.</li></ul></li><li>connection<ul><li>就是返回拿到这个cursor的connection是哪一个connection</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> SQLite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符编码笔记</title>
      <link href="/2017/12/13/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/12/13/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>想来想去终于决定写一个关于计算机字符编码的笔记了 ( 应该说终于愿意去学了..) , 原本的目的只是搞清楚Unicode的, 考虑到字符编码问题是一个有趣, 在开发中经常会遇到并且稍微有点麻烦和棘手的问题, 但是在网络上却很难找到将这个说的比较细致和成体系的文章, 所以我决定倾尽精力去写这篇笔记, 我会尽量的去查资料和参考他人的文章和博客, 将关于计算机编码的问题捣鼓清楚.</p><p>在笔记的后半部分, 我也会针对Python3的Unicode做一些说明, 并且当说到Unicode的时候, 我会尝试说明一些关于UTF-8 with BOM在Linux&#x2F;Unix内核中的一些矛盾.</p><p><strong>关于我搜寻和参考的资料, 都会贴在文章的最后.</strong></p><blockquote><p>这个世界上没有纯文本, 如果你想要读出它, 就要知道它的编码. </p></blockquote><span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>首先我们要说明一些关于字符编码的基本概念, 有了这些概念的理解阅读后面的内容才不费劲~. 由于我默认将文章的受众定位成了有计算机科学基础的学生, 所以最基本的概念就直接一笔带过了.</p><h3 id="位"><a href="#位" class="headerlink" title="位"></a>位</h3><p>就是我们熟知的比特(Bit), 也是二进制位, 因此有0和1两个值. Bit是<code>Binary digit</code>的缩写.</p><p>是计算机用来表示信息的最小单位.</p><h3 id="字节-字-字长"><a href="#字节-字-字长" class="headerlink" title="字节, 字, 字长"></a>字节, 字, 字长</h3><p>将一连串的比特组合在一起, 就构成了<strong>位串</strong>. 由于一个位的表示能力有限, 所以我们更多的情况下使用的是<strong>特定长度的</strong>位串来表示信息. 为什么说是特定长度呢? 标准, 标准, 标准! 我们制定几种不同长度的位串, 来表示不同的信息, 比如说有:</p><ul><li>半字节(nibble, 使用<strong>4个比特</strong>, 我反正是没见过的..)</li><li>字节(byte, 使用<strong>8个比特</strong>, 是现代个人计算机的最小的存取和寻址单位)</li><li>字(WORD, 视具体操作系统位数决定字节数* 下面补充说明)</li><li>双字(DWORD, 视具体操作系统位数决定字节数)</li><li>四字(QWORD, 视具体操作系统的位数决定字节数)</li></ul><blockquote><p>补充一点, 关于字节的位数, 一般说来都是8个bit, 但是这也只是一个标准制定的而已, 其实过去也有非8位的字节标准. 在一些严谨的计算机文献中, 会使用八位组(Octet)来代替字节.</p></blockquote><p>刚刚就说了, 一个位的表示能力有限, 所以我们想到使用字节, 而对于最小单位的字节来说, 仍然不能充分发挥计算机的运算能力, 所以对于计算机来说, 更高效处理的单位长度其实是<strong>字</strong>的长度, 也就是<strong>字长</strong>. 这也就是上面说的视具体操作系统位数决定的. 其实这样说不精确, 甚至说不是很对. 因为字长实际上是<strong>由CPU对外的总线宽度决定</strong>的, 它决定了CPU一次处理的数据的实际比特位.</p><p>所以, 64位的CPU可以使用32位的操作系统, 但是这样不会发挥出它应有的性能.</p><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>字符集, 其实就是一堆字符的集合, 包括各种文字, 数字, 字母, 音标, 标点符号, 图形等等. 将这些字符进行编号放在一起形成的序列, 就是字符集 (Charset) .</p><p>常见的字符集有</p><ul><li>ASCII</li><li>ISO8859-? 系列</li><li>GB(GB2312, GBK, GB18030)系列</li><li>BIG5</li><li>Unicode</li></ul><p>只有字符集没有什么卵用.</p><h3 id="编码-amp-解码"><a href="#编码-amp-解码" class="headerlink" title="编码&amp;解码"></a>编码&amp;解码</h3><p>这个很好理解了,就是将信息从一种格式转换成为另外一种格式.</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>编码, 刚刚说了, 就是格式之间的转换, 而计算机中的字符编码, 就是将字符转换(或者说映射)成为二进制数的过程. 这样, 我们就可以在计算机中方便的表示, 存储, 处理, 以及在网络中传输字符信息了.</p><p>这也是一种抽象.</p><h3 id="代码页"><a href="#代码页" class="headerlink" title="代码页"></a>代码页</h3><p>代码页 (code page), 真的是一个很迷的概念.主要是来源于IBM的字符数据表示体系结构. 经常是被理解成是字符集的别称, 但这是不对的. 维基百科给出的概念是:</p><blockquote><p>In <a href="https://en.wikipedia.org/wiki/Computing">computing</a>, a <strong>code page</strong> is a table of values that describes the character set used for <a href="https://en.wikipedia.org/wiki/Character_encoding">encoding</a> a particular set of <a href="https://en.wikipedia.org/wiki/Character_(computing)">characters</a>, usually combined with a number of <a href="https://en.wikipedia.org/wiki/Control_character">control characters</a>.</p></blockquote><p>大体翻译过来就是说是一个描述字符集的值表, 用于编码一组特定的字符(包含一些控制字符). 这么看来还真的就是字符集的意思. </p><p>但是仔细看一下, 它是在<strong>描述</strong>字符集, 就是说根据具体的情况, 代码页可能会对字符集做一定的扩展, 在早期计算机还没有出现图形界面的时候, IBM称呼BIOS所支持的字符集位代码页, 而由于该代码页是烧录在显卡上的, 所以也被称为是OEM代码页.</p><p>正因为此, 每个厂商有自己的代码页, 所以代码页也叫做”内码表”. 当我们想要知道一个二进制字节是什么字符的时候, 就要去根据系统设置的代码页去<strong>查表</strong>. 所以, 只有在操作系统的层面上, 我们才说代码页这个概念.</p><h3 id="字符编码模型"><a href="#字符编码模型" class="headerlink" title="字符编码模型"></a>字符编码模型</h3><p>这是一个极其重要的概念了, 模型的设计直接反应编码系统的组成结构和相关性. 例如, 在ASCII为代表的<strong>简单字符编码模型</strong>中, 刚刚所说的<strong>字符集</strong>和<strong>字符编码</strong>就是一个玩意, 没有什么区分.</p><p>而在我们后面将要隆重介绍的Unicode和UCS(通用字符集)中, 这个模型将会稍显复杂, 因为他会考虑很多内容.</p><blockquote><p>UCS其实就是ISO&#x2F;IEC 10646标准, 全称是通用字符集. 和Unicode字符集保持同步和一致. 实际上这个标准就是Unicode联盟和ISO&#x2F;IEC共同制定的. 因此UCS的具体实现就是Unicode的具体实现, 即UTF-8, UTF-16, UTF-32.</p></blockquote><p>在<a href="http://www.unicode.org/reports/tr17/">Unicode技术报告#17</a>中, 描述了Unicode的字符编码模型. 报告中阐述和引入了巨多名词和概念, 我们慢慢展开.</p><p>先来说一下字符编码模型考虑的内容</p><ul><li>有哪些字符</li><li>字符编号是什么</li><li>如何将编号映射成逻辑序列, 即<strong>码元序列</strong></li><li>如何将码元序列转换成物理层面的字节流</li><li>在一些特殊或者复杂环境中, 如何将字节序列进行适应性的处理</li></ul><p>仔细思考一下, 就不难发现, <strong>现代字符编码模型</strong>和过去的简单字符编码模型不同的地方就是它更关注: <strong>通用</strong>, <strong>不同编码方式</strong> 这两点. 类似我们的<strong>解耦</strong>, 现代字符编码模型将字符集和字符编码方式进行了解耦, 使得更容易扩展, 更加通用, 一套字符集, 我们可以不同的编码方式进行处理. 也就是字符集和字符编码实现是一对多的形式.</p><p>根据上面所说的考虑内容, Unicode字符编码模型是这样分层(分级别)的:</p><ul><li><strong>级别一 抽象字符表ACR(Abstract Character Repertoire)：</strong>明确字符的范围(即确定支持哪些字符)</li><li><strong>级别二 编号字符集CCS(Coded Character Set)：</strong>用数字编号表示字符(即用数字给抽象字符表ACR中的字符进行编号)</li><li><strong>级别三 字符编码方式CEF(Character Encoding Form)：</strong>将字符编号编码为逻辑上的码元序列(即逻辑字符编码)</li><li><strong>级别四 字符编码模式CES(Character Encoding Scheme)：</strong>将逻辑上的码元序列映射为物理上的字节序列(即物理字符编码)</li></ul><blockquote><p>说一下, 这里知乎作者Jacky lin的文章中, 说是5层, 但是我看根据UTR中的说法, Unicode字符编码模型应该是四个级别, J所说的第五个层次TES, 应该只能算作是一个重要的概念.</p><p>报告的原文(第7版)摘几段:</p><p>The <strong>four</strong> levels of the Unicode Character Encoding Model can be summarized as:…</p><p><strong>In addition to the four individual levels</strong>, there are two other useful <strong>concepts</strong>:…<strong>TES</strong></p><p>However, <strong>four</strong> levels need to be defined to adequately cover the distinctions required for the Unicode character encoding model. </p><p>感觉无论怎么看, TES都不是算是模型的层次…</p></blockquote><p>现在我们慢慢展开说一下这四个等级.</p><h4 id="1-抽象字符表-ACR"><a href="#1-抽象字符表-ACR" class="headerlink" title="1. 抽象字符表 ACR"></a>1. 抽象字符表 ACR</h4><p>在这里, 我们通过定义<strong>抽象字符</strong>的无序集合来确定字符的范围. 字符表可以是<strong>封闭</strong>的, 也就是在制定时就决定了, 典型的例子是ASCII以及ISO8859系列, 而Unicode为了达到通用的目的, 提出设计<strong>开放</strong>的字符表, 也就是说, 我们可以随时添加新的字符到表中.</p><p>这里我们所说的抽象字符是不具有的<strong>字形</strong>的, 所以才说是抽象的.</p><p>稍稍总结一下ACR的三个特点: <strong>无序</strong>, <strong>封闭和开放</strong>, <strong>字符不具有具体的字形</strong>.</p><h4 id="2-编号字符集-CCS"><a href="#2-编号字符集-CCS" class="headerlink" title="2. 编号字符集 CCS"></a>2. 编号字符集 CCS</h4><p>一个编号字符集定义成是从上面的抽象字符集合到非负整数集合的映射. 这些整数不一定要连续, 我们把定义了整数的抽象字符的这个位置(想象一个表格的单元格)称为<strong>码点(code point)</strong>(暂时存个疑问), 所以这样就形成了一个<strong>编号空间(Code space, 也可以叫做码点空间)</strong>. 一个存在上限的有多种方式描述的非负整数范围. 例如, 我们可以通过一对非负整数: GB2312的汉字编号空间就是94 x 94. 也可以直接使用一个非负整数: ISO-8859-1的256, 或者也可以使用字符的存储单元尺寸, 比如ISO-8859-1的范围是2^8 &#x3D; 256.</p><p>回到上面的码点这个概念, 并不是说码点的数量和抽象字符的数量(编号)是一致的, 这是因为在我们的CCS中, 还存在了非字符码点和保留码点. 不仅如此, 多个码点可能还对应这同一个字符, 比如: <code>\u51c9</code>与<code>\uf979</code>的这两个码点是同一个字符“凉”(<strong>注意, 这并不是汉字liáng, 这是一个字符.</strong>). 更多的例子可以在这里查询到: <a href="http://www.unicode.org/charts/PDF/UF900.pdf">CJK兼容-F900-F921</a>. 还有, 例如上面的注音符号, 他就是由多个码点表示的, 由基本符号的a加上注音符号.</p><p>最后稍微注意, 这里我们说的是<strong>编号</strong>, 而非编码. 这是两个截然不同的概念. 其实这一步和计算机丁点关系都没有, 因为没有涉及到下面说的字符编码方式和字符编码模式.</p><h4 id="3-字符编码方式-CEF"><a href="#3-字符编码方式-CEF" class="headerlink" title="3. 字符编码方式 CEF"></a>3. 字符编码方式 CEF</h4><p>从这一步开始, 就开始进入到计算机的表示了. 我们知道常见的数据类型也就是单,双,四字节, 分别能够表示256, 65536, 4294967296个码位. 那么现在这一级别需要考虑的就是如何将无限扩展的(上面说了Unicode是开放的ACR, 也许现在就有新的emoji表情被添加到字符表中), 不仅如此, 过去诞生且正在使用的那些字符编码我们是抛弃不用(显然不可能), 还是向下兼容, 如果是兼容的话, 是完全兼容, 还是部分兼容 ?</p><p>这些问题的解决方案 就是我们的CEF了. CEF将字符集中字符的码点值转换成有限长度的编码值, 这个编码值就是之前提到的<strong>码元序列</strong>, 码元(code unit)就是这个序列的单位名称. 这里的转换也还没有这么具体, 只不过是逻辑上的方式.</p><p>对于ASCII这样的简单字符编码模型, 字符编码其实就是字符编号, 而它的编码方式就是简单的直接映射. 对于Unicode这样的现代复杂字符编码模型, 字符编号和字符编码并不一定相等, 而映射方式也不一定是直接的.</p><p>到这里你就更加清楚了, CEF其实就是字符编码标准的实现方式. 例如: UTF(Unicode&#x2F;UCS Transformation Format)-8, UTF-16, UTF-32就是Unicode的编码方式.</p><p>上面的说法似曾相识吧! 很多博客, 网站都是这么说的. 其实也勉勉强强可以这么理解.</p><h4 id="4-字符编码模式-CES"><a href="#4-字符编码模式-CES" class="headerlink" title="4. 字符编码模式 CES"></a>4. 字符编码模式 CES</h4><p>终于到了这一级别, 在这一个级别, 就会将物理层面上的具体实现纳入考虑. 包括对各种不同的硬件平台与操作系统设计上的差异考虑. 在这一层, 码元序列就会转换成为<strong>字节序列</strong>. </p><p>由于太具体了, 所以我们就把这一部分的内容丢到后面吧.</p><h2 id="历史的车轮-—-编码史"><a href="#历史的车轮-—-编码史" class="headerlink" title="历史的车轮 — 编码史"></a>历史的车轮 — 编码史</h2><p>最早最早, 我们的计算机仅仅是用来做数字运算的, 所以没有编码这回事. 后来人们发现可以使用计算机做更多的事情, 所以首先就是要想办法编码字符, 也就是使用二进制来表示字符. 所以在1963和1964年由IBM为大型机操作系统开发制定了一个编码标准, 类似ASCII, 叫做扩展二进制编码的十进制交换码 — (EBCDIC). 但是这个编码标准设计的太糟糕了, 就连英文字母都不是连续的, 造成很多困扰和麻烦. 所以在后来出现了个人计算机的时候, 大家都使用了ASCII编码标准.</p><blockquote><p> 顺便说个笑话:</p><p> 教授：”所以美国政府去IBM提出了一个加密标准，他们想出了…”</p><p> 学生：“EBCDIC！”</p></blockquote><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>事实上, ASCII的标准制定工作比上面的EBCDIC的制定还要早一点, 它的第一版和EBCDIC同一年出版, 接着在1967年进行重大更新, 目前最新的修订发生在1986年. </p><p>ASCII的全称是美国信息交换标准码, 可以说是最基础、最重要、应用最广泛一个字符编码方案. 所以现在大部分的通行编码方案都兼容ASCII编码. 至于EBCDIC, 你看我连个二级标题都没给他…应该是凉了.</p><p>接下来我们来简单说说ASCII编码方案吧, 它使用八个比特位, 但实际上只有7位在用, 因为规定最高位始终置零(在某些场合用来做奇偶校验). 这样就应该可以表示128个字符, 对于English来说, 完全够了.</p><ul><li>0-31 都是控制字符和不可打印字符</li><li>32-126 是可打印可显示的字符 - 数字, 字母, 符号.</li><li>127 控制字符DEL.</li></ul><p>这里的转换很简单, 不存在什么编码算法, 也没有什么码元序列和字节序列的转换. ASCII字符集标准就是ISO&#x2F;IEC-646标准.</p><h3 id="EASCII"><a href="#EASCII" class="headerlink" title="EASCII"></a>EASCII</h3><p>渐渐地, 计算机从美国流传到了欧洲各国, 由于各种欧洲国家的语言中存在英语中不存在的一些字符, 例如一些衍生的拉丁字符, 所以他们就想要使用ASCII标准没有使用的最高位. 可是这样终究还是有限的 表示的字符数量变成了256个.</p><p>多出来的那128个就是最高位置1的结果, 表示出来的符号包括表格符号、计算符号、希腊字母和特殊的拉丁符号.</p><p>不过这一个标准也很少使用了, 这是因为后来ISO制定和发布了著名的ISO-8859系列标准.</p><h3 id="ISO-8859"><a href="#ISO-8859" class="headerlink" title="ISO-8859"></a>ISO-8859</h3><p>这个和上面的两个就不一样了, ISO&#x2F;IEC-8859是一套标准, 一共包含从ISO-8859-1到ISO-8859-16, 除去已经被废弃的ISO-8859-12, 总共有15个标准. 这些标准涵盖了欧洲各国使用的字符, 甚至包括一些外来语. 而且每一个具体的标准都只是用了扩展ASCII的<code>0xA0-0xFF</code>, 即160-255这96个编码.</p><h3 id="GB系列"><a href="#GB系列" class="headerlink" title="GB系列"></a>GB系列</h3><p>渐渐地, 计算机发展到了亚洲地区. 于是自然, 需要想个办法来表示这些亚洲地区文字. 以汉字为例, 汉字的表示和英语不同, 鉴于其表示的特殊性和复杂性, 中国相关部门设计了GB系列编码, GB就是国标的汉语拼音的缩写, 国家标准的意思. GB的编码规则向下兼容ASCII, 如果一个字节是0-127, 那么就字节的含义还是ASCII制定的含义. 但是当出现ASCII单字节和GB多字节混合使用的时候, 就要先将GB编码的最高位设置成1, 以防止冲突.</p><p>对了, <strong>凡是GB系列的编码, 都是符合ISO-8859标准的.</strong></p><h4 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h4><p>这是最早的中文国家标准, 诞生于1980年. 目前GB2312仍然被广泛使用, 它一共包括了6763个汉字, 还收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符.GB2312-1980通过 这6763个汉字已经足够日常使用. GB2312的编码方法和EASCII类似, 都是使用ASCII不使用的最高位, 它规定所有的汉字必须大于127, 然后<strong>必须</strong>和原本ASCII一起结合使用, 正因为此, 他不能兼容EASCII的扩展部分. </p><p>由于当时的计算机仍然是终端和文本模式的时代, 而每个字符都是一个小点阵, 占8个像素宽, 而汉字并不适合这样展示, 所以又出现了全角和半角的区别.  全角的标点符号和半角的标点符号在中文输入法下是一样的, 而在英文输入法中, 半角标点的宽度就是全角的一半大小. 关于全角半角, 我们在后面还会提到.</p><h4 id="GB13000-x2F-GBK"><a href="#GB13000-x2F-GBK" class="headerlink" title="GB13000 &#x2F; GBK"></a>GB13000 &#x2F; GBK</h4><p>1993年, Unicode1.1标准(ISO&#x2F;IEC 10646.1:1993)第一部分发布(关于Unicode和ISO10646的相关, 我们在后面会说), 随后中国就发布了新的国标: GB13000-1993. 这一个标准和前面的那两个相一致. 后来在2010年, 发布了替代标准GB13000-2010, 和ISO&#x2F;IEC10646:2003保持一致</p><blockquote><p>不知道为什么, 感觉GB13000的资料好少. 搜不到什么相关信息</p></blockquote><p>由于汉字的数量实在是太庞大了, 而一些人名, 古汉语, 生僻字都没有被包括在GB2312标准中, 所以同一年(1993), GBK, (即国家标准扩展的汉语拼音缩写)被定义, 尽管这个时候这并不是官方的标准, 但微软已经在Windows 95中实现了GBK的代码页(cp936). 由于Windows的广泛使用, 使得GBK成为了当时的事实标准. 于是, 在1995年, 国家发布GBK1.0规范, 对于cp936做了轻微的扩展. 但是目前的状态是, cp936就等同于GBK, 尽管GBK比cp936多出95个字符. IANA也把cp936作为GBK的别名.</p><p>GBK不同于GB2312, 汉字依然从127开始, 但是不要求使用原来的ASCII的比特位, 这样才能表示更多的字符. </p><h4 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h4><p>这个是目前最新的国家标准, 制定于2000年, 以取代GBK.在2005年, 国家对GB18030进行了补充, 在GBK的基础上增加了CJK.</p><p>微软也对GB18030制定了代码页(CP54936), 不过, 在(Windows7)系统的设置中并不能找到这个代码页, 只不过在Command Line中可以进行切换.</p><h4 id="GB系列的编码方式-以GB2312为例"><a href="#GB系列的编码方式-以GB2312为例" class="headerlink" title="GB系列的编码方式(以GB2312为例)"></a>GB系列的编码方式(以GB2312为例)</h4><p>首先我们明确, GB系列的汉字编码都是双字节编码, 也就是1个汉字相当于是2个英文字符.</p><p>接下来, 开始了. </p><p><strong>高迷预警.</strong></p><p>我们要先来说几个概念, 再逐渐引入这些概念的过程中, 就来解释GB2312的编码.</p><ul><li>区位码</li><li>国标码</li><li>内码</li><li>外码</li><li>字形码</li></ul><p>就直接从上到下说吧, 对于GB2312字符集, 我们把它分成94个区, 至于为什么是94个区, 是因为GB2312是7位双字节编码, 也就是<code>128*128</code>, 由于需要避开ASCII的控制字符和空格(至于为什么后面再解释), 所以就只剩下了<code>94*94</code>了. 结合上面所说的概念 — 编号空间, 码点空间. 这个<code>94*94</code>的空间就是GB2312的编号空间了. 这样就可以通过一个横坐标一个纵坐标来唯一定位一个点, 这个横坐标就是<strong>区</strong>, 纵坐标就是<strong>位</strong>, 加在一起就是<strong>区位码</strong>. 这样说有点抽象. 其实, 高位字节就是这里的横坐标, 而低位字节就是纵坐标. 举个例子, 汉字字符: “万”  它的区位码是45 82, 所以45就代表高字节, 而82就代表低位字节.</p><p>在GB2312中, 是这样分区的:</p><p>1）01~09区(682个): 特殊符号、数字、英文字符、制表符等，包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母等在内的682个全角字符.</p><p>2）16~55区(3755个): 常用汉字(也称一级汉字), 按拼音排序</p><p>3）56~87区(3008个): 非常用汉字(也称二级汉字), 按部首&#x2F;笔画排序</p><p>剩余的都是空区, 留作扩展.</p><p>你可能这个时候做了实验, 但是发现”万”好像并不是<code>45 82</code>, 而是<code>cd f2</code>. 这个继续往下看就知道了.</p><p>接下来回到刚刚说的, GB2312避开了ASCII的控制字符以及空格(从0H-20H, 0-32), 所以就导致整个编码开始于21H, 也就是10进制的33. </p><blockquote><p>注意: 这里我为了简便, 略了另外一个字节, 正确的表示应该是(21H,21H)这样的, 因为双字节编码, 下同. </p></blockquote><p>因此, 我们的编码就必须向后移动20H的位置(至于为什么要避开, 后面再说, 先别急), 即范围是从(21H, 21H)到(7E, 7E). 这样就进行了区位码到<strong>国际码</strong>的转换. 国际码又称作交换码, 那么还是用之前的”万”来做例子, “万”的国际码就是<code>77 114</code>, 也就是十六进制的<code>4d 72</code>.  </p><p>说道这里, 可能敏感的你已经发现了, 第一: <code>4d 72</code>和之前的<code>cd f2</code>还是不对应, 第二: <code>77 114</code>和ASCII已存在的字符发生了冲突, 例如, 这就和<code>M, r</code>发生了冲突. 所以这个国际码并不能直接拿来用. 那咋办? 我们之前就说过了, 把ASCII没使用的最高位置1就行了, 即<strong>加上128, 80H</strong>. </p><blockquote><p>值得一提的是, 这里的加上80H, 是微软提出的解决方案. 本质上他是改变了GB2312的编码方式.  GB2312真正的规范编码, 到这里就结束了 — 国际码就是GB2312的规范编码.</p></blockquote><p>这个时候”万”的GB2312编码就变成了之前的<code>cd f2</code>了, 我们把这个最后的编码叫做<strong>内码</strong>. 意思就是计算机内部使用的编码.</p><p>现在我们就解释了GB系列的编码方式, 接下来就来回答一下上面的疑问: 为什么要避开那20H个. 说来也简单, 其实上面也已经解释了, 原本我们可以直接保留所有的ASCII编码的, 也就是直接从128开始编码, 但是考虑到全角和半角的英文字符, 所以GB2312就把这些重新进行编码加入到双字节编码的队列中. 而不可打印的控制字符, 也就是那20H, 32个就进行了保留, 这就是避开的原因.</p><p>最后我们再把外码和字形码说一下: 最简单的理解方式, 我们再输入的时候使用的代码就是<strong>外码</strong>, 例如五笔输入法, 拼音输入法这些, 规定的代码就是外码. 而<strong>字形码</strong>可以简单的理解成是我们的字体, 也即是具体的<strong>显示形状</strong>.</p><h3 id="Big5"><a href="#Big5" class="headerlink" title="Big5"></a>Big5</h3><p>1984年策划制定, 主要用于台湾地区, 用于繁体汉字的显示, 可以读作大五码. 名字来自于台湾五家公司的财团.</p><p>这个就不展开说了, 他定义的汉字数量真的好少…好像还需要各种奇怪的扩展才能满足需要.</p><blockquote><p><strong>ANSI</strong></p><p>我们在这里扩展一下, 说一下这个玩意. 在我们使用Windows的notepad的时候, 默认的存储编码方式是<code>ANSI</code>. 这是个什么玩意? 严格的说, 这不是一个编码方式, ANSI是美国国家标准协会的缩写. 它规定了各国字符编码对应的代码页标准, 例如我们在之前的概念中说过, GB系列的编码方式在Win中就是CP943, 当然这是指简体中文系统, 而繁体中文的Windows中, ANSI就对应Big5的代码页, 这就是说, 即使你们都是ANSI编码, 但不一定你们对应的文件编码是一致的.</p><p>所以, 你也可以不严谨的说: ANSI是系统的默认编码方式, 不过这个也是会依靠系统语言而改变的. 另外只有Windows中存在这样的说法.</p></blockquote><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>由于各个国家, 各个地区的编码方式都不一样, 于是我们自然就会想, 如果能有一种编码标准能够收纳全世界的语言, 每一个字符全球都使用那独一无二的一个就好了. 于是, 统一编码标准 - Unicode就横空出世了.</p><p>Unicode到底代表什么, 根据不同的上下文环境, 代指不同的东西. 不过很多的时候都会发生概念的误用.  如果说直接定义Unicode的话, 他应该是个<strong>编码标准</strong>. 而在这个标准定义的字符集, 就是Unicode字符集. 接下就可能引起大家困扰的Unicode标准和ISO&#x2F;IEC-10646标准, 我们来理一下他们的关系.</p><p>最初最初, 在1989年ISO策划搞一个通用字符集, 并且这个通用字符集就在1990年出版了, 这就是ISO10646的最早版本, 但是这个标准和现在的ISO10646存在明显的不一样. 而在同一年, Unicode也是存在的,只不过尚未正式出版. 而软件公司拒绝接受ISO复杂的设定和限制, 要求一些国家机构进行投票反对. 所以ISO的制定者们意识到, 需要和Unicode进行协商统一. 后来Unicode联盟和国际标准化组织就在1991年联合开发并且发布了Unicode1.0.0标准, 最初的标准中并不包含中文, 接着在次年定义了2w余个CJK中日韩表意字符(1.0.1), 到这里Unicode标准和UCS标准并没有严格意义上的对应. 而到了1993年, Unicode1.1标准发布并且和ISO&#x2F;IEC-10646-1:1993保持了基本的一致, 而到了Unicode2.0发布的时候, 它的字符名称和代码点已经和ISO&#x2F;IEC-10646:1993的前七个修订版完全匹配. 至此之后, Unicode标准和ISO&#x2F;IEC-10646标准拥有近乎是一样的字符集, 并且大致同步. 今年(2017年)6月份, Unicode第10个版本发布, 相对应的ISO-10646:2017.</p><p>目前, 两个项目都依然存在, 但统一码联盟Unicode Consortium和ISO&#x2F;IEC都同意保持两者的通用字符集相互兼容, 并共同调整未来的任何扩展.</p><p>接下来我们就来解释下, Unicode的字符集是怎么涵盖目前人类所使用的全部字符的.</p><p>Unicode一共设置了17个平面(Plane), 从0-16, 每一个平面上都有2^16&#x3D;65536个码点, 而我们平常所使用的大部分字符, 都定义在第0个平面上, 这个平面叫做: BMP(Basic Multilingual Plane, 基本多语言平面). 除此之外, 其他的16个平面都是增补性质的, 一些象形文字, 埃及文字, 表情游戏符号(emoji, 扑克牌, 麻将, 多米诺骨牌)等等. </p><p>在基本的BMP平面中, 有一部分用来是保留的范围, 这一段从0xE000~0xF8FF, 一共有6400个码点, 被定义成是私有区(Private use zone).</p><table><thead><tr><th>Plane 0</th><th>Plane 1</th><th>Plane 2</th><th>Planes 3–13</th><th>Plane 14</th><th>Planes 15–16</th></tr></thead><tbody><tr><td>0000–FFFF</td><td>10000–1FFFF</td><td>20000–2FFFF</td><td>30000–DFFFF</td><td>E0000–EFFFF</td><td>F0000–10FFFF</td></tr></tbody></table><p>上面的表格就是各个平面的码点范围.</p><p>我们着重关注的其实就是Plane 0, 也就是上面刚刚说的BMP.</p><p>最早, Unicode字符编码是双字节编码也就是16位, 这个其实就是我们后面要说的UTF-16, 等说到了的时候再解释吧. 这样当在考虑原先的ASCII编码的时候, 为了考虑兼容(其实UTF-16也没有很好的兼容, 这个后面再说)于是就保持和它的原来的<strong>编号</strong>不变, 只不过在<strong>编码</strong>上, 将原来的8位扩展到了16位, 但是我们知道ASCII字符只需要用到UTF-16的16位编码中的低8位, 所以其高8位永远是0, 实际上也只用到了低8位中的低7位，因此准确地说其高9位永远是0. </p><p>注意到我刚刚才说的是编号一致, 其实对于ASCII这样的传统字符编码模型, 我们可以同时使用编号和编码的, 他们没有什么大的区别.</p><p>ASCII还好办, 毕竟是8位编码, 但是对于中文就麻烦了, GB系列的标准本身就是双字节编码, 所以就没法提供一个算法进行互相转换. 其实ASCII码也不能说是兼容了, 这种解决方法也是不完全的.</p><p>Unicode给每一个码点都编了一个唯一的字符编号(码点编号), 并且在表示这个的时候, 在前面加上一个<code>U+</code>.</p><p>我们回到之前说的UCS字符集, 这个玩意其实有两个组成: UCS-2和UCS-4, 他们分别定义2字节和4字节的码点编号, 其中UCS-2和我们的BMP是对应关系, 它们保持一致. <strong>注意: UCS-2和UCS-4不是字符编码方式, 也不能把他们和UTF-16和UTF-32画等号, UCS和Unicode字符集一样, 也是可以使用多种方式对字符编号进行编码的.</strong></p><p>再说到具体的编码方式之前, 我们要先来说一个超级重要的概念 — <strong>字节序</strong></p><h4 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h4><p>字节序, Byte-order. 或者叫做<code>Endianness</code>, 翻译过来是端序, 在1980年短语<code>Big-endian</code>和<code>Little-endian</code>第一次出现, 来表示异构计算机之间的通信和交换数据的重要概念, 在现代网络中, 字节序也是一个十分重要的概念.</p><p>简单来说, 字节序就是规定多字节数据在计算机存储, 读取的时候的各个字节的排列顺序. 我们也可以把字节序称为端序, **”端”**就是指多字节数据的两边(端)字节, 一般情况下, 我们人读取数据是从左边往右边, 或者是从上到下, 这就是从大端到小端, 从高位到低位, 而对于内存地址而言, 从左到右, 从上到下, 就是从低位地址到高位地址. 这都是几乎确定的.</p><p>我们要先解释一下, 上面这一段其实解释的很迷(SO SORRY, 我的极限语言表达能力). 所谓大端, 其实就是指代更大属主的那一端, 而小端自然就是更小的那一边.</p><p>那么接下里, 我们就可以引入UTF中两个令人迷惑的概念了: <strong>大端序</strong>和<strong>小端序</strong>(其实还有一个<strong>中间序</strong>, 不过使用的不多).</p><p>大端序就是指按照我们正常的读写顺序(即刚刚说的从左到右, 从上到下), 正好大端在<strong>前面</strong>(也就是左或上). 而小端序就是说按照我们正常的读写顺序, 正好小端在<strong>前面</strong>. </p><p>其实说到底, 如果我们的计算机是按照字节为单位来处理数据的话, 就不存在这么复杂的概念了, 因为处理数据的单位是单个字节, 有什么大端小端关系? 当然也是没有什么顺序的了. 但是问题就是计算机处理数据是按照数据类型来的, 而这些数据类型是多字节数据类型, 而一旦把多个单字节当做一个整体处理, 就必定会牵扯到排列顺序的问题.</p><p>那么现在就来具体的说一下大端序和小端序吧:</p><h5 id="大端序"><a href="#大端序" class="headerlink" title="大端序"></a>大端序</h5><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/Big-Endian.svg/560px-Big-Endian.svg.png" alt="大端序"></p><p>看图就觉得很清晰, 而且很符合正常的读写习惯, 也即是按照顺序把字节填充进去.</p><h5 id="小端序"><a href="#小端序" class="headerlink" title="小端序"></a>小端序</h5><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/Little-Endian.svg/560px-Little-Endian.svg.png" alt="小端序"></p><p>小端序就是反过来的, 字节头位于内存地址的高位, 而尾部位于低位.</p><h5 id="中端序"><a href="#中端序" class="headerlink" title="中端序"></a>中端序</h5><p>中端序也称为是混合序, 其实就是像这样的:<br><img src="https://pic4.zhimg.com/50/v2-099eb9b3df42395ee58ed21599e7f616_hd.jpg" alt="混合序"></p><p>而具体是什么序, 取决于软件层面操作系统和硬件层面的CPU. 一般来说, 大部分的操作系统(NT, Linux)都是小端序的, 而且Intel X86架构的CPU也都是小端序的, 但例如Power PC这样的架构就是大端序的, 而且Mac OS X也是大端序的.</p><p>这样的话, 就很麻烦, 尤其是对于那些设计系统的工程师, 以及一些做跨平台, 异构应用的编写人员就不可避免的考虑到字节序的问题. </p><h4 id="Unicode的CEF"><a href="#Unicode的CEF" class="headerlink" title="Unicode的CEF"></a>Unicode的CEF</h4><p>由于Unicode是这篇文章的一个侧重点, 而且Unicode比较复杂, 所以我们就单独开一个小节, 来介绍他的CEF选择和实现方案.</p><p>回过头来看看Unicode的平面(Plane)表, 其中定义了很多<strong>码点</strong>, 另外我们再之前的Unicode编码模型中说了, CEF就是将字符编号转换成为<strong>码元序列</strong>的方式. 在具体的说大家熟知的UTF之前我们来较为深入的重新看下这两个概念, 顺便再复习一下, 这样就更容易理解UTF的设计啦.</p><p>我们说在一个编号空间中, 码点就是那个横纵坐标相交的那个点, 通过这个唯一的坐标对来表示, 这个坐标对就是这个码点所对应的字符编号(除了字符码点还有别的, 对于他们就不能这么说了, 但是这样表述比较直接), 然后Unicode在这些字符编号面加上了个<code>U+</code>来声明这是一个Unicode码点, 17个平面, 每个平面有65535个码点 这样就是一共1114112个码点. 另外最长的甚至需要21位二进制来表示, 也就是用三个字节以上来表示.</p><p>那么在计算机中, 码点需要转换成为码元. 这样才可以在计算机存储以及网络中传输, 怎么来理解码元呢? 就像是我们编程语言中的数据类型, 或者是汇编语言中的WORD, DWORD这些. 所以当然, 我们的码元在机器中也存在单字节和多字节的类型的, 而就像上面说的, 多字节就存在一个关于字节序的问题, 这也就是为啥我们要强调这个码元的原因.</p><p>就像基本的数据类型: BYTE, WORD, DWORD一样, 我们的码元类型也就分成这些: 对应上面的这三个, 分别有单字节, 2字节和4字节的码元. 是不是想到什么了? 没错, 这三种码元类型就对应UTF-8, UTF-16, UTF-32这三种<code>Unicode Transform Form</code>, 也就是<strong>Unicode码转换格式</strong>, 你也可以把这个叫做<code>UCS Transform Form</code>, 即通用字符集转换格式. 说到这里你就明白了, 所谓Unicode的CEF, 其实就是选择了一个类型的码元来编码.</p><p>至于具体是怎么样进行编码的, 我们在下面一个部分来说. (以UTF-8为重点, 毕竟使用最为广泛, 至于UTF-32暂不讨论)</p><p>你可能会说, 我还听说过<code>UTF-7</code>, <code>UTF-1</code>这些, 怎么上面没有提到呢? 实际上, <code>UTF-1</code>其实就是<code>UTF-8</code>的退役前身. 目前已经不再是Unicode的标准, 而<code>UTF-7</code>是为了电子邮件而设计的, 目前是<code>deprecated</code>的状态, 不再是Unicode的标准, 作为信息RFC存在.</p><h5 id="UTF-8和本不应存在的BOM"><a href="#UTF-8和本不应存在的BOM" class="headerlink" title="UTF-8和本不应存在的BOM"></a>UTF-8和本不应存在的BOM</h5><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/utf-8_web_growth.png" alt="utf-8_web_growth.png"></p><p>先来看一下UTF-8在前几年的增长势头(Web页面, 由Google统计).</p><p>UTF-8在目前仍然是最广泛使用的具体编码方案, 但他却不是UTF最早的, 最早的是UTF-16. 最标准的称呼方法应该是<code>UTF-8</code>, 在一些不区分大小写的语言中, 例如: <code>HTML</code>, <code>CSS</code>, <code>XML</code>等, 都可使用<code>utf-8</code>这样的说法. 但是<code>utf8</code>或者<code>UTF8</code>这样缺失连字符的说法不被认为是正确的, 一些现代的浏览器或者是一些相关的标准(<code>HTML5</code>比如) 也可以有效的识别 但最好还是使用标准名称.</p><p>接下来步入正题, 我们来说说UTF-8的一些组成和特性.</p><p>其实我们刚刚提到了先出现的UTF-16, 那为啥没有坚持使用下去呢, 为啥要重新设计一个UTF-8呢? 这是因为UTF-16的编码方式采用双字节编码, 导致原来的ASCII编码都要变成双字节, 从而导致存储和效率低下, 其实这也没什么, 更严重的问题是C语言在解析文本的时候, 由于将高位的<code>0x00</code>解析成字符串结尾导致问题频频出现, 这就使得Unicode的推行遇到问题, 从而重新设计了UTF-8</p><p>UTF-8使用单字节编码, 可变长或者不定长的码元序列. 所以在使用UTF-8对ASCII字符集进行编码的时候, 是<strong>透明</strong>的. 这既是它的第一个特性. 不仅如此, 由于UTF-8在表示非ASCII字符的时候使用多个单字节码元来构成码元序列, 从而可以很好的进行兼容. 再加上单字符编码节省空间, UTF-8很快就收到了推崇.</p><p>另外我们说, UTF-8的编码空间远远大于UTF-16. (这里的编码空间和之前的Code Space是两个层次的概念, 我们现在在探讨CEF, 别忘记了) 至于为啥, 我们再具体的阐述UTF-8的编码算法的时候再说.</p><p>现在站在高层想一想, 现在知道UTF-8是变长编码的, 那么一个很明显的缺点就是: 我们无法轻易的得知一段文本的字符数量, 同样, 对这一段文本的索引也会成为一个比较棘手的问题.</p><p>好了, 接下来我们就来拓展之前的字节序这个话题. 我们都已经知道UTF-8是单字节编码, 那么按理说是不存在字节序这个问题的呀?  这个问题我们会在后面探讨, 姑且就先默认, 来看一下Unicode是怎么解决字节序这个问题的.</p><p>Unicode&#x2F;UCS标准规定, 使用一个叫做字节序标记(Byte-Order Mark, BOM)的东西来进行规范, 在文本的开头加上一个不占宽度的’’标记’’, 这样一来这个标记就会具有以下的三个基本作用:</p><ul><li>文本流是使用什么字节序(或者说端序)存储的.</li><li>以一种高可信度来说明文本流是遵循Unicode标准编码的.</li><li>该文本流是使用哪一个Unicode编码来进行编码的.</li></ul><p>有关于这个标记的具体内容, 其实大家可能都见过的: <code>U+FEFF</code>. 至于为啥是这个, 我们还是要先保留一下.</p><blockquote><p>补充一下, 在旧版本(Unicode 3.2)之前, 这个<code>U+FEFF</code>还有一个名字叫做零宽度不中断空格(ZERO WIDTH NO-BREAK SPACE) 也就是说, 如果在文本中(而原本应该出现在文档流头部的)出现了这个字符, 就会将其视作成一个不产生任何空间占用的(这里的空间是说字符和字符之间的间隙), 不允许换行的特殊字符. 但是, 在新版本(3.2)的Unicode 标准中, 这个名称不再被建议使用. 而是由另外一个新的名词来代替: word joiner(怎么翻译啊..词连接器吧) 具体的码点值是: <code>U+2060</code></p></blockquote><p>那么怎么表示文本流的字节序是大端序还是小端序呢? 使用下面的声明方式:</p><ul><li>0xFE 0xFF &#x3D;&gt; UTF-16 大端序</li><li>0xFF 0xFE &#x3D;&gt; UTF-16 小端序</li><li>0x00 0x00 0xFE 0xFF &#x3D;&gt; UTF-32 大端序</li><li>0xFF 0xFE 0x00 0x00 &#x3D;&gt; UTF-32 小端序</li></ul><p>那么UTF-8呢? BOM对于UTF-8的表现形式是: <code>0xEF 0xBB 0xBF</code>. 但是我们知道UTF-8采用单字节编码, 应该是不需要这个东西的, 那为什么还有这个呢? 说道这个话题可能就要扯的远了一点. 首先我们要明确的是, BOM对于UTF-8只有一种作用, 那就是声明这一段文本是使用UTF-8编码的. Unicode标准允许UTF-8出现BOM, 但是不推荐使用. 在某些情况下(尤其是类Unix系统下), 很多程序会因为文本头部的这一段而解析错误.</p><p>在这里插一下我在网上搜集到的, 关于为什么UTF-8和BOM的一些相关:</p><blockquote><p>在之前说道代码页这个概念的时候, 还有ANSI的设定, 我们都可以看出来微软的操作系统-Windows的一些设计思想. </p><p>Windows强调一个很重要的东西 — <strong>兼容性</strong>.而且对兼容性的支持到了一个很执着的地步. 很多人说Windows为啥就不能使用Unicode编码呢? 事实上是, Windows的内核就是UTF-16编码写的, 也就是说, 整个内核态全部都是默认使用Unicode. 但是微软控制不了用户态运行的各个应用程序, 总不能强制要求所有的开发者使用Unicode编码吧. 因此他就使用了两种不同的编码方式, 即Unicode和Code page. 这样, 当程序和不支持Unicode的程序进行交互的时候, 就会使用到Code page了. 此时才会回到我们之前说的缺省代码页的问题.</p><p>(所以说你们也别老说人家微软了…为了兼容真的好麻烦的) 这里才开始正经的说UTF-8和BOM. 前面只是为了说一下微软对Unicode态度.</p><p>从Windows的API中其实就可以看出来一点, 比如<code>CreateFile</code>, 就会自动识别并把BOM剔除. 所以UTF-8 with BOM对于Windows来说不是那么影响, 反而, 为了达到兼容的目的, 加上BOM这么一个trick还是挺合理的, 尽管使用字节序标记作为识别头部并不是很优雅.</p><p>而且, 前面也说过了, Windows原生支持的是UTF-16, 因此就算是为了自己和自己兼容, 他也是需要BOM这个东西的.</p><p>但是对于Unix来说就不是这么回事了. 这个我们放在后面说.</p></blockquote><p>接下来就来具体的说一下UTF-8的编码方式吧.</p><p>先来解决一个重要的问题: UTF-8的变长编码, 我怎么知道接下来的长度是多少? 那就是, 通过<strong>首字节</strong>来判断.</p><ul><li>如果首字节以0开头，肯定是单字节编码(即单个单字节码元)；</li><li>如果首字节以110开头，肯定是双字节编码(即由两个单字节码元所组成的双码元序列)；</li><li>如果首字节以1110开头，肯定是三字节编码(即由三个单字节码元所组成的三码元序列)，以此类推。</li></ul><p>使用这样的规律来进行. 提问! 仅仅按照这样的规律, 有没有发现什么问题呀?</p><p>是了, 最大的问题就在于, 如果在多字节的情况下第二个字节或者后续字节仍然是110&#x2F;1110这样开头, 那不是乱套了吗. 所以, 规定后续字节均使用10开头.</p><p>上面的四个前缀(0&#x2F;10&#x2F;110&#x2F;1110)的每一个0, 就是前缀码的终结标志. 另外考虑到单字节的情况, 前缀码0和ASCII字符集的设定完全相符, 真是巧妙.</p><p>这样, 将前缀码全部剔除掉之后的剩余的内容, 就是Unicode码点值了. 如果难以理解, 请看这样的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;屎&quot;</span></span><br><span class="line">s.encode(<span class="string">&quot;unicode-escape&quot;</span>)</span><br><span class="line"><span class="comment"># b&#x27;\\u5c4e&#x27;</span></span><br><span class="line">s.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="comment"># b&#x27;\xe5\xb1\x8e&#x27;</span></span><br></pre></td></tr></table></figure><p>通过<code>unicode-escape</code>我们可以得到码点值, 通过<code>utf-8</code>我们可以得到UTF-8编码拿到的具体的字节序列.</p><p>接下来分析一波:</p><p>我们先把得到的字节序列写成二进制:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e5</span><br><span class="line">1110 0101 =&gt; 1110 表示由三个字节组成, 剔除掉之后是 0101</span><br><span class="line">b1</span><br><span class="line">1011 0001 =&gt; 剔除10, 得到 1100 01</span><br><span class="line">8e</span><br><span class="line">1000 1110 =&gt; 剔除10, 得到 00 1110</span><br></pre></td></tr></table></figure><p>接着我们看一下码点的值:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5c</span><br><span class="line">0101 1100</span><br><span class="line">4e</span><br><span class="line">0100 1110</span><br></pre></td></tr></table></figure><p>OK! 我们来吧剔除之后的比特拼起来:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0101 1100 0100 1110</span><br></pre></td></tr></table></figure><p>和码点对比, 当当当! 恭喜你得到了<strong>屎</strong>!</p><h5 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h5><p>略 ( 而且UTF-16的编码算法还是挺复杂的… )</p><h4 id="BOM和Unix的矛盾"><a href="#BOM和Unix的矛盾" class="headerlink" title="BOM和Unix的矛盾"></a>BOM和Unix的矛盾</h4><p>在Windows上, BOM的加入可以解决很多问题, 但是在Unix上确是一个很矛盾和麻烦的东西. 没错, Unix&#x2F;Linux是原生支持UTF-8的, 这里的UTF-8是说<strong>标准UTF-8</strong>, 也就是不携带BOM的UTF-8. </p><p>熟悉Linux的朋友都知道, Linux的设计哲学中有这样的: “<strong>一切文档中的数据都可见</strong>“. 从Shell解析的<code>#!</code>幻数设定就看的出来. 而BOM的到来使得很多Unix程序都傻眼了, 他们自己明明都添加了对BOM的支持, 但是却因为BOM的加入, 使得Shell的<code>#!</code>失效了(因为这个幻数必须放在文档的头部). 这样还没到自己处理, 在Shell这里就卡住了. 很多解释器对于编码类型都有他们自己的声明:</p><ul><li><code>-*- coding: utf-8 -*-</code> Python</li><li><code>use utf-8</code> Perl</li></ul><p>等等, 看上去这样的处理都比加上一个不可见的BOM头部要可靠和合理的多</p><p>另外, BOM的加入对于文本流式的处理变得麻烦, Linux是很强调<strong>流</strong>这个概念的.</p><p>一个最典型的例子, 在Windows上使用notepad默认编码编写的C源程序, 在Mac OS X或者Linux&#x2F;Unix上使用gcc去编译的时候, 会因为出现非法字符而编译失败.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>以下是(部分)参考资料:</p><p><a href="https://baike.baidu.com/item/%E5%8C%BA%E4%BD%8D%E7%A0%81/11027286">百度百科-区位码</a> 区位码<br><a href="https://en.wikipedia.org/wiki/Character_encoding">Wikipedia-Character_encoding</a> 字符编码<br><a href="https://en.wikipedia.org/wiki/EBCDIC">Wikipedia-EBCDIC</a> EBCDIC编码标准<br><a href="https://en.wikipedia.org/wiki/Unicode#History">Wikipedia-Unicode-历史</a> Unicode发展历史<br><a href="https://en.wikipedia.org/wiki/Universal_Coded_Character_Set#History">Wikipedia-UCS-历史</a> UCS历史<br><a href="https://en.wikipedia.org/wiki/Endianness">Wikipedia-Endianness</a> 字节序<br><a href="https://en.wikipedia.org/wiki/Byte_order_mark">Wikipedia-Byte_order_mark</a> 字节序标记<br><a href="https://en.wikipedia.org/wiki/Word-joiner">Wikipedia-Word-joiner</a><br><a href="http://www.unicode.org/reports/tr17/">UTR#17</a> Unicode技术报告 #17 — Unicode字符编码模型<br><a href="http://www.chi2ko.com/tool/CJK.htm">中日韩Unicode对照表</a> 这个页面会渲染个几秒钟, 浏览器可能会卡<br><a href="http://www.unicode.org/charts/PDF/UF900.pdf">CJK兼容表-F900-F921</a><br><a href="https://zhuanlan.zhihu.com/p/27012715">知乎专刊-刨根究底字符编码</a> 这篇笔记的主要参考来源以及结构组织来源, 感谢作者-<a href="https://www.zhihu.com/people/jacky-lin-53">Jacky lin</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">阮一峰-字符编码笔记</a> ASCII，Unicode 和 UTF-8<br><a href="http://slides.ruanyifeng.com/unicode/#intro">阮一峰-Unicode和ES6-Slide</a><br><a href="https://www.zhihu.com/question/55075967/answer/144329603">知乎-GB2312区位码转机内码为什么要同时加上2020H和8080H</a><br><a href="https://www.zhihu.com/question/20129435">知乎-为什么使用 JavaScript 中 string 的 trim 方法时要替换 \uFEFF 呢?</a><br><a href="https://www.zhihu.com/question/42048612">知乎-微软为什么用带 BOM 的 UTF-8，造成和多数系统的不兼容？</a><br><a href="https://www.zhihu.com/question/20167122/answer/14199022">知乎-「带 BOM 的 UTF-8」和「无 BOM 的 UTF-8」有什么区别？网页代码一般使用哪个？</a> 陈甫鸼的回答<br>AND 一大波的知乎回答, 太多了不好贴…对不起了各位答主🤦‍<br>吐槽一下: <a href="http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201307/218730.shtml">字符编码的前世今生-TGideas-腾讯游戏官方设计团队</a> 我看到腾讯官方的文章, 还兴冲冲的点了进去, 说实话, 随便的翻阅了一下感觉作者对编码的一些概念还不是很清楚…有点误人子弟的感觉…(别揍我)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unicode </tag>
            
            <tag> Codec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化运维之Puppet</title>
      <link href="/2017/11/11/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E4%B9%8BPuppet/"/>
      <url>/2017/11/11/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E4%B9%8BPuppet/</url>
      
        <content type="html"><![CDATA[<p>自动化运维第二步, 比Ansible还强大的集中配置工具Puppet.</p><p>了解Puppet的类, 模板, 配置语言和资源.</p><span id="more"></span><h2 id="Puppet简介"><a href="#Puppet简介" class="headerlink" title="Puppet简介"></a>Puppet简介</h2><p>我们之前使用过Ansible使得集群实现了集中部署, 十分方便. 那么和Ansible相比较, Puppet有什么不同吗? 从规模上讲, Puppet管理的节点个数要远远大于Ansible, 使用Puppet管理几千个节点都是很轻松的. 而且我们在说Ansible的时候提到过Puppet是需要agent的, 而Ansible是agentless的.</p><p>在大部分的场景下, 我们使用Ansible都是需要手动进行的. 而Puppet可以做到在很多场景下进行自动的管理. 几乎是整个生命周期的管理, 如下:</p><ul><li>provisioning: 安装</li><li>configuration: 配置</li><li>orchestration: 编排</li><li>reporting: 报告</li></ul><p>另外, 说到Puppet的版本也很有趣, 他的版本演化大体是这样的:</p><blockquote><p>0.2 –&gt; 0.24.x –&gt; 0.25.x –&gt; 0.26.x(2.6) –&gt; 2.7 –&gt; 3.0 –&gt; … –&gt; 5.X</p><p>目前的版本已经到了5.3.2, 其中2.7是一个过渡版本, 和2.6差距甚远. </p></blockquote><p>继续说说Puppet, 由于是master-agent模型, 所以我们需要在每一个节点上安装客户端, 接着选择一个节点充当服务器端. 但是, 即使是使用Ansible去集中分发安装也不是很理想, 一般的做法倾向于使用模板的方式, 基于虚拟机和容器来进行构建, 并且, 得益于云环境, 虚拟化技术, 我们在系统的安装上面也可以得到很多方便的地方.</p><p>我们来对比一下Ansible和Puppet(准确的说是对比一下有无agent), 首先, 如果没有agent的协助, 我们就需要使用ssh协议进行通信, 另外, 不仅如此, ssh的用户就是我们执行命令的用户, 而大部分情况下都是root权限执行, 这样直接放任登录是十分不安全的, 即使说可以使用sudo, 但还是一样, 攻击者依然可以利用sudo来间接使用管理权限. 而agent就不一样了, agent和本地的权限是仅仅存在在本机的, 而和服务器端的认证就是基于自己的私密协议, 或者证书, 或者预共享密钥等等. 这样的安全系数是提高了不少的.</p><p>我们真正的功能实现实在agent端的, master仅仅是为了发送指令, 并管理agent端. 接下来我们来说说Puppet的工作模型吧.</p><p>Puppet采用了基于模型, 声明性的配置编程语言, 由于Puppet是用Ruby写的, 所以这个编程语言其实可以说是Ruby的子集.那么具体是什么样的工作模式呢, 我们把他们分成四步:</p><ul><li>定义(define): 在这一步我们使用刚才说的编程语言来定义资源和他们的状态. 这里说的资源不是之前在说HA的时候的资源. 这里的资源可以类比的比作Ansible的模块</li><li>模拟(stimulate): 这里, Puppet根据资源关系, puppet在本地无损运行测试代码, 相当于是一次模拟部署</li><li>没有问题了之后, 就进入了强制(force): 比对客户机的状态和定义的资源状态是否一致, 自动强制执行</li><li>最后就可以将执行的结果日志发送到自带的dashboard或者其他的第三方的可视化平台.</li></ul><p>在说具体的Puppet的语言之前, 我们还需要介绍一下Puppet的组成层次, 一共分成三层:</p><ul><li>配置语言层</li><li>事务层</li><li>资源抽象层</li></ul><p>这里我们稍微补充一些吧, 首先是资源抽象层,其实这个我们在Ansible中已经感受过了, 安装一个服务, 在Ubuntu和CentOS下的工具和过程肯定是不一样的. 再或者, Windows主机上和Linux主机上创建一个用户的系统调用也是不一样的, 而抽象就可以将不一样的调用封装成为统一的接口. 向上一层, 事务层其实就和他的名字一个作用, 如果我们要启动http的服务但是, Apache根本就没有安装, 这根本就不可能启动成功, 所以出现了问题就要进行回退. 基于这些, 最后提供一个配置语言的借口就可以了.</p><p>其中, 我们的资源可以分成这样的三个维度</p><ul><li>资源类型: 例如用户, 组, crontab, 文件, 服务, 等等..</li><li>属性及状态以及实现方式分离</li><li>期望状态, 决定对应的资源存在与否</li></ul><p>因此, 说道这里, 我们就能知道了puppet的核心组件就是资源了. 我们在使用Ansible的时候, 因为在命令行中手敲命令实在是太麻烦了, 所以我们编制yaml格式的playbook来执行, 对于Puppet, 他把这个类似的东西叫做: <strong>资源清单(manifest)</strong>.</p><p>特定的资源在清单中组织起来,以及资源依赖的文件形成的这样的一个层次, 在Ansible中叫做角色(Role), 我当时提过但是没有深入的去实现. 所以简单的小结一下就是: Puppet的资源相当于是Ansible的模块, 而资源清单相当于Ansible中的角色.</p><p>现在我们就可以更加具体的过一遍Puppet的执行过程了:</p><blockquote><p> 先来考虑一台主机的过程, 这就很简单了. 根据需求我们可能会有多个manifest清单文件, 我们说过这是ruby的子集, 所以要经过编译成为伪代码, 这个伪代码其实已经是二进制的了, 所以会直接进行执行, 这个过程就是apply阶段了, 进行状态查询和执行目标状态. </p><p> 但是更多的场景是master&#x2F;agent的模型,agent向master端请求catalog(伪代码), 同时发送自己的主机名和facts信息. 而master节点收到了请求之后, 开始查询请求者的站点清单, 选择适当的manifest, 经过编译成为二进制的catalog, 发送给客户机 <strong>注意这发送的是二进制码</strong>, 客户机经过应用阶段之后, 将执行的报告发送给服务器端. — 编译过程发生在master节点上. 另外, 这里所说的站点清单, 其实就是include了许多manifest的一个清单文件.</p></blockquote><p>我们知道Ansible是基于SSH协议做的认证和数据传递, 那么Puppet的主从节点之间是怎么沟通的呢? </p><p>答案是: <strong>HTTPS</strong>. 这也算是个挺麻烦的协议了, 但是实际上我们在配置的时候是挺容易的, 原因就在于这个master节点自己就是个CA. 所以他可以自己向client签发证书. 不仅如此, 每一个agent其实自己是有一个准备好的证书请求的, 那么问题就简单了, 并且这个也成为了核心: <strong>要不要给agent签署证书.</strong> 一旦签署了就说明双方互相信任了. 那么到底怎么签署呢? 这个其实就只能看管理员自己了, 是否签署只能由人工来判定, 当然也是可以全部批量签署的, 但是那样显然是存在安全风险的.</p><p>说道这, 我们也可以看到Puppet和Ansible的另一个不一样的点: Ansible是服务器端主动进行推送, 而Puppet是客户端去服务器端拉取二进制代码, 服务器端根据主机名选择清单进行编译, 最后返回结果. 不过本质上二者的机制是一样的.</p><p>现在我们就来安装一下Puppet试试吧. 可以在他的官方站点找到rpm包. 由于Puppet是使用Ruby编写的, 所以需要Ruby的依赖.</p><p>安装完成之后, 我们就可以来试试了, 首先就是先来看帮助了. Puppet的帮助信息获取是通过help的子命令进行的, 他的命令格式就像这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: puppet &lt;subcommand&gt; [options] &lt;action&gt; [options]</span><br></pre></td></tr></table></figure><p>由于子命令也算不少, 所以就不一一说, 用到的时候我们再说好了. </p><p>前面说过Puppet有一个资源抽象, 那么支持什么资源类型呢, 我们可以通过下面的命令查看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># puppet describe -l</span></span><br><span class="line">These are the types known to puppet:</span><br><span class="line">augeas          - Apply a change or an array of changes to the  ...</span><br><span class="line">computer        - Computer object management using DirectorySer ...</span><br><span class="line">cron            - Installs and manages cron <span class="built_in">jobs</span></span><br><span class="line"><span class="built_in">exec</span>            - Executes external commands</span><br><span class="line">file            - Manages files, including their content, owner ...</span><br><span class="line">filebucket      - A repository <span class="keyword">for</span> storing and retrieving file  ...</span><br><span class="line">group           - Manage <span class="built_in">groups</span></span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>接下来我们就从资源切入, 来说说如何定义资源和清单文件吧.</p><h2 id="Puppet资源"><a href="#Puppet资源" class="headerlink" title="Puppet资源"></a>Puppet资源</h2><p>定义一个资源很简单, 只要使用下面的语法格式就可以了:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type &#123; <span class="string">&#x27;name&#x27;</span></span><br><span class="line">  key =&gt; value1[,value2[,]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如这样的例子:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user &#123; <span class="string">&#x27;testuser&#x27;</span></span><br><span class="line">  <span class="keyword">ensure</span> =&gt; present,</span><br><span class="line">  uid =&gt; <span class="string">&#x27;777&#x27;</span>,</span><br><span class="line">  gid =&gt; <span class="string">&#x27;777&#x27;</span>,</span><br><span class="line">  shell =&gt; <span class="string">&#x27;/bin/sh&#x27;</span>,</span><br><span class="line">  home =&gt; <span class="string">&#x27;/home/testuser&#x27;</span>,</span><br><span class="line">  managehome =&gt; <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义资源的时候, 资源类型必须使用小写. 而且同一个类型下同一个名字的资源只能存在一个.(就是说不能同名啦)</p><p>另外, 我们在定义资源的时候, 会有一些特殊的属性, 主要分三类:name, ensure, metaparameter.</p><p>其中, name不同于我们在上面定义的<code>&#39;testuser&#39;</code>, 这是一个用来在目标系统上识别特定属性的一个变量, 每一个资源类型只能有一个, 也就是说是唯一的. 有没有觉得这个又和<code>&#39;testuser&#39;</code>有点相像? 是了, 其实他们两个在某种意义上都指向同一变量, 如果不指明<code>name</code>, puppet就会使用<code>&#39;name&#39;</code>来充当namevar.</p><p> 接着我们再来说说ensure这个特殊属性, 有点类似Ansible的state的, 主要有这些值:</p><ul><li>file 存在并且是文件</li><li>directory 存在并且是目录</li><li>present 存在, 通用的描述上面三种</li><li>absent: 不存在</li></ul><p>接下来, 就是实战一些常见的资源吧.</p><p>我们首先在家目录下创建一个manifest目录, 接着就在这里面做测试吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># mkdir manifest</span></span><br><span class="line">[root@master manifest]<span class="comment"># vim test1.pp</span></span><br><span class="line">&lt;!--<span class="keyword">in</span> vim--&gt;</span><br><span class="line">group &#123; <span class="string">&#x27;centos&#x27;</span>:</span><br><span class="line">        gid =&gt; 2000,</span><br><span class="line">        ensure =&gt; present</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user &#123; <span class="string">&quot;centos&quot;</span>:</span><br><span class="line">        gid =&gt; 2000,</span><br><span class="line">        uid =&gt; 2000,</span><br><span class="line">        shell =&gt; /bin/sh,</span><br><span class="line">        home =&gt; /home/centos,</span><br><span class="line">        ensure =&gt; present,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该很好看懂的, 接着就是生成catalog了, 由于我们现在是在单机测试, 而不是主从模型, 所以我们使用puppet的<code>apply</code>子命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># puppet apply -v test1.pp</span></span><br><span class="line">Notice: Compiled catalog <span class="keyword">for</span> master <span class="keyword">in</span> environment production <span class="keyword">in</span> 3.86 seconds</span><br><span class="line">Info: Applying configuration version <span class="string">&#x27;1510488497&#x27;</span></span><br><span class="line">Notice: /Stage[main]/Main/Group[centos]/ensure: created</span><br><span class="line">Notice: /Stage[main]/Main/User[centos]/ensure: created</span><br><span class="line">Info: Creating state file /var/lib/puppet/state/state.yaml</span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 19.48 seconds</span><br></pre></td></tr></table></figure><blockquote><p>好慢啊…</p></blockquote><p>此时 我们的用户和组就已经创建完成了. 可以来确认一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">centos:x:2000:</span><br><span class="line">[root@master manifest]<span class="comment"># tail -1 /etc/passwd</span></span><br><span class="line">centos:x:2000:2000::/home/centos:/bin/sh</span><br></pre></td></tr></table></figure><p>而且, 这里我们都没有指明name, 所以就自动选择了title作为我们的namevar.</p><p>我们之前也说过了, 使用describe可以来查看特定的资源, 接下里我们就一个一的来说吧:</p><h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><p>group的经藏使用的选项还是很少的, 所以比较简单, 就是以下的几个</p><ul><li>name: 组名, NameVar</li><li>gid: GID</li><li>system: true, false</li><li>ensure: present, absent</li><li>members: 组内成员</li></ul><p>很简单, 直接看下面类似的user吧</p><h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p>user就要比group麻烦一点了, 选项的个数也比较多</p><ul><li>Comment: 注释信息</li><li>ensure: 不用再解释了吧</li><li>expiry: 过期期限</li><li>gid: GID</li><li>groups: 属于哪个组</li><li>home: 家目录位置</li><li>shell: 默认的shell</li><li>name: 用户名, nameVar</li><li>system: 是否是系统组</li><li>uid: UID</li><li>password: 用户的密码, 根据对方的操作系统不同, 使用不同的带有杂质的不同加密算法来进行</li></ul><p>其实也很容易, 接着看一个和Ansible很相像的:</p><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>用来管理文件, 文件的内容, 文件的属主属组, 他们的权限 . 可以处理的文件包括一般文件, 目录文件, 符号链接等.</p><p>文件的内容, 可以直接通过content指出, 支持换行符等. 所以就有这样的属性了:</p><ul><li>content: 文件的内容制定, 可以使用\n等特殊字符</li><li>source: 从指定位置下载文件</li><li>ensure: file, directory, link, present, absent</li></ul><p>以上的三个属性, 用来指明文件的内容来源, 接下就是一些常规的属性:</p><ul><li>force: 如果文件和目录同名, 是覆盖还是放弃</li><li>mode: 指明权限, 可以使用数字或者字符</li><li>group: 属组</li><li>owner: 属主</li><li>path: 目标路径</li><li>mtime, ctime, atime</li><li>target: 当ensure为link的时候, target指定的是符号链接的目标, path就是链接的位置了</li></ul><p>接着就来试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">file &#123; <span class="string">&#x27;/tmp/testdir&#x27;</span>:</span><br><span class="line">ensure =&gt; directory,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file &#123; <span class="string">&#x27;/tmp/puppet.test&#x27;</span>:</span><br><span class="line">content =&gt; <span class="string">&#x27;Puppet test\nLine two&#x27;</span>,</span><br><span class="line">ensure =&gt; file,</span><br><span class="line">owner =&gt; <span class="string">&#x27;centos&#x27;</span>,</span><br><span class="line">group =&gt; <span class="string">&#x27;centos&#x27;</span>,</span><br><span class="line">mode =&gt; <span class="string">&#x27;0400&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file &#123; <span class="string">&#x27;/tmp/fstab&#x27;</span>:</span><br><span class="line"><span class="built_in">source</span>: <span class="string">&quot;/etc/fstab&quot;</span>,</span><br><span class="line">ensure =&gt; file</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file &#123; <span class="string">&#x27;/tmp/testdir/puppet.link&#x27;</span>:</span><br><span class="line">ensure =&gt; <span class="built_in">link</span>,</span><br><span class="line">target =&gt; <span class="string">&quot;/tmp/puppet.test&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们编写这样的示例, 接着编译一下试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># puppet apply test2.pp</span></span><br><span class="line">Notice: Compiled catalog <span class="keyword">for</span> master <span class="keyword">in</span> environment production <span class="keyword">in</span> 0.29 seconds</span><br><span class="line">Notice: /Stage[main]/Main/File[/tmp/puppet.test]/ensure: defined content as <span class="string">&#x27;&#123;md5&#125;870d2a178ae85c5ea7732338c4863ef2&#x27;</span></span><br><span class="line">Notice: /Stage[main]/Main/File[/tmp/fstab]/ensure: defined content as <span class="string">&#x27;&#123;md5&#125;82b1f625714ceefc4886929b1f95a00b&#x27;</span></span><br><span class="line">Notice: /Stage[main]/Main/File[/tmp/testdir]/ensure: created</span><br><span class="line">Notice: /Stage[main]/Main/File[/tmp/testdir/puppet.link]/ensure: created</span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 1.71 seconds</span><br></pre></td></tr></table></figure><p>接着就可以去<code>/tmp</code>下去确认了. </p><p>接下来的一个也是一个很重要的类型了, 那就是执行命令的类型: exec</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>用来执行外部命令, 而且支持条件执行, 以及触发执行, 这就很灵活了. 另外, 命令执行本身具有幂等性.</p><p>他有哪些属性呢? 我们来看一下:</p><ul><li>command: 指定运行的命令, 这个就是nameVar</li><li>creates: 如果目标文件不存在, 就会执行nameVar指定的命令</li><li>cwd: 指定工作路径</li><li>user: 指定命令的执行者</li><li>onlyif: 只有这个属性的执行结果是0才会执行nameVar指定的命令</li><li>unless: 和onlyif相反, 只有执行失败才会执行nameVar</li><li>refresh: 指明如何更新这个资源, 如果是服务, 我们可以在更新了配置文件之后重新载入或者重新启动, 但是对于命令, 这个就需要我们手动指定了. 默认是在再次执行一遍 也可以手动指定成其他的.</li><li>refreshonly: 类似的, 这个意思就是只有在收到通知的时候才执行.</li><li>returns: 期望的返回值, 返回的其他值都被认定成是执行失败的.</li><li>tries: 尝试执行的次数</li><li>timeout: 超时时长的设定</li><li>path: 指明命令的搜索路径, 通常是列表的形式([‘’, ‘’, ‘’]). 在这里如果不指明, <strong>每一个命令必须是绝对路径的.</strong></li></ul><p>我们说过有些命令是具有幂等性的, 例如:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> &#123;<span class="string">&#x27;/sbin/modprobe ext4&#x27;</span>:</span><br><span class="line"><span class="attr">user</span> =&gt; <span class="literal">root</span>,</span><br><span class="line"><span class="attr">group</span> =&gt; <span class="literal">root</span>,</span><br><span class="line"><span class="attr">refresh</span> =&gt; <span class="string">&quot;/sbin/modprobe -r ext4 &amp;&amp; /sbin/modprobe ext4&quot;</span>,</span><br><span class="line"><span class="attr">timeout</span> =&gt; <span class="number">5</span>,</span><br><span class="line"><span class="attr">tries</span> =&gt; <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个命令执行几遍结果都是一样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># lsmod | grep ext4</span></span><br><span class="line">ext4                  381065  2</span><br><span class="line">jbd2                   93284  1 ext4</span><br><span class="line">mbcache                 8193  1 ext4</span><br></pre></td></tr></table></figure><p>但是, 像这样的命令就存在问题了:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> &#123;<span class="string">&#x27;/bin/echo Hello &gt; /tmp/test&#x27;</span>:</span><br><span class="line"><span class="attr">user</span> =&gt; <span class="literal">root</span>,</span><br><span class="line"><span class="attr">group</span> =&gt; <span class="literal">root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然第一次的执行是没有问题的, 但是第二次的执行将会破坏幂等性, 假设我们把Hello换成别的内容, 那么文件内的内容就会被被破坏.</p><p>这个时候, 为了保证文件不会被破坏, 我们就可以使用unless或者creates来控制命令执行, 修改之后的结果是这样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> &#123;<span class="string">&#x27;/bin/echo World &gt; /tmp/test&#x27;</span>:</span><br><span class="line">user =&gt; root,</span><br><span class="line">group =&gt; root,</span><br><span class="line">unless =&gt; <span class="string">&#x27;/usr/bin/test -e /tmp/test&#x27;</span>,</span><br><span class="line">creates =&gt; <span class="string">&#x27;/tmp/test&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里的unless和creates有一个就可以了, 他们都可以确保幂等性.</p><p>执行之后的结果就是这样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># puppet apply -v test4.pp</span></span><br><span class="line">Notice: Compiled catalog <span class="keyword">for</span> master <span class="keyword">in</span> environment production <span class="keyword">in</span> 0.07 seconds</span><br><span class="line">Info: Applying configuration version <span class="string">&#x27;1510886222&#x27;</span></span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 0.08 seconds</span><br></pre></td></tr></table></figure><p>根本就不会执行命令.</p><h3 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h3><p>这个资源可以说是最简单的一个资源了, 简单到只需要一行就可以定义结束, 他的参数一共其实就三个:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># puppet describe notify</span></span><br><span class="line"></span><br><span class="line">notify</span><br><span class="line">======</span><br><span class="line">Sends an arbitrary message to the agent run-time <span class="built_in">log</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Parameters</span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line">- **message**</span><br><span class="line">    The message to be sent to the <span class="built_in">log</span>.</span><br><span class="line"></span><br><span class="line">- **name**</span><br><span class="line">    An arbitrary tag <span class="keyword">for</span> your own reference; the name of the message.</span><br><span class="line"></span><br><span class="line">- **withpath**</span><br><span class="line">    Whether to show the full object path. Defaults to <span class="literal">false</span>.</span><br><span class="line">    Valid values are `<span class="literal">true</span>`, `<span class="literal">false</span>`.</span><br></pre></td></tr></table></figure><p>其中, message就是我们的nameVar, 这样的话我们定义一个资源就像这样:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">notify</span> &#123;<span class="string">&quot;Hello, there&quot;</span>: &#125;</span><br></pre></td></tr></table></figure><p>执行的结果就像这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># puppet apply test5.pp</span></span><br><span class="line">Notice: Compiled catalog <span class="keyword">for</span> master <span class="keyword">in</span> environment production <span class="keyword">in</span> 0.06 seconds</span><br><span class="line">Notice: Hello, there</span><br><span class="line">Notice: /Stage[main]/Main/Notify[Hello, there]/message: defined <span class="string">&#x27;message&#x27;</span> as <span class="string">&#x27;Hello, there&#x27;</span></span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 0.08 seconds</span><br></pre></td></tr></table></figure><h3 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h3><p>见到名字就知道是定时任务的资源了, 来看一下常用的属性:</p><ul><li>ensure: present, absent</li><li>command: 要执行的crontab任务</li><li>hour: </li><li>minute: </li><li>monthday: </li><li>weekday: </li><li>name: </li><li>user: 执行用户</li><li>environment: 执行的时候的环境变量</li></ul><p>大体上就这些. 我们来实际写一个试试吧:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cron&#123;<span class="string">&#x27;sync time&#x27;</span>:</span><br><span class="line">command =&gt; <span class="string">&quot;/usr/sbin/ntpdate edu.ntp.org.cn &gt; /dev/null 2&gt;&amp;1&quot;</span>,</span><br><span class="line">user =&gt; <span class="string">&quot;root&quot;</span>,</span><br><span class="line">ensure =&gt; present,</span><br><span class="line">minute =&gt; <span class="string">&quot;*/10&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># crontab -l</span></span><br><span class="line">no crontab for root</span><br><span class="line">[root@master manifest]<span class="comment"># puppet apply test6.pp</span></span><br><span class="line">Notice: Compiled catalog for master in environment production in 0.11 seconds</span><br><span class="line">Notice: /Stage[main]/Main/Cron[sync time]/ensure: created</span><br><span class="line">Notice: Finished catalog run in 0.73 seconds</span><br><span class="line">[root@master manifest]<span class="comment"># crontab -l</span></span><br><span class="line"><span class="comment"># HEADER: This file was autogenerated at Fri Nov 17 13:19:43 +0800 2017 by puppet.</span></span><br><span class="line"><span class="comment"># HEADER: While it can still be managed manually, it is definitely not recommended.</span></span><br><span class="line"><span class="comment"># HEADER: Note particularly that the comments starting with &#x27;Puppet Name&#x27; should</span></span><br><span class="line"><span class="comment"># HEADER: not be deleted, as doing so could cause duplicate cron jobs.</span></span><br><span class="line"><span class="comment"># Puppet Name: sync time</span></span><br><span class="line">*/10 * * * * /usr/sbin/ntpdate edu.ntp.org.cn &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>如果要删除也是很简单的啦, 直接把ensure的值改成<code>absent</code>就行了.</p><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>这个是用来管理程序包的一个资源类型. 由于不同系统平台安装的方式不一样, 但是Puppet将目的和实现方式进行了分离, 这就方便了我们. 我们既可以直接指明安装的软件包是什么就行了.</p><p>他有这些参数:</p><ul><li>configfiles: 有两个参数: keep和replace 它表明如果我们进行软件的覆盖安装的时候, 对于配置文件是怎么处理的.</li><li>ensure: 可以直接安装版本号, 或者跟上latest, present(installed), absent等.</li><li>name: 就是我们要安装的程序包的名字了</li><li>source: 包的来源, 可以是本地文件的路径, 也可以是URL</li></ul><p>来看这样的例子:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> &#123;<span class="string">&quot;zsh&quot;</span>:</span><br><span class="line"><span class="attr">ensure</span> =&gt; installed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> &#123;<span class="string">&quot;kmod-e1000&quot;</span>:</span><br><span class="line"><span class="attr">ensure</span> =&gt; installed,</span><br><span class="line"><span class="attr">source</span> =&gt; <span class="string">&quot;/root/kmod-e1000-8.0.35-1.el6.elrepo.x86_64.rpm&quot;</span>,</span><br><span class="line"><span class="attr">provider</span> =&gt; rpm,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># puppet apply -v test7.pp</span></span><br><span class="line">Notice: Compiled catalog <span class="keyword">for</span> master <span class="keyword">in</span> environment production <span class="keyword">in</span> 0.43 seconds</span><br><span class="line">Info: Applying configuration version <span class="string">&#x27;1510921085&#x27;</span></span><br><span class="line">Notice: /Stage[main]/Main/Package[zsh]/ensure: created</span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 28.97 seconds</span><br><span class="line">[root@master manifest]<span class="comment"># modprobe e1000</span></span><br><span class="line">[root@master manifest]<span class="comment"># lsmod | grep e1000</span></span><br><span class="line">e1000                 165474  0</span><br><span class="line">[root@master manifest]<span class="comment"># rpm -q zsh</span></span><br><span class="line">zsh-4.3.11-4.el6.centos.2.x86_64</span><br></pre></td></tr></table></figure><p>这个例子表示, 我们也可以使用本地的RPM包, 但是要指明provider, 否则puppet会报错. </p><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>接下来再来说一些这个service吧, 主要负责服务的管理, 常用的属性有这些:</p><ul><li>binary: 服务二进制程序的位置</li><li>enable: 是否开机自动启动, 对于Windows还有一个manual合法值(对于Linux不常见)</li><li>ensure: stopped(false), running(true)</li><li>hasrestart: 指明当前的启动脚本是否自携带restart选项</li><li>hasstatus: 于hasrestart类似, 不解释了</li><li>path: 和上面的exec一样, 指明搜索路径</li><li>restart, start, status, stop: 手动指明, 如果脚本自己不携带的话</li><li>pattern: 用来搜索服务相关的所有进程的模式字符串</li></ul><p>接下来按照惯例, 写个小栗子吧:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> &#123;<span class="string">&#x27;nginx&#x27;</span>:</span><br><span class="line"><span class="attr">ensure</span> =&gt; installed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service</span> &#123;<span class="string">&#x27;nginx&#x27;</span>:</span><br><span class="line"><span class="attr">ensure</span> =&gt; <span class="literal">running</span>,</span><br><span class="line"><span class="attr">enable</span> =&gt; <span class="keyword">true</span>,</span><br><span class="line"><span class="attr">hasstatus</span> =&gt; <span class="keyword">true</span>,</span><br><span class="line"><span class="attr">hasrestart</span> =&gt; <span class="keyword">true</span>,</span><br><span class="line"><span class="attr">restart</span> =&gt; <span class="string">&quot;service nginx reload&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的效果就像这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># puppet apply -v test8.pp</span></span><br><span class="line">Notice: Compiled catalog <span class="keyword">for</span> master <span class="keyword">in</span> environment production <span class="keyword">in</span> 8.88 seconds</span><br><span class="line">Info: Applying configuration version <span class="string">&#x27;1510989337&#x27;</span></span><br><span class="line">Notice: /Stage[main]/Main/Service[nginx]/ensure: ensure changed <span class="string">&#x27;stopped&#x27;</span> to <span class="string">&#x27;running&#x27;</span></span><br><span class="line">Info: /Stage[main]/Main/Service[nginx]: Unscheduling refresh on Service[nginx]</span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 30.72 seconds</span><br><span class="line">[root@master manifest]<span class="comment"># rpm -q nginx</span></span><br><span class="line">nginx-1.10.2-1.el6.x86_64</span><br><span class="line">[root@master manifest]<span class="comment"># service nginx status</span></span><br><span class="line">nginx (pid  8002) is running...</span><br></pre></td></tr></table></figure><p>在前面我们说过一些特殊属性还记得不~ 我们来说一下metaparameters, 这个玩意可以来确保资源之间的执行次序, Puppet提供了四个元参数来定义资源之间的相关性, 为了说明资源就需要做资源的引用. </p><p>常见的资源引用就像这样写:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type[<span class="string">&#x27;title&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这里要注意一点: <strong>资源引用的时候, 他的类型名必须要大写</strong></p><p>而资源之间的相关性有这些:</p><ul><li>before</li><li>require</li><li>notify</li><li>subscribe</li></ul><p>这四个元参数就是我们用来定义资源相关性的, 我们回到第一个例子, 来重下个定义:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">group</span> &#123; <span class="string">&#x27;centos&#x27;</span>:</span><br><span class="line">        <span class="attr">gid</span> =&gt; <span class="number">2000</span>,</span><br><span class="line">        <span class="attr">ensure</span> =&gt; <span class="literal">present</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">user</span> &#123; <span class="string">&quot;centos&quot;</span>:</span><br><span class="line">        <span class="attr">gid</span> =&gt; <span class="number">2000</span>,</span><br><span class="line">        <span class="attr">uid</span> =&gt; <span class="number">2000</span>,</span><br><span class="line">        <span class="attr">shell</span> =&gt; <span class="string">&quot;/bin/sh&quot;</span>,</span><br><span class="line">        <span class="attr">home</span> =&gt; <span class="string">&quot;/home/centos&quot;</span>,</span><br><span class="line">        <span class="attr">ensure</span> =&gt; <span class="literal">present</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义的存在一个严重的错误, 如果用户创建的时候 ,组不存在的话就会导致用户创建失败.</p><p>所以 这里我们需要制定一个规则, 就是在组创建之后才可以创建用户. 所以第一种方法, 就是说明在group的里面加上指明要在user前 就像这样:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">group</span> &#123; <span class="string">&#x27;centos&#x27;</span>:</span><br><span class="line">        <span class="attr">gid</span> =&gt; <span class="number">2000</span>,</span><br><span class="line">        <span class="attr">ensure</span> =&gt; <span class="literal">present</span>,</span><br><span class="line">        <span class="attr">before</span> =&gt; User[<span class="string">&#x27;centos&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者user里面加上在group之后的约束:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">user</span> &#123; <span class="string">&quot;centos&quot;</span>:</span><br><span class="line">        <span class="attr">gid</span> =&gt; <span class="number">2000</span>,</span><br><span class="line">        <span class="attr">uid</span> =&gt; <span class="number">2000</span>,</span><br><span class="line">        <span class="attr">shell</span> =&gt; <span class="string">&quot;/bin/sh&quot;</span>,</span><br><span class="line">        <span class="attr">home</span> =&gt; <span class="string">&quot;/home/centos&quot;</span>,</span><br><span class="line">        <span class="attr">ensure</span> =&gt; <span class="literal">present</span>,</span><br><span class="line">        <span class="attr">require</span> =&gt; Group[<span class="string">&#x27;centos&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然最简单的方法就是:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">group</span> &#123; <span class="string">&#x27;centos&#x27;</span>:</span><br><span class="line">        <span class="attr">gid</span> =&gt; <span class="number">2000</span>,</span><br><span class="line">        <span class="attr">ensure</span> =&gt; <span class="literal">present</span>,</span><br><span class="line">&#125; -&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">user</span> &#123; <span class="string">&quot;centos&quot;</span>:</span><br><span class="line">        <span class="attr">gid</span> =&gt; <span class="number">2000</span>,</span><br><span class="line">        <span class="attr">uid</span> =&gt; <span class="number">2000</span>,</span><br><span class="line">        <span class="attr">shell</span> =&gt; <span class="string">&quot;/bin/sh&quot;</span>,</span><br><span class="line">        <span class="attr">home</span> =&gt; <span class="string">&quot;/home/centos&quot;</span>,</span><br><span class="line">        <span class="attr">ensure</span> =&gt; <span class="literal">present</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样直接使用链式的方式来指明, 尤其在项目数量多的时候, 这样的链式方法更加清晰.</p><p>接下来就来应用一下通知和订阅, 还是使用Nginx来做演示, 我们先写一个:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> &#123;<span class="string">&quot;nginx&quot;</span>:</span><br><span class="line"><span class="attr">ensure</span> =&gt; installed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span> &#123;<span class="string">&quot;/etc/nginx/nginx.conf&quot;</span>:</span><br><span class="line"><span class="attr">ensure</span> =&gt; <span class="literal">present</span>,</span><br><span class="line"><span class="attr">source</span> =&gt; <span class="string">&quot;/root/nginx.conf&quot;</span>,</span><br><span class="line"><span class="attr">require</span> =&gt; Package[<span class="string">&#x27;nginx&#x27;</span>],</span><br><span class="line"><span class="attr">notify</span> =&gt; Service[<span class="string">&#x27;nginx&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service</span> &#123;<span class="string">&#x27;nginx&#x27;</span>:</span><br><span class="line"><span class="attr">hasrestart</span> =&gt; <span class="keyword">true</span>,</span><br><span class="line"><span class="attr">hasstatus</span> =&gt; <span class="keyword">true</span>,</span><br><span class="line"><span class="attr">enable</span> =&gt; <span class="keyword">true</span>,</span><br><span class="line"><span class="attr">ensure</span> =&gt; <span class="literal">running</span>,</span><br><span class="line"><span class="attr">require</span> =&gt; [ Package[<span class="string">&#x27;nginx&#x27;</span>], File[<span class="string">&#x27;/etc/nginx/nginx.conf&#x27;</span>] ],</span><br><span class="line"><span class="attr">restart</span> =&gt; <span class="string">&quot;service nginx reload&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们看一下当前的Nginx工作进程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># ps aux | grep nginx</span></span><br><span class="line">root      8002  0.0  0.0 108960  1860 ?        Ss   15:16   0:00 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">nginx     8005  0.0  0.0 109384  2708 ?        S    15:16   0:00 nginx: worker process</span><br><span class="line">nginx     8006  0.0  0.0 109384  2704 ?        S    15:16   0:07 nginx: worker process</span><br><span class="line">root     10370  0.0  0.0 103324   864 pts/0    S+   23:33   0:00 grep nginx</span><br></pre></td></tr></table></figure><p>接着我们修改一下<code>/root/nginx.conf</code>, 把里面的<code>worker_processes</code>修改成4, 接着再次执行这个puppet:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># puppet apply test9.pp</span></span><br><span class="line">Notice: Compiled catalog <span class="keyword">for</span> master <span class="keyword">in</span> environment production <span class="keyword">in</span> 0.55 seconds</span><br><span class="line">Notice: /Stage[main]/Main/File[/etc/nginx/nginx.conf]/content: content changed <span class="string">&#x27;&#123;md5&#125;1510a037b9fb468daa9fff6d3b5bdd90&#x27;</span> to <span class="string">&#x27;&#123;md5&#125;9a182199db0446eadfd93810907bbf09&#x27;</span></span><br><span class="line">Notice: /Stage[main]/Main/Service[nginx]: Triggered <span class="string">&#x27;refresh&#x27;</span> from 1 events</span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 6.94 seconds</span><br></pre></td></tr></table></figure><p>可以清晰的看到说明, 文件的md5值发生了改变, 再次查看一下work_processes:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># ps aux | grep nginx</span></span><br><span class="line">root      8002  0.0  0.1 109620  4656 ?        Ss   15:16   0:01 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">nginx    10602  0.0  0.0 110072  3400 ?        S    23:33   0:00 nginx: worker process</span><br><span class="line">nginx    10603  0.0  0.0 110072  3400 ?        S    23:33   0:00 nginx: worker process</span><br><span class="line">nginx    10604  0.0  0.0 110072  3400 ?        S    23:33   0:00 nginx: worker process</span><br><span class="line">nginx    10605  0.0  0.0 110072  3400 ?        S    23:33   0:00 nginx: worker process</span><br><span class="line">root     10607  0.0  0.0 103324   868 pts/0    S+   23:34   0:00 grep nginx</span><br></pre></td></tr></table></figure><p>生效了~</p><p>刚刚说过了可以使用<code>-&gt;</code>来链式的说明依赖关系, 我们也可以使用<code>~&gt;</code>来链式的说明通知关系.</p><h2 id="Puppet的其他语法"><a href="#Puppet的其他语法" class="headerlink" title="Puppet的其他语法"></a>Puppet的其他语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>首先由于Puppet使用Ruby, 所以基本上变量都遵循基本规则, 他的变量都使用<code>$</code>开头. 接着赋值符号是<code>=</code>. 并且, 在Puppet支持的所有变量类型中, 除了正则表达式其他所有的都可以直接赋值.</p><p>赋值方法同样支持<code>=</code>和<code>+=</code>两种. </p><p>接下来我们再来说一下Puppet的作用域.</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>Puppet的变量之间是可以进行隔离的, 这得益于他的作用域, 但是要先说明的是, 作用域不能隔离资源引用, 在全代码范围之内都是可以引用的.</p><p>作用域(Scope)分成全局作用域和节点作用域, 在Node Scope中, 我们将来会定义一些类, 甚至还可以进行类之间的嵌套. 即父类和子类.</p><p>因此在引用变量的时候就有两种形式的: 一种是相对路径引用, 一种是绝对路径引用 (例如: $::scope::scope::var )</p><p>接下来我们就来看一下puppet支持的变量类型有哪些吧.</p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li><p>字符型: 非结构化的文本字符串, 可以加上引号. 同样的, 单引号不替换变量, 双引号替换变量, 并且同样支持转义符</p></li><li><p>数值型:  支持整数和浮点数, 只有在数值的上下文中在把数值当成是数值型, 一般都当做字符型.</p></li><li><p>数组: 使用逗号分隔, 支持负数索引</p></li><li><p>布尔: 同样也有其他数据类型可以转换成为布尔类型</p></li><li><p>undef: undefined的意思</p></li><li><p>hash: 其实hash类型就是键值对类型呀</p></li><li><p>正则表达式( 非标准变量类型 )</p><ul><li><p>这个正则表达式的表现形式特别诡异, 首先他不能赋值给变量并且只能在一些特定的位置出现, 他的一个形式是这样的:</p></li><li><p>常见的option有这些: <code>i</code>: 忽略字符大小写, <code>m</code>: 把<code>.</code>当成是换行符, <code>x</code>: 忽略模式中的空白和注释</p></li><li><pre><code class="puppet">(?[-]&lt;[DIS|EN]ABLE-OPTION&gt;:&lt;SUBPATTERN&gt;)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">除了这些自定义的变量, Puppet还引入了很多factar变量和内置变量, 对于factor变量, 我们之前在说Ansible的时候就提到过, 这里, 我们可以使用下面的命令查看:</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">[root@master ~]# facter -p</span><br><span class="line">filesystems =&gt; ext4,iso9660</span><br><span class="line">fqdn =&gt; master</span><br><span class="line">gid =&gt; root</span><br><span class="line">hardwareisa =&gt; x86_64</span><br><span class="line">hardwaremodel =&gt; x86_64</span><br><span class="line">hostname =&gt; master</span><br><span class="line">id =&gt; root</span><br><span class="line">interfaces =&gt; eth0,lo</span><br><span class="line">ipaddress =&gt; 59.68.29.77</span><br><span class="line">ipaddress_eth0 =&gt; 59.68.29.77</span><br><span class="line">ipaddress_lo =&gt; 127.0.0.1</span><br><span class="line">is_virtual =&gt; true</span><br><span class="line">kernel =&gt; Linux</span><br><span class="line">kernelmajversion =&gt; 2.6</span><br><span class="line">kernelrelease =&gt; 2.6.32-696.13.2.el6.x86_64</span><br><span class="line">kernelversion =&gt; 2.6.32</span><br><span class="line">...</span><br><span class="line">macaddress =&gt; 00:50:56:AF:15:3B</span><br><span class="line">macaddress_eth0 =&gt; 00:50:56:AF:15:3B</span><br><span class="line">manufacturer =&gt; VMware, Inc.</span><br><span class="line">memoryfree =&gt; 1.05 GB</span><br><span class="line">memoryfree_mb =&gt; 1074.68</span><br><span class="line">memorysize =&gt; 3.74 GB</span><br><span class="line">memorysize_mb =&gt; 3832.41</span><br><span class="line">mtu_eth0 =&gt; 1500</span><br><span class="line">mtu_lo =&gt; 65536</span><br><span class="line">netmask =&gt; 255.255.255.0</span><br><span class="line">netmask_eth0 =&gt; 255.255.255.0</span><br><span class="line">netmask_lo =&gt; 255.0.0.0</span><br><span class="line">network_eth0 =&gt; 59.68.29.0</span><br><span class="line">network_lo =&gt; 127.0.0.0</span><br><span class="line">operatingsystem =&gt; CentOS</span><br><span class="line">operatingsystemmajrelease =&gt; 6</span><br><span class="line">operatingsystemrelease =&gt; 6.9</span><br><span class="line">...</span><br><span class="line">selinux =&gt; true</span><br><span class="line">....</span><br><span class="line">virtual =&gt; vmware</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>等等一大堆系统信息. ( 这个命令似乎已经过时了, 推荐使用<code>puppet facts</code> ) 上面这些都可以直接引用. 还可以引用一些内置变量例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 客户端</span></span><br><span class="line"><span class="variable">$clientversion</span></span><br><span class="line"><span class="variable">$clientcert</span></span><br><span class="line"><span class="comment">## 服务端</span></span><br><span class="line"><span class="variable">$servername</span></span><br><span class="line"><span class="variable">$serverip</span></span><br><span class="line"><span class="variable">$serverversion</span></span><br><span class="line"><span class="variable">$module_name</span></span><br></pre></td></tr></table></figure><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>基本的条件判断puppet也都支持, 例如<code>if</code>, <code>case</code>, <code>selector</code>, <code>unless</code></p><p>举个例子:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if <span class="variable">$processorcount</span> &gt; 1 &#123;</span><br><span class="line">notice(<span class="string">&quot;Yes!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">notice(<span class="string">&quot;Nooo!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果显然是:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># puppet apply test10.pp</span></span><br><span class="line">Notice: Scope(Class[main]): Yes!</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>接下来我们再来试试正则表达加上条件判断:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if <span class="variable">$operatingsystem</span> =~ /^(?i-mx:(centos|redhat))/ &#123;</span><br><span class="line">notice(<span class="string">&quot;welcome to $1 server!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">notice(<span class="string">&quot;I don&#x27;t know you.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># puppet apply test11.pp</span></span><br><span class="line">Notice: Scope(Class[main]): welcome to CentOS server!</span><br></pre></td></tr></table></figure><p>接着一个case的例子:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case <span class="variable">$operatingsystem</span> &#123;</span><br><span class="line">/(?i-mx:(redhat|ubuntu))/: &#123; notice(<span class="string">&quot;welcome to $1&quot;</span>) &#125;</span><br><span class="line"><span class="string">&quot;centos&quot;</span>,<span class="string">&quot;CentOS&quot;</span>,<span class="string">&quot;Centos&quot;</span>: &#123; notice(<span class="string">&quot;Centos&quot;</span>) &#125;</span><br><span class="line">default: &#123; notice(<span class="string">&quot;I dont&#x27;t know.&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果也很明显:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># puppet apply test12.pp</span></span><br><span class="line">Notice: Scope(Class[main]): Centos</span><br><span class="line">Notice: Compiled catalog <span class="keyword">for</span> master <span class="keyword">in</span> environment production <span class="keyword">in</span> 0.07 seconds</span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 0.06 seconds</span><br></pre></td></tr></table></figure><p>接下来再来说一下<code>Selector</code>, 什么玩意这是? 其实就是一个根据情况赋值变量, 看个例子就知道了:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$webserver</span> = <span class="variable">$operatingsystem</span> ? &#123;</span><br><span class="line">/(?i-mx:(ubuntu|debian))/ =&gt; <span class="string">&#x27;apache2&#x27;</span>,</span><br><span class="line">/(?i-mx:(redhat|centos|fedora))/ =&gt; <span class="string">&#x27;httpd&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据操作系统选择不同的值来赋给webserver.</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p> 我们可以通过创建可继承的<strong>类</strong>来在puppet的全局进行调用, 在这里, 类其实就可以理解成是一段被命名的代码块. </p><p>我们结合一个例子来介绍它:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">apache</span> &#123;</span><br><span class="line">        <span class="keyword">package</span> &#123;<span class="string">&quot;httpd&quot;</span>:</span><br><span class="line">                <span class="attr">ensure</span> =&gt; installed</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">file</span> &#123;<span class="string">&quot;httpd.conf&quot;</span>:</span><br><span class="line">                <span class="attr">ensure</span> =&gt; file,</span><br><span class="line">                <span class="attr">path</span> =&gt; <span class="string">&quot;/etc/httpd/conf/httpd.conf&quot;</span>,</span><br><span class="line">                <span class="attr">require</span> =&gt; Package[<span class="string">&#x27;httpd&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">service</span> &#123;<span class="string">&quot;httpd&quot;</span>:</span><br><span class="line">                <span class="attr">require</span> =&gt; Package[<span class="string">&#x27;httpd&#x27;</span>],</span><br><span class="line">                <span class="attr">subscribe</span> =&gt; File[<span class="string">&#x27;httpd.conf&#x27;</span>],</span><br><span class="line">                <span class="attr">ensure</span> =&gt; <span class="literal">running</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 类名必须使用小写字母开头, 可以包含小写字母, 数字, 下划线. 前面说过Scope的概念, 每次我们声明一个类, 就会引入一个新的作用域, 这个时候, 如果是要引用这个作用域中的变量的话, 就需要使用完全限定名称.</p><p>现在直接执行的话, 不会有任何效果, 原因就是现在只是定义了类, 如果想要让它起到效果的话就需要声明他,声明一个类的方式主要有四种:</p><ul><li>使用<code>include</code>来声明一个类</li><li>像定义资源一样定义一个类(不加任何参数)来声明他</li><li>使用<code>require</code>来声明一个类</li></ul><p>我们来一个一个看, 首先是<code>include</code></p><p>我们再刚刚定义类的那个文件的最后加上一句:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include apache</span><br></pre></td></tr></table></figure><p>接着正常执行试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># puppet apply -v test13.pp</span></span><br><span class="line">Notice: Compiled catalog <span class="keyword">for</span> master <span class="keyword">in</span> environment production <span class="keyword">in</span> 5.15 seconds</span><br><span class="line">Info: Applying configuration version <span class="string">&#x27;1511097112&#x27;</span></span><br><span class="line">Notice: /Stage[main]/Apache/Package[httpd]/ensure: created</span><br><span class="line">Notice: /Stage[main]/Apache/Service[httpd]/ensure: ensure changed <span class="string">&#x27;stopped&#x27;</span> to <span class="string">&#x27;running&#x27;</span></span><br><span class="line">Info: /Stage[main]/Apache/Service[httpd]: Unscheduling refresh on Service[httpd]</span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 188.24 seconds</span><br></pre></td></tr></table></figure><p>类还可以传递参数, 就像函数一样. 没想到吧, 我们再来举个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class nginx($server=&#x27;nginx&#x27;) &#123;</span><br><span class="line">        package &#123;$server:</span><br><span class="line">                ensure =&gt; installed</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        file &#123;&quot;/etc/nginx/nginx.conf&quot;:</span><br><span class="line">                ensure =&gt; present,</span><br><span class="line">                source =&gt; &quot;/root/nginx.conf&quot;,</span><br><span class="line">                require =&gt; Package[$server],</span><br><span class="line">                notify =&gt; Service[&#x27;nginx&#x27;]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        service &#123;&#x27;nginx&#x27;:</span><br><span class="line">                hasrestart =&gt; true,</span><br><span class="line">                hasstatus =&gt; true,</span><br><span class="line">                enable =&gt; true,</span><br><span class="line">                ensure =&gt; running,</span><br><span class="line">                require =&gt; [ Package[$server], File[&#x27;/etc/nginx/nginx.conf&#x27;] ],</span><br><span class="line">                restart =&gt; &quot;service nginx reload&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里, 我们在class的开头定义了一个<code>$server</code>参数, 并且给了他一个默认值. 那么怎么调用它, 给他传参数呢? 就像这样:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &#123;<span class="string">&quot;nginx&quot;</span>:</span><br><span class="line">        server =&gt; <span class="string">&#x27;tengine&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以了. ( 不过当前好像没有收录tengine的yum源, 所以肯定会报错的啦, 你可以把tengine改成nginx跑一遍.. )</p><p>使用<code>nginx</code>做传入参数的执行结果参考:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Notice: Compiled catalog <span class="keyword">for</span> master <span class="keyword">in</span> environment production <span class="keyword">in</span> 0.61 seconds</span><br><span class="line">Info: Applying configuration version <span class="string">&#x27;1511099152&#x27;</span></span><br><span class="line">Notice: /Stage[main]/Nginx/Package[nginx]/ensure: created</span><br><span class="line">Info: Computing checksum on file /etc/nginx/nginx.conf</span><br><span class="line">Info: FileBucket got a duplicate file &#123;md5&#125;1510a037b9fb468daa9fff6d3b5bdd90</span><br><span class="line">Info: /Stage[main]/Nginx/File[/etc/nginx/nginx.conf]: Filebucketed /etc/nginx/nginx.conf to puppet with <span class="built_in">sum</span> 1510a037b9fb468daa9fff6d3b5bdd90</span><br><span class="line">Notice: /Stage[main]/Nginx/File[/etc/nginx/nginx.conf]/content: content changed <span class="string">&#x27;&#123;md5&#125;1510a037b9fb468daa9fff6d3b5bdd90&#x27;</span> to <span class="string">&#x27;&#123;md5&#125;1cf93649e4d6f892a34c08cfb26d6d6e&#x27;</span></span><br><span class="line">Info: /Stage[main]/Nginx/File[/etc/nginx/nginx.conf]: Scheduling refresh of Service[nginx]</span><br><span class="line">Notice: /Stage[main]/Nginx/Service[nginx]/ensure: ensure changed <span class="string">&#x27;stopped&#x27;</span> to <span class="string">&#x27;running&#x27;</span></span><br><span class="line">Info: /Stage[main]/Nginx/Service[nginx]: Unscheduling refresh on Service[nginx]</span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 14.77 seconds</span><br></pre></td></tr></table></figure><h4 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h4><p>类之间是支持继承的, 而定义子类的方式像这样:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">base_class</span> &#123;</span><br><span class="line">  ...code...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">base_class::class_name</span> <span class="title">inherits</span> <span class="title">base_class</span> &#123;</span><br><span class="line">  ...code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说明一下, 定义子类的名字其实没有必要些之前的<code>base_class::</code>这些的. 另外, 在我们定义子类的时候, 父类会被先自动的首先声明. </p><p>子类有什么用处呢, 还是以我们的Nginx来举个例子, 可能在某些场景下, 我们发Nginx是用来做代理的, 有的场景下, 我们的Nginx是用来做HTTP服务器的, 等等, 但是他们都有一个共同点, 那就是都需要安装Nginx程序包, 都需运行Nginx服务, 也就是说他们之间的不同点就在于配置文件的差异, 所以, 我们完全就可以将package和service当做父类, 为这个父类提供不同的子类(file)就可以节省代码, 实现重用. 来看一个示例:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">nginx</span> &#123;</span><br><span class="line">        <span class="keyword">package</span> &#123;<span class="string">&#x27;nginx&#x27;</span>:</span><br><span class="line">                <span class="attr">ensure</span> =&gt; installed</span><br><span class="line">        &#125; -&gt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">service</span> &#123;<span class="string">&#x27;nginx&#x27;</span>:</span><br><span class="line">                <span class="attr">restart</span> =&gt; <span class="string">&#x27;service nginx reload&#x27;</span>,</span><br><span class="line">                <span class="attr">hasstatus</span> =&gt; <span class="keyword">true</span>,</span><br><span class="line">                <span class="attr">hasrestart</span> =&gt; <span class="keyword">true</span>,</span><br><span class="line">                <span class="attr">ensure</span> =&gt; <span class="literal">running</span>,</span><br><span class="line">                <span class="attr">enable</span> =&gt; <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">nginx::http</span> <span class="title">inherits</span> <span class="title">nginx</span> &#123;</span><br><span class="line">        <span class="keyword">file</span> &#123; <span class="string">&#x27;/etc/nginx/nginx.conf&#x27;</span>:</span><br><span class="line">                <span class="attr">ensure</span> =&gt; file,</span><br><span class="line">                <span class="attr">notify</span> =&gt; Service[<span class="string">&#x27;nginx&#x27;</span>],</span><br><span class="line">                <span class="attr">source</span> =&gt; <span class="string">&quot;/root/nginx/nginx_http.conf&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">nginx::proxy</span> <span class="title">inherits</span> <span class="title">nginx</span> &#123;</span><br><span class="line">        <span class="keyword">file</span> &#123;<span class="string">&#x27;/etc/nginx/nginx.conf&#x27;</span>:</span><br><span class="line">                <span class="attr">ensure</span> =&gt; file,</span><br><span class="line">                <span class="attr">notify</span> =&gt; Service[<span class="string">&#x27;nginx&#x27;</span>],</span><br><span class="line">                <span class="attr">source</span> =&gt; <span class="string">&quot;/root/nginx/nginx_proxy.conf&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是像刚刚所说的, 重用安装包和服务的Nginx在不同场景下的应用.</p><p>通过子类, 我们还可以使用更高级的特性 — 覆盖父类的资源属性.</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">nginx::http</span> <span class="title">inherits</span> <span class="title">nginx</span> &#123;</span><br><span class="line">Package[<span class="string">&#x27;nginx&#x27;</span>] &#123;</span><br><span class="line">name =&gt; <span class="string">&#x27;tengine&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">file</span> &#123; <span class="string">&#x27;/etc/nginx/nginx.conf&#x27;</span>:</span><br><span class="line"><span class="attr">ensure</span> =&gt; file,</span><br><span class="line"><span class="attr">notify</span> =&gt; Service[<span class="string">&#x27;nginx&#x27;</span>],</span><br><span class="line"><span class="attr">source</span> =&gt; <span class="string">&quot;/root/nginx/nginx_http.conf&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里, 我们先引用父类的Package资源, 接着修改nameVar, 接着引入这个子类执行它, 可以从执行结果看出, 确实已经在尝试安装tengine了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">otice: Compiled catalog <span class="keyword">for</span> master <span class="keyword">in</span> environment production <span class="keyword">in</span> 0.58 seconds</span><br><span class="line">Info: Applying configuration version <span class="string">&#x27;1511163767&#x27;</span></span><br><span class="line">Error: Execution of <span class="string">&#x27;/usr/bin/yum -d 0 -e 0 -y list tengine&#x27;</span> returned 1: Error: No matching Packages to list</span><br><span class="line">Error: /Stage[main]/Nginx/Package[nginx]/ensure: change from absent to present failed: Execution of <span class="string">&#x27;/usr/bin/yum -d 0 -e 0 -y list tengine&#x27;</span> returned 1: Error: No matching Packages to list</span><br><span class="line">Notice: /Stage[main]/Nginx/Service[nginx]: Dependency Package[nginx] has failures: <span class="literal">true</span></span><br><span class="line">Warning: /Stage[main]/Nginx/Service[nginx]: Skipping because of failed dependencies</span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 77.87 seconds</span><br></pre></td></tr></table></figure><p> 同样的, 我们还可以追加新值, 使用<code>+&gt;</code>来追加.</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>和之前的Ansible所使用的Jinja2类似, Puppet使用的是Ruby的模板语言, 叫做<code>ERB</code>, 即<code>Embedded RuBy</code>. 其实和JSP以及ejs都十分相像. </p><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">&lt;%</span><span class="language-ruby"> <span class="title class_">Ruby</span> <span class="title class_">Expression</span> </span><span class="language-xml">%&gt;</span></span><br><span class="line"><span class="language-xml">&lt;%</span><span class="language-ruby"> <span class="comment">#Comment </span></span><span class="language-xml">%&gt;</span></span><br><span class="line"><span class="language-xml">&lt;%%</span><span class="language-ruby"> == &lt;%</span></span><br><span class="line"><span class="language-ruby"></span><span class="language-xml">%%&gt; == %&gt;</span></span><br><span class="line"><span class="language-xml">&lt;%-</span><span class="language-ruby"> <span class="title class_">Ruby</span> <span class="title class_">Code</span> </span><span class="language-xml">%&gt; 忽略空白字符</span></span><br><span class="line"><span class="language-xml">&lt;%</span><span class="language-ruby"> <span class="title class_">Ruby</span> <span class="title class_">Code</span> </span><span class="language-xml">-%&gt; 忽略空白行</span></span><br></pre></td></tr></table></figure><p>当然在这里面也是可以引用Puppet的变量的, 但是此时就需要使用<code>@</code>字符开头</p><p>另外, 基本的循环和迭代语法是这样的:</p><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"># 循环</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&lt;%</span><span class="language-ruby"> <span class="keyword">if</span> <span class="variable constant_">CONDTION</span> </span><span class="language-xml">-%&gt;</span></span><br><span class="line"><span class="language-xml">some text</span></span><br><span class="line"><span class="language-xml">&lt;%</span><span class="language-ruby"> <span class="keyword">end</span> </span><span class="language-xml">%&gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&lt;%</span><span class="language-ruby"> <span class="keyword">if</span> <span class="variable constant_">CONDITION</span> </span><span class="language-xml">-%&gt;</span></span><br><span class="line"><span class="language-xml">some text</span></span><br><span class="line"><span class="language-xml">&lt;%</span><span class="language-ruby"> <span class="keyword">else</span> </span><span class="language-xml">%&gt;</span></span><br><span class="line"><span class="language-xml">some text</span></span><br><span class="line"><span class="language-xml">&lt;%</span><span class="language-ruby"> <span class="keyword">end</span> </span><span class="language-xml">%&gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"># 迭代</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&lt;%</span><span class="language-ruby"> <span class="variable">@ArrayName</span>.echo <span class="keyword">do</span> |<span class="params"> Var_name </span>| </span><span class="language-xml">-%&gt;</span></span><br><span class="line"><span class="language-xml">some text with &lt;%=</span><span class="language-ruby"> <span class="title class_">Var</span>_name  </span><span class="language-xml">%&gt;</span></span><br><span class="line"><span class="language-xml">&lt;%</span><span class="language-ruby"> <span class="keyword">end</span> </span><span class="language-xml">%&gt;</span></span><br></pre></td></tr></table></figure><p>我们使用之前的Nginx配置文件来实践一下这个:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="attribute">worker_processes</span> &lt;% <span class="variable">@processorcount</span> %&gt;;</span><br></pre></td></tr></table></figure><p>接下来我们的puppet清单也要修改一下:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">nginx::proxy</span> <span class="title">inherits</span> <span class="title">nginx</span> &#123;</span><br><span class="line"><span class="keyword">file</span> &#123;<span class="string">&#x27;/etc/nginx/nginx.conf&#x27;</span>:</span><br><span class="line"><span class="attr">ensure</span> =&gt; file,</span><br><span class="line"><span class="attr">notify</span> =&gt; Service[<span class="string">&#x27;nginx&#x27;</span>],</span><br><span class="line"><span class="attr">content</span> =&gt; template(<span class="string">&#x27;/root/nginx/nginx_proxy.conf&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">include nginx::proxy</span><br></pre></td></tr></table></figure><p>这里我们使用的tempalate函数会将目标文件处理成文本流文件, 所以我们要把source修改成content.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Notice: Compiled catalog <span class="keyword">for</span> master <span class="keyword">in</span> environment production <span class="keyword">in</span> 0.60 seconds</span><br><span class="line">Info: Applying configuration version <span class="string">&#x27;1511166414&#x27;</span></span><br><span class="line">Info: Computing checksum on file /etc/nginx/nginx.conf</span><br><span class="line">Info: /Stage[main]/Nginx::Proxy/File[/etc/nginx/nginx.conf]: Filebucketed /etc/nginx/nginx.conf to puppet with <span class="built_in">sum</span> 90cc6772f4dd26a421ce78358801ec95</span><br><span class="line">Notice: /Stage[main]/Nginx::Proxy/File[/etc/nginx/nginx.conf]/content: content changed <span class="string">&#x27;&#123;md5&#125;90cc6772f4dd26a421ce78358801ec95&#x27;</span> to <span class="string">&#x27;&#123;md5&#125;9d140bc8d6be6be51c471322210b9393&#x27;</span></span><br><span class="line">Info: /Stage[main]/Nginx::Proxy/File[/etc/nginx/nginx.conf]: Scheduling refresh of Service[nginx]</span><br><span class="line">Notice: /Stage[main]/Nginx/Service[nginx]/ensure: ensure changed <span class="string">&#x27;stopped&#x27;</span> to <span class="string">&#x27;running&#x27;</span></span><br><span class="line">Info: /Stage[main]/Nginx/Service[nginx]: Unscheduling refresh on Service[nginx]</span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 5.16 seconds</span><br><span class="line">[root@master manifest]<span class="comment"># head /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="comment"># For more information on configuration, see:</span></span><br><span class="line"><span class="comment">#   * Official English Documentation: http://nginx.org/en/docs/</span></span><br><span class="line"><span class="comment">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span></span><br><span class="line"></span><br><span class="line">user nginx;</span><br><span class="line">worker_processes 2;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load dynamic modules. See /usr/share/nginx/README.dynamic.</span></span><br></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>最后再来说下模块的概念. 这里和Ansible和Role几乎一样的概念, 就是有层次的组织起来需要的资源清单文件, 并且分成多个文件进行模块式的调用. 具体的文件组织是这样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module_name/</span><br><span class="line">manifest/</span><br><span class="line">init.pp: 至少包含一个和模块同名的类</span><br><span class="line">files: 静态文件 (puppet:///modules/module_name/file_name)</span><br><span class="line">templates: 模板文件路径 (module_name/template_name)</span><br><span class="line">libs: 插件目录</span><br><span class="line">tests: 示例和帮助</span><br><span class="line">spec: 插件的tests目录</span><br></pre></td></tr></table></figure><p>Puppet自己有一个命令可以用来管理模块:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># puppet help module</span></span><br><span class="line"></span><br><span class="line">USAGE: puppet module &lt;action&gt; [--environment production ]</span><br><span class="line">[--modulepath <span class="variable">$basemodulepath</span> ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This subcommand can find, install, and manage modules from the Puppet Forge,</span><br><span class="line">a repository of user-contributed Puppet code. It can also generate empty</span><br><span class="line">modules, and prepare locally developed modules <span class="keyword">for</span> release on the Forge.</span><br></pre></td></tr></table></figure><p>他自己还有一个Forge, 这意味着我们可以上传自己模块和下载别人写好的模块.</p><p>创建一个模块是十分容易的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># mkdir -pv /etc/puppet/modules/nginx/&#123;manifests,files,templates,tests,lib,spec&#125;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `/etc/puppet/modules/nginx<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `/etc/puppet/modules/nginx/manifests&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `/etc/puppet/modules/nginx/files<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `/etc/puppet/modules/nginx/templates&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `/etc/puppet/modules/nginx/tests<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `/etc/puppet/modules/nginx/lib&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `/etc/puppet/modules/nginx/spec<span class="string">&#x27;</span></span><br><span class="line"><span class="string">[root@master manifest]# puppet module list</span></span><br><span class="line"><span class="string">/etc/puppet/modules</span></span><br><span class="line"><span class="string">└── nginx (???)</span></span><br><span class="line"><span class="string">/usr/share/puppet/modules (no modules installed)</span></span><br></pre></td></tr></table></figure><p>接下来我们就可以把之前写的清单文件扔到固定的位置去了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifest]<span class="comment"># cp test16.pp /etc/puppet/modules/nginx/manifests/init.pp</span></span><br><span class="line">[root@master manifest]<span class="comment"># cp /root/nginx/nginx_http.conf /etc/puppet/modules/nginx/files/</span></span><br><span class="line">[root@master manifest]<span class="comment"># cp /root/nginx/nginx_proxy.conf /etc/puppet/modules/nginx/templates/nginx_proxy.conf.erb</span></span><br></pre></td></tr></table></figure><p>当然路径什么的是需要修改的, 并且再把声明语句去除. </p><p>此时我们就可以这么执行: ( –noop表示不执行 )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifests]<span class="comment"># puppet apply --noop -v -e &quot;include nginx::proxy&quot;</span></span><br><span class="line">Notice: Compiled catalog <span class="keyword">for</span> master <span class="keyword">in</span> environment production <span class="keyword">in</span> 0.59 seconds</span><br><span class="line">Info: Applying configuration version <span class="string">&#x27;1511167958&#x27;</span></span><br><span class="line">Notice: /Stage[main]/Nginx::Proxy/File[/etc/nginx/nginx.conf]/ensure: current_value absent, should be file (noop)</span><br><span class="line">Info: /Stage[main]/Nginx::Proxy/File[/etc/nginx/nginx.conf]: Scheduling refresh of Service[nginx]</span><br><span class="line">Notice: Class[Nginx::Proxy]: Would have triggered <span class="string">&#x27;refresh&#x27;</span> from 1 events</span><br><span class="line">Notice: /Stage[main]/Nginx/Package[nginx]/ensure: current_value absent, should be present (noop)</span><br><span class="line">Notice: /Stage[main]/Nginx/Service[nginx]/ensure: current_value stopped, should be running (noop)</span><br><span class="line">Info: /Stage[main]/Nginx/Service[nginx]: Unscheduling refresh on Service[nginx]</span><br><span class="line">Notice: Class[Nginx]: Would have triggered <span class="string">&#x27;refresh&#x27;</span> from 2 events</span><br><span class="line">Notice: Stage[main]: Would have triggered <span class="string">&#x27;refresh&#x27;</span> from 2 events</span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 1.32 seconds</span><br></pre></td></tr></table></figure><p>使用<code>-e</code>参数加上puppet代码语句来执行, 可以看到模块是生效的.</p><h2 id="Puppet的master-agent模型实现"><a href="#Puppet的master-agent模型实现" class="headerlink" title="Puppet的master-agent模型实现"></a>Puppet的master-agent模型实现</h2><p>我们之前说过的master-agent模型的相关信息, agent会定期的去向服务器端去发送catalog的请求,该请求中会携带自己的fact信息和自己的节点名称 服务端收到请求之后会去辨别客户端的身份. 在这个过程中, agent和master之间会通过ssl进行双向的认证.  这里, 我们使用的是节点名称而不是IP地址. 这就是说, 在我们的Puppet主从模型中, DNS服务是一个至关重要的部分. </p><p>默认的请求间隔时间是30min. master收到之后会去查找对应的清单并去编译它, 最后将生成的catalog发送给agent. 对于master端, 他工作在8140&#x2F;tcp端口</p><p>我们再master节点上安装puppet-server程序包, 来看一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># rpm -ql puppet-server</span></span><br><span class="line">/etc/puppet/environments</span><br><span class="line">/etc/puppet/environments/example_env</span><br><span class="line">/etc/puppet/environments/example_env/README.environment</span><br><span class="line">/etc/puppet/environments/example_env/manifests</span><br><span class="line">/etc/puppet/environments/example_env/modules</span><br><span class="line">/etc/puppet/fileserver.conf</span><br><span class="line">/etc/puppet/manifests</span><br><span class="line">/etc/rc.d/init.d/puppetmaster</span><br><span class="line">/etc/rc.d/init.d/puppetqueue</span><br><span class="line">/etc/sysconfig/puppetmaster</span><br><span class="line">/usr/share/man/man8/puppet-ca.8.gz</span><br><span class="line">/usr/share/man/man8/puppet-master.8.gz</span><br></pre></td></tr></table></figure><p>安装生成的文件很简单, 其实主要是两个配置文件和daemon.</p><p>按照惯例, 我们现在应该去看一下配置文件了, 首先就是<code>/etc/puppet/puppet.conf</code>这个主配置文件, 里面主要是两个部分:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line">    <span class="comment"># The Puppet log directory.</span></span><br><span class="line">    <span class="comment"># The default value is &#x27;$vardir/log&#x27;.</span></span><br><span class="line">    logdir = /var/log/puppet</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Where Puppet PID files are kept.</span></span><br><span class="line">    <span class="comment"># The default value is &#x27;$vardir/run&#x27;.</span></span><br><span class="line">    rundir = /var/run/puppet</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Where SSL certificates are kept.</span></span><br><span class="line">    <span class="comment"># The default value is &#x27;$confdir/ssl&#x27;.</span></span><br><span class="line">    ssldir = <span class="variable">$vardir</span>/ssl</span><br><span class="line"></span><br><span class="line">[agent]</span><br><span class="line">    <span class="comment"># The file in which puppetd stores a list of the classes</span></span><br><span class="line">    <span class="comment"># associated with the retrieved configuratiion.  Can be loaded in</span></span><br><span class="line">    <span class="comment"># the separate ``puppet`` executable using the ``--loadclasses``</span></span><br><span class="line">    <span class="comment"># option.</span></span><br><span class="line">    <span class="comment"># The default value is &#x27;$confdir/classes.txt&#x27;.</span></span><br><span class="line">    classfile = <span class="variable">$vardir</span>/classes.txt</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Where puppetd caches the local configuration.  An</span></span><br><span class="line">    <span class="comment"># extension indicating the cache format is added automatically.</span></span><br><span class="line">    <span class="comment"># The default value is &#x27;$confdir/localconfig&#x27;.</span></span><br><span class="line">    localconfig = <span class="variable">$vardir</span>/localconfig</span><br></pre></td></tr></table></figure><p>其中main中的设定是用于全局的, 而agent显然就只是用于agent端的. 显然这是一个ini风格的配置, 而且还可以引用之前定义的值. </p><p>关于配置, 我们可以使用<code>puppet config print</code>来获取所有的当前配置, 并可以通过<code>puppet config set</code>来设置.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># puppet config print</span></span><br><span class="line">dbname = puppet</span><br><span class="line">thin_storeconfigs = <span class="literal">false</span></span><br><span class="line">disable_per_environment_manifest = <span class="literal">false</span></span><br><span class="line">max_warnings = 10</span><br><span class="line">ignoremissingtypes = <span class="literal">false</span></span><br><span class="line">cfacter = <span class="literal">false</span></span><br><span class="line">ssl_server_ca_auth =</span><br><span class="line">yamldir = /var/lib/puppet/yaml</span><br><span class="line">rundir = /var/run/puppet</span><br><span class="line">genmanifest = <span class="literal">false</span></span><br><span class="line">smtpserver = none</span><br><span class="line">http_keepalive_timeout = 4</span><br><span class="line">templatedir = /var/lib/puppet/templates</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>另外, 我们还有puppet master和puppet agent两个子命令分别来实现master和agent的运行, 其实这里主要就是一些前后台的启动以及一些启动选项.</p><p>关于上面的配置文件, 我们是可以自动的生成一份出来的, 使用的就是master的—genconfig选项 对于agent端, 我们就需要使用agent的这个选项了. 但是注意: **生成新的配置之前不能删除或者移动原有的&#x2F;etc&#x2F;puppet&#x2F;puppet.conf **, 而且: <strong>诡异的是, 生成的配置文件可能包含该版本不兼容的选项, 以及不兼容的默认值</strong></p><p>如果想要获得Puppet详尽的配置文档, 可以使用puppet doc. 在这里文档是分段的, 我们通过-r 加上reference_name就可以了, name们可以通过puppet doc —list获取.</p><p>现在我们就来试试运行puppet master吧: ( 首先我们应该确保节点之间的名称解析没有问题 )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># puppet master -v --no-daemonize</span></span><br><span class="line">Info: Creating a new SSL key <span class="keyword">for</span> master</span><br><span class="line">Info: csr_attributes file loading from /etc/puppet/csr_attributes.yaml</span><br><span class="line">Info: Creating a new SSL certificate request <span class="keyword">for</span> master</span><br><span class="line">Info: Certificate Request fingerprint (SHA256): C2:DE:BF:FC:1E:40:6D:34:AA:D1:D4:57:1B:8F:AF:93:09:BE:31:D7:4A:AF:65:97:09:A8:ED:48:FC:BC:52:FA</span><br><span class="line">Notice: master has a waiting certificate request</span><br><span class="line">Notice: Signed certificate request <span class="keyword">for</span> master</span><br><span class="line">Notice: Removing file Puppet::SSL::CertificateRequest master at <span class="string">&#x27;/var/lib/puppet/ssl/ca/requests/master.pem&#x27;</span></span><br><span class="line">Notice: Removing file Puppet::SSL::CertificateRequest master at <span class="string">&#x27;/var/lib/puppet/ssl/certificate_requests/master.pem&#x27;</span></span><br><span class="line">Notice: Starting Puppet master version 3.8.7</span><br><span class="line">^CNotice: Caught INT; exiting</span><br></pre></td></tr></table></figure><p>我们可以看到, 当前的主机已经自己成为了一个CA, 自己生成证书请求并且签署了自己的证书. </p><p>接下来我们还是把它当做一个后台服务跑起来.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># service puppetmaster start</span></span><br><span class="line">Starting puppetmaster:                                     [  OK  ]</span><br><span class="line">[root@master ~]<span class="comment"># ss -tnl</span></span><br><span class="line">State      Recv-Q Send-Q                                               Local Address:Port                                                 Peer Address:Port</span><br><span class="line">LISTEN     0      5                                                                *:8140                                                            *:*</span><br></pre></td></tr></table></figure><p>已经监听在了自己的端口上.</p><p>现在我们就可以尝试启动一个客户端试试: ( 这一次先不正式启动, 因此加入test和noop的dry-run参数 )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@agent ~]<span class="comment"># puppet agent --verbose --noop --no-daemonize --test --server master</span></span><br><span class="line">Info: Creating a new SSL key <span class="keyword">for</span> agent</span><br><span class="line">Info: Caching certificate <span class="keyword">for</span> ca</span><br><span class="line">Info: csr_attributes file loading from /etc/puppet/csr_attributes.yaml</span><br><span class="line">Info: Creating a new SSL certificate request <span class="keyword">for</span> agent</span><br><span class="line">Info: Certificate Request fingerprint (SHA256): 30:9E:60:EA:2B:71:9D:27:11:05:57:C0:37:5E:A4:90:C5:4F:BE:96:73:1F:2E:8A:1E:F2:2F:6B:0D:AA:89:99</span><br><span class="line">Info: Caching certificate <span class="keyword">for</span> ca</span><br><span class="line">Exiting; no certificate found and waitforcert is disabled</span><br></pre></td></tr></table></figure><blockquote><p>脱坑指南: 如果你的Puppet客户端出现No route to host - connect(2)之类的报错, 那么你可以先检查一下Puppet服务端的iptables是否打开了8140TCP的ACCEPT策略</p></blockquote><p>我们可以从输出信息看到, 客户端生成了一个证书签署请求发送给了master端. 现在我们让客户端跑起来然后去master端看看怎么签署证书吧. 在服务端, 我们使用个cert子命令来进行证书的管理, 包括签署, 撤销, 验证, 清理等等.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># puppet cert list</span></span><br><span class="line">  <span class="string">&quot;agent&quot;</span> (SHA256) 30:9E:60:EA:2B:71:9D:27:11:05:57:C0:37:5E:A4:90:C5:4F:BE:96:73:1F:2E:8A:1E:F2:2F:6B:0D:AA:89:99</span><br></pre></td></tr></table></figure><p>可以看到刚刚我们发出的证书请求. 接着就来把它签了吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># puppet cert sign --all</span></span><br><span class="line">Notice: Signed certificate request <span class="keyword">for</span> agent</span><br><span class="line">Notice: Removing file Puppet::SSL::CertificateRequest agent at <span class="string">&#x27;/var/lib/puppet/ssl/ca/requests/agent.pem&#x27;</span></span><br></pre></td></tr></table></figure><p> 接着我们再启动一次客户端:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@agent ~]<span class="comment"># puppet agent --verbose --no-daemonize --server master</span></span><br><span class="line">Info: Caching certificate <span class="keyword">for</span> agent</span><br><span class="line">Info: Caching certificate_revocation_list <span class="keyword">for</span> ca</span><br><span class="line">Info: Caching certificate <span class="keyword">for</span> agent</span><br><span class="line">Notice: Starting Puppet client version 3.8.7</span><br><span class="line">Info: Retrieving pluginfacts</span><br><span class="line">Info: Retrieving plugin</span><br><span class="line">Info: Caching catalog <span class="keyword">for</span> agent</span><br><span class="line">Info: Applying configuration version <span class="string">&#x27;1511263299&#x27;</span></span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 0.07 seconds</span><br></pre></td></tr></table></figure><p>得到了证书也是就可以通信了.</p><p>接着我们之前说过, 在服务端我们需要配置需要用到的模块, 还需要一个站点清单, 这个清单文件在哪里呢? </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># ls /etc/puppet/</span></span><br><span class="line">auth.conf  environments  fileserver.conf  manifests  modules  puppet.conf</span><br><span class="line">[root@master ~]<span class="comment"># cd /etc/puppet/manifests/</span></span><br><span class="line">[root@master manifests]<span class="comment"># ls</span></span><br><span class="line">[root@master manifests]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>我们需要在这里面创建一个叫做<code>site.pp</code>的文件. 另外, 我们之前显示过当前安装的模块有哪些, 这个搜索路径是怎么定的呢? </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@master manifests]<span class="comment"># puppet module list</span></span><br><span class="line">/etc/puppet/modules</span><br><span class="line">└── nginx (???)</span><br><span class="line">/usr/share/puppet/modules (no modules installed)</span><br><span class="line">[root@master manifests]<span class="comment"># puppet config print modulepath</span></span><br><span class="line">/etc/puppet/modules:/usr/share/puppet/modules</span><br></pre></td></tr></table></figure><p> 接着回到我们的<code>site.pp</code>, 这个文件怎么写呢 其实很简单的, 来看一个示例:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node <span class="string">&quot;agent&quot;</span> &#123;</span><br><span class="line">include nginx::proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>十分简单 使用node加上你的node_name 然后括号里面还是puppet_code就可以了. 这个时候我们再来尝试执行一次客户端:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@agent ~]<span class="comment"># puppet agent --verbose --no-daemonize --server master --noop</span></span><br><span class="line">Notice: Starting Puppet client version 3.8.7</span><br><span class="line">Info: Retrieving pluginfacts</span><br><span class="line">Info: Retrieving plugin</span><br><span class="line">Info: Caching catalog <span class="keyword">for</span> agent</span><br><span class="line">Info: Applying configuration version <span class="string">&#x27;1511265661&#x27;</span></span><br><span class="line">Notice: /Stage[main]/Nginx::Proxy/File[/etc/nginx/nginx.conf]/ensure: current_value absent, should be file (noop)</span><br><span class="line">Info: /Stage[main]/Nginx::Proxy/File[/etc/nginx/nginx.conf]: Scheduling refresh of Service[nginx]</span><br><span class="line">Notice: Class[Nginx::Proxy]: Would have triggered <span class="string">&#x27;refresh&#x27;</span> from 1 events</span><br><span class="line">Notice: /Stage[main]/Nginx/Package[nginx]/ensure: current_value absent, should be present (noop)</span><br><span class="line">Notice: /Stage[main]/Nginx/Service[nginx]/ensure: current_value stopped, should be running (noop)</span><br><span class="line">Info: /Stage[main]/Nginx/Service[nginx]: Unscheduling refresh on Service[nginx]</span><br><span class="line">Notice: Class[Nginx]: Would have triggered <span class="string">&#x27;refresh&#x27;</span> from 2 events</span><br><span class="line">Notice: Stage[main]: Would have triggered <span class="string">&#x27;refresh&#x27;</span> from 2 events</span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 16.52 seconds</span><br></pre></td></tr></table></figure><p>看, 已经起到效果了.  接下来我们就直接应用一下看看吧 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@agent ~]<span class="comment"># puppet agent --verbose --no-daemonize --server master</span></span><br><span class="line">Notice: Starting Puppet client version 3.8.7</span><br><span class="line">Info: Retrieving pluginfacts</span><br><span class="line">Info: Retrieving plugin</span><br><span class="line">Info: Caching catalog <span class="keyword">for</span> agent</span><br><span class="line">Info: Applying configuration version <span class="string">&#x27;1511266440&#x27;</span></span><br><span class="line">Notice: /Stage[main]/Nginx/Package[nginx]/ensure: created</span><br><span class="line">Info: Computing checksum on file /etc/nginx/nginx.conf</span><br><span class="line">Info: /Stage[main]/Nginx::Proxy/File[/etc/nginx/nginx.conf]: Filebucketed /etc/nginx/nginx.conf to puppet with <span class="built_in">sum</span> 1510a037b9fb468daa9fff6d3b5bdd90</span><br><span class="line">Notice: /Stage[main]/Nginx::Proxy/File[/etc/nginx/nginx.conf]/content: content changed <span class="string">&#x27;&#123;md5&#125;1510a037b9fb468daa9fff6d3b5bdd90&#x27;</span> to <span class="string">&#x27;&#123;md5&#125;9d140bc8d6be6be51c471322210b9393&#x27;</span></span><br><span class="line">Info: /Stage[main]/Nginx::Proxy/File[/etc/nginx/nginx.conf]: Scheduling refresh of Service[nginx]</span><br><span class="line">Notice: /Stage[main]/Nginx/Service[nginx]/ensure: ensure changed <span class="string">&#x27;stopped&#x27;</span> to <span class="string">&#x27;running&#x27;</span></span><br><span class="line">Info: /Stage[main]/Nginx/Service[nginx]: Unscheduling refresh on Service[nginx]</span><br><span class="line">Notice: Finished catalog run <span class="keyword">in</span> 146.49 seconds</span><br></pre></td></tr></table></figure><p>但是很多时候, 我们的很多主机都需要同样的配置, 有没有什么办法把他们写在一起呢? 如果是功能相近的node名字, 我们可以这么写:</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node /web\d*\.bili\.com/ &#123;</span><br><span class="line">  ... puppet code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们稍微补充一个主机的命名规范:</p><blockquote><p>角色 - 运营商 - 机房名 - IP.DOMAIN.LTD</p><p>也就是形如这样的: <code>web1-mobile-xz-1.1.1.1.baidu.com</code></p></blockquote><p>像是类使用一样, 我们的节点也是可以使用继承的方式来实现的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">node basenode &#123;</span><br><span class="line">  include ntp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node web1-mobile-xz-1.1.1.1.baidu.com &#123;</span><br><span class="line">  include nginx::proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以实现定义一个基节点来实现功能. 除此之外, 我们还可以在<code>site.pp</code>文件中进行分段的管理, 例如这样的结构:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/etc/puppet/manifests/</span><br><span class="line">site.pp</span><br><span class="line">import <span class="string">&quot;webservers/*.pp&quot;</span></span><br><span class="line">...</span><br><span class="line">webservers/</span><br><span class="line">1.pp</span><br><span class="line">2.pp</span><br><span class="line">cacheservers/</span><br><span class="line">1.pp</span><br><span class="line">2.pp</span><br><span class="line">appservers/</span><br><span class="line">1.pp</span><br><span class="line">2.pp</span><br></pre></td></tr></table></figure><p>这样就可以实现更加清晰的管理层次.</p><p>现在, 我们仍然面临两个问题:</p><ul><li>主机名解析</li><li>如何向不同环境节点分发puppet agent</li></ul><p>关于DNS, 我们可以搭建内网动态改变的弹性DNS服务, 这个就不说了. 现在我们主要来解决第二个问题, 由于我们可能会有多个环境, ( 例如: 我们可能会有生产环境, 测试环境, 等等 ) 这个时候他们就需要不同的配置文件, 其实我们的Puppet已经有这方面的设定了, 我们来看一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master puppet]<span class="comment"># ls</span></span><br><span class="line">auth.conf  environments  fileserver.conf  manifests  modules  puppet.conf</span><br><span class="line">[root@master puppet]<span class="comment"># tree environments/</span></span><br><span class="line">environments/</span><br><span class="line">└── example_env</span><br><span class="line">    ├── manifests</span><br><span class="line">    ├── modules</span><br><span class="line">    └── README.environment</span><br><span class="line"></span><br><span class="line">3 directories, 1 file</span><br></pre></td></tr></table></figure><p>在我们的Puppet的目录下, 我们可以看到他已经能够给了一个example环境, 这样我们只需要在puppet的配置文件中加上特定的环境配置段就可以了, 就像这样:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[production]</span></span><br><span class="line"><span class="attr">manifest</span> = /etc/puppet/environments/production/manifests/site.pp</span><br><span class="line"><span class="attr">modulepath</span> = /etc/puppet/environments/production/modules/</span><br><span class="line"><span class="attr">fileserverconfig</span> = /etc/puppet/fileserver.conf</span><br><span class="line"><span class="section">[testing]</span></span><br><span class="line"><span class="attr">manifest</span> = /etc/puppet/environments/testing/manifests/site.pp</span><br><span class="line"><span class="attr">modulepath</span> = /etc/puppet/environments/testing/modules/</span><br><span class="line"><span class="attr">fileserverconfig</span> = /etc/puppet/fileserver.conf</span><br><span class="line"><span class="section">[...]</span></span><br></pre></td></tr></table></figure><p>但是首先, 我们需要在前面加上声明, 声明master端支持哪些环境才行, 就像这样:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[master]</span></span><br><span class="line"><span class="attr">environment</span> = production, testing, ...</span><br></pre></td></tr></table></figure><p>以上的配置是master端的, 对于我们的agent端, 只需要指定环境就行了, like this:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[agent]</span></span><br><span class="line"><span class="attr">environment</span> = tesing</span><br></pre></td></tr></table></figure><p>指定自己的环境就行了. 而我们默认的agent的环境配置就是生产环境, 可以通过下面的命令获得:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@agent ~]<span class="comment"># puppet config print environment</span></span><br><span class="line">production</span><br><span class="line">[root@agent ~]<span class="comment"># puppet agent --configprint environment</span></span><br><span class="line">production</span><br></pre></td></tr></table></figure><p>接下来我们再来说一下<code>fileserver.conf</code>这个配置文件, 也就是puppet的文件服务器. 这个配置文件和<code>puppet.conf</code>以及<code>auth.conf</code>一起发挥作用, 目的其实就是对puppet的文件访问做授权的, 也就是一些安全配置, 使得agent能够或者不能访问某些文件.</p><p>这个文件主要有两个组成部分: <code>MOUNT_POINT</code>和<code>PERMISSIONS</code>.  通过观察默认内容和注释 也能搞清楚个大概.</p><p>典型的配置就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[label]</span><br><span class="line">path /PATH/TO/SOMEWHERE</span><br><span class="line">allow XXXX</span><br><span class="line">allow_ip XXXX</span><br><span class="line">deny all</span><br></pre></td></tr></table></figure><p>如果是想要实现先认证再授权的话, 就像permission中定义的那样, 加上<code>auth yes</code>的flag.</p><p>而<code>auth.conf</code>就是我们的认证配置文件, 其实就是为了Puppet提供ACL功能, 主要是应用于puppet的Restful的接口.不过一般情况下, 我们没有必要去修改他.</p><p>说到Puppet的Restful接口, 我们来看看是什么样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://master_ip:8140/&#123;environment&#125;/&#123;resource&#125;/&#123;key&#125;</span><br></pre></td></tr></table></figure><p>除了这两个典型文件, 还有这样的配置:</p><ul><li><p>namespaceauth.conf 控制命名空间的访问法则</p><ul><li>puppet中的命名空间有这些: <code>fileserver, puppetmaster, puppetrunner, puppetreports, resource</code></li></ul></li><li><p>autosign.conf 证书自动签署</p><ul><li>直接在里面写上域名集合就行了, 例如: <code>*.yaoxuannn.com</code></li></ul><p>我们直接来试试吧, 创建一个autosign.conf:</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.newthread.com</span><br></pre></td></tr></table></figure><p><em>对了, 这个地方我把连个节点的名字改了一下, 都加上了后缀newthread.com. 所以你的hosts文件和原来的节点分发以及帧数都要进行修改或者清除</em></p><p>这个时候我们再次启动客户端, 可以看到他直接就执行了, 因为证书被自动签署了, 也可以在master端使用cert子命令进行观察.</p><h3 id="kick模式"><a href="#kick模式" class="headerlink" title="kick模式"></a>kick模式</h3><p>尽管我们说过Puppet的工作模式是客户端到服务端进行抓取. 但是在一些情况下我们也需要服务端能够主动的将catalog给agent节点. </p><p>这里注意, 尽管看起来和Ansible的push很相像, 但事实上还不是push, 实际上是puppet master向所有的节点要求你们快来pull 这样的. 也就是说实际上只不过是缩短30min的等待时间罢了.</p><p>这个功能要求客户端监听在一个套接字上, 当收到这样的kick信息时才可以来处理. 这个特殊的端口就是<code>8139</code>端口. 而且默认这个功能是没有启用的. 如果想要获得这个kick效果 我们还需要去配置agent.</p><p>在Puppet的文档只写的很详细了, 我们就根据他说的来做:</p><p>首先, 我们查看一下当前Puppet agent的监听配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@agent.newthread.com puppet]<span class="comment"># puppet config print listen</span></span><br><span class="line"> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>接着, 我们修改他的配置文件, 增加listen &#x3D; true:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@agent.newthread.com puppet]<span class="comment"># tail -1 /etc/puppet/puppet.conf</span></span><br><span class="line">    listen = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>重启服务再检查:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@agent.newthread.com puppet]<span class="comment"># netstat -antp</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:8139                0.0.0.0:*                   LISTEN      29464/ruby</span><br></pre></td></tr></table></figure><p>就监听在<code>8139</code>了, 然后我们打开防火墙的8139入站访问.</p><p> 接着在agent增加对其run的访问, 在auth.conf中增加:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path /run</span><br><span class="line">method save</span><br><span class="line">allow master.newthread.com</span><br></pre></td></tr></table></figure><p>接着编辑或者新建<code>namespaceauth.conf</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[puppetrunner]</span><br><span class="line">allow *.newthread.com</span><br></pre></td></tr></table></figure><p>接着我们再master端执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@master.newthread.com ~]<span class="comment"># puppet kick agent.newthread.com</span></span><br><span class="line">Warning: Puppet kick is deprecated. See http://links.puppetlabs.com/puppet-kick-deprecation</span><br><span class="line">Warning: Failed to load ruby LDAP library. LDAP functionality will not be available</span><br><span class="line">Triggering agent.newthread.com</span><br><span class="line">Getting status</span><br><span class="line">status is success</span><br><span class="line">agent.newthread.com finished with <span class="built_in">exit</span> code 0</span><br><span class="line">Finished</span><br></pre></td></tr></table></figure><p>OK了.</p><p>不过需要说明的是, 正如显示的警告, <strong>这个功能要被废弃掉</strong>.</p><h3 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h3><p>最后我们来说一下puppet的dashboard. 也就是他的报告展示功能. 由于使用率不是很高 所以就简单的过一遍好了.</p><p>首先安装数据库mariadb, 略. 之前说过很多次了.</p><p>接着安装必要的软件包, 主要是ruby的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install rubygem-rake ruby-mysql</span><br><span class="line">yum install http://yum.puppet.com/el/6/products/x86_64/puppet-dashboard-1.2.9-1.el6.noarch.rpm</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Cluster </tag>
            
            <tag> Puppet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫学习笔记</title>
      <link href="/2017/11/04/Python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/11/04/Python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>今天开始学习写爬虫吧~</p><span id="more"></span><h2 id="Python对XML-JSON-HTML的解析"><a href="#Python对XML-JSON-HTML的解析" class="headerlink" title="Python对XML,JSON,HTML的解析"></a>Python对XML,JSON,HTML的解析</h2><h3 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h3><p>我们知道一般的无结构文本的组织格式常见的有CSV, XML, JSON, HTML这些. 其中比较相近的是XML和HTML这两个. 他们之间最大的不同点应该就是XML中没有自闭和标签这一点了, 例如:在HTML中经常会看到<code>&lt;br/&gt;</code>这样的自己就把自己闭合的标签, 而在XML中, 这个就是非法的字符.</p><p>废话不说了, 直接看一个XML的解析实例: </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bookstore</span> <span class="attr">name</span>=<span class="string">&quot;The First Bookstore&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">name</span>=<span class="string">&quot;HarryPotter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">amount</span>&gt;</span>23<span class="tag">&lt;/<span class="name">amount</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>100<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">name</span>=<span class="string">&quot;Little Prince&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">amount</span>&gt;</span>10<span class="tag">&lt;/<span class="name">amount</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>88<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个典型的XML文件 现在我们去用Python搞它:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line">doc = minidom.parse(<span class="string">&#x27;book.xml&#x27;</span>)</span><br><span class="line">root = doc.documentElement</span><br><span class="line"><span class="built_in">print</span>(root.nodeName)</span><br><span class="line"><span class="built_in">print</span>(root.getAttribute(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">books = root.getElementsByTagName(<span class="string">&quot;book&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> books:</span><br><span class="line">    amounts = book.getElementsByTagName(<span class="string">&quot;amount&quot;</span>)</span><br><span class="line">    prices = book.getElementsByTagName(<span class="string">&quot;price&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The book &quot;</span> + book.getAttribute(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot; have &quot;</span> + amounts[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue + <span class="string">&quot; left.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;And the price of it is &quot;</span> + prices[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue)</span><br></pre></td></tr></table></figure><p> 其中, 我们使用DOM的方式进行解析, 从代码中也可以看出来, 这里是把整个XML文件解析结束之后(也就是装载进内存之后)才可以进行处理. 显然这种方式的有点在于他可以快速的定位到任意一个节点上, 而缺点自然就是速度慢和资源占用大了. </p><p>输出结果就像这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bookstore</span><br><span class="line">The First Bookstore</span><br><span class="line">The book HarryPotter have 23 left.</span><br><span class="line">And the price of it is 100</span><br><span class="line">The book Little Prince have 10 left.</span><br><span class="line">And the price of it is 88</span><br></pre></td></tr></table></figure><p>与DOM不一样的, 另一种解析方式, 叫做SAX. 他的特点就是通过Handler的方式对这个XML文件进行解析, 读到哪里处理哪里.</p><p>代码就像是这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.parsers.expat <span class="keyword">import</span> ParserCreate</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultSaxHandler</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_element</span>(<span class="params">self, name, attrs</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;element %s, attrs: %s&#x27;</span> % (name, <span class="built_in">str</span>(attrs)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">end_element</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;element %s end.&quot;</span> % name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">char_data</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="keyword">if</span> val.strip():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;And %s&#x27;s value is %s&quot;</span> % (self.name, val))</span><br><span class="line"></span><br><span class="line">handler = DefaultSaxHandler()</span><br><span class="line">parser = ParserCreate()</span><br><span class="line">parser.StartElementHandler = handler.start_element</span><br><span class="line">parser.EndElementHandler = handler.end_element</span><br><span class="line">parser.CharacterDataHandler = handler.char_data</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;book.xml&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    parser.Parse(f.read())</span><br></pre></td></tr></table></figure><p>我们说过Python是一个鸭子类型的语言, 就是说只要你实现了这些功能, 那么我就可以说你是什么类型的. 这里, 我们实现一个SAX的解析器, 通过三个方法, 来读取他们的节点名称, 属性列表, 节点的值, 以及最后的读取到结束的标签的动作.</p><p>这样通过对handler赋值, 我们就可以进行文档的解析了, 输出结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">element bookstore, attrs: &#123;&#x27;name&#x27;: &#x27;The First Bookstore&#x27;&#125;</span><br><span class="line">element book, attrs: &#123;&#x27;name&#x27;: &#x27;HarryPotter&#x27;&#125;</span><br><span class="line">element amount, attrs: &#123;&#125;</span><br><span class="line">And amount&#x27;s value is 23</span><br><span class="line">element amount end.</span><br><span class="line">element price, attrs: &#123;&#125;</span><br><span class="line">And price&#x27;s value is 100</span><br><span class="line">element price end.</span><br><span class="line">element book end.</span><br><span class="line">element book, attrs: &#123;&#x27;name&#x27;: &#x27;Little Prince&#x27;&#125;</span><br><span class="line">element amount, attrs: &#123;&#125;</span><br><span class="line">And amount&#x27;s value is 10</span><br><span class="line">element amount end.</span><br><span class="line">element price, attrs: &#123;&#125;</span><br><span class="line">And price&#x27;s value is 88</span><br><span class="line">element price end.</span><br><span class="line">element book end.</span><br><span class="line">element bookstore end.</span><br></pre></td></tr></table></figure><p>十分简单吧.</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>我们之前其实说过了Python对JSON的支持的, 虽然篇幅不多, 但是这个模块真的不是很复杂,(起码使用起来不难). </p><p>比如这样的JSON文件:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;book&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HarryPort&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;101&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;amount&quot;</span><span class="punctuation">:</span> <span class="string">&quot;199&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;book&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Little Prince&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;18&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;amount&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>python对JSON的api设计是, 如果文件操作, 那么就是<code>load</code>和<code>dump</code>. 而如果是对字符串对象的操作的话, 就是<code>loads</code>和<code>dumps</code>了. 所以针对上面的那个文件, 我们这样来解析:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;book.json&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">output = json.load(f)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure><p>就完了. 很简单. 这里输出的output变量其实是个字典. 当然了, 我也可以从字典得到JSON字符串, 综合起来就是这样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;book.json&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">output = json.load(f)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(output))</span><br><span class="line"><span class="built_in">print</span>(output[<span class="string">&#x27;value&#x27;</span>])</span><br><span class="line">json_str = json.dumps(output)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(json_str))</span><br><span class="line"><span class="built_in">print</span>(json_str)</span><br></pre></td></tr></table></figure><p>上面代码的输出是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">[&#123;&#x27;book&#x27;: &#x27;HarryPort&#x27;, &#x27;price&#x27;: &#x27;101&#x27;, &#x27;amount&#x27;: &#x27;199&#x27;&#125;, &#123;&#x27;book&#x27;: &#x27;Little Prince&#x27;, &#x27;price&#x27;: &#x27;18&#x27;, &#x27;amount&#x27;: &#x27;123&#x27;&#125;]</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line">&#123;&quot;value&quot;: [&#123;&quot;book&quot;: &quot;HarryPort&quot;, &quot;price&quot;: &quot;101&quot;, &quot;amount&quot;: &quot;199&quot;&#125;, &#123;&quot;book&quot;: &quot;Little Prince&quot;, &quot;price&quot;: &quot;18&quot;, &quot;amount&quot;: &quot;123&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>最后我们在来说一下HTML的解析, 关于这个, 我打算直接用个例子就带过去, 原因有两个:</p><ul><li>原生的HTML Parser在实际情况下不会得到使用,  第三方库的使用概率要大的多</li><li>HTML Parser模块很简单, 他和前面的SAX解析XML几乎差不多.</li></ul><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>首先一个Web页面:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>403 Forbidden<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;white&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>403 Forbidden<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>nginx/1.4.6 (Ubuntu)<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(  嘿嘿, 特意挑了一个403页面 )</p><p>这里我们能看到除了存在和XML一样的的前后闭合标签, 还有一个烦人的<code>&lt;hr/&gt;</code>. 现在我们来实现一下我们的Parser:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> html.parser <span class="keyword">import</span> HTMLParser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultParser</span>(<span class="title class_ inherited__">HTMLParser</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_starttag</span>(<span class="params">self, tag, attrs</span>):</span><br><span class="line">        <span class="keyword">if</span> tag == <span class="string">&#x27;html&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Start parsing.&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tag == <span class="string">&#x27;title&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Output title:&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> tag == <span class="string">&#x27;h1&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Output h1:&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> attrs:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s has attr: %s&quot;</span> % (tag, attrs))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_endtag</span>(<span class="params">self, tag</span>):</span><br><span class="line">        <span class="keyword">if</span> tag == <span class="string">&#x27;html&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;End parsing&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_startendtag</span>(<span class="params">self, tag, attrs</span>):</span><br><span class="line">        <span class="keyword">if</span> tag == <span class="string">&#x27;hr&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Found hr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_data</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = DefaultParser()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;index.html&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    parser.feed(f.read())</span><br><span class="line">parser.close()</span><br></pre></td></tr></table></figure><p>这样执行之后获得的结果是这样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Start parsing.</span><br><span class="line">Output title:</span><br><span class="line">403 Forbidden</span><br><span class="line">body has attr: [(&#x27;bgcolor&#x27;, &#x27;white&#x27;)]</span><br><span class="line">Output h1:</span><br><span class="line">403 Forbidden</span><br><span class="line">Found hr</span><br><span class="line">nginx/1.4.6 (Ubuntu)</span><br><span class="line">End parsing</span><br></pre></td></tr></table></figure><p>其实, Python除了这个HTMLParser, 还有其他的用来解析HTML文档的模块, 而且事实上, 他们要更加好用. 不过也就到这里了. 现在我们来看看这一次爬虫使用到的第一个库! — <strong>request</strong>.</p><h2 id="Request库的使用"><a href="#Request库的使用" class="headerlink" title="Request库的使用"></a>Request库的使用</h2><p>Request是一个超级好用的Python网络库, 封装大量的urllib3中的API, 并提供一个更好用的接口给开发者. 最简单的一个请求操作就是这样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://59.68.29.126&quot;</span></span><br><span class="line"></span><br><span class="line">res = requests.get(url)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="built_in">print</span>(res.status_code)</span><br><span class="line"><span class="built_in">print</span>(res.headers)</span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure><p>你会发现, get不就是我们的HTTP方法中的一个嘛, 事实也是如此, request的HTTP方法就是直接用的其方法名来命名的.</p><p>这样的请求输出的结果是这样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Response [403]&gt;</span><br><span class="line">403</span><br><span class="line">&#123;&#x27;Server&#x27;: &#x27;nginx/1.4.6 (Ubuntu)&#x27;, &#x27;Date&#x27;: &#x27;Sun, 05 Nov 2017 12:07:26 GMT&#x27;, &#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;, &#x27;Transfer-Encoding&#x27;: &#x27;chunked&#x27;, &#x27;Connection&#x27;: &#x27;keep-alive&#x27;, &#x27;Content-Encoding&#x27;: &#x27;gzip&#x27;&#125;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.4.6 (Ubuntu)&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>怎么样, <code>get</code>输出的response对象中携带了大量你所需要的值和结果. </p><p>GET请求就是这样的, 那么接下来如果我想要携带参数去请求呢:</p><p>请看下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/get&#x27;</span></span><br><span class="line">params = &#123;<span class="string">&#x27;k1&#x27;</span>: <span class="string">&#x27;v1&#x27;</span>, <span class="string">&#x27;k2&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;k3&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line">res = requests.get(url, params=params)</span><br><span class="line"><span class="built_in">print</span>(res.url)</span><br></pre></td></tr></table></figure><p>输出的结果是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://httpbin.org/get?k1=v1&amp;k3=1&amp;k3=2&amp;k3=3</span><br></pre></td></tr></table></figure><p>由于k2没有参数值, 所以直接就略去了. 而k3是个数组,  所以出现了多次.</p><blockquote><p>关于 httpbin.org这个网站, 它提供了很多很方便的功能, 例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ curl http://httpbin.org/user-agent</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;user-agent&quot;</span>: <span class="string">&quot;curl/7.54.0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">➜  ~ curl http://httpbin.org/headers</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;*/*&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;close&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>,</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;curl/7.54.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他的主页上有更多说明.</p></blockquote><p>这样就可以携带参数的请求了.</p><p>除了文本请求, 有时候我们可能需要去爬一些图片什么的二进制数据, 这怎么办呢? 其实这个时候和我们的Requests的滚阿西就不是很大了, 只不过是需要response对象中的一个content属性罢了, 以图片为例, 来看下面的一个实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.baidu.com/img/bd_logo1.png&quot;</span></span><br><span class="line">res = requests.get(url)</span><br><span class="line">image = Image.<span class="built_in">open</span>(BytesIO(res.content))</span><br><span class="line">image.save(<span class="string">&quot;baidu_logo.png&quot;</span>)</span><br></pre></td></tr></table></figure><p>这样, 我们就可以进行图片的抓取了. 有的时候, 一张图有可能会很大, 这个时候, 我们可以把它当做原始数据 一个chunk一个chunk的读取, 也就是<strong>流式读取</strong>. 来看改进之后的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.baidu.com/img/bd_logo1.png&quot;</span></span><br><span class="line">res = requests.get(url, stream=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;baidu_logo_stream.png&quot;</span>, <span class="string">&#x27;wb+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> trunk <span class="keyword">in</span> res.iter_content(<span class="number">512</span>):</span><br><span class="line">        f.write(trunk)</span><br></pre></td></tr></table></figure><p>GET的用法其实就是这些了, 接着我们说一下POST的用法, 最常用的场景就是提交表单了. 这个时候其实和GET携带参数差不多的用法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://httpbin.org/post&quot;</span></span><br><span class="line">form = &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&#x27;Justin&#x27;</span>, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;ielts666&quot;</span>&#125;</span><br><span class="line">res = requests.post(url, data=form)</span><br><span class="line"><span class="built_in">print</span>(json.loads(res.text)[<span class="string">&#x27;form&#x27;</span>])</span><br><span class="line">res = requests.post(url, data=json.dumps(form))</span><br><span class="line"><span class="built_in">print</span>(json.loads(res.text)[<span class="string">&#x27;form&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(json.loads(res.text)[<span class="string">&#x27;data&#x27;</span>])</span><br></pre></td></tr></table></figure><p>得到的结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;password&#x27;: &#x27;ielts666&#x27;, &#x27;username&#x27;: &#x27;Justin&#x27;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;&quot;username&quot;: &quot;Justin&quot;, &quot;password&quot;: &quot;ielts666&quot;&#125;</span><br></pre></td></tr></table></figure><p>也就是说, 当我们post传入的data是个字段对象的时候, 数据就会填充在表单中,而如果是纯文本, 就会丢在data项目中.</p><p>说道了提交表单, 我们还要说一下有关Cookie的一些, 首先先用必应做个实验: (因为它的Cookie比较多 - -)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://bing.com&quot;</span></span><br><span class="line">res = requests.get(url)</span><br><span class="line"><span class="built_in">print</span>(res.cookies.items())</span><br></pre></td></tr></table></figure><p>结果是这样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(&#x27;MUID&#x27;, &#x27;270542D09F6B6A1B05D349E29EB76BFB&#x27;), (&#x27;SRCHD&#x27;, &#x27;AF=NOFORM&#x27;), (&#x27;SRCHUID&#x27;, &#x27;V=2&amp;GUID=0FC639A2A7F7477EAD9CC949860A8CBD&amp;dmnchg=1&#x27;), (&#x27;SRCHUSR&#x27;, &#x27;DOB=20171106&#x27;), (&#x27;_EDGE_S&#x27;, &#x27;F=1&amp;SID=0E4DEFBCD35565913449E48ED28964EC&#x27;), (&#x27;_EDGE_V&#x27;, &#x27;1&#x27;), (&#x27;_SS&#x27;, &#x27;SID=0E4DEFBCD35565913449E48ED28964EC&#x27;), (&#x27;MUIDB&#x27;, &#x27;270542D09F6B6A1B05D349E29EB76BFB&#x27;)]</span><br></pre></td></tr></table></figure><p>当然我们也可以进行遍历, 进行进一步的操作.</p><p>同样, 我们也可以携带Cookie进行请求, 就像这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&quot;http://httpbin.org/cookies&quot;</span></span><br><span class="line">cookie = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&#x27;Justin&#x27;</span>&#125;</span><br><span class="line">res = requests.get(url, cookies=cookie)</span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure><p>我们的Cookie确实送过去了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;cookies&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Justin&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Requests同样可以做到重定向以及重定向的历史:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&quot;http://yaoxuannn.com&quot;</span></span><br><span class="line">res = requests.get(url, allow_redirects=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(res.url)</span><br><span class="line"><span class="built_in">print</span>(res.status_code)</span><br><span class="line"><span class="built_in">print</span>(res.history[<span class="number">0</span>].status_code)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://yaoxuannn.com//</span><br><span class="line">200</span><br><span class="line">302</span><br></pre></td></tr></table></figure><p>最后关于Requests的基本功能, 我们再说一个使用代理:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&quot;http://httpbin.org&quot;</span></span><br><span class="line">proxies = &#123;<span class="string">&quot;http&quot;</span>: <span class="string">&quot;假装有个代理服务器&quot;</span>, <span class="string">&quot;https&quot;</span>: <span class="string">&quot;假装这里有个代理服务器&quot;</span>&#125;</span><br><span class="line">res = requests.get(url, proxies=proxies)</span><br></pre></td></tr></table></figure><p>这样就差不多了.</p><h2 id="BeautifulSoup-4的使用"><a href="#BeautifulSoup-4的使用" class="headerlink" title="BeautifulSoup 4的使用"></a>BeautifulSoup 4的使用</h2><p>我们提供一个示例文档:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample File<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--body_start--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;para&quot;</span>&gt;</span>This is a sample file for beautiful soup4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>Click Here<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>And you will see the homepage of baidu</span><br><span class="line">    <span class="tag">&lt;<span class="name">em</span> <span class="attr">id</span>=<span class="string">&quot;em&quot;</span>&gt;</span>BAIDU<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>last para<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以很清楚的看出来, 它的排版并不是很好看(甚至还有错误[body没有闭合]). 接下来我们就可以使用BS来做一下处理:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(<span class="built_in">open</span>(<span class="string">&quot;bs_sample.html&quot;</span>), <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup.prettify())</span><br></pre></td></tr></table></figure><p>输出的文本就是按照层级结构排过版的了 同时, body标签也被自动的补全了.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">   Sample File</span><br><span class="line">  <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--body_start--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;para&quot;</span>&gt;</span></span><br><span class="line">   This is a sample file for beautiful soup4</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span></span><br><span class="line">   Click Here</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">   And you will see the homepage of baidu</span><br><span class="line">   <span class="tag">&lt;<span class="name">em</span> <span class="attr">id</span>=<span class="string">&quot;em&quot;</span>&gt;</span></span><br><span class="line">    BAIDU</span><br><span class="line">   <span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">   last para</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来就是BS的强大的地方了, 我们可以非常方便的读取文档, 就像下面这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(<span class="built_in">open</span>(<span class="string">&quot;bs_sample.html&quot;</span>), <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"><span class="comment"># print(soup.prettify())</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(soup.title))</span><br><span class="line"><span class="built_in">print</span>(soup.title.text)</span><br><span class="line"><span class="built_in">print</span>(soup.p)</span><br></pre></td></tr></table></figure><p>输出的结果是这个样子的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;bs4.element.Tag&#x27;&gt;</span><br><span class="line">Sample File</span><br><span class="line">&lt;p class=&quot;para&quot;&gt;This is a sample file for beautiful soup4&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>但是 问题出来了, 这里抓取到的元素都是第一个, 后面的元素好像没法直接获得. 所以这个时候, 我们就需要进行遍历了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(<span class="built_in">open</span>(<span class="string">&quot;bs_sample.html&quot;</span>), <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> soup.body.contents:</span><br><span class="line">    <span class="built_in">print</span>(item.name)</span><br></pre></td></tr></table></figure><p>输出的结果有点奇怪:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">None</span><br><span class="line">None</span><br><span class="line">None</span><br><span class="line">p</span><br><span class="line">None</span><br><span class="line">a</span><br><span class="line">p</span><br><span class="line">None</span><br><span class="line">p</span><br><span class="line">None</span><br></pre></td></tr></table></figure><p> 这是因为papp这四个元素是body下的直接子元素.</p><p>接下来我们看一下BS的CSS查询:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&quot;.para&quot;</span>))</span><br></pre></td></tr></table></figure><p>这样我就得到了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;p class=&quot;para&quot;&gt;This is a sample file for beautiful soup4&lt;/p&gt;]</span><br></pre></td></tr></table></figure><p>这样一个元素列表.</p><p>当然id查询也是可以的, 就不演示了. 当然也是支持这样的层级查找:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&quot;body &gt; p.para&quot;</span>))</span><br></pre></td></tr></table></figure><p>很简单, 更多使用到时候在实战中使用再说. 现在我们来看一下Python &gt; sqlite的使用</p><h2 id="sqlite"><a href="#sqlite" class="headerlink" title="sqlite"></a>sqlite</h2><p> Python方便的地方就是他自带了sqlite, 这很方便, 而且SQL语句的使用也是很标准的, 所以如果你使用过MySQL, 那么使用sqlite模块也是手到拈来的事情了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line">conn = sqlite3.connect(<span class="string">&quot;test.db&quot;</span>)</span><br><span class="line">create_sql = <span class="string">&quot;create table if not exists test(id int primary key not null, name varchar(20) not null)&quot;</span></span><br><span class="line">conn.execute(create_sql)</span><br><span class="line">insert_sql = <span class="string">&quot;insert into test values(?, ?)&quot;</span></span><br><span class="line">conn.execute(insert_sql, (<span class="number">1</span>, <span class="string">&quot;test&quot;</span>))</span><br><span class="line">conn.execute(insert_sql, (<span class="number">2</span>, <span class="string">&quot;test&quot;</span>))</span><br><span class="line">get_sql = <span class="string">&quot;select * from test where name = ?&quot;</span></span><br><span class="line">res = conn.execute(get_sql, (<span class="string">&quot;test&quot;</span>,))</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> res.fetchall():</span><br><span class="line">    <span class="built_in">print</span>(item[<span class="number">1</span>])</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><p>这样输出的结果就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">test</span><br></pre></td></tr></table></figure><p>好了, 准备的额差不多了, 接下来我就来试着模拟登陆一下好了.</p><h2 id="土家购模拟登录"><a href="#土家购模拟登录" class="headerlink" title="土家购模拟登录"></a>土家购模拟登录</h2><p>不管写什么爬虫, 我们都需要先观察对方网站是怎么处理的请求, 怎么发送的表单, 土家购的登录十分简单, 直接使用浏览器的开发者工具就可以了: ( 别问我土家购是什么 - - )</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/tujiagou_login.png" alt="tujiagou_login.png"></p><p>十分好看.</p><p>接下来我就要来模拟一下登陆过程了, 直接上个代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line"></span><br><span class="line">login_url = <span class="string">&quot;http://tjg.hangowa.com/member/?act=login&amp;op=login&amp;inajax=1&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">&quot;User-Agent&quot;</span>:</span><br><span class="line">               <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 \</span></span><br><span class="line"><span class="string">               (KHTML, like Gecko) Chrome/62.0.3202.75 Safari/537.36&quot;</span>,</span><br><span class="line">           <span class="string">&quot;Referer&quot;</span>:</span><br><span class="line">               <span class="string">&quot;http://tjg.hangowa.com/member/?act=login&amp;op=index&amp;ref_url=%2Fmember \</span></span><br><span class="line"><span class="string">               %2F%3Fact%3Dmember_information%26op%3Dindex&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">formdata = &#123;</span><br><span class="line">    <span class="string">&quot;formhash&quot;</span>: <span class="string">&quot;gjn1eYx_4djUfHKPpQAhjX0eYT0fEDP&quot;</span>,</span><br><span class="line">    <span class="string">&quot;form_submit&quot;</span>: <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">    <span class="string">&quot;nchash&quot;</span>: <span class="literal">None</span>,</span><br><span class="line">    <span class="string">&quot;user_name&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;不告诉你&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ref_url&quot;</span>: <span class="string">&quot;/member/?act=member_information&amp;op=index&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = s.post(login_url, data=formdata, headers=headers)</span><br><span class="line">home = s.get(<span class="string">&quot;http://tjg.hangowa.com/shop/index.php?act=cart&quot;</span>)</span><br><span class="line">soup = BeautifulSoup(home.content, <span class="string">&quot;html5lib&quot;</span>)</span><br><span class="line">goods = soup.select(<span class="string">&quot;td &gt; a &gt; img&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> good <span class="keyword">in</span> goods:</span><br><span class="line">    <span class="built_in">print</span>(good.get(<span class="string">&quot;alt&quot;</span>))</span><br><span class="line"></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><p>这样就可以获得我的购物车的商品了, 结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">骑龙烘青9号50g绿茶</span><br><span class="line">恩施鹤峰骑龙绿茶250g袋装</span><br><span class="line">恩施鹤峰青翠源黑茶400g</span><br><span class="line">斑鹤黄金白茶50g*2一盒二袋</span><br><span class="line">恩施鹤峰斑鹤250g绿茶</span><br><span class="line">%name%</span><br></pre></td></tr></table></figure><p>是不是很简单呢, 当然. 这也是因为土家购对登录没有做什么验证啥的, 所以很轻松的就登陆进去了.</p><p>接着我们可以使用开发者工具把自己登陆之后的Cookie复制下来, 只要对方没有设置其他的干扰项, 我们就可以使用你的Cookie进行免密码的登陆进去. </p><p>接着来看这两个小栗子:</p><h2 id="Bilibili排行榜和动态通知"><a href="#Bilibili排行榜和动态通知" class="headerlink" title="Bilibili排行榜和动态通知"></a>Bilibili排行榜和动态通知</h2><p>直接上代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.75 Safari/537.36&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;https://www.bilibili.com/ranking&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.bilibili.com/index/rank/all-3-0.json&quot;</span></span><br><span class="line"></span><br><span class="line">rank_res = requests.get(url, headers=headers)</span><br><span class="line">rank_json = json.loads(rank_res.text)</span><br><span class="line">location = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> rank_json[<span class="string">&#x27;rank&#x27;</span>][<span class="string">&#x27;list&#x27;</span>]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第%s名: %s Up:%s\n播放数:%s 硬币:%s, 弹幕:%s&quot;</span> % (<span class="built_in">str</span>(location), item[<span class="string">&#x27;title&#x27;</span>], item[<span class="string">&#x27;author&#x27;</span>], item[<span class="string">&#x27;play&#x27;</span>], item[<span class="string">&#x27;coins&#x27;</span>], item[<span class="string">&#x27;video_review&#x27;</span>]))</span><br><span class="line">    location += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>运行结果就像这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">第1名: 【凉风】不正经解说柯南剧场版M21-唐红的恋歌 Up:凉风有性胖次君</span><br><span class="line">播放数:484836 硬币:30721, 弹幕:5670</span><br><span class="line">--------------------</span><br><span class="line">第2名: 诸葛亮的红色蜀国 Up:画画峰</span><br><span class="line">播放数:822549 硬币:60046, 弹幕:7214</span><br><span class="line">--------------------</span><br><span class="line">第3名: 【马云】王妃：我的baby，我要霸占你的钱！ Up:深海色带鱼</span><br><span class="line">播放数:521766 硬币:41325, 弹幕:3235</span><br><span class="line">--------------------</span><br><span class="line">第4名: 【C菌】首款赛博朋克风恐怖神作!【&gt;Observer_ (观察者)】实况连载, 更新第五集 Up:渗透之C君</span><br><span class="line">播放数:398717 硬币:21198, 弹幕:11739</span><br><span class="line">--------------------</span><br><span class="line">第5名: 【兄贵】病名为爱♂ Up:小可儿</span><br><span class="line">播放数:465863 硬币:55400, 弹幕:7637</span><br><span class="line">--------------------</span><br><span class="line">第6名: 死亡？蜘蛛侠：仅剩之日 Up:努力的Lorre</span><br><span class="line">播放数:557282 硬币:60271, 弹幕:8679</span><br><span class="line">--------------------</span><br><span class="line">第7名: 正气凛然！对美少女的丝袜诱惑说不！【二次元观察室04】 Up:吃素的狮子</span><br><span class="line">播放数:220998 硬币:31966, 弹幕:10283</span><br><span class="line">--------------------</span><br><span class="line">第8名: 《守望先锋》动画短片：《荣耀》 Up:网易暴雪游戏视频</span><br><span class="line">播放数:536341 硬币:22895, 弹幕:5294</span><br><span class="line">--------------------</span><br><span class="line">第9名: 【原作党很严格】为什么动画都喜欢魔改剧情？泛式带你走进魔改党背后的真相 Up:泛式</span><br><span class="line">播放数:237893 硬币:23400, 弹幕:3576</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>很有意思吧, 另外, 使用你登录之后的Cookie就可以直接进行动态的抓取了, 代码如下(Cookie需要替换):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://api.bilibili.com/x/web-feed/feed?callback=jQuery172020613184013553032_1510060069102&amp;jsonp=jsonp&amp;ps=10&amp;type=0&amp;_=1510060069292&quot;</span></span><br><span class="line"></span><br><span class="line">cookie = &#123;</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&quot;你的Cookie&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&quot;https://www.bilibili.com/account/dynamic&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.75 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.get(url, cookies=cookie, headers=header)</span><br><span class="line">result = res.text</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">&quot;jQuery[0-9_]*\((.*)\)&quot;</span></span><br><span class="line"></span><br><span class="line">dynamic = json.loads(re.sub(pattern, <span class="string">r&#x27;\1&#x27;</span>, result))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dynamic[<span class="string">&#x27;data&#x27;</span>]:</span><br><span class="line">    archive = data[<span class="string">&#x27;archive&#x27;</span>]</span><br><span class="line">    bangumi = data[<span class="string">&#x27;bangumi&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--&quot;</span> * <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> archive:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发布时间: %s Up: %s 标题: %s\n%s&quot;</span> % (datetime.fromtimestamp(<span class="built_in">float</span>(data[<span class="string">&#x27;pubdate&#x27;</span>])), archive[<span class="string">&#x27;owner&#x27;</span>][<span class="string">&#x27;name&#x27;</span>], archive[<span class="string">&#x27;title&#x27;</span>], archive[<span class="string">&#x27;desc&#x27;</span>]))</span><br><span class="line">    <span class="keyword">if</span> bangumi:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;**我关注的番剧更新了!**\n**%s**\n**第%s话: %s**&quot;</span> % (bangumi[<span class="string">&#x27;title&#x27;</span>], bangumi[<span class="string">&#x27;new_ep&#x27;</span>][<span class="string">&#x27;index&#x27;</span>], bangumi[<span class="string">&#x27;new_ep&#x27;</span>][<span class="string">&#x27;index_title&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>运行的结果就像这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">--------------------</span><br><span class="line">发布时间: 2017-11-07 20:40:25 Up: 刘哔电影 标题: 【刘哔】我不扶墙就服这支广告的设计</span><br><span class="line">京东今年大牌云集，还让外卖小哥抢了戏？我不扶墙就服这支广告的设计，会引起的某些欲望，观看要谨慎，京东11.11 全球好物节，千万别忘了我们的约定！</span><br><span class="line">--------------------</span><br><span class="line">发布时间: 2017-11-06 18:20:23 Up: 刘哔电影 标题: 【刘哔】烂片吐槽之《青春期3》：你确定你过的是青年期 不是更年期吗？</span><br><span class="line">明明是更年期！</span><br><span class="line">--------------------</span><br><span class="line">**我关注的番剧更新了!**</span><br><span class="line">**宝石之国**</span><br><span class="line">**第5话: 归来**</span><br><span class="line">--------------------</span><br><span class="line">发布时间: 2017-11-04 15:53:19 Up: 泛式 标题: 【原作党很严格】为什么动画都喜欢魔改剧情？泛式带你走进魔改党背后的真相</span><br><span class="line">视频类型: 动漫杂谈</span><br><span class="line">相关题材: 欢迎来到实力至上主义的教室，血界战线，电玩咖，中二病也要谈恋爱，噬魂师，火影忍者，甘城光辉游乐园，银魂，食灵，钢之炼金术师，Clannad，旋风管家</span><br><span class="line">简介: 近来魔改一词出现得越来越频繁，为什么动画组总是喜欢教原作党做人？今天就来和大家聊一聊动画化时的剧情魔改现象吧。 （所有论点系业余言论，仅供娱乐）</span><br><span class="line"></span><br><span class="line">微博：https://weibo.com/FunShiki</span><br><span class="line">--------------------</span><br><span class="line">发布时间: 2017-11-04 14:12:37 Up: 凉风有性胖次君 标题: 【凉风】不正经解说柯南剧场版M21-唐红的恋歌</span><br><span class="line">视频类型: 动漫杂谈</span><br><span class="line">相关题材: 名侦探柯南</span><br><span class="line">简介: 这里什么都有→微博@凉风有性胖次君 http://weibo.com/10112015</span><br><span class="line">--------------------</span><br><span class="line">发布时间: 2017-11-03 19:00:55 Up: 刘哔电影 标题: 【刘哔】三分钟带你看小品改编电影《兄弟，别闹！》</span><br><span class="line">11.10～带上喜欢的妹子一起去看吧！</span><br><span class="line">--------------------</span><br><span class="line">发布时间: 2017-11-03 16:46:26 Up: 逍遥散人 标题: 【散人】穿越尉迟恭 把妹不轻松 手机网聊版</span><br><span class="line">相关游戏: 尉迟恭是什么鬼</span><br><span class="line">简介补充: 游戏名尉迟恭是什么鬼网聊版</span><br><span class="line">录制出现点问题，所以最开始介绍游戏的话语没录上，直接开场。</span><br><span class="line">玩了玩超级有趣，继续做上来大家看个乐。</span><br><span class="line">--------------------</span><br><span class="line">发布时间: 2017-11-03 03:47:12 Up: 刘哔电影 标题: 温情解说之《追缉炸弹客》：最了解你的不是枕边人，而是你的敌人</span><br><span class="line">最了解你的不是枕边人，而是你的敌人</span><br><span class="line">--------------------</span><br><span class="line">发布时间: 2017-11-02 18:30:57 Up: 还有一天就放假了 标题: 【波澜哥】爱澜澜</span><br><span class="line">小红红：五句啊，五句要是再唱不准你就娶我，口亨！</span><br><span class="line">--------------------</span><br><span class="line">发布时间: 2017-11-02 16:31:24 Up: LexBurner 标题: 【Lex吐槽】刀剑神域序列之争，我永远喜欢亚丝娜！</span><br><span class="line">视频类型: 动漫杂谈</span><br><span class="line">相关题材: 刀剑神域序列之争</span><br><span class="line">简介: 新浪微博@LexBurner</span><br></pre></td></tr></table></figure><p>(哎呀, 你们看到我关注的UP了..嘿嘿)</p><h2 id="Python爬虫框架-—-scrapy"><a href="#Python爬虫框架-—-scrapy" class="headerlink" title="Python爬虫框架 — scrapy"></a>Python爬虫框架 — scrapy</h2><p>但是, 如果说在生产环境中使用脚本一个页面一个页面的下载, 解析实在是太没有逻辑了, 而且没有效率. 而且实现起来的难度较大, 于是, 框架就这样诞生了. 其中**<code>scrapy</code>**就是这些框架中一个十分有名的一个.</p><p>来看一下他的架构:<br><img src="http://images2015.cnblogs.com/blog/953786/201606/953786-20160612162715136-1486217043.jpg" alt="Scrapy"></p><p>大体上也能搞清楚个大概, Scrapy的工作模式, 接下来我们就来说说这个架构, 最显眼的就是右边的那个下载器了, 他做的事情很单纯, 就是把内容下载过来交给Spider组件, 只要有请求过来, 下载器就会自动的去下载. 而下载的东西去哪里了呢? Spider组件将下载器给他的资源统一输出到输出管道上, 这个管道的另一端是谁呢? 不一定了, 有可能是文件, 有可能是数据库等等. 总之就是你最后期望得到的输出目标. 那么下载器的请求来源是哪里? 自然就是上面的那个调度器了, 由Spiders组件将需要请求的连接地址发送给调度器, 接着根据当前爬虫的状态动态的调度请求, 这就是Scheduler的工作.</p><p> 关于scrapy本身, 我们就先说道这里, 接着我们来看一个小例子: 抓取七月在线的课程:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;Test&quot;</span></span><br><span class="line">    start_urls = [<span class="string">&quot;https://www.julyedu.com/category/index&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> response.xpath(<span class="string">&#x27;//div[@class=&quot;course_info_box&quot;]&#x27;</span>):</span><br><span class="line">            title = item.xpath(<span class="string">&#x27;a/h4/text()&#x27;</span>).extract_first()</span><br><span class="line">            desc = item.xpath(<span class="string">&#x27;a/p[@class=&quot;course-info-tip&quot;][1]/text()&#x27;</span>).extract_first()</span><br><span class="line">            time = item.xpath(<span class="string">&#x27;a/p[@class=&quot;course-info-tip info-time&quot;]/text()&#x27;</span>).extract_first()</span><br><span class="line">            res = &#123;</span><br><span class="line">                <span class="string">&quot;title&quot;</span>: title,</span><br><span class="line">                <span class="string">&quot;desc&quot;</span>: desc,</span><br><span class="line">                <span class="string">&quot;time&quot;</span>: time</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">yield</span> res</span><br></pre></td></tr></table></figure><p>怎么执行呢, 我们可以使用scrapy提供的命令行工具来执行它, 就像是这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crapy runspider scrapy_test.py -o scrapy_test.json</span><br></pre></td></tr></table></figure><p>其中<code>-o</code>参数可以将<code>yield</code>出去的结果输出到文件中 要求这个结果必须是基本类型的字典或者None, 以及Scrapy的BaseItem和Request类.</p><p>我们现在来看一下上面的那个小例子, 首先我们继承一个爬虫类, 这个类中我们必须要提供的是这个爬虫的名字也就是name类变量和需要爬的urls, 这个是一个列表, 由于上面的例子是个单页测试, 所以就是一个单独的页面. 接着是我们需要我们爬虫抓取的内容如何获取, 如何去解析资源的方法.</p><p>现在我们稍微爬去多一点资源, 这一次我们主要是采取URL拼接的方式来爬的: 一个爬取博客园文章和推荐数的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlogSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;cnblog&quot;</span></span><br><span class="line">    start_urls = [<span class="string">&quot;https://www.cnblogs.com/pick/#p%s&quot;</span> % p <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> response.xpath(<span class="string">&#x27;//div[@class=&quot;post_item&quot;]&#x27;</span>):</span><br><span class="line">            title = item.xpath(<span class="string">&#x27;div[@class=&quot;post_item_body&quot;]/h3/a/text()&#x27;</span>).extract_first()</span><br><span class="line">            recommand = item.xpath(<span class="string">&#x27;div[@class=&quot;digg&quot;]/div/span/text()&#x27;</span>).extract_first()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> &#123;</span><br><span class="line">                <span class="string">&quot;title&quot;</span>: title,</span><br><span class="line">                <span class="string">&quot;rec_no&quot;</span>: recommand</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>注意这里所使用的start_urls, 由于我们可以从URL中发现规律, 这样就可以进行分页的抓取了. 另外还有一种, 就是手动的去请求下一页, 你也可以理解成是重新请求一个新的URL啦, 我们来看一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QuoteSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;quoteSpider&quot;</span></span><br><span class="line">    start_urls = [<span class="string">&quot;http://quotes.toscrape.com/tag/life/&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> response.xpath(<span class="string">&quot;//div[@class=&#x27;quote&#x27;]&quot;</span>):</span><br><span class="line">            content = item.xpath(<span class="string">&quot;span[@class=&#x27;text&#x27;]/text()&quot;</span>).extract_first()</span><br><span class="line">            author = item.xpath(<span class="string">&quot;span[2]/small/text()&quot;</span>).extract_first()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> &#123;</span><br><span class="line">                <span class="string">&quot;content&quot;</span>: content,</span><br><span class="line">                <span class="string">&quot;author&quot;</span>: author</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        next_page = response.xpath(<span class="string">&quot;//li[@class=&#x27;next&#x27;]/a/@href&quot;</span>).extract_first()</span><br><span class="line">        <span class="keyword">if</span> next_page:</span><br><span class="line">            next_page = response.urljoin(next_page)</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(next_page, callback=self.parse)</span><br></pre></td></tr></table></figure><p>这里我们尝试获取页面上的下一页, 如果存在就继续请求. 由于获取到的href目标是个相对地址, 所以我们还需要进行一次URL的拼接. </p><p>到现在为止, 我们都在使用scrapy的单文件, 但是事实上我们一个爬虫都是有一个项目来驱动的, 使用scrapy创建一个project是十分简单的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  scrapy startproject qqnews</span><br><span class="line">New Scrapy project <span class="string">&#x27;qqnews&#x27;</span>, using template directory <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/scrapy/templates/project&#x27;</span>, created <span class="keyword">in</span>:</span><br><span class="line">    /.../qqnews</span><br><span class="line"></span><br><span class="line">You can start your first spider with:</span><br><span class="line">    <span class="built_in">cd</span> qqnews</span><br><span class="line">    scrapy genspider example example.com</span><br><span class="line">➜  tree qqnews</span><br><span class="line">qqnews</span><br><span class="line">├── qqnews</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── __pycache__</span><br><span class="line">│   ├── items.py</span><br><span class="line">│   ├── middlewares.py</span><br><span class="line">│   ├── pipelines.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   └── spiders</span><br><span class="line">│       ├── __init__.py</span><br><span class="line">│       └── __pycache__</span><br><span class="line">└── scrapy.cfg</span><br><span class="line"></span><br><span class="line">4 directories, 7 files</span><br></pre></td></tr></table></figure><p>而且我们的爬虫就在这个spider目录下创建:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  vim qqnews/qqnews/spiders/qq_news_spider.py</span><br></pre></td></tr></table></figure><p> 接着我们就可以去写爬虫了…</p><blockquote><p><strong>脱坑指南</strong> 如果你爬取不了(比如说被拒绝, 或者超时, 或者一直没反应), 那么尝试一下将setting.py里面的<code>ROBOTSTXT_OBEY</code>改成<code>False</code>. 这样我们的scrapy就不会遵循robots规则了.</p><p>另外, 腾讯新闻的渲染好坑啊, 他竟然是把所有的内容都扔到了前面的一个script里面的__initData变量里面(unicode编码)</p><p><strong>12.08的更新: 腾讯新闻居然改版了?? 下面的代码不再适用.</strong></p></blockquote><p>在这个过程中, 我们可以使用一个scrapy提供的调试工具来帮助我们更好的查看错误出在什么地方.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; scrapy shell http://view.inews.qq.com/a/20171125A07ZUK00</span><br><span class="line">...(omitted)</span><br><span class="line">[s] Available Scrapy objects:</span><br><span class="line">[s]   scrapy     scrapy module (contains scrapy.Request, scrapy.Selector, etc)</span><br><span class="line">[s]   crawler    &lt;scrapy.crawler.Crawler object at 0x1041e7550&gt;</span><br><span class="line">[s]   item       &#123;&#125;</span><br><span class="line">[s]   request    &lt;GET http://view.inews.qq.com/a/20171125A07ZUK00&gt;</span><br><span class="line">[s]   response   &lt;200 http://view.inews.qq.com/a/20171125A07ZUK00&gt;</span><br><span class="line">[s]   settings   &lt;scrapy.settings.Settings object at 0x105233940&gt;</span><br><span class="line">[s]   spider     &lt;DefaultSpider <span class="string">&#x27;default&#x27;</span> at 0x10550f668&gt;</span><br><span class="line">[s] Useful shortcuts:</span><br><span class="line">[s]   fetch(url[, redirect=True]) Fetch URL and update <span class="built_in">local</span> objects (by default, redirects are followed)</span><br><span class="line">[s]   fetch(req)                  Fetch a scrapy.Request and update <span class="built_in">local</span> objects</span><br><span class="line">[s]   shelp()           Shell <span class="built_in">help</span> (<span class="built_in">print</span> this <span class="built_in">help</span>)</span><br><span class="line">[s]   view(response)    View response <span class="keyword">in</span> a browser</span><br></pre></td></tr></table></figure><p>接着就来上代码吧:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;qqnews&quot;</span></span><br><span class="line">    start_urls = [<span class="string">&quot;http://news.qq.com/world_index.shtml&quot;</span>]</span><br><span class="line">    cookie = &#123;</span><br><span class="line">        <span class="string">&quot;pgv_pvi&quot;</span>: <span class="string">&quot;6074546176&quot;</span>,</span><br><span class="line">        <span class="string">&quot;RK&quot;</span>: <span class="string">&quot;Kbk2ExxeFH&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pgv_pvid&quot;</span>: <span class="string">&quot;6264596920&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ptcz&quot;</span>: <span class="string">&quot;252b68d3ef2d7ecb0281a23b9f3f2e7c69a5f0d7427c7245392836431c89ce58&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pt2gguin&quot;</span>: <span class="string">&quot;o0438425627&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6)  \</span></span><br><span class="line"><span class="string">        AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Upgrade-Insecure-Requests&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        hotspot = response.xpath(<span class="string">&#x27;//div[@id=&quot;subHot&quot;]/a/@href&#x27;</span>).extract_first()</span><br><span class="line">        news = response.xpath(<span class="string">&#x27;//div[@class=&quot;list first&quot;]/div/div/div/em/a/@href&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> news:</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(item, callback=self.news_parse, cookies=self.cookie, headers=self.headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">news_parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        pattern = <span class="string">r&#x27;&quot;cnt_html&quot;:&quot;(.*)&quot;,&quot;content&quot;&#x27;</span></span><br><span class="line">        raw_content = response.xpath(<span class="string">&#x27;/html/body/script[3]/text()&#x27;</span>).extract_first().strip()</span><br><span class="line">        res = re.search(pattern, raw_content).groups()[<span class="number">0</span>].encode().decode(<span class="string">&#x27;unicode_escape&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">&#x27;article_html&#x27;</span>: res</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>好了, 但是到现在 我们都只是蠢蠢的在yield和print对不, 但是对于一个项目来说 我们是需要一个Item来把他们保存下来的. 这就是scrapy的Item, 注意到子安我们的项目目录中中是存在一个叫做<code>item.py</code>的文件的, 我们在这里面写上需要保存的项目:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QqnewsItem</span>(scrapy.Item):</span><br><span class="line">    article = scrapy.Field()</span><br></pre></td></tr></table></figure><p>接着在爬虫中引入它并给他附上值就行了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qqnews.iterms <span class="keyword">import</span> QqnewsItem</span><br><span class="line">...(omitted)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">news_parse</span>(<span class="params">self, response</span>):</span><br><span class="line">    item = QqnewsItem()</span><br><span class="line">        pattern = <span class="string">r&#x27;&quot;cnt_html&quot;:&quot;(.*)&quot;,&quot;content&quot;&#x27;</span></span><br><span class="line">        raw_content = response.xpath(<span class="string">&#x27;/html/body/script[3]/text()&#x27;</span>).extract_first().strip()</span><br><span class="line">        res = re.search(pattern, raw_content).groups()[<span class="number">0</span>].encode().decode(<span class="string">&#x27;unicode_escape&#x27;</span>)</span><br><span class="line">       item[<span class="string">&#x27;article&#x27;</span>] = res</span><br></pre></td></tr></table></figure><p>接着我们的item还可以继续输送到pipeline中, pipeline正如其名, 将输送进来的数据进行美化加工. 如果有点乱了的话, 不妨看一下前面的架构图</p><p>Pipeline常见的应用场景是:</p><ul><li>清理HTML数据</li><li>抓取关键字</li><li>重复性检查</li><li>存储到DB中</li></ul><p>我们来看一下这个文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QqnewsPipeline</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>): <span class="comment"># 这里传进来的item就是刚刚说的那个啦, 我们可以在这里提取他的字段进行修改和再赋值.</span></span><br><span class="line">        <span class="keyword">return</span> item </span><br></pre></td></tr></table></figure><p>return一个item或者字典, 还可以抛出</p><p>其实, 我们可以通过覆盖一下的几个方法来继续更多的操作</p><ul><li>open_crawler 比如我们打开文件, 打开数据库链接都是在这里搞</li><li>close_crawler close掉链接和文件描述符</li><li>from_crawler 在这个方法中, 我们可以绑定各种钩子以及访问核心组件 信号和配置等</li></ul><p>接下来我打算写一个豆瓣读书的Top250这样的项目, 这一次就会综合上面的各个组件了.</p><p>首先启动项目:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  scrapy startproject douban_book</span><br></pre></td></tr></table></figure><p>接着我们先来定义我们需要抓取的信息有哪些, 然后先把他们呢注册一下.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubanBookItem</span>(scrapy.Item):</span><br><span class="line">    name = scrapy.Field()</span><br><span class="line">    price = scrapy.Field()</span><br><span class="line">    edition_year = scrapy.Field()</span><br><span class="line">    publisher = scrapy.Field()</span><br><span class="line">    rating = scrapy.Field()</span><br></pre></td></tr></table></figure><p>接着就可以开始定义我们的爬虫了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> douban_book.items <span class="keyword">import</span> DoubanBookItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6)  \</span></span><br><span class="line"><span class="string">    AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;https://book.douban.com/&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubanSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&quot;douban_book_Spider&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;douban.com&quot;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://book.douban.com/top250&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="built_in">print</span>(response)</span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(response.url, callback=self.page_parse, headers=header)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> link <span class="keyword">in</span> response.xpath(<span class="string">&#x27;//div[@class=&quot;paginator&quot;]/a/@href&#x27;</span>).extract():</span><br><span class="line">            <span class="built_in">print</span>(link)</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(link, callback=self.page_parse, headers=header)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">page_parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> response.xpath(<span class="string">&#x27;//tr[@class=&quot;item&quot;]&#x27;</span>):</span><br><span class="line">            book = DoubanBookItem()</span><br><span class="line">            book[<span class="string">&#x27;name&#x27;</span>] = item.xpath(<span class="string">&#x27;td[2]/div[1]/a/@title&#x27;</span>).extract_first()</span><br><span class="line">            book[<span class="string">&#x27;rating&#x27;</span>] = item.xpath(<span class="string">&#x27;td[2]/div[2]/span[2]/text()&#x27;</span>).extract_first()</span><br><span class="line">            info = item.xpath(<span class="string">&#x27;td[2]/p[1]/text()&#x27;</span>).extract_first().split(<span class="string">&quot; / &quot;</span>)</span><br><span class="line">            book[<span class="string">&#x27;author&#x27;</span>] = info[<span class="number">0</span>]</span><br><span class="line">            book[<span class="string">&#x27;price&#x27;</span>] = info[-<span class="number">1</span> ]</span><br><span class="line">            book[<span class="string">&#x27;edition_year&#x27;</span>] = info[-<span class="number">2</span>]</span><br><span class="line">            book[<span class="string">&#x27;publisher&#x27;</span>] = info[-<span class="number">3</span>]</span><br><span class="line">            <span class="keyword">yield</span> book</span><br></pre></td></tr></table></figure><p>到此, 我们就完成了一个包含item的爬虫. 但是这个地方要说明一下, 第29-33行的工作其实严格上应该放在pipeline中来处理, 而不是在我们的爬虫中进行处理. 优化后这就是一个较为完整的爬虫项目了 虽然他很微小.</p><p>接下来我们来说一下如何抓取图片, 这是一个很大的需求, 所以scrapy早就为我们想好了, 它提供了一个<code>ImagesPipeline</code>类, 只要将一个item传过去, 并且携带特定的字段就可以继续操作, 包括基本的去重, 缩略图生成, 图片大小过滤. 当然这是需要PIL库的支持的.</p><p>大体说来, 我们的图片爬取步骤几乎是固定的, 就是这样的:</p><ul><li>爬取一个item, 并且将图片的URL加入到其<code>image_urls</code>字段中</li><li>从Spider中返回的item送到pipeline中, 图片在这里会被下载而item被锁定直到下载完成, 最后剩余的一些信息(路径, 校验和等)会被传递到item的相应字段中.</li></ul><p>一个图片item起码要包含:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PictureItem</span>(scrapy.Item):</span><br><span class="line">    images = scrapy.Field()</span><br><span class="line">    image_urls = scrapy.Field()</span><br><span class="line">    image_paths = scrapy.Field()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>images</code>和<code>image_urls</code>这两个属性.</p><p>另外, 写好pipeline之后, 我们需要在<code>setting.py</code>文件中开启该pipeline, 并且制定一些图片下载的全局总控参数, 例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">&#x27;photo_crawler.pipelines.PhotoCrawlerPipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IMAGES_STORE = <span class="string">&#x27;/tmp/pics&#x27;</span></span><br><span class="line">IMAGES_EXPIRES = <span class="number">90</span></span><br><span class="line">IMAGES_MIN_HEIGHT = <span class="number">480</span></span><br><span class="line">IMAGES_MIN_WIDTH = <span class="number">920</span></span><br></pre></td></tr></table></figure><p>尺寸大小小于<code>IMAGES_MIN_HEIGHT*IMAGES_MIN_WIDTH</code>的图片会被忽略.</p><p>接着在spider中, 我们需要通过解析把图片的url都丢到item中, 传给pipeline.</p><p>最重要的部分来了, 我们需要在<code>imagepipeline</code>的继承类中个对下面的两个方法进行重载, <code>get_media_requests(item, info)</code>和<code>item_completed(results, items, info)</code></p><p>其中, 前者返回一个<code>Request</code>对象, 交给后者来处理, 后者处理之后会返回一个元组, 包含是否成功的标识以及图片信息或者报错信息.</p><p>接下来就来试试吧. 先把最基本的爬虫写了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> photo_crawler.items <span class="keyword">import</span> PictureItem</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PicSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;Douban_crawler&#x27;</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://www.douban.com/photos/album/1655441250/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        pic_list = response.xpath(<span class="string">&#x27;//div[@class=&quot;photolst clearfix&quot;]/div/a/@href&#x27;</span>).extract()</span><br><span class="line">        <span class="built_in">print</span>(pic_list)</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> pic_list:</span><br><span class="line">            page = page + <span class="string">&quot;large/&quot;</span></span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url=page, callback=self.parse_large)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_large</span>(<span class="params">self, response</span>):</span><br><span class="line">        picture = PictureItem()</span><br><span class="line">        ori_pic_url = response.xpath(<span class="string">&#x27;//*[@id=&quot;pic-viewer&quot;]/a/img/@src&#x27;</span>).extract()</span><br><span class="line">        picture[<span class="string">&#x27;image_urls&#x27;</span>] = ori_pic_url</span><br><span class="line">        <span class="keyword">yield</span> picture</span><br></pre></td></tr></table></figure><p>这里我们的示例来自豆瓣的相册.</p><p>上面的内容大体在干什么基本都是我上面说过的, 主要是来看看pipeline做了什么:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scrapy.pipelines.images <span class="keyword">import</span> ImagesPipeline</span><br><span class="line"><span class="keyword">from</span> scrapy.exceptions <span class="keyword">import</span> DropItem</span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Request</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhotoCrawlerPipeline</span>(<span class="title class_ inherited__">ImagesPipeline</span>):</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;cookie&quot;</span>:<span class="string">&quot;bid=MsOyVJ-WczQ&quot;</span>,</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>:<span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6)  \</span></span><br><span class="line"><span class="string">        AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_media_requests</span>(<span class="params">self, item, info</span>):</span><br><span class="line">        <span class="keyword">yield</span> Request(item[<span class="string">&#x27;image_urls&#x27;</span>][<span class="number">0</span>], headers=self.headers, meta=item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">item_completed</span>(<span class="params">self, results, item, info</span>):</span><br><span class="line">        <span class="built_in">print</span>(results)</span><br><span class="line">        path = [img[<span class="string">&#x27;path&#x27;</span>] <span class="keyword">for</span> ok, img <span class="keyword">in</span> results <span class="keyword">if</span> ok]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">&#x27;No path&#x27;</span>)</span><br><span class="line">        item[<span class="string">&#x27;image_paths&#x27;</span>] = path</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们简单的写了一个头部, 然后就重载了上面说的那两个方法.</p><p>这样执行之后, 我们就可以看到在<code>SETTING.py</code>文件中定义的存储路径下的图片了, 但是这个时候图片都是SHA-1算法的摘要值, 显然不方便辨认, 所以这就需要我们进行重新命名, 可以在pipeline中加上这个方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">file_path</span>(<span class="params">self, request, response=<span class="literal">None</span>, info=<span class="literal">None</span></span>):</span><br><span class="line">    ext = request.url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>].split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    item_name = request.meta[<span class="string">&#x27;images&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">    path = <span class="string">&#x27;full/&#123;&#125;.&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(item_name, ext)</span><br><span class="line">    <span class="built_in">print</span>(path)</span><br><span class="line">    <span class="keyword">return</span> path</span><br></pre></td></tr></table></figure><p>返回的路径就是文件的位置, 当然也包括了他自己的文件名和后缀. 而且在这里使用到了上面的<code>get_media_requests</code>中meta参数传递的item.</p><h2 id="并发编程-多并发爬虫"><a href="#并发编程-多并发爬虫" class="headerlink" title="并发编程, 多并发爬虫"></a>并发编程, 多并发爬虫</h2><p>在前面的Scrapy使用中 我们发现他爬取的速度非常快, 这是因为它使用了并发和异步的爬取模式.</p><p>我曾经在一开始学习Python的时候稍微了解过一些关于多线程, 多进程的并发编程. 但现在看来, 那个时候理解的显然不够深入, 因此我们现在再来把Python的并发编程复习一遍吧.</p><p>先来写几个小例子吧, 就当是复习了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fork only work on Unix/Linux</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Forking...&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is child process %s&quot;</span> % os.getpid())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;parent process %s&quot;</span> % os.getpid())</span><br></pre></td></tr></table></figure><p>但是我们知道这个fork仅仅工作在Unix&#x2F;Linux平台上, 如果是为了更好的可移植性, 就应该使用一个Python为我们封装好的多进程库<code>multiprocessing</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_process</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Running. (%s)&quot;</span> % os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;parent process %s&quot;</span> % os.getpid())</span><br><span class="line">    p = multiprocessing.Process(target=run_process)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End&quot;</span>) </span><br></pre></td></tr></table></figure><p>对于多线程的支持, Python提供连个模块: <code>_thread</code>和<code>threading</code>. 推荐使用后者, 因为其封装的更高层, 这样我就可以更加专注于业务逻辑的编写上.</p><p>说道多线程就一定会提到一个问题, 那就是<strong>资源争用</strong>. 下面的实验可以的话尽量使用Python2来做测试.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_it</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    balance = balance + n</span><br><span class="line">    balance = balance - n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_thread</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        change_it(n)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run_thread, args=(<span class="number">5</span>,))</span><br><span class="line">t2 = threading.Thread(target=run_thread, args=(<span class="number">8</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"><span class="built_in">print</span>(balance)</span><br></pre></td></tr></table></figure><p>执行之后就会发现balance的值发生了变化.</p><p>那么怎么办呢, 加个锁就行了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_thread</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            change_it(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure><p>速度测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  time python test.py</span><br><span class="line">52</span><br><span class="line">python test.py  0.06s user 0.04s system 117% cpu 0.081 total</span><br><span class="line">➜  time python test.py</span><br><span class="line">50</span><br><span class="line">python test.py  0.06s user 0.04s system 115% cpu 0.081 total</span><br><span class="line">➜  time python test.py</span><br><span class="line">10</span><br><span class="line">python test.py  0.06s user 0.04s system 117% cpu 0.085 total</span><br></pre></td></tr></table></figure><p>在加了锁之后:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  time python test.py</span><br><span class="line">0</span><br><span class="line">python test.py  0.16s user 0.16s system 133% cpu 0.237 total</span><br><span class="line">➜  time python test.py</span><br><span class="line">0</span><br><span class="line">python test.py  0.16s user 0.15s system 130% cpu 0.234 total</span><br><span class="line">➜  time python test.py</span><br><span class="line">0</span><br><span class="line">python test.py  0.16s user 0.16s system 131% cpu 0.245 total</span><br></pre></td></tr></table></figure><p>接着我们再说一下线程安全的(当然也有对多进程的)队列, Python提供了先进先出的, 后进先出的, 以及优先队列三种. 当队列中没有元素的时候获取就会发生阻塞, 同样, 当队列满了的时候加入元素也会造成阻塞.</p><p>一个消费者&#x2F;生产者模型:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Current thread: %s started.&quot;</span> % threading.current_thread().name)</span><br><span class="line">        <span class="keyword">return</span> func(*args)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(randint(<span class="number">0</span>,<span class="number">2</span>))</span><br><span class="line">        q.put(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pull</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        q.get()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Get one element. Current size: %d&quot;</span> % q.qsize())</span><br><span class="line"></span><br><span class="line">threads = [ threading.Thread(target=push, name=<span class="string">&quot;Push_thread&quot;</span>), threading.Thread(target=pull, name=<span class="string">&quot;Pull_thread&quot;</span>)]</span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.start()</span><br></pre></td></tr></table></figure><p>样例输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  python3 queueTest.py</span><br><span class="line">Current thread: Push_thread started.</span><br><span class="line">Current thread: Pull_thread started.</span><br><span class="line">Get one element. Current size: 0</span><br><span class="line">Get one element. Current size: 0</span><br><span class="line">Get one element. Current size: 3</span><br><span class="line">Get one element. Current size: 2</span><br><span class="line">Get one element. Current size: 1</span><br><span class="line">Get one element. Current size: 0</span><br></pre></td></tr></table></figure><p>我们在之前也提到过一个叫threadLocal的玩意, 这个东西其实你可以理解成是为了方便我们的变量获取而封装的一个东西.</p><p>由于我们创建和销毁进程是需要成本的, 所以使用<strong>线程池</strong>就可以充分利用CPU以及降低切换成本. 例子就略啦.</p><p>接下来就来开始这一部分的正式内容吧, 先来说说协程. 使用select进行一步IO, 缺点在于不能实现消息循环和状态控制.</p><p>来一段代码来做演示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">wget</span>(<span class="params">host</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;wget %s...&quot;</span> % host)</span><br><span class="line">    connect = asyncio.open_connection(host, <span class="number">80</span>)</span><br><span class="line">    reader, writer = <span class="keyword">await</span> connect</span><br><span class="line">    header = <span class="string">&#x27;GET / HTTP/1.1\r\nHost: %s\r\n\r\n&#x27;</span> % host</span><br><span class="line">    writer.write(header.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">await</span> writer.drain()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = <span class="keyword">await</span> reader.readline()</span><br><span class="line">        <span class="keyword">if</span> line == <span class="string">b&#x27;\r\n&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s header &gt; %s&#x27;</span> % (host, line.decode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">hosts = [<span class="string">&#x27;www.google.com&#x27;</span>, <span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;www.sina.com&#x27;</span>, <span class="string">&#x27;www.douban.com&#x27;</span>]</span><br><span class="line">tasks = [wget(host) <span class="keyword">for</span> host <span class="keyword">in</span> hosts]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><p>这里的<code>async</code>和<code>await</code>是Python3.5以后的版本中新增的关键字, 如果是以前的版本, 应该使用<code>@asyncio.coroutine</code>装饰器和<code>yield from</code>关键字.</p><p>尽管google没法访问到, 但是我们依然可以不受到干扰的得到其他的头部信息.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#######################################################################</span></span><br><span class="line"><span class="comment"># File Name: pic_crawler.py</span></span><br><span class="line"><span class="comment"># Author:Justin</span></span><br><span class="line"><span class="comment"># mail:justin13wyx@gmail.com</span></span><br><span class="line"><span class="comment"># Created Time: Tue Dec 12 20:53:47 2017</span></span><br><span class="line"><span class="comment"># ==============================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">url, name=<span class="literal">None</span>, path=<span class="string">&quot;/tmp/&quot;</span></span>):</span><br><span class="line">    data = requests.get(url).content</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> name:</span><br><span class="line">        name = url.split(<span class="string">&quot;/&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line">    path = path.join([name])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;downloading %s&quot;</span> % path)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> pic:</span><br><span class="line">        pic.write(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">content</span>):</span><br><span class="line">    data = json.loads(content, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    imgs = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data[<span class="string">&quot;list&quot;</span>]:</span><br><span class="line">        sub_item = item[<span class="string">&quot;arr&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;image&quot;</span> <span class="keyword">in</span> sub_item[<span class="string">&quot;type&quot;</span>]:</span><br><span class="line">            imgs.extend(<span class="string">&quot;http://litten.me/ins/%s.jpg&quot;</span> % img <span class="keyword">for</span> img <span class="keyword">in</span> sub_item[<span class="string">&quot;link&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> [ threading.Thread(target=download, name=<span class="string">&quot;download_thread&quot;</span>, args=(img,)) <span class="keyword">for</span> img <span class="keyword">in</span> imgs ]:</span><br><span class="line">        thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crawl</span>(<span class="params">url=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> url:</span><br><span class="line">        stamp = <span class="built_in">int</span>(datetime.now().timestamp() * <span class="number">1000</span>)</span><br><span class="line">        target = <span class="string">&quot;http://litten.me/photos/ins.json?t=%s&quot;</span> % <span class="built_in">str</span>(stamp)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        target = url</span><br><span class="line">    content = requests.get(target).text</span><br><span class="line">    parse(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    crawl()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Spider </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>drbd实现HA的MySQL集群</title>
      <link href="/2017/10/29/drbd%E5%AE%9E%E7%8E%B0HA%E7%9A%84MySQL%E9%9B%86%E7%BE%A4/"/>
      <url>/2017/10/29/drbd%E5%AE%9E%E7%8E%B0HA%E7%9A%84MySQL%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<p>现在我们来把目光放在HA存储上面吧~</p><span id="more"></span><h2 id="drbd简述"><a href="#drbd简述" class="headerlink" title="drbd简述"></a>drbd简述</h2><p>什么是drbd? 全称是Distributed Replicated Block Device, 分布式复制块设备.基于内核和相关脚本构建的.用来构建高可用性的集群. 总体来看, 就像是基于网络的RAID1. 可以进行数据块级别的复制, 由于存在在文件系统模块的下层, 所以当然是无法理解文件系统的层次.</p><p>整体的一个流程如下:</p><p><img src="https://terry.im/wiki/terry/attachments/33325169/33554434.gif" alt="img"></p><p>其中有底色的那一个大块就是我们的内核空间, 上方就是用户空间, 用户空间的应用程序发起写入的系统调用请求将数据写入到磁盘设备, 原本应该是经过FS -&gt; BC -&gt; DS -&gt; DD最后进入硬件设备的, 但是我们的DRBD在中间横插一刀, 将写入的数据原封不动的复制一遍, 并且通过TCP&#x2F;IP协议栈经由网卡发送出去. 另外一边,接收端收到之后发送到DRBD, 接着进过scheduler通过驱动到达磁盘.</p><p>同样, 这样的模型也规定了DRBD只能是一读一写, 读写分离的形式, 一旦出现双写, 就会造成数据不一致的情况. 当然, 双主模型也不是不可以, 只不过需要分布式文件系统的援助. 利用它的分布式锁机制才可以.</p><p>上述的这个过程, 其实就是在镜像一个数据, 主要有三个特点:</p><ul><li>实时性: 复制立即发生</li><li>透明性: 数据的存放是透明和独立的</li><li>同步和异步</li></ul><p>到这里, 我们就对DRBD有了一个大体的印象了, 有没有觉得他有点像我们之前说的一个内核模块? <strong>LVS</strong>. 对了~当时我们通过<code>ipvsadm</code>来进行规则的管理, 同样, 我们的DRBD也提供了用户空间的管理工具 – <code>drbdadm</code>. 此工具更高层, 更贴近用户. 比较低层的有: <code>drbdsetup</code>和<code>drbdmeta</code>. 前者是底层配置后者用来修改管理数据结构. adm其实就是对这些工具高层封装.</p><p>使用这些前端管理工具就可以使得DRBD发挥效果, 但是在说到配置之前, 我们先来看看DRBD的工作模式.</p><p>DRBD有三种复制的方式,我们可以概括成: <strong>同步, 半同步, 异步</strong>.</p><p>我们知道DRBD是基于网络的, 而且之前我们也说过, 当发起系统调用之后会进入不可中断的睡眠态, 而直到返回结果才会继续执行. 而上面这几个复制方式区别就在什么时候返回处理结果上. </p><p>如果是刚刚提交就返回, 那就是异步. 如果是将数据扔到自己的消息队列上的时候再返回, 那就是半同步. 如果是把数据交给对方, 并且已经到达了的, 那就是同步的.</p><p>现在就可以说说DRBD的资源构成了. 必须要有的有三个部分:</p><ul><li>名字: 只允许不包含空格符的ASCII字符</li><li>drbd设备: &#x2F;dev&#x2F;drbd#<ul><li>主设备号: 147</li></ul></li><li>磁盘配置: 各个主机用于组成drbd设备的磁盘或者分区;</li><li>网络配置: 节点通信间的网络通信属性;</li></ul><h2 id="drdb的使用"><a href="#drdb的使用" class="headerlink" title="drdb的使用"></a>drdb的使用</h2><blockquote><p>有点坑..这个drbd. 我们用CentOS6来实现.</p></blockquote><p>首先安装必要的服务, 主要是两个rpm包, 一个是drbd84-utils, 一个是kmod-drbd84. 其中第二个需要特定的内核补丁.</p><p>安装完成了之后, 我们看一下生成的文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ~]<span class="comment"># rpm -ql drbd84-utils</span></span><br><span class="line">/etc/bash_completion.d/drbdadm</span><br><span class="line">/etc/drbd.conf</span><br><span class="line">/etc/drbd.d</span><br><span class="line">/etc/drbd.d/global_common.conf</span><br><span class="line">/etc/ha.d/resource.d/drbddisk</span><br><span class="line">/etc/ha.d/resource.d/drbdupper</span><br><span class="line">/etc/rc.d/init.d/drbd</span><br><span class="line">/etc/xen/scripts/block-drbd</span><br><span class="line">/lib/drbd/drbdadm-84</span><br><span class="line">/lib/drbd/drbdsetup-84</span><br><span class="line">/lib/udev/rules.d/65-drbd.rules</span><br><span class="line">/sbin/drbdadm</span><br><span class="line">/sbin/drbdmeta</span><br><span class="line">/sbin/drbdsetup</span><br><span class="line">/usr/lib/drbd</span><br><span class="line">/usr/lib/drbd/crm-fence-peer.sh</span><br><span class="line">/usr/lib/drbd/crm-unfence-peer.sh</span><br><span class="line">/usr/lib/drbd/notify-emergency-reboot.sh</span><br><span class="line">/usr/lib/drbd/notify-emergency-shutdown.sh</span><br><span class="line">/usr/lib/drbd/notify-io-error.sh</span><br><span class="line">/usr/lib/drbd/notify-out-of-sync.sh</span><br><span class="line">/usr/lib/drbd/notify-pri-lost-after-sb.sh</span><br><span class="line">/usr/lib/drbd/notify-pri-lost.sh</span><br><span class="line">/usr/lib/drbd/notify-pri-on-incon-degr.sh</span><br><span class="line">/usr/lib/drbd/notify-split-brain.sh</span><br><span class="line">/usr/lib/drbd/notify.sh</span><br><span class="line">/usr/lib/drbd/outdate-peer.sh</span><br><span class="line">/usr/lib/drbd/rhcs_fence</span><br><span class="line">/usr/lib/drbd/snapshot-resync-target-lvm.sh</span><br><span class="line">/usr/lib/drbd/stonith_admin-fence-peer.sh</span><br><span class="line">/usr/lib/drbd/unsnapshot-resync-target-lvm.sh</span><br><span class="line">/usr/lib/ocf/resource.d/linbit/drbd</span><br><span class="line">/usr/sbin/drbd-overview</span><br><span class="line">/usr/sbin/drbdadm</span><br><span class="line">/usr/sbin/drbdmeta</span><br><span class="line">/usr/sbin/drbdsetup</span><br><span class="line">/usr/share/cluster/drbd.metadata</span><br><span class="line">/usr/share/cluster/drbd.sh</span><br><span class="line">...(omitted)</span><br><span class="line">/var/lib/drbd</span><br></pre></td></tr></table></figure><p>三个执行程序都是这个包提供的. 而另外一边, kmod其实就是安装了一个ko而已.</p><p>我们来看看配置文件吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;drbd.d/global_common.conf&quot;</span>;</span><br><span class="line">include <span class="string">&quot;drbd.d/*.res&quot;</span>;</span><br></pre></td></tr></table></figure><p>是模块式的配置, 显然<code>global_common</code>就是全局配置了, 而其他所有以<code>res</code>结尾的. 就都是我们的资源配置了.</p><p>先来看一下全局配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 drbd.d]<span class="comment"># grep &quot;&#123;$&quot; global_common.conf </span></span><br><span class="line">global &#123;</span><br><span class="line">common &#123;</span><br><span class="line">handlers &#123;</span><br><span class="line">startup &#123;</span><br><span class="line">options &#123;</span><br><span class="line">disk &#123;</span><br><span class="line">net &#123;</span><br></pre></td></tr></table></figure><p>层次一目了然. 全局和通用配置, 通用配置就是每一个drbd设备的配置</p><p>其中global定义drbd整体的工作属性, 关于这个没什么好设置的, 接着是handlers. 其实就是当发生了一些情况的时候调用哪些脚本的处理器, 接着startup定义启动时超时选项等等, options指定一些同步属性, disk用来指明磁盘属性,net指定属性, 我们可以在这里添加使用的带宽大小以及加密选项.</p><p>简单的配置一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">disk &#123;</span><br><span class="line">    on-io-error detach;</span><br><span class="line">&#125;</span><br><span class="line">net &#123;</span><br><span class="line">    protocol C;</span><br><span class="line">    cram-hmac-alg <span class="string">&#x27;sha1&#x27;</span>;</span><br><span class="line">    shared-secret <span class="string">&#x27;52f5308f3a2f9b31ba&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就来定义一下资源(mysql.res):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">resource mysql &#123;</span><br><span class="line">        on VM-node3 &#123;</span><br><span class="line">                device /dev/drbd0;</span><br><span class="line">                disk /dev/sdb1;</span><br><span class="line">                meta-disk internal;</span><br><span class="line">                address 192.168.206.22:7789;</span><br><span class="line">        &#125;</span><br><span class="line">        on VM-node4 &#123;</span><br><span class="line">                device /dev/drbd0;</span><br><span class="line">                disk /dev/sdb1;</span><br><span class="line">                meta-disk internal;        </span><br><span class="line">                address 192.168.206.23:7789;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里, 同样的项目可以整合在一起, 于是我们的资源定义就简化成这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resource mysql &#123;</span><br><span class="line">        device /dev/drbd0;</span><br><span class="line">        disk /dev/sdb1;</span><br><span class="line">        meta-disk internal;</span><br><span class="line">        on VM-node3 &#123;</span><br><span class="line">                address 192.168.206.22:7789;</span><br><span class="line">        &#125;</span><br><span class="line">        on VM-node4 &#123;</span><br><span class="line">                address 192.168.206.23:7789;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中, meta-link 表示元数据存放在哪里. internal表示就在原磁盘上.</p><p>OK, 接着确定配置是一样的, 我们把它拷贝到另一个节点上, 当然另一个节点是已经安装过drbd的.</p><p>接下来就可以直接启动服务了, 但是在此次之前, 我们还需要初始化一下资源, 由于我之前写的是sdb1, 所以还是要先加进来一块新的磁盘并且进行分区的.</p><p>接着执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node4 ~]<span class="comment"># drbdadm create-md mysql</span></span><br><span class="line">initializing activity <span class="built_in">log</span></span><br><span class="line">NOT initializing bitmap</span><br><span class="line">Writing meta data...</span><br><span class="line">New drbd meta data block successfully created.</span><br></pre></td></tr></table></figure><p>两边都要做这样的操作,接着就可以启动服务了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ~]<span class="comment"># service drbd start</span></span><br><span class="line">Starting DRBD resources: [</span><br><span class="line">     create res: mysql</span><br><span class="line">   prepare disk: mysql</span><br><span class="line">    adjust disk: mysql</span><br><span class="line">     adjust net: mysql</span><br><span class="line">]</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>注意: 如果只启动一端, 会等待另外一边的启动. 直到两方都启动才会成功启动.</p><p>接下来, 我们可以通过下面的方式来查看当前drbd的状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ~]<span class="comment"># cat /proc/drbd</span></span><br><span class="line">version: 8.4.7-1 (api:1/proto:86-101)</span><br><span class="line">GIT-<span class="built_in">hash</span>: 3a6a769340ef93b1ba2792c6461250790795db49 build by mockbuild@Build64R6, 2016-01-12 13:27:11</span><br><span class="line"> 0: cs:Connected ro:Secondary/Secondary ds:Inconsistent/Inconsistent C r-----</span><br><span class="line">    ns:0 nr:0 dw:0 dr:0 al:0 bm:0 lo:0 pe:0 ua:0 ap:0 ep:1 wo:f oos:3144572</span><br><span class="line">[root@VM-node3 ~]<span class="comment"># drbd-overview </span></span><br><span class="line"> 0:mysql/0  Connected Secondary/Secondary Inconsistent/Inconsistent </span><br></pre></td></tr></table></figure><p>你会发现, 现在我们的drbd都是备用节点, 而且数据不一致. 所以我们必须手动的将其中一个节点变成主节点才行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ~]<span class="comment"># drbdadm primary --force mysql</span></span><br><span class="line">[root@VM-node3 ~]<span class="comment"># cat /proc/drbd</span></span><br><span class="line">version: 8.4.7-1 (api:1/proto:86-101)</span><br><span class="line">GIT-<span class="built_in">hash</span>: 3a6a769340ef93b1ba2792c6461250790795db49 build by mockbuild@Build64R6, 2016-01-12 13:27:11</span><br><span class="line"> 0: cs:SyncSource ro:Primary/Secondary ds:UpToDate/Inconsistent C r-----</span><br><span class="line">    ns:2924 nr:0 dw:0 dr:3756 al:0 bm:0 lo:0 pe:1 ua:3 ap:0 ep:1 wo:f oos:3141692</span><br><span class="line">[&gt;....................] <span class="built_in">sync</span><span class="string">&#x27;ed:  0.2% (3141692/3144572)K</span></span><br><span class="line"><span class="string">finish: 0:32:43 speed: 1,440 (1,440) K/sec</span></span><br><span class="line"><span class="string">[root@VM-node3 ~]# cat /proc/drbd</span></span><br><span class="line"><span class="string">version: 8.4.7-1 (api:1/proto:86-101)</span></span><br><span class="line"><span class="string">GIT-hash: 3a6a769340ef93b1ba2792c6461250790795db49 build by mockbuild@Build64R6, 2016-01-12 13:27:11</span></span><br><span class="line"><span class="string"> 0: cs:SyncSource ro:Primary/Secondary ds:UpToDate/Inconsistent C r-----</span></span><br><span class="line"><span class="string">    ns:14512 nr:0 dw:0 dr:15572 al:0 bm:0 lo:0 pe:1 ua:4 ap:0 ep:1 wo:f oos:3130076</span></span><br><span class="line"><span class="string">[&gt;....................] sync&#x27;</span>ed:  0.6% (3130076/3144572)K</span><br><span class="line">finish: 0:21:08 speed: 2,416 (2,416) K/sec</span><br></pre></td></tr></table></figure><p>接着数据就会开始进行复制. 同步完成之后就是这个状态了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ~]<span class="comment"># cat /proc/drbd</span></span><br><span class="line">version: 8.4.7-1 (api:1/proto:86-101)</span><br><span class="line">GIT-<span class="built_in">hash</span>: 3a6a769340ef93b1ba2792c6461250790795db49 build by mockbuild@Build64R6, 2016-01-12 13:27:11</span><br><span class="line"> 0: cs:Connected ro:Primary/Secondary ds:UpToDate/UpToDate C r-----</span><br><span class="line">    ns:3144572 nr:0 dw:0 dr:3145244 al:0 bm:0 lo:0 pe:0 ua:0 ap:0 ep:1 wo:f oos:0</span><br></pre></td></tr></table></figure><p>我们的节点是主节点, 而且双方都是UpToDate的状态.</p><p>接着就可以开始格式化文件系统了, 由于我们的drbd是位级别对齐的, 所以文件系统也会自动的同步过去.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ~]<span class="comment"># mke2fs -t ext4 /dev/drbd0</span></span><br><span class="line">mke2fs 1.41.12 (17-May-2010)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Fragment size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">196608 inodes, 786143 blocks</span><br><span class="line">39307 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=805306368</span><br><span class="line">24 block <span class="built_in">groups</span></span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">32768, 98304, 163840, 229376, 294912</span><br><span class="line"></span><br><span class="line">Writing inode tables: <span class="keyword">done</span>                            </span><br><span class="line">Creating journal (16384 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">This filesystem will be automatically checked every 35 mounts or</span><br><span class="line">180 days, whichever comes first.  Use tune2fs -c or -i to override.</span><br><span class="line">[root@VM-node3 ~]<span class="comment"># mount /dev/drbd0 /mnt/</span></span><br><span class="line">[root@VM-node3 ~]<span class="comment"># ls /mnt/</span></span><br><span class="line">lost+found</span><br></pre></td></tr></table></figure><p>这样就可以正常使用了. 另外 如果进行主备的切换, 我们就需要首先卸载, 接着降级主节点, 升级备用节点, 接着备用节点就可以进行挂载使用了, 反之亦然.</p><p>那么, 切换来切换去真是是很麻烦的, 所以我们可以将这个drbd设备定义成资源, 通过HA服务来进行自动的调度.</p><p>OK, 以上就是我们MySQL高可用的前导基础准备了. 现在就可以正式开始了.</p><h2 id="项目-drbd-pacemaker实现高可用MySQL集群"><a href="#项目-drbd-pacemaker实现高可用MySQL集群" class="headerlink" title="项目: drbd+pacemaker实现高可用MySQL集群"></a>项目: drbd+pacemaker实现高可用MySQL集群</h2><p>当前是一个肥肠干净的集群, 没有配置任何资源:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ~]<span class="comment"># pcs status</span></span><br><span class="line">Cluster name: </span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: VM-node3 (version 1.1.15-5.el6-e174ec8) - partition with quorum</span><br><span class="line">Last updated: Tue Oct 31 19:09:26 2017Last change: Mon Oct 30 23:24:09 2017 by root via cibadmin on VM-node4</span><br><span class="line">, 2 expected votes</span><br><span class="line">2 nodes and 0 resources configured</span><br><span class="line"></span><br><span class="line">Online: [ VM-node3 VM-node4 ]</span><br><span class="line"></span><br><span class="line">No resources</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Daemon Status:</span><br><span class="line">  corosync: active/disabled</span><br><span class="line">  pacemaker: active/disabled</span><br><span class="line">  pcsd: active/disabled</span><br></pre></td></tr></table></figure><p>接着我们就要开始配置drbd的资源了, 我们来看一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">crm(live)ra<span class="comment"># classes</span></span><br><span class="line">lsb</span><br><span class="line">ocf / .isolation heartbeat linbit pacemaker</span><br><span class="line">service</span><br><span class="line">stonith</span><br></pre></td></tr></table></figure><p>多了一个linbit. 这个其实就是我们的drbd的ra了, 接着来看一下需要哪些参数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parameters (*: required, []: default):</span><br><span class="line"></span><br><span class="line">drbd_resource* (string): drbd resource name</span><br><span class="line">    The name of the drbd resource from the drbd.conf file.</span><br></pre></td></tr></table></figure><p>至此都和以前没什么 区别, 但是 drbd资源特殊的性表现在主从上, 这是一个clone资源, 一主一从, 如果要配置主从资源, 在crmsh中, 我们在configure中使用ms这个关键字来指明. 不过, 有哪些参数呢? 这些参数就是pacemaker中定义克隆资源的专用属性, 有这些:</p><ul><li>clone-max: 最多克隆出的份数</li><li>clone-node-max: 在单个节点上最多运行几个克隆</li><li>notify: 当一份克隆启动或者停止的时候, 是否通知给其他的节点</li><li>master-max: 最多克隆的master资源的个数</li><li>master-node-max: 同一个节点最多运行多少master资源</li></ul><p>那么我们来定义一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ~]<span class="comment"># crm</span></span><br><span class="line">crm(live)<span class="comment"># configure</span></span><br><span class="line">crm(live)configure<span class="comment"># primitive drbd_mysql ocf:linbit:drbd drbd_resource=&quot;mysql&quot; op monitor role=&quot;Slave&quot; interval=20s timeout=20s op monitor role=&quot;Master&quot; interval=10s timeout=20s</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">WARNING: drbd_mysql: default <span class="built_in">timeout</span> 20s <span class="keyword">for</span> start is smaller than the advised 240</span><br><span class="line">WARNING: drbd_mysql: default <span class="built_in">timeout</span> 20s <span class="keyword">for</span> stop is smaller than the advised 100</span><br><span class="line">crm(live)configure<span class="comment"># delete drbd_mysql</span></span><br><span class="line">crm(live)configure<span class="comment"># primitive drbd_mysql ocf:linbit:drbd drbd_resource=&quot;mysql&quot; op monitor role=&quot;Slave&quot; interval=20s timeout=20s op monitor role=&quot;Master&quot; interval=10s timeout=20s op start timeout=240s op stop timeout=100</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">crm(live)configure<span class="comment"># ms ms_drbd_mysql drbd_mysql meta clone-max=&quot;2&quot; clone-node-max=&quot;1&quot; master-max=&quot;1&quot; master-node-max=&quot;1&quot; notify=&quot;true&quot;</span></span><br><span class="line">crm(live)configure<span class="comment"># commit</span></span><br><span class="line">crm(live)configure<span class="comment"># cd</span></span><br><span class="line">crm(live)<span class="comment"># status</span></span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: VM-node3 (version 1.1.15-5.el6-e174ec8) - partition with quorum</span><br><span class="line">Last updated: Tue Oct 31 22:54:17 2017Last change: Tue Oct 31 22:54:14 2017 by root via cibadmin on VM-node3</span><br><span class="line">, 2 expected votes</span><br><span class="line">2 nodes and 2 resources configured</span><br><span class="line"></span><br><span class="line">Online: [ VM-node3 VM-node4 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> Master/Slave Set: ms_drbd_mysql [drbd_mysql]</span><br><span class="line">     Masters: [ VM-node4 ]</span><br><span class="line">     Slaves: [ VM-node3 ]</span><br><span class="line"></span><br><span class="line">crm(live)<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">bye</span></span><br><span class="line">[root@VM-node3 ~]<span class="comment"># drbd-overview </span></span><br><span class="line"> 0:mysql/0  Connected Secondary/Primary UpToDate/UpToDate </span><br></pre></td></tr></table></figure><p>服务已然运行.</p><p>但是我们说过, 如果没有文件系统, 是没办法工作的, 所以我们要继续添加 文件系统的资源, 不仅如此, 这个资源还应该在drbd之后启动, 而且, 他还必须在主节点上, 这就同时有了位置和顺序的约束:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">crm(live)configure<span class="comment"># primitive drbd_fs ocf:heartbeat:Filesystem params device=&quot;/dev/drbd0&quot; directory=&quot;/data&quot; fstype=&quot;ext4&quot; op monitor interval=20s timeout=40s op start timeout=60s op stop timeout=60s</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">crm(live)configure<span class="comment"># show</span></span><br><span class="line">node VM-node3</span><br><span class="line">node VM-node4</span><br><span class="line">primitive drbd_fs Filesystem \</span><br><span class="line">params device=<span class="string">&quot;/dev/drbd0&quot;</span> directory=<span class="string">&quot;/data&quot;</span> fstype=ext4 \</span><br><span class="line">op monitor interval=20s <span class="built_in">timeout</span>=40s \</span><br><span class="line">op start <span class="built_in">timeout</span>=60s interval=0 \</span><br><span class="line">op stop <span class="built_in">timeout</span>=60s interval=0</span><br><span class="line">primitive drbd_mysql ocf:linbit:drbd \</span><br><span class="line">params drbd_resource=mysql \</span><br><span class="line">op monitor role=Slave interval=20s <span class="built_in">timeout</span>=20s \</span><br><span class="line">op monitor role=Master interval=10s <span class="built_in">timeout</span>=20s \</span><br><span class="line">op start <span class="built_in">timeout</span>=240s interval=0 \</span><br><span class="line">op stop <span class="built_in">timeout</span>=100 interval=0</span><br><span class="line">ms ms_drbd_mysql drbd_mysql \</span><br><span class="line">meta clone-max=2 clone-node-max=1 master-max=1 master-node-max=1 notify=<span class="literal">true</span></span><br><span class="line">property cib-bootstrap-options: \</span><br><span class="line">have-watchdog=<span class="literal">false</span> \</span><br><span class="line">dc-version=1.1.15-5.el6-e174ec8 \</span><br><span class="line">cluster-infrastructure=<span class="string">&quot;classic openais (with plugin)&quot;</span> \</span><br><span class="line">expected-quorum-votes=2 \</span><br><span class="line">stonith-enabled=<span class="literal">false</span></span><br><span class="line">crm(live)configure<span class="comment"># colocation drbd_fs_with_drbd_mysql inf: drbd_fs ms_drbd_mysql:Master</span></span><br><span class="line">crm(live)configure<span class="comment"># order drbd_fs_after_drbd_mysql Mandatory: ms_drbd_mysql:promote drbd_fs:start</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">crm(live)configure<span class="comment"># commit</span></span><br><span class="line">crm(live)configure<span class="comment"># cd</span></span><br><span class="line">crm(live)<span class="comment"># status</span></span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: VM-node3 (version 1.1.15-5.el6-e174ec8) - partition with quorum</span><br><span class="line">Last updated: Wed Nov  1 10:23:41 2017Last change: Wed Nov  1 10:23:37 2017 by root via cibadmin on VM-node3</span><br><span class="line">, 2 expected votes</span><br><span class="line">2 nodes and 3 resources configured</span><br><span class="line"></span><br><span class="line">Online: [ VM-node3 VM-node4 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> Master/Slave Set: ms_drbd_mysql [drbd_mysql]</span><br><span class="line">     Masters: [ VM-node4 ]</span><br><span class="line">     Slaves: [ VM-node3 ]</span><br><span class="line"> drbd_fs(ocf::heartbeat:Filesystem):Started VM-node4</span><br></pre></td></tr></table></figure><p>可以看到, 文件系统在VM-node4上启动, 原因当然就是因为VM-node4是master节点了, 现在我们下线node4:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node4 scripts]<span class="comment"># pcs node standby VM-node4</span></span><br></pre></td></tr></table></figure><p>接着就可以看到, 资源一起转移到VM-node3:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ~]<span class="comment"># mount</span></span><br><span class="line">...(omitted)</span><br><span class="line">/dev/drbd0 on /data <span class="built_in">type</span> ext4 (rw)</span><br></pre></td></tr></table></figure><p>接下来就要安装MariaDB了, 熟悉的流程, 但是这一次要注意我们只能在master节点上进行安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ~]<span class="comment"># crm status</span></span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: VM-node3 (version 1.1.15-5.el6-e174ec8) - partition with quorum</span><br><span class="line">Last updated: Wed Nov  1 11:56:45 2017Last change: Wed Nov  1 11:56:43 2017 by root via crm_attribute on VM-node4</span><br><span class="line">, 2 expected votes</span><br><span class="line">2 nodes and 3 resources configured</span><br><span class="line"></span><br><span class="line">Online: [ VM-node3 VM-node4 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> Master/Slave Set: ms_drbd_mysql [drbd_mysql]</span><br><span class="line">     Masters: [ VM-node3 ]</span><br><span class="line">     Slaves: [ VM-node4 ]</span><br><span class="line"> drbd_fs(ocf::heartbeat:Filesystem):Started VM-node3</span><br><span class="line">[root@VM-node3 ~]<span class="comment"># groupadd -r -g 306 mysql</span></span><br><span class="line">[root@VM-node3 ~]<span class="comment"># useradd -r -g 306 -u 306 mysql</span></span><br><span class="line">[root@VM-node3 mariadb55]<span class="comment"># chown root:mysql -R mysql</span></span><br><span class="line">[root@VM-node3 mysql]<span class="comment"># bash scripts/mysql_install_db --user=mysql --datadir=/data/db_data/</span></span><br><span class="line">[root@VM-node3 db_data]<span class="comment"># cp /usr/local/src/mariadb55/mysql/support-files/mysql.server /etc/rc.d/init.d/mysqld</span></span><br><span class="line">[root@VM-node3 db_data]<span class="comment"># chkconfig --add mysqld</span></span><br><span class="line">[root@VM-node3 db_data]<span class="comment"># chkconfig mysqld off</span></span><br><span class="line">[root@VM-node3 db_data]<span class="comment"># mkdir /etc/mysql</span></span><br><span class="line">[root@VM-node3 db_data]<span class="comment"># cp /usr/local/src/mariadb55/mysql/support-files/my-large.cnf /etc/mysql/my.cnf</span></span><br><span class="line">[root@VM-node3 db_data]<span class="comment"># vim /etc/mysql/my.cnf </span></span><br><span class="line">---(In Vim)</span><br><span class="line">[mysqld]</span><br><span class="line">...(omitted)</span><br><span class="line">datadir = /data/db_data</span><br><span class="line">innodb_file_per_table = on</span><br><span class="line">skip_name_resolve = on</span><br><span class="line">---(Quit)</span><br><span class="line">[root@VM-node3 db_data]<span class="comment"># service mysqld start</span></span><br><span class="line">Starting MySQL.171101 13:29:07 mysqld_safe Logging to <span class="string">&#x27;/data/db_data/VM-node3.err&#x27;</span>.</span><br><span class="line">171101 13:29:07 mysqld_safe Starting mysqld daemon with databases from /data/db_data</span><br><span class="line">. SUCCESS! </span><br><span class="line">[root@VM-node3 db_data]<span class="comment"># /usr/local/src/mariadb55/mysql/bin/mysql</span></span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection <span class="built_in">id</span> is 2</span><br><span class="line">Server version: 5.5.58-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;192.168.206.%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;cluster&#x27;</span>;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; FLUSH PRIVILEGES;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; quit</span><br><span class="line">Bye</span><br><span class="line">[root@VM-node3 db_data]<span class="comment"># service mysqld stop</span></span><br><span class="line">Shutting down MySQL.. SUCCESS! </span><br></pre></td></tr></table></figure><p>接下来master切换成另一个(让node3成为standby), 这个时候就不需要初始化了, 因为我们的文件是镜像过来的. 直接复制一下配置文件启动一下服务试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node4 mysql]<span class="comment"># mkdir /etc/mysql</span></span><br><span class="line">---</span><br><span class="line">[root@VM-node3 ~]<span class="comment"># scp /etc/mysql/my.cnf VM-node4:/etc/mysql/my.cnf </span></span><br><span class="line">---</span><br><span class="line">[root@VM-node4 mysql]<span class="comment"># cp support-files/mysql.server /etc/rc.d/init.d/mysqld</span></span><br><span class="line">[root@VM-node4 mysql]<span class="comment"># chkconfig --add mysqld</span></span><br><span class="line">[root@VM-node4 mysql]<span class="comment"># chkconfig mysqld off</span></span><br><span class="line">[root@VM-node4 mysql]<span class="comment"># service mysqld start</span></span><br><span class="line">Starting MySQL.171101 13:40:50 mysqld_safe Logging to <span class="string">&#x27;/data/db_data/VM-node4.err&#x27;</span>.</span><br><span class="line">171101 13:40:50 mysqld_safe Starting mysqld daemon with databases from /data/db_data</span><br><span class="line">..                                                         [  OK  ]</span><br></pre></td></tr></table></figure><p>OK, 如果数据库服务已经OK, 就可以配置资源和资源约束了. 当然我们还需要一个虚拟的IP地址.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">crm(live)<span class="comment"># configure </span></span><br><span class="line">crm(live)configure<span class="comment"># primitive ip ocf:heartbeat:IPaddr params ip=&quot;192.168.206.20&quot; op monitor interval=10s timeout=20s</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">crm(live)configure<span class="comment"># primitive mysql lsb:mysqld op monitor interval=20s timeout=20s</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">crm(live)configure<span class="comment"># colocation ip_with_drbd_Master inf: ip ms_drbd_mysql:Master</span></span><br><span class="line">crm(live)configure<span class="comment"># colocation mysql_with_drbd_Master inf: mysql ms_drbd_mysql:Master</span></span><br><span class="line">crm(live)configure<span class="comment"># show</span></span><br><span class="line">crm(live)configure<span class="comment"># order mysql_after_drbd Mandatory: </span></span><br><span class="line">drbd_fs         ip              ms_drbd_mysql   mysql           </span><br><span class="line">crm(live)configure<span class="comment"># order mysql_after_drbd Mandatory: drbd_fs:start mysql:start</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">crm(live)configure<span class="comment"># order mysql_after_ip Mandatory: ip:start mysql:start</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">crm(live)configure<span class="comment"># commit</span></span><br><span class="line">crm(live)configure<span class="comment"># cd</span></span><br><span class="line">crm(live)<span class="comment"># status</span></span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: VM-node3 (version 1.1.15-5.el6-e174ec8) - partition with quorum</span><br><span class="line">Last updated: Wed Nov  1 21:34:04 2017Last change: Wed Nov  1 21:33:58 2017 by root via cibadmin on VM-node3</span><br><span class="line">, 2 expected votes</span><br><span class="line">2 nodes and 5 resources configured</span><br><span class="line"></span><br><span class="line">Node VM-node4: standby</span><br><span class="line">Online: [ VM-node3 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> Master/Slave Set: ms_drbd_mysql [drbd_mysql]</span><br><span class="line">     Masters: [ VM-node3 ]</span><br><span class="line">     Stopped: [ VM-node4 ]</span><br><span class="line"> drbd_fs(ocf::heartbeat:Filesystem):Started VM-node3</span><br><span class="line"> ip(ocf::heartbeat:IPaddr):Started VM-node3</span><br><span class="line"> mysql(lsb:mysqld):Started VM-node3</span><br></pre></td></tr></table></figure><p>至此, 我们的资源 就大体完成了, 打开网段内另外一台主机, 连接尝试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]<span class="comment"># mysql -uroot -h192.168.206.20 -p</span></span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection <span class="built_in">id</span> is 7</span><br><span class="line">Server version: 5.5.58-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| <span class="built_in">test</span>               |</span><br><span class="line">| testdb             |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; show databasesl;</span><br><span class="line">ERROR 2006 (HY000): MySQL server has gone away</span><br><span class="line">No connection. Trying to reconnect...</span><br><span class="line">ERROR 2003 (HY000): Can<span class="string">&#x27;t connect to MySQL server on &#x27;</span>192.168.206.20<span class="string">&#x27; (111)</span></span><br><span class="line"><span class="string">ERROR: Can&#x27;</span>t connect to the server</span><br><span class="line"></span><br><span class="line">unknown [(none)]&gt; show databases;</span><br><span class="line">No connection. Trying to reconnect...</span><br><span class="line">ERROR 2003 (HY000): Can<span class="string">&#x27;t connect to MySQL server on &#x27;</span>192.168.206.20<span class="string">&#x27; (111)</span></span><br><span class="line"><span class="string">ERROR: Can&#x27;</span>t connect to the server</span><br><span class="line"></span><br><span class="line">unknown [(none)]&gt; show databases;</span><br><span class="line">No connection. Trying to reconnect...</span><br><span class="line">Connection <span class="built_in">id</span>:    2</span><br><span class="line">Current database: *** NONE ***</span><br><span class="line"></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| <span class="built_in">test</span>               |</span><br><span class="line">| testdb             |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; </span><br></pre></td></tr></table></figure><p>可以看到中间的连接断掉了, 原因很简单, 我在中间将节点(node3)进行了下线, 于是过了一会node4得到了资源, mysql于是就重新连接了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Cluster </tag>
            
            <tag> MySQL </tag>
            
            <tag> drbd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Corosync/Pacemaker集群配置</title>
      <link href="/2017/10/28/Corosync-Pacemaker%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/10/28/Corosync-Pacemaker%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>继续学习高可用集群啦.</p><span id="more"></span><h2 id="体验PCS"><a href="#体验PCS" class="headerlink" title="体验PCS"></a>体验PCS</h2><p>之前就已经说过了, corosync是一个从Heartbeat V3中分出来的单独的messaging layer. 同时也是一个投票系统. 现在在CentOS7上, 我们使用Corosync+Pacemaker组合来构建服务.</p><p>首先我们先来看一下pcs这个东西, 之前也已经说过了, 用于集群的全生命周期管理.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Available Packages</span><br><span class="line">Name        : pcs</span><br><span class="line">Arch        : x86_64</span><br><span class="line">Version     : 0.9.158</span><br><span class="line">Release     : 6.el7.centos</span><br><span class="line">Size        : 4.8 M</span><br><span class="line">Repo        : base/7/x86_64</span><br><span class="line">Summary     : Pacemaker Configuration System</span><br><span class="line">URL         : https://github.com/ClusterLabs/pcs</span><br><span class="line">License     : GPLv2</span><br><span class="line">Description : pcs is a corosync and pacemaker configuration tool.  It permits <span class="built_in">users</span> to</span><br><span class="line">            : easily view, modify and create pacemaker based clusters.</span><br></pre></td></tr></table></figure><p>我们之前 都已经说了这么多了, 所以这次就直接来配置好了. 首先安装程序包吧, 由于pcs依赖corosync和pacemaker, 所以只需要安装pcs就行了, 为了方便我们建立一个ansible的服务器组(ha), 把他们VM-node1和VM-node2放进去吧.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible ha -m yum -a &#x27;name=pcs state=latest&#x27;</span></span><br></pre></td></tr></table></figure><p>这次准备的两个CentSOS7,  而且已经做好了密钥ssh登录, 主机名解析, 时间同步. </p><p>安装完成之后, 会看到: pcs有个守护进程 这个我们需要启动起来接着设置成为开机启动:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible ha -m service -a &#x27;name=pcsd state=started enabled=yes&#x27;</span></span><br><span class="line"><span class="comment"># 查看一下</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># systemctl status pcsd</span></span><br><span class="line">● pcsd.service - PCS GUI and remote configuration interface</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/pcsd.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Sat 2017-10-28 14:04:32 CST; 17s ago</span><br><span class="line"> Main PID: 23944 (pcsd)</span><br><span class="line">   CGroup: /system.slice/pcsd.service</span><br><span class="line">           └─23944 /usr/bin/ruby /usr/lib/pcsd/pcsd &gt; /dev/null &amp;</span><br><span class="line"></span><br><span class="line">Oct 28 14:04:30 VM-node1 systemd[1]: Starting PCS GUI and remote configuration interface...</span><br><span class="line">Oct 28 14:04:32 VM-node1 systemd[1]: Started PCS GUI and remote configuration interface.</span><br></pre></td></tr></table></figure><p>也确确实实的启动了. 是一个ruby程序呢 监听在2224&#x2F;tcp端口.</p><p>除了这个pcsd守护进程, 我们还有一个叫做pcs的程序, 更改程序就通过pcsd来建立联系和交换信息. 但是pcs不可能随意的就进行信息的交换和决策. 一定是需要验证的, 所以我们一个用户来用作pcs的验证:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible ha -m shell -a &quot;echo &quot;test&quot; | passwd hacluster --stdin&quot;</span></span><br><span class="line">VM-node2 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">Changing password <span class="keyword">for</span> user hacluster.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line"></span><br><span class="line">VM-node1 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">Changing password <span class="keyword">for</span> user hacluster.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure><p>这个用户也是存在的, 我们只需要保证密码是没有问题的就行了.</p><p>现在我们就来认证两个节点, 首先, 我们说说pcs这个程序的命令格式 , 和ip类似, pcs也是有很多子模块&#x2F;子命令的, 接着这些模块各自又存在很多操作命令, 稍微看一下文档就明白了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">    cluster     Configure cluster options and nodes.</span><br><span class="line">    resource    Manage cluster resources.</span><br><span class="line">    stonith     Manage fence devices.</span><br><span class="line">    constraint  Manage resource constraints.</span><br><span class="line">    property    Manage pacemaker properties.</span><br><span class="line">    acl         Manage pacemaker access control lists.</span><br><span class="line">    qdevice     Manage quorum device provider on the <span class="built_in">local</span> host.</span><br><span class="line">    quorum      Manage cluster quorum settings.</span><br><span class="line">    booth       Manage booth (cluster ticket manager).</span><br><span class="line">    status      View cluster status.</span><br><span class="line">    config      View and manage cluster configuration.</span><br><span class="line">    pcsd        Manage pcs daemon.</span><br><span class="line">    node        Manage cluster nodes.</span><br><span class="line">    alert       Manage pacemaker alerts.</span><br></pre></td></tr></table></figure><p>这里我们使用cluster的auth命令来认证:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible ha -a &quot;pcs cluster auth VM-node1 VM-node2 -u hacluster -p test&quot;</span></span><br><span class="line">VM-node2 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">VM-node1: Authorized</span><br><span class="line">VM-node2: Authorized</span><br><span class="line"></span><br><span class="line">VM-node1 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">VM-node1: Authorized</span><br><span class="line">VM-node2: Authorized</span><br></pre></td></tr></table></figure><p>认证完成了之后, 我们就可以建立集群了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># pcs cluster setup --name testcluster VM-node1 VM-node2</span></span><br><span class="line">Destroying cluster on nodes: VM-node1, VM-node2...</span><br><span class="line">VM-node1: Stopping Cluster (pacemaker)...</span><br><span class="line">VM-node2: Stopping Cluster (pacemaker)...</span><br><span class="line">VM-node1: Successfully destroyed cluster</span><br><span class="line">VM-node2: Successfully destroyed cluster</span><br><span class="line"></span><br><span class="line">Sending <span class="string">&#x27;pacemaker_remote authkey&#x27;</span> to <span class="string">&#x27;VM-node1&#x27;</span>, <span class="string">&#x27;VM-node2&#x27;</span></span><br><span class="line">VM-node1: successful distribution of the file <span class="string">&#x27;pacemaker_remote authkey&#x27;</span></span><br><span class="line">VM-node2: successful distribution of the file <span class="string">&#x27;pacemaker_remote authkey&#x27;</span></span><br><span class="line">Sending cluster config files to the nodes...</span><br><span class="line">VM-node1: Succeeded</span><br><span class="line">VM-node2: Succeeded</span><br><span class="line"></span><br><span class="line">Synchronizing pcsd certificates on nodes VM-node1, VM-node2...</span><br><span class="line">VM-node1: Success</span><br><span class="line">VM-node2: Success</span><br><span class="line">Restarting pcsd on the nodes <span class="keyword">in</span> order to reload the certificates...</span><br><span class="line">VM-node1: Success</span><br><span class="line">VM-node2: Success</span><br></pre></td></tr></table></figure><p>一路绿灯, 集群建立完毕, 这个时候会自动生成一份corosync的配置文件, 来看下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># grep &#x27;^[^[:space:]].*&#123;$&#x27; /etc/corosync/corosync.conf</span></span><br><span class="line">totem &#123;</span><br><span class="line">nodelist &#123;</span><br><span class="line">quorum &#123;</span><br><span class="line">logging &#123;</span><br></pre></td></tr></table></figure><p>这个配置也是的分成了几段的,首先的totem中定义了使用的版本和协议, 集群的名字, 包括是否使用安全认证等等, 接着nodelist中 分成了一个一个node的内容块, 其实就是定义每一个节点的信息了, 再往后即使很熟悉的投票系统的设置, 包括使用哪边提供的voting system, 是否是两节点模型啊等等. 最后就是关于日志的记录了, 很容易就能看懂, 包括是否记录到文件, 是否记录到syslog中, 以及位置定义.</p><p>好了现在我们就可以尝试启动集群了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># pcs cluster start --all</span></span><br><span class="line">VM-node2: Starting Cluster...</span><br><span class="line">VM-node1: Starting Cluster...</span><br></pre></td></tr></table></figure><p>这样就启动完成了, 我们有多种方法查看当前集群的状态, 一个一个来看看吧.</p><ul><li>使用pcs的status查看</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># pcs status</span></span><br><span class="line">Cluster name: testcluster</span><br><span class="line">WARNING: no stonith devices and stonith-enabled is not <span class="literal">false</span></span><br><span class="line">Stack: corosync</span><br><span class="line">Current DC: VM-node1 (version 1.1.16-12.el7_4.4-94ff4df) - partition with quorum</span><br><span class="line">Last updated: Sat Oct 28 14:41:58 2017</span><br><span class="line">Last change: Sat Oct 28 14:40:29 2017 by hacluster via crmd on VM-node1</span><br><span class="line"></span><br><span class="line">2 nodes configured</span><br><span class="line">0 resources configured</span><br><span class="line"></span><br><span class="line">Online: [ VM-node1 VM-node2 ]</span><br><span class="line"></span><br><span class="line">No resources</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Daemon Status:</span><br><span class="line">  corosync: active/disabled</span><br><span class="line">  pacemaker: active/disabled</span><br><span class="line">  pcsd: active/enabled</span><br></pre></td></tr></table></figure><p>其中告诉了现在的信息传递层协议是corosync, 当前的DC是VM-node1 以及时间和当前的在线状态, 资源情况和守护进程的状态.</p><p>还可以在后面加上其他的参数来查看不同的信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># pcs status corosync</span></span><br><span class="line"></span><br><span class="line">Membership information</span><br><span class="line">----------------------</span><br><span class="line">    Nodeid      Votes Name</span><br><span class="line">         1          1 VM-node1 (<span class="built_in">local</span>)</span><br><span class="line">         2          1 VM-node2</span><br></pre></td></tr></table></figure><ul><li>corosync-cfgtool</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># corosync-cfgtool -s VM-node1</span></span><br><span class="line">Printing ring status.</span><br><span class="line">Local node ID 1</span><br><span class="line">RING ID 0</span><br><span class="line"><span class="built_in">id</span>= 192.168.206.9</span><br><span class="line">status= ring 0 active with no faults</span><br></pre></td></tr></table></figure><p>没什么好说的, 就简单的信息输出, -s 就是status的意思吧 (我猜的)</p><ul><li>corosync-cmapctl</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># corosync-cmapctl </span></span><br><span class="line">...(omitted)</span><br><span class="line">runtime.totem.pg.mrp.srp.members.1.config_version (u64) = 0</span><br><span class="line">runtime.totem.pg.mrp.srp.members.1.ip (str) = r(0) ip(192.168.206.9) </span><br><span class="line">runtime.totem.pg.mrp.srp.members.1.join_count (u32) = 1</span><br><span class="line">runtime.totem.pg.mrp.srp.members.1.status (str) = joined</span><br><span class="line">runtime.totem.pg.mrp.srp.members.2.config_version (u64) = 0</span><br><span class="line">runtime.totem.pg.mrp.srp.members.2.ip (str) = r(0) ip(192.168.206.10) </span><br><span class="line">runtime.totem.pg.mrp.srp.members.2.join_count (u32) = 1</span><br><span class="line">runtime.totem.pg.mrp.srp.members.2.status (str) = joined</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>能够输出大量的运行时参数.</p><p>我们可以使用<code>crm_verify</code>来验证当前的集群配置是否存在异常:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># crm_verify -LV</span></span><br><span class="line">   error: unpack_resources:Resource start-up disabled since no STONITH resources have been defined</span><br><span class="line">   error: unpack_resources:Either configure some or <span class="built_in">disable</span> STONITH with the stonith-enabled option</span><br><span class="line">   error: unpack_resources:NOTE: Clusters with shared data need STONITH to ensure data integrity</span><br><span class="line">Errors found during check: config not valid</span><br></pre></td></tr></table></figure><p>挨 出现了错误. 其实这个在之前也出现过了, 就是刚刚我们查看状态的时候显示的<code>WARNING</code>. 我们现在没有STONITH设备, 但是我们却开启了STNITH功能, 所以我们需要把它关闭, 关闭的方法也很简单, 我们使用pcs的property子命令来搞定:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># pcs property list --all</span></span><br><span class="line">  ..(omitted)</span><br><span class="line">  stonith-enabled: <span class="literal">true</span></span><br><span class="line">  ..(omitted)</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># pcs property set stonith-enabled=false</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># crm_verify -LV</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>这就是pcs, 接下来我们再来试试crmsh.</p><h2 id="crmsh体验"><a href="#crmsh体验" class="headerlink" title="crmsh体验"></a>crmsh体验</h2><p>刚刚使用的pcs是需要pcsd才可以进行管理的, 也即是我们之前说的有agent的, 而crmsh就不需要, 他通过ssh来进行管理, 直接yum install crmsh就可以, 如果没有就尝试找找其他的源吧. 接着我们需要安装pssh和python-pssh这两个包. 他们是为了提供并行的ssh和python的pssh接口.</p><p>crmsh支持交互式模式, 而且还提供了类shell的操作方式, 例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># crm</span></span><br><span class="line">crm(live)<span class="comment"># ls</span></span><br><span class="line">cibstatus        <span class="built_in">help</span>             site             </span><br><span class="line"><span class="built_in">cd</span>               cluster          quit             </span><br><span class="line">end              script           verify           </span><br><span class="line"><span class="built_in">exit</span>             ra               maintenance      </span><br><span class="line"><span class="built_in">bye</span>              ?                <span class="built_in">ls</span>               </span><br><span class="line">node             configure        back             </span><br><span class="line">report           cib              resource         </span><br><span class="line">up               status           corosync         </span><br><span class="line">options          <span class="built_in">history</span>       </span><br><span class="line">crm(live)<span class="comment"># resource</span></span><br><span class="line">crm(live)resource<span class="comment"># cd ..</span></span><br><span class="line">crm(live)<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>但是不得不说的是, 这个crmsh提供的子命令和子子命令实在是太多了, 让人眼花缭乱.</p><p>我们直接用一个实例去学习吧.</p><h4 id="使用crmsh-corosync-pacemaker实现httpd高可用"><a href="#使用crmsh-corosync-pacemaker实现httpd高可用" class="headerlink" title="使用crmsh+corosync+pacemaker实现httpd高可用"></a>使用crmsh+corosync+pacemaker实现httpd高可用</h4><p>再熟悉不过了, 我们需要的资源有:</p><ul><li>VIP</li><li>httpd服务</li></ul><p>好了, 简单的部署一下, playbook如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">ha</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">httpd</span> <span class="string">service</span></span><br><span class="line">    <span class="attr">yum:</span> <span class="string">name=httpd</span> <span class="string">state=latest</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Copy</span> <span class="string">index.html</span> <span class="string">to</span> <span class="string">nodes</span></span><br><span class="line">    <span class="attr">template:</span> <span class="string">src=/root/index.html</span> <span class="string">dest=/var/www/html/index.html</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Start</span> <span class="string">httpd</span> <span class="string">service</span> <span class="string">and</span> <span class="string">disable</span> <span class="string">it</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=started</span> <span class="string">enabled=yes</span></span><br></pre></td></tr></table></figure><p>模板文件很简单的一行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;&#123;&#123; ansible_fqdn &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>接着我们要确定可以正常访问:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo\Desktop</span><br><span class="line">λ curl 192.168.206.9</span><br><span class="line">&lt;h1&gt;VM-node1&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo\Desktop</span><br><span class="line">λ curl 192.168.206.10</span><br><span class="line">&lt;h1&gt;VM-node2&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>你可能会觉得奇怪, 为什么我们这一次设置成了开机自动启动, 其实这是因为crmsh只能从enable的unit中找到资源.</p><p>接下来就要开始配置了, 进入crmsh的RA模块:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># crm ra</span></span><br><span class="line">crm(live)ra<span class="comment"># classes</span></span><br><span class="line">lsb</span><br><span class="line">ocf / .isolation heartbeat openstack pacemaker</span><br><span class="line">service</span><br><span class="line">systemd</span><br><span class="line">crm(live)ra<span class="comment"># list ocf heartbeat</span></span><br><span class="line">IPaddr   IPaddr2     ...(omitted)</span><br><span class="line">crm(live)ra<span class="comment"># cd</span></span><br><span class="line">crm(live)<span class="comment"># configure</span></span><br><span class="line">crm(live)configure<span class="comment"># primitive webip ocf:heartbeat:IPaddr params ip=192.168.206.11</span></span><br><span class="line">crm(live)configure<span class="comment"># show</span></span><br><span class="line">node 1: VM-node1</span><br><span class="line">node 2: VM-node2</span><br><span class="line">primitive webip IPaddr \</span><br><span class="line">params ip=192.168.206.11</span><br><span class="line">property cib-bootstrap-options: \</span><br><span class="line">have-watchdog=<span class="literal">false</span> \</span><br><span class="line">dc-version=1.1.16-12.el7_4.4-94ff4df \</span><br><span class="line">cluster-infrastructure=corosync \</span><br><span class="line">cluster-name=testcluster \</span><br><span class="line">stonith-enabled=<span class="literal">false</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">crm(live)configure<span class="comment"># commit</span></span><br><span class="line">crm(live)configure<span class="comment"># cd</span></span><br><span class="line">crm(live)<span class="comment"># status</span></span><br><span class="line">Stack: corosync</span><br><span class="line">Current DC: VM-node1 (version 1.1.16-12.el7_4.4-94ff4df) - partition with quorum</span><br><span class="line">Last updated: Sat Oct 28 15:54:58 2017</span><br><span class="line">Last change: Sat Oct 28 15:54:55 2017 by root via cibadmin on VM-node1</span><br><span class="line"></span><br><span class="line">2 nodes configured</span><br><span class="line">1 resource configured</span><br><span class="line"></span><br><span class="line">Online: [ VM-node1 VM-node2 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> webip(ocf::heartbeat:IPaddr):Stopped</span><br></pre></td></tr></table></figure><p>资源就已经配置好了, 但是还没有启动.(过一小会再看就是Started的了) 我是怎么知道这些参数和格式的呢, 在之前的ra中, 我们可以使用info来查看每一个RA的参数配置.</p><p>如何进行资源的迁移呢? 很简单, 只要把当前的节点变成备用的就行了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">crm(live)<span class="comment"># status</span></span><br><span class="line">Stack: corosync</span><br><span class="line">Current DC: VM-node1 (version 1.1.16-12.el7_4.4-94ff4df) - partition with quorum</span><br><span class="line">Last updated: Sat Oct 28 15:56:50 2017</span><br><span class="line">Last change: Sat Oct 28 15:54:55 2017 by root via cibadmin on VM-node1</span><br><span class="line"></span><br><span class="line">2 nodes configured</span><br><span class="line">1 resource configured</span><br><span class="line"></span><br><span class="line">Online: [ VM-node1 VM-node2 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> webip(ocf::heartbeat:IPaddr):Started VM-node1</span><br><span class="line"></span><br><span class="line">crm(live)<span class="comment"># node</span></span><br><span class="line">crm(live)node<span class="comment"># standby</span></span><br><span class="line">crm(live)node<span class="comment"># cd</span></span><br><span class="line">crm(live)<span class="comment"># status</span></span><br><span class="line">Stack: corosync</span><br><span class="line">Current DC: VM-node1 (version 1.1.16-12.el7_4.4-94ff4df) - partition with quorum</span><br><span class="line">Last updated: Sat Oct 28 15:57:52 2017</span><br><span class="line">Last change: Sat Oct 28 15:57:46 2017 by root via crm_attribute on VM-node1</span><br><span class="line"></span><br><span class="line">2 nodes configured</span><br><span class="line">1 resource configured</span><br><span class="line"></span><br><span class="line">Node VM-node1: standby</span><br><span class="line">Online: [ VM-node2 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> webip(ocf::heartbeat:IPaddr):Started VM-node2</span><br></pre></td></tr></table></figure><p>已经跑到VM-node2上去了. 不仅如此, 我们的VM-node1已经是软下线的状态了.</p><p>接着我们把node1上线:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crm(live)<span class="comment"># node online</span></span><br></pre></td></tr></table></figure><p>此时也许你的IP资源并没有回来 这是由于资源粘性导致的.</p><p>接着我们来配置httpd服务资源:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">crm(live)<span class="comment"># configure</span></span><br><span class="line">crm(live)configure<span class="comment"># primitive webserver systemd:httpd</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">WARNING: webserver: default <span class="built_in">timeout</span> 20s <span class="keyword">for</span> start is smaller than the advised 100</span><br><span class="line">WARNING: webserver: default <span class="built_in">timeout</span> 20s <span class="keyword">for</span> stop is smaller than the advised 100</span><br><span class="line">crm(live)configure<span class="comment"># commit</span></span><br><span class="line">WARNING: webserver: default <span class="built_in">timeout</span> 20s <span class="keyword">for</span> start is smaller than the advised 100</span><br><span class="line">WARNING: webserver: default <span class="built_in">timeout</span> 20s <span class="keyword">for</span> stop is smaller than the advised 100</span><br><span class="line">crm(live)configure<span class="comment"># cd</span></span><br><span class="line">crm(live)<span class="comment"># status</span></span><br><span class="line">Stack: corosync</span><br><span class="line">Current DC: VM-node1 (version 1.1.16-12.el7_4.4-94ff4df) - partition with quorum</span><br><span class="line">Last updated: Sat Oct 28 16:35:17 2017</span><br><span class="line">Last change: Sat Oct 28 16:35:09 2017 by root via cibadmin on VM-node1</span><br><span class="line"></span><br><span class="line">2 nodes configured</span><br><span class="line">2 resources configured</span><br><span class="line"></span><br><span class="line">Online: [ VM-node1 VM-node2 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> webip(ocf::heartbeat:IPaddr):Started VM-node2</span><br><span class="line"> webserver(systemd:httpd):Started VM-node1</span><br></pre></td></tr></table></figure><p>忽略那个警告吧先…</p><p>但是现在的IP和httpd服务不在一个节点上, 这显然不是我们希望的. 这怎么办呢? 对 定义组资源.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">crm(live)<span class="comment"># configure</span></span><br><span class="line">crm(live)configure<span class="comment"># group webservice webip webserver</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">WARNING: webserver: default <span class="built_in">timeout</span> 20s <span class="keyword">for</span> start is smaller than the advised 100</span><br><span class="line">WARNING: webserver: default <span class="built_in">timeout</span> 20s <span class="keyword">for</span> stop is smaller than the advised 100</span><br><span class="line">crm(live)configure<span class="comment"># commit</span></span><br><span class="line">crm(live)configure<span class="comment"># cd</span></span><br><span class="line">crm(live)<span class="comment"># status</span></span><br><span class="line">Stack: corosync</span><br><span class="line">Current DC: VM-node1 (version 1.1.16-12.el7_4.4-94ff4df) - partition with quorum</span><br><span class="line">Last updated: Sat Oct 28 16:37:39 2017</span><br><span class="line">Last change: Sat Oct 28 16:37:33 2017 by root via cibadmin on VM-node1</span><br><span class="line"></span><br><span class="line">2 nodes configured</span><br><span class="line">2 resources configured</span><br><span class="line"></span><br><span class="line">Online: [ VM-node1 VM-node2 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> Resource Group: webservice</span><br><span class="line">     webip(ocf::heartbeat:IPaddr):Started VM-node2</span><br><span class="line">     webserver(systemd:httpd):Started VM-node2</span><br></pre></td></tr></table></figure><p>这样就OK啦. 访问测试也是没有问题的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo\Desktop</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;VM-node2&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>这里, 定义组的时候的顺序是挺重要的, 他会决定资源的调度顺序.</p><h2 id="corosync的配置"><a href="#corosync的配置" class="headerlink" title="corosync的配置"></a>corosync的配置</h2><p>刚刚我们使用pcs和crmsh进行了集群配置, 现在我们来手动配置corosync一下. 首先当然就是从corosync的配置文件入手了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># cp -v /etc/corosync/corosync.conf.example /etc/corosync/corosync.conf</span></span><br><span class="line"><span class="built_in">cp</span>: overwrite ‘/etc/corosync/corosync.conf’? y</span><br><span class="line">‘/etc/corosync/corosync.conf.example’ -&gt; ‘/etc/corosync/corosync.conf’</span><br></pre></td></tr></table></figure><p>先覆盖掉之前生成的那个配置文件, 而且原来的是使用udpu协议的, 这次我们使用udp的广播试试.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">totem &#123;</span><br><span class="line">        version: 2 <span class="comment"># 使用的corosync版本</span></span><br><span class="line">        crypto_cipher: none <span class="comment"># 对称加密的算法 (aes256)</span></span><br><span class="line">        crypto_hash: none <span class="comment"># 单向哈希的算法 (sha1)</span></span><br><span class="line">        interface &#123; <span class="comment"># 配置交换信息的接口</span></span><br><span class="line">                ringnumber: 0 <span class="comment"># 为了防止出现环路, 按照0-&gt;1的顺序, 只要0在1就不会发送.</span></span><br><span class="line">                bindnetaddr: 192.168.1.0 <span class="comment"># 绑定的网络地址</span></span><br><span class="line">                mcastaddr: 239.255.1.1 <span class="comment"># 多播地址</span></span><br><span class="line">                mcastport: 5405 <span class="comment"># 多播端口</span></span><br><span class="line">                ttl: 1 <span class="comment"># 路由最大跳数,设置成1来防止环路</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">logging &#123; <span class="comment"># 日志相关</span></span><br><span class="line">        fileline: off</span><br><span class="line">        to_stderr: no</span><br><span class="line">        to_logfile: <span class="built_in">yes</span></span><br><span class="line">        logfile: /var/log/cluster/corosync.log</span><br><span class="line">        to_syslog: no</span><br><span class="line">        debug: off</span><br><span class="line">        timestamp: on</span><br><span class="line">        logger_subsys &#123;</span><br><span class="line">                subsys: QUORUM</span><br><span class="line">                debug: off</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">quorum &#123; <span class="comment"># 定义投票系统</span></span><br><span class="line">        provider: corosync_votequorum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们增加下安全认证, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crypto_cipher: aes128</span><br><span class="line">crypto_hash: sha1</span><br><span class="line">secauth: on</span><br></pre></td></tr></table></figure><p>接着, 其实如果是V1这个地方我们可以不添加 nodelist的, 因为待会验证的主机都会自动加入的, 但是稳妥起见, 或者说更清晰一点, 还是写一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nodelist &#123;</span><br><span class="line"></span><br><span class="line">        node &#123;</span><br><span class="line">                ring0_addr: 192.168.206.9</span><br><span class="line">                node_id:0</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node &#123;</span><br><span class="line">                ring0_addr: 192.168.206.10</span><br><span class="line">                node_id:1</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就要生成密钥文件了, 使用<code>corosync-keygen</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 corosync]<span class="comment"># corosync-keygen </span></span><br><span class="line">Corosync Cluster Engine Authentication key generator.</span><br><span class="line">Gathering 1024 bits <span class="keyword">for</span> key from /dev/random.</span><br><span class="line">Press keys on your keyboard to generate entropy.</span><br><span class="line">Press keys on your keyboard to generate entropy (bits = 920).</span><br><span class="line">Press keys on your keyboard to generate entropy (bits = 1000).</span><br><span class="line">Writing corosync key to /etc/corosync/authkey.</span><br></pre></td></tr></table></figure><p>接着把这个文件和配置保持原有权限复制到各个节点上:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 corosync]<span class="comment"># scp -p authkey corosync.conf VM-node2:/etc/corosync/</span></span><br><span class="line">authkey                                                                                                                                  100%  128    66.4KB/s   00:00    </span><br><span class="line">corosync.conf                                                                                                                            100% 3015   981.5KB/s   00:00  </span><br></pre></td></tr></table></figure><p>接下来我们试着手动启动服务, 如果没有问题就可以验证一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 corosync]<span class="comment"># tail /var/log/cluster/corosync.log </span></span><br><span class="line">Oct 28 20:57:36 [34337] VM-node1 corosync info    [QB    ] server name: votequorum</span><br><span class="line">Oct 28 20:57:36 [34337] VM-node1 corosync notice  [SERV  ] Service engine loaded: corosync cluster quorum service v0.1 [3]</span><br><span class="line">Oct 28 20:57:36 [34337] VM-node1 corosync info    [QB    ] server name: quorum</span><br><span class="line">Oct 28 20:57:36 [34337] VM-node1 corosync notice  [TOTEM ] A new membership (192.168.206.9:16) was formed. Members joined: 3232288265</span><br><span class="line">Oct 28 20:57:36 [34337] VM-node1 corosync notice  [QUORUM] Members[1]: 3232288265</span><br><span class="line">Oct 28 20:57:36 [34337] VM-node1 corosync notice  [MAIN  ] Completed service synchronization, ready to provide service.</span><br><span class="line">Oct 28 20:57:36 [34337] VM-node1 corosync notice  [TOTEM ] A new membership (192.168.206.9:24) was formed. Members joined: 3232288266</span><br><span class="line">Oct 28 20:57:36 [34337] VM-node1 corosync notice  [QUORUM] This node is within the primary component and will provide service.</span><br><span class="line">Oct 28 20:57:36 [34337] VM-node1 corosync notice  [QUORUM] Members[2]: 3232288265 3232288266</span><br><span class="line">Oct 28 20:57:36 [34337] VM-node1 corosync notice  [MAIN  ] Completed service synchronization, ready to provide service.</span><br></pre></td></tr></table></figure><p>接下来就可以启动pacemaker服务了, 启动之前, 我们来看一下他的配置.</p><h2 id="pacemaker"><a href="#pacemaker" class="headerlink" title="pacemaker"></a>pacemaker</h2><p>直接进入启动环境配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PCMK_logfile=/var/log/pacemaker.log</span><br></pre></td></tr></table></figure><p>其他的选项又有什么大的必要开启. </p><p>接着直接启动吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># systemctl start pacemaker</span></span><br></pre></td></tr></table></figure><p>好了, 集群就这样启动了, 接下来只要配置一下资源就行了. 可以使用crmsh或者pcs啥的工具就行了.</p><p>还可以使用 crm_verify来检查一下状态, 这个程序可不是crm提供的! 他是pacemaker自带的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># crm_verify -LV</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># rpm -qf `which crm_verify`</span></span><br><span class="line">pacemaker-cli-1.1.16-12.el7_4.4.x86_64</span><br></pre></td></tr></table></figure><h2 id="项目-构建Web高可用服务集群"><a href="#项目-构建Web高可用服务集群" class="headerlink" title="项目: 构建Web高可用服务集群"></a>项目: 构建Web高可用服务集群</h2><p>我们这次再加上一个节点, 用它来做NFS共享存储. 这样就应该是三个资源了.VIP+httpd+Filesystem</p><p>先来规划一下, VIP: 192.168.206.11: ocf: heartbeat:IPaddr ; httpd: systemd; nfs shared storage: ocf: heartbeat:Filesystem</p><p>先来配置一下NFS server:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]<span class="comment"># cat /etc/exports </span></span><br><span class="line">/data192.168.206.0/24(rw,no_root_squash)</span><br><span class="line">[root@VM-node0 ~]<span class="comment"># cat /data/index.html </span></span><br><span class="line">&lt;h1&gt;Test page <span class="keyword">in</span> VM-node3&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>接着分别做测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># systemctl start httpd</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># mount -t nfs VM-node0:/data /var/www/html/</span></span><br><span class="line">----</span><br><span class="line">C:\Users\lenovo\Desktop</span><br><span class="line">λ curl 192.168.206.9</span><br><span class="line">&lt;h1&gt;Test page <span class="keyword">in</span> VM-node0&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>另外一个:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># systemctl start httpd </span></span><br><span class="line">[root@VM-node2 ~]<span class="comment"># mount -t nfs VM-node0:/data /var/www/html/</span></span><br><span class="line">----</span><br><span class="line">C:\Users\lenovo\Desktop</span><br><span class="line">λ curl 192.168.206.10</span><br><span class="line">&lt;h1&gt;Test page <span class="keyword">in</span> VM-node0&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>测试结束之后, 解除挂载和httpd服务.</p><p>好了, 正式开始了!</p><p>这一次我们不使用组资源, 而是通过资源约束的方式来配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]<span class="comment"># crm</span></span><br><span class="line">crm(live)<span class="comment"># configure</span></span><br><span class="line">crm(live)configure<span class="comment"># show</span></span><br><span class="line">node 3232288264: VM-node0</span><br><span class="line">node 3232288265: VM-node1</span><br><span class="line">node 3232288266: VM-node2</span><br><span class="line">property cib-bootstrap-options: \</span><br><span class="line">have-watchdog=<span class="literal">false</span> \</span><br><span class="line">dc-version=1.1.16-12.el7_4.4-94ff4df \</span><br><span class="line">cluster-infrastructure=corosync \</span><br><span class="line">stonith-enabled=<span class="literal">false</span></span><br><span class="line">crm(live)configure<span class="comment"># cd</span></span><br><span class="line">crm(live)<span class="comment"># configure</span></span><br><span class="line">crm(live)configure<span class="comment"># primitive webip ocf:heartbeat:IPaddr2 params ip=192.168.206.11 op monitor interval=30s timeout=20s</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">crm(live)configure<span class="comment"># primitive webserver systemd:httpd op start timeout=30s op stop timeout=30s op monitor interval=30s timeout=20s</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">WARNING: webserver: specified <span class="built_in">timeout</span> 30s <span class="keyword">for</span> start is smaller than the advised 100</span><br><span class="line">WARNING: webserver: specified <span class="built_in">timeout</span> 30s <span class="keyword">for</span> stop is smaller than the advised 100</span><br><span class="line">WARNING: webserver: specified <span class="built_in">timeout</span> 20s <span class="keyword">for</span> monitor is smaller than the advised 100</span><br><span class="line">crm(live)configure<span class="comment"># edit</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">crm(live)configure<span class="comment"># primitive webstore ocf:heartbeat:Filesystem params device=&quot;VM-node0:/data&quot; fstype=nfs directory=&quot;/var/www/html&quot;</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">WARNING: webstore: default <span class="built_in">timeout</span> 20s <span class="keyword">for</span> start is smaller than the advised 60</span><br><span class="line">WARNING: webstore: default <span class="built_in">timeout</span> 20s <span class="keyword">for</span> stop is smaller than the advised 60</span><br><span class="line">crm(live)configure<span class="comment"># edit</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">crm(live)configure<span class="comment"># order store_after_ip Mandatory: webip webstore</span></span><br><span class="line">crm(live)configure<span class="comment"># order server_after_store Mandatory: webserver webstore</span></span><br><span class="line">crm(live)configure<span class="comment"># verify</span></span><br><span class="line">crm(live)configure<span class="comment"># commit</span></span><br><span class="line">crm(live)configure<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">bye</span></span><br><span class="line">[root@VM-node0 ~]<span class="comment"># crm status</span></span><br><span class="line">Stack: corosync</span><br><span class="line">Current DC: VM-node2 (version 1.1.16-12.el7_4.4-94ff4df) - partition with quorum</span><br><span class="line">Last updated: Sun Oct 29 07:49:31 2017</span><br><span class="line">Last change: Sun Oct 29 07:49:25 2017 by root via cibadmin on VM-node0</span><br><span class="line"></span><br><span class="line">3 nodes configured</span><br><span class="line">3 resources configured</span><br><span class="line"></span><br><span class="line">Online: [ VM-node0 VM-node1 VM-node2 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> webip(ocf::heartbeat:IPaddr2):Started VM-node0</span><br><span class="line"> webserver(systemd:httpd):Started VM-node0</span><br><span class="line"> webstore(ocf::heartbeat:Filesystem):Started VM-node0</span><br></pre></td></tr></table></figure><p>OK, 呼出一口气….来测试一下吧.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo\Desktop</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;Web Page on NFS&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>这样就大功告成啦!!</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Cluster </tag>
            
            <tag> Corosync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化运维之Ansible</title>
      <link href="/2017/10/25/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E4%B9%8BAnsible/"/>
      <url>/2017/10/25/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E4%B9%8BAnsible/</url>
      
        <content type="html"><![CDATA[<p>自动化运维第一步, 走起.</p><span id="more"></span><p>由于这是第一篇学习自动化运维工具的文章, 所以我们先来瞎扯扯..</p><h2 id="自动化运维相关"><a href="#自动化运维相关" class="headerlink" title="自动化运维相关"></a>自动化运维相关</h2><p>我们的运维工作, 假设从系统的安装开始, 这里就已经有很多说的点了. 比如我们可以从设备厂商协调好, 安装指定版本的系统, 这样拿过来的机器就已经是有系统了. 另外, 还可以使用我们之前说的PXE技术进行网络引导, 只要接通电源开机就可以自动进行安装了. 这是物理机的情况. 如果是虚拟机就更简单了, 我们可以直接生成一个模板, 模板中都携带了需要配置的各个参数, 但是这个时候, 我们可能需要在安装的时候有工具能够动态的去插入一些私有的信息, 例如MAC地址. 接着安装完系统, 我们就进入程序包的安装, 配置和服务启动, 想象一个十几台机器的场景, 难道一个一个手动的配置? 显然不可能, 这里我们就需要有能够统一集中部署的方法, 也就是批量的操作. 再往后, 我们就需要进行服务的发布了, 这个一般就是比较重要的一环了, 我们需要进行平滑的, 滚动的更新和版本回滚. 再往后, 就是监控的工作. 例如:告警, 自动修复等等.</p><p>再说说我们的程序发布问题, 首先在程序的研发阶段完成了之后, 显然是需要进行测试的. 这一步叫做<strong>预发布验证</strong>, 新版本的代码先发布到测试环境中, 测试环境可能和线上的环境配置相同, 只不过没有接入调度器罢了. 在我们的程序发布中, 有一些原则性的问题需要保证:</p><ul><li>不能影响用户体验</li><li>系统不能停机</li><li>不能导致系统故障或者系统不可用</li></ul><p>这样我们就需要一个发布模型, 常见的一种叫做<strong>灰度模型, 灰度发布</strong>, 一般我们可以使用符号链接的方式进行版本间切换. 接着 按照我们说过的 只要路径相同, 或者说都是标准的. 我们就可以通过应用程序或者脚本进行自动的切换.</p><h2 id="Ansible入门"><a href="#Ansible入门" class="headerlink" title="Ansible入门"></a>Ansible入门</h2><p>现在就来说说主角了, Ansible是一个使用Python语言的自动化运维工具, 功能挺强大的. 不过不管怎么说, 先来想个这样的问题, 我们怎么在远端执行命令呢? 我们知道所有的操作都是需要用户的权限来执行的. 这个时候还记得之前在说keepalived和heartbeat的时候使用的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh VM-node3 <span class="string">&quot;date&quot;</span></span><br></pre></td></tr></table></figure><p>吗?</p><p>是的, 我们的ansible就是使用ssh协议进行的远端调用. 这就说明, 我们只需要一个ansible服务端就行了, 被调用的, 或者说被管理的节点不需要特地安装其他的程序. 这就是<code>agentless</code>的运维工具.  而另外一种 就是<code>agent</code>的, 这就是运维工具的一个小分类. </p><p>除了ansible, fabric也是基于ssh的. 另外, puppet , func 这些就是典型的需要agent的类型了.</p><p>当然, 是否需要agent各有各的好处和缺点. </p><blockquote><p>截止目前(2017-10-25 13:51), Ansible的github仓库star数是26w, 3420个仍旧open的issue和1.1万个已经closed的.</p></blockquote><p>Ansible能够实现统一配置, 统一部署, 批量执行, 多层次多用户并行等功能. 来看一张架构图:</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b10000_10000&sec=1508910970&di=b03f6498f57d1acb911248e9d8ddd53e&src=http://s2.51cto.com/wyfs02/M02/79/79/wKiom1aSQHHjJRZTAAEBRfKpi_E196.png" alt="img"></p><p> 左上角的Host Inventory就是字面意思, 存放管理的主机清单. Ansible通过才能够下面定制的Playbooks从Inventory中抓取主机清单, 接着通过右上角的连接插件进行连接和管理操作. 而且还可以使用插件和其他语言建立自定义的模块.</p><p>Ansible依靠Python中的Paramiko, PyYAML, Jinja2等库和模块构建. </p><p>直接安装看看, ansible被收录在epel源中, 配置好yum源就可以直接yum install了.</p><p>安装完成后, 我们可以看到, 几个配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># rpm -ql ansible | less</span></span><br><span class="line">/etc/ansible</span><br><span class="line">/etc/ansible/ansible.cfg</span><br><span class="line">/etc/ansible/hosts</span><br><span class="line">/etc/ansible/roles</span><br><span class="line">..(omitted)</span><br></pre></td></tr></table></figure><p>主配置文件就是那个cfg了, 额hosts就是我们的inventory.  但是这个清单文件也不是随随便便就可以写的, 里面要指明Web服务器, 存储服务器等等包括其他的一些信息.</p><p>由于使用ssh的方式, 所以不妨还是先把基于密钥的认证做一下, 当然这不是必须的, 我们也可以在配置文件中指明主机的账号和密码. 我已经配好了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ssh VM-node2 &#x27;date&#x27;</span></span><br><span class="line">Thu Oct 26 05:40:41 CST 2017</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ssh VM-node3 &#x27;date&#x27;</span></span><br><span class="line">Wed Oct 25 21:40:44 CST 2017</span><br></pre></td></tr></table></figure><p>接下来我们就来看一下ansible基本命令是怎么使用的吧.</p><p>ansible基于模块的设计, 所以我们使用ansible, 其实就是使用它的模块, ansible的默认模块是一个叫做<code>command</code>的模块. 总体的命令格式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible &lt;host-pattern&gt; [options]</span><br></pre></td></tr></table></figure><p>这里的host-pattern就是可以指定的主机, 默认使用的配置文件就是<code>/etc/ansible/hosts</code>, 我们先来看一下这个文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[testservers]</span><br><span class="line">192.168.206.9</span><br><span class="line">192.168.206.10</span><br><span class="line">192.168.206.22</span><br><span class="line"><span class="comment">#####</span></span><br><span class="line">www[001:006].example.com</span><br></pre></td></tr></table></figure><p>通过这样的组定义, 我们可以一个服务器组, 也支持这样的, ansible可以自动展开.</p><p>定义了主机之后 ,我们就可以使用ansible了, 示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible testservers -m command -a &quot;uname -r&quot;</span></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">2.6.32-220.el6.x86_64</span><br><span class="line"></span><br><span class="line">192.168.206.10 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">3.10.0-693.2.2.el7.x86_64</span><br><span class="line"></span><br><span class="line">192.168.206.9 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">3.10.0-693.2.2.el7.x86_64</span><br></pre></td></tr></table></figure><p>来解释一下,  首先我们指明对哪些主机执行操作, 这里就使用的是当时在文件中定义的组名, 接着我们使用-m指明使用的模块command, 后面的参数就是对于每一个模块而言的了. 每一个模块有自己的参数.</p><p>那么我该怎么样获取每个模块的用法呢? ansible-doc就是为了这个存在的, 我们可以使用下面来查看所有的模块和每个模块的用法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible-doc -l</span></span><br><span class="line">a10_server                                Manage A10 Networks AX/SoftAX/Thunder/vThunder devices<span class="string">&#x27; server object.                                                      </span></span><br><span class="line"><span class="string">a10_server_axapi3                         Manage A10 Networks AX/SoftAX/Thunder/vThunder devices                                                                      </span></span><br><span class="line"><span class="string">a10_service_group                         Manage A10 Networks AX/SoftAX/Thunder/vThunder devices&#x27;</span> service <span class="built_in">groups</span>.                                                     </span><br><span class="line">a10_virtual_server                        Manage A10 Networks AX/SoftAX/Thunder/vThunder devices<span class="string">&#x27; virtual servers.                                                    </span></span><br><span class="line"><span class="string">accelerate                                Enable accelerated mode on remote node                                                                                      </span></span><br><span class="line"><span class="string">aci_aep                                   Manage attachable Access Entity Profile (AEP) on Cisco ACI fabrics (infra:AttEntityP)                                       </span></span><br><span class="line"><span class="string">aci_ap                                    Manage top level Application Profile (AP) objects on Cisco ACI fabrics (fv:Ap)                                              </span></span><br><span class="line"><span class="string">aci_bd                                    Manage Bridge Domains (BD) on Cisco ACI Fabrics (fv:BD)                                                                     </span></span><br><span class="line"><span class="string">aci_bd_subnet                             Manage Subnets on Cisco ACI fabrics (fv:Subnet)                                                                             </span></span><br><span class="line"><span class="string">aci_bd_to_l3out                           Bind Bridge Domain to L3 Out on Cisco ACI fabrics (fv:RsBDToOut)                                                            </span></span><br><span class="line"><span class="string">aci_config_rollback                       Provides rollback and rollback preview functionality for Cisco ACI fabrics (config:ImportP)                                 </span></span><br><span class="line"><span class="string">aci_config_snapshot                       Manage Config Snapshots on Cisco ACI fabrics (config:Snapshot, config:ExportP)                             </span></span><br><span class="line"><span class="string">...(omitted)</span></span><br></pre></td></tr></table></figure><p>太多了, 我们看看一共有多少的模块支持:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible-doc -l | wc -l</span></span><br><span class="line">1375</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ansible-doc command</span></span><br><span class="line">&gt; COMMAND    (/usr/lib/python2.7/site-packages/ansible/modules/commands/command.py)</span><br><span class="line"></span><br><span class="line">        The `<span class="built_in">command</span><span class="string">&#x27; module takes the command name followed by a list of space-delimited arguments. The given command will be executed</span></span><br><span class="line"><span class="string">        on all selected nodes. It will not be processed through the shell, so variables like `$HOME&#x27;</span> and operations like `<span class="string">&quot;&lt;&quot;</span><span class="string">&#x27;, `&quot;&gt;&quot;&#x27;</span>,</span><br><span class="line">        `<span class="string">&quot;|&quot;</span><span class="string">&#x27;, `&quot;;&quot;&#x27;</span> and `<span class="string">&quot;&amp;&quot;</span><span class="string">&#x27; will not work (use the [shell] module if you need these features). For Windows targets, use the</span></span><br><span class="line"><span class="string">        [win_command] module instead.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">OPTIONS (= is mandatory):</span></span><br><span class="line"><span class="string">...(omitted)</span></span><br></pre></td></tr></table></figure><p>1000+的模块, 但是我们使用的也是很有限的几个. 可以直接在后面加上模块的名字, 就可以获取到相关的说明和文档了.</p><p>另外, 由于command是默认模块, 所以也可以不用特定指明:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -a &quot;uname -r&quot;</span></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">2.6.32-220.el6.x86_64</span><br><span class="line"></span><br><span class="line">192.168.206.10 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">3.10.0-693.2.2.el7.x86_64</span><br><span class="line"></span><br><span class="line">192.168.206.9 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">3.10.0-693.2.2.el7.x86_64</span><br></pre></td></tr></table></figure><p>使用all关键字, 就可以对整个文件中的主机发出指令.</p><p>接下来就来学习一下常见的几个模块吧.</p><h3 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h3><p>先来看一个示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible testservers -m cron -a &quot;minute=*/10 job=&#x27;/bin/echo Hello&#x27; name=&#x27;test of Ansible cron module&#x27; state=present&quot;</span></span><br><span class="line">192.168.206.22 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;envs&quot;</span>: [], </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;jobs&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;test of Ansible cron module&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">192.168.206.10 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;envs&quot;</span>: [], </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;jobs&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;test of Ansible cron module&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">192.168.206.9 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;envs&quot;</span>: [], </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;jobs&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;test of Ansible cron module&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来稍微确认一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible testservers -a &#x27;crontab -l&#x27;</span></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line"><span class="comment">#Ansible: test of Ansible cron module</span></span><br><span class="line">*/10 * * * * /bin/echo Hello</span><br><span class="line"></span><br><span class="line">192.168.206.10 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line"><span class="comment">#Ansible: test of Ansible cron module</span></span><br><span class="line">*/10 * * * * /bin/echo Hello</span><br><span class="line"></span><br><span class="line">192.168.206.9 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line"><span class="comment">#Ansible: test of Ansible cron module</span></span><br><span class="line">*/10 * * * * /bin/echo Hello</span><br></pre></td></tr></table></figure><p>已经添加好了.</p><p>我们来说说一些相关的参数吧, 首先肯定要提供的就是我们的时间间隔和任务是什么, 对应minute, hour, day, weekday, 如果不指明就是默认的<code>*</code>. 接着我们需要指明添加的名字是什么, 这样Ansible才可以对他们进行操作. 如果不指定就是None, 这样造成的后果是很严重的, 相当于每一次操作就会改变全体. 接着最后我们写了一个state, 指明是添加还是去除, 默认是添加.</p><p>比如我们现在把之前添加的删除掉:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible testservers -m cron -a &quot;name=&#x27;test of Ansible cron module&#x27; state=absent&quot;</span></span><br><span class="line">192.168.206.22 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;envs&quot;</span>: [], </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;jobs&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line">192.168.206.10 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;envs&quot;</span>: [], </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;jobs&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line">192.168.206.9 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;envs&quot;</span>: [], </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;jobs&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就没有了.</p><h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p>user模块听名字也就知道功能是什么了吧哈哈. 对就是进行用户管理的, 有很多属性和指令, 必须要给的一个就是name用户名了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -m user -a &#x27;name=user1&#x27;</span></span><br><span class="line">192.168.206.22 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;comment&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;createhome&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;group&quot;</span>: 500, </span><br><span class="line">    <span class="string">&quot;home&quot;</span>: <span class="string">&quot;/home/user1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;user1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;shell&quot;</span>: <span class="string">&quot;/bin/bash&quot;</span>, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;present&quot;</span>, </span><br><span class="line">    <span class="string">&quot;system&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: 500</span><br><span class="line">&#125;</span><br><span class="line">192.168.206.10 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;comment&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;createhome&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;group&quot;</span>: 1000, </span><br><span class="line">    <span class="string">&quot;home&quot;</span>: <span class="string">&quot;/home/user1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;user1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;shell&quot;</span>: <span class="string">&quot;/bin/bash&quot;</span>, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;present&quot;</span>, </span><br><span class="line">    <span class="string">&quot;system&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: 1000</span><br><span class="line">&#125;</span><br><span class="line">192.168.206.9 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;comment&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;createhome&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;group&quot;</span>: 1001, </span><br><span class="line">    <span class="string">&quot;home&quot;</span>: <span class="string">&quot;/home/user1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;user1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;shell&quot;</span>: <span class="string">&quot;/bin/bash&quot;</span>, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;present&quot;</span>, </span><br><span class="line">    <span class="string">&quot;system&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: 1001</span><br><span class="line">&#125;</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -m user -a &#x27;name=user1&#x27;</span></span><br><span class="line">192.168.206.22 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;comment&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;createhome&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;group&quot;</span>: 500, </span><br><span class="line">    <span class="string">&quot;home&quot;</span>: <span class="string">&quot;/home/user1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;user1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;shell&quot;</span>: <span class="string">&quot;/bin/bash&quot;</span>, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;present&quot;</span>, </span><br><span class="line">    <span class="string">&quot;system&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: 500</span><br><span class="line">&#125;</span><br><span class="line">192.168.206.10 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;comment&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;createhome&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;group&quot;</span>: 1000, </span><br><span class="line">    <span class="string">&quot;home&quot;</span>: <span class="string">&quot;/home/user1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;user1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;shell&quot;</span>: <span class="string">&quot;/bin/bash&quot;</span>, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;present&quot;</span>, </span><br><span class="line">    <span class="string">&quot;system&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: 1000</span><br><span class="line">&#125;</span><br><span class="line">192.168.206.9 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;comment&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;createhome&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;group&quot;</span>: 1001, </span><br><span class="line">    <span class="string">&quot;home&quot;</span>: <span class="string">&quot;/home/user1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;user1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;shell&quot;</span>: <span class="string">&quot;/bin/bash&quot;</span>, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;present&quot;</span>, </span><br><span class="line">    <span class="string">&quot;system&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: 1001</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们也可以确认一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -a &#x27;tail -1 /etc/passwd&#x27;</span></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">user1:x:500:500::/home/user1:/bin/bash</span><br><span class="line"></span><br><span class="line">192.168.206.10 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">user1:x:1000:1000::/home/user1:/bin/bash</span><br><span class="line"></span><br><span class="line">192.168.206.9 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">user1:x:1001:1001::/home/user1:/bin/bash</span><br></pre></td></tr></table></figure><p>要删除也很简单了, 直接state&#x3D;absent就行了. 其他的功能通过读文档也能很快的OK.</p><h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><p>就好比我们的groupadd命令的参数极其的少一样, 这个模块也很简单:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible-doc -s group</span></span><br><span class="line">- name: Add or remove <span class="built_in">groups</span></span><br><span class="line">  group:</span><br><span class="line">      gid:                   <span class="comment"># Optional `GID&#x27; to set for the group.</span></span><br><span class="line">      name:                  <span class="comment"># (required) Name of the group to manage.</span></span><br><span class="line">      state:                 <span class="comment"># Whether the group should be present or not on the remote host.</span></span><br><span class="line">      system:                <span class="comment"># If `yes&#x27;, indicates that the group created is a system group.</span></span><br></pre></td></tr></table></figure><p>设置gid, 组名, 状态, 是否为系统组.完了. 就是这么简洁.</p><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>主要用来实现文件复制,  先来实际操作一次:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible testservers -m copy -a &quot;src=/etc/fstab dest=/tmp/fstab.ansible owner=root mode=640&quot;</span></span><br><span class="line">192.168.206.22 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;checksum&quot;</span>: <span class="string">&quot;bcc5409249b05584582f46eb8cc41d6f93df01f8&quot;</span>, </span><br><span class="line">    <span class="string">&quot;dest&quot;</span>: <span class="string">&quot;/tmp/fstab.ansible&quot;</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;gid&quot;</span>: 0, </span><br><span class="line">    <span class="string">&quot;group&quot;</span>: <span class="string">&quot;root&quot;</span>, </span><br><span class="line">    <span class="string">&quot;md5sum&quot;</span>: <span class="string">&quot;4fba41ce7527a0977db246e220f94855&quot;</span>, </span><br><span class="line">    <span class="string">&quot;mode&quot;</span>: <span class="string">&quot;0640&quot;</span>, </span><br><span class="line">    <span class="string">&quot;owner&quot;</span>: <span class="string">&quot;root&quot;</span>, </span><br><span class="line">    <span class="string">&quot;size&quot;</span>: 465, </span><br><span class="line">    <span class="string">&quot;src&quot;</span>: <span class="string">&quot;/root/.ansible/tmp/ansible-tmp-1509005226.85-229350602804565/source&quot;</span>, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;file&quot;</span>, </span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: 0</span><br><span class="line">&#125;</span><br><span class="line">192.168.206.10 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;checksum&quot;</span>: <span class="string">&quot;bcc5409249b05584582f46eb8cc41d6f93df01f8&quot;</span>, </span><br><span class="line">    <span class="string">&quot;dest&quot;</span>: <span class="string">&quot;/tmp/fstab.ansible&quot;</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;gid&quot;</span>: 0, </span><br><span class="line">    <span class="string">&quot;group&quot;</span>: <span class="string">&quot;root&quot;</span>, </span><br><span class="line">    <span class="string">&quot;md5sum&quot;</span>: <span class="string">&quot;4fba41ce7527a0977db246e220f94855&quot;</span>, </span><br><span class="line">    <span class="string">&quot;mode&quot;</span>: <span class="string">&quot;0640&quot;</span>, </span><br><span class="line">    <span class="string">&quot;owner&quot;</span>: <span class="string">&quot;root&quot;</span>, </span><br><span class="line">    <span class="string">&quot;secontext&quot;</span>: <span class="string">&quot;unconfined_u:object_r:admin_home_t:s0&quot;</span>, </span><br><span class="line">    <span class="string">&quot;size&quot;</span>: 465, </span><br><span class="line">    <span class="string">&quot;src&quot;</span>: <span class="string">&quot;/root/.ansible/tmp/ansible-tmp-1509005226.81-171401749560627/source&quot;</span>, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;file&quot;</span>, </span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: 0</span><br><span class="line">&#125;</span><br><span class="line">192.168.206.9 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;checksum&quot;</span>: <span class="string">&quot;bcc5409249b05584582f46eb8cc41d6f93df01f8&quot;</span>, </span><br><span class="line">    <span class="string">&quot;dest&quot;</span>: <span class="string">&quot;/tmp/fstab.ansible&quot;</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;gid&quot;</span>: 0, </span><br><span class="line">    <span class="string">&quot;group&quot;</span>: <span class="string">&quot;root&quot;</span>, </span><br><span class="line">    <span class="string">&quot;md5sum&quot;</span>: <span class="string">&quot;4fba41ce7527a0977db246e220f94855&quot;</span>, </span><br><span class="line">    <span class="string">&quot;mode&quot;</span>: <span class="string">&quot;0640&quot;</span>, </span><br><span class="line">    <span class="string">&quot;owner&quot;</span>: <span class="string">&quot;root&quot;</span>, </span><br><span class="line">    <span class="string">&quot;secontext&quot;</span>: <span class="string">&quot;unconfined_u:object_r:admin_home_t:s0&quot;</span>, </span><br><span class="line">    <span class="string">&quot;size&quot;</span>: 465, </span><br><span class="line">    <span class="string">&quot;src&quot;</span>: <span class="string">&quot;/root/.ansible/tmp/ansible-tmp-1509005226.8-44103016607587/source&quot;</span>, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;file&quot;</span>, </span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着简单的验证一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -a &#x27;ls -l /tmp/fstab.ansible&#x27;</span></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">-rw-r----- 1 root root 465 Oct 26 16:07 /tmp/fstab.ansible</span><br><span class="line"></span><br><span class="line">192.168.206.10 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">-rw-r-----. 1 root root 465 Oct 26 16:51 /tmp/fstab.ansible</span><br><span class="line"></span><br><span class="line">192.168.206.9 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">-rw-r-----. 1 root root 465 Oct 26 16:07 /tmp/fstab.ansible</span><br></pre></td></tr></table></figure><p>确实也存在了.</p><p>其实我们会用到的参数也不是很多, 就那一些. 目的地址是必须要指明的,而且需要使用<strong>绝对地址</strong>. 另外, 对于目录, 如果出现了不存在的父目录, 会报错并执行失败.</p><p>使用owner&#x2F;group可以来指定属主属组, 接着mode用来指定权限, 都是很好理解的. 有意思的是, src并不是必须的. 我们也可以使用content来指明文件的内容, 例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -m copy -a &#x27;content=&quot;Hello World\nHello Ansible\n&quot; dest=/tmp/test.ansible&#x27;</span></span><br><span class="line">192.168.206.22 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;checksum&quot;</span>: <span class="string">&quot;b9169ba8226473029923516a19a73c4c68f10daa&quot;</span>, </span><br><span class="line">    <span class="string">&quot;dest&quot;</span>: <span class="string">&quot;/tmp/test.ansible&quot;</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;gid&quot;</span>: 0, </span><br><span class="line">    <span class="string">&quot;group&quot;</span>: <span class="string">&quot;root&quot;</span>, </span><br><span class="line">    <span class="string">&quot;md5sum&quot;</span>: <span class="string">&quot;0bb9e5050a1820c59d836bf9ef6a5080&quot;</span>, </span><br><span class="line">    <span class="string">&quot;mode&quot;</span>: <span class="string">&quot;0644&quot;</span>, </span><br><span class="line">    <span class="string">&quot;owner&quot;</span>: <span class="string">&quot;root&quot;</span>, </span><br><span class="line">    <span class="string">&quot;size&quot;</span>: 26, </span><br><span class="line">    <span class="string">&quot;src&quot;</span>: <span class="string">&quot;/root/.ansible/tmp/ansible-tmp-1509008122.2-242725231441981/source&quot;</span>, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;file&quot;</span>, </span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: 0</span><br><span class="line">&#125;</span><br><span class="line">...(omitted)</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -a &quot;cat /tmp/test.ansible&quot;</span></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">Hello World</span><br><span class="line">Hello Ansible</span><br><span class="line"></span><br><span class="line">192.168.206.10 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">Hello World</span><br><span class="line">Hello Ansible</span><br><span class="line"></span><br><span class="line">192.168.206.9 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">Hello World</span><br><span class="line">Hello Ansible</span><br></pre></td></tr></table></figure><p>虽然, 该模块也可以提供对文件的操作, 但是更多的时候, 我们使用file模块</p><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>对于我们刚刚复制过去的那两个文件, 我们来修改一下属组属主, 修改一下权限, 并且来做个符号链接吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -m file -a &#x27;owner=user1 group=user1 mode=600 path=/tmp/fstab.ansible&#x27;</span></span><br><span class="line">192.168.206.22 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;gid&quot;</span>: 500, </span><br><span class="line">    <span class="string">&quot;group&quot;</span>: <span class="string">&quot;user1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;mode&quot;</span>: <span class="string">&quot;0600&quot;</span>, </span><br><span class="line">    <span class="string">&quot;owner&quot;</span>: <span class="string">&quot;user1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/tmp/fstab.ansible&quot;</span>, </span><br><span class="line">    <span class="string">&quot;size&quot;</span>: 465, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;file&quot;</span>, </span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: 500</span><br><span class="line">&#125;</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>还是..来验证一下吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -a &#x27;ls -l /tmp/fstab.ansible&#x27;</span></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">-rw------- 1 user1 user1 465 Oct 26 16:07 /tmp/fstab.ansible</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>接着, 我们在做一个符号链接指向它:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -m file -a &#x27;path=/tmp/fstab.link src=/tmp/fstab.ansible state=link&#x27;</span></span><br><span class="line">192.168.206.22 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;dest&quot;</span>: <span class="string">&quot;/tmp/fstab.link&quot;</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;gid&quot;</span>: 0, </span><br><span class="line">    <span class="string">&quot;group&quot;</span>: <span class="string">&quot;root&quot;</span>, </span><br><span class="line">    <span class="string">&quot;mode&quot;</span>: <span class="string">&quot;0777&quot;</span>, </span><br><span class="line">    <span class="string">&quot;owner&quot;</span>: <span class="string">&quot;root&quot;</span>, </span><br><span class="line">    <span class="string">&quot;size&quot;</span>: 18, </span><br><span class="line">    <span class="string">&quot;src&quot;</span>: <span class="string">&quot;/tmp/fstab.ansible&quot;</span>, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;link&quot;</span>, </span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: 0</span><br><span class="line">&#125;</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>也来…验证一下吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -a &#x27;ls -l /tmp/fstab.link&#x27;</span></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">lrwxrwxrwx 1 root root 18 Oct 26 17:03 /tmp/fstab.link -&gt; /tmp/fstab.ansible</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>注意在我们进行链接的时候要指明state&#x3D;link才行. 否则会报错的. 另外, 如果创建的是硬链接, 状态就是hard了.</p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>这是一个超级简单的模块哈哈, 这样用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -m ping</span></span><br><span class="line">192.168.206.22 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;ping&quot;</span>: <span class="string">&quot;pong&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">192.168.206.10 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;ping&quot;</span>: <span class="string">&quot;pong&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">192.168.206.9 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;ping&quot;</span>: <span class="string">&quot;pong&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果主机可以ping通, 就会显示pong!</p><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>看名字就可以意识到这是一个超级重要的模块了吧哈哈. 我们来看一下吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible testservers -a &quot;service httpd status&quot;</span></span><br><span class="line"> [WARNING]: Consider using service module rather than running service</span><br><span class="line"></span><br><span class="line">192.168.206.22 | FAILED | rc=3 &gt;&gt;</span><br><span class="line">httpd is stoppednon-zero <span class="built_in">return</span> code</span><br><span class="line"></span><br><span class="line">192.168.206.10 | FAILED | rc=3 &gt;&gt;</span><br><span class="line">● httpd.service - The Apache HTTP Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">     Docs: man:httpd(8)</span><br><span class="line">           man:apachectl(8)</span><br><span class="line"></span><br><span class="line">Oct 25 03:50:01 VM-node2 systemd[1]: Unit httpd.service cannot be reloaded because it is inactive.Redirecting to /bin/systemctl status httpd.servicenon-zero <span class="built_in">return</span> code</span><br></pre></td></tr></table></figure><p>由于我们的后端两个主机不是一个系统, 这就造成输出的信息并不一致的情况了, 接着我们启动并且设置成开机自动启动httpd服务:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible testservers -m service -a &#x27;enabled=true state=started name=httpd&#x27;</span></span><br><span class="line">192.168.206.22 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;enabled&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;httpd&quot;</span>, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;started&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">192.168.206.10 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;enabled&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;httpd&quot;</span>, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;started&quot;</span>, </span><br><span class="line">    <span class="string">&quot;status&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;ActiveEnterTimestampMonotonic&quot;</span>: <span class="string">&quot;0&quot;</span>, </span><br><span class="line">        <span class="string">&quot;ActiveExitTimestampMonotonic&quot;</span>: <span class="string">&quot;0&quot;</span>, </span><br><span class="line">        ...(omitted)</span><br><span class="line">        <span class="string">&quot;UnitFileState&quot;</span>: <span class="string">&quot;disabled&quot;</span>, </span><br><span class="line">        <span class="string">&quot;Wants&quot;</span>: <span class="string">&quot;system.slice&quot;</span>, </span><br><span class="line">        <span class="string">&quot;WatchdogTimestampMonotonic&quot;</span>: <span class="string">&quot;0&quot;</span>, </span><br><span class="line">        <span class="string">&quot;WatchdogUSec&quot;</span>: <span class="string">&quot;0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>( CentOS7输出的信息真可怕…</p><p>接着我们确认一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible testservers -a &#x27;service httpd status&#x27;</span></span><br><span class="line"> [WARNING]: Consider using service module rather than running service</span><br><span class="line"></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">httpd (pid  14688) is running...</span><br><span class="line"></span><br><span class="line">192.168.206.10 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">● httpd.service - The Apache HTTP Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Thu 2017-10-26 18:19:33 CST; 2min 48s ago</span><br><span class="line">     Docs: man:httpd(8)</span><br><span class="line">           man:apachectl(8)</span><br><span class="line"> Main PID: 9510 (httpd)</span><br><span class="line">   Status: <span class="string">&quot;Total requests: 0; Current requests/sec: 0; Current traffic:   0 B/sec&quot;</span></span><br><span class="line">   CGroup: /system.slice/httpd.service</span><br><span class="line">           ├─9510 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─9511 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─9513 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─9514 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─9516 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           └─9517 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line"></span><br><span class="line">Oct 26 18:19:33 VM-node2 systemd[1]: Starting The Apache HTTP Server...</span><br><span class="line">Oct 26 18:19:33 VM-node2 systemd[1]: Started The Apache HTTP Server.Redirecting to /bin/systemctl status httpd.service</span><br></pre></td></tr></table></figure><p>确实已经启动, 而且, 开机自启动也已经OK了.</p><p>总结一下 service模块通过enabled来决定是否开机自动启动, 取值true或者false. name: 服务名称. state: 状态(stopped, started, restarted)</p><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>shell模块和command模块有点类似, 但是不同之处在于, command不提供变量支持.  我们来做个测试就知道了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -m command -a &quot;tail -1 /etc/shadow&quot;</span></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">user1:!!:17465:0:99999:7:::</span><br><span class="line"></span><br><span class="line">192.168.206.10 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">user1:!!:17465:0:99999:7:::</span><br><span class="line"></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -m command -a &quot;echo &#x27;password&#x27; | passwd --stdin user1&quot;</span></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">password | passwd --stdin user1</span><br><span class="line"></span><br><span class="line">192.168.206.10 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">password | passwd --stdin user1</span><br><span class="line"></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -m command -a &quot;tail -1 /etc/shadow&quot;</span></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">user1:!!:17465:0:99999:7:::</span><br><span class="line"></span><br><span class="line">192.168.206.10 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">user1:!!:17465:0:99999:7:::</span><br></pre></td></tr></table></figure><p>没有设置成功, 原因是我们使用了管道符. 接下来换做shell试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -m shell -a &quot;echo &#x27;password&#x27; | passwd --stdin user1&quot;</span></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">Changing password <span class="keyword">for</span> user user1.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line"></span><br><span class="line">192.168.206.10 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">Changing password <span class="keyword">for</span> user user1.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line"></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -m command -a &quot;tail -1 /etc/shadow&quot;</span></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">user1:$6<span class="variable">$paTv</span>//V6<span class="variable">$UmwQlj0OinDI9RLkIcHUWFvQNHxZF9aacuH272zDaRyoKpn21jH568IVLEJv</span>.Q8ShxPrtie9CHdfEuiVFgOwl0:17465:0:99999:7:::</span><br><span class="line"></span><br><span class="line">192.168.206.10 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">user1:$6<span class="variable">$3DO</span>.U5ry<span class="variable">$uAXVYHoNz7R5IfdksZZZMvcYLnlXYKuIHebpg65obLoTupzZZmbAFvY4soylGBwepad33v6QJ6sPqbduAwMUX</span>.:17465:0:99999:7:::</span><br></pre></td></tr></table></figure><p>提示语也是不一样的. 密码也成功的更新了.</p><p>shell虽然支持这样的, 但是如果是要执行脚本, 我们就需要下一个模块了</p><h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><p>script模块用于脚本执行, 比较坑的一个地方是, 它不支持绝对路径, 也就是说仅仅只有当你使用相对路径才接受:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># cat script </span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Test&quot;</span> &gt; /tmp/script.ansible</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># chmod  +x script</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -m script -a &#x27;script&#x27;</span></span><br><span class="line">192.168.206.22 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;rc&quot;</span>: 0, </span><br><span class="line">    <span class="string">&quot;stderr&quot;</span>: <span class="string">&quot;Shared connection to 192.168.206.22 closed.\r\n&quot;</span>, </span><br><span class="line">    <span class="string">&quot;stdout&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;stdout_lines&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line">192.168.206.10 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;rc&quot;</span>: 0, </span><br><span class="line">    <span class="string">&quot;stderr&quot;</span>: <span class="string">&quot;Shared connection to 192.168.206.10 closed.\r\n&quot;</span>, </span><br><span class="line">    <span class="string">&quot;stdout&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;stdout_lines&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照惯例, 验证一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -a &#x27;cat /tmp/script.ansible&#x27;</span></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">Test</span><br><span class="line"></span><br><span class="line">192.168.206.10 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">Test</span><br></pre></td></tr></table></figure><h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><p>见名知意啦, 为了yum安装软件包的一个模块, 使用起来也很简单:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -m yum -a &#x27;name=zsh&#x27;</span></span><br><span class="line">192.168.206.22 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;rc&quot;</span>: 0, </span><br><span class="line">    <span class="string">&quot;results&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;Loaded plugins: </span></span><br><span class="line"><span class="string">        ...(omitted)</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">192.168.206.10 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    &quot;</span>changed<span class="string">&quot;: true, </span></span><br><span class="line"><span class="string">    &quot;</span>failed<span class="string">&quot;: false, </span></span><br><span class="line"><span class="string">    &quot;</span>msg<span class="string">&quot;: &quot;</span><span class="string">&quot;, </span></span><br><span class="line"><span class="string">    &quot;</span>rc<span class="string">&quot;: 0, </span></span><br><span class="line"><span class="string">    &quot;</span>results<span class="string">&quot;: [</span></span><br><span class="line"><span class="string">...(omitted)</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这样就安装完成了, 我们来验证一下咯:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -a &#x27;rpm -q zsh&#x27;</span></span><br><span class="line"> [WARNING]: Consider using yum, dnf or zypper module rather than running rpm</span><br><span class="line"></span><br><span class="line">192.168.206.22 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">zsh-4.3.11-4.el6.centos.2.x86_64</span><br><span class="line"></span><br><span class="line">192.168.206.10 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">zsh-5.0.2-28.el7.x86_64</span><br></pre></td></tr></table></figure><p>删除也是很简单的, 直接指明state&#x3D;absent就行了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -m yum -a &#x27;name=zsh state=absent&#x27;</span></span><br><span class="line">192.168.206.10 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;rc&quot;</span>: 0, </span><br><span class="line">    <span class="string">&quot;results&quot;</span>: [</span><br><span class="line">    ...(omitted)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">192.168.206.22 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="string">&quot;rc&quot;</span>: 0, </span><br><span class="line">    <span class="string">&quot;results&quot;</span>: [</span><br><span class="line">...(omitted)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -a &#x27;rpm -q zsh&#x27;</span></span><br><span class="line"> [WARNING]: Consider using yum, dnf or zypper module rather than running rpm</span><br><span class="line"></span><br><span class="line">192.168.206.22 | FAILED | rc=1 &gt;&gt;</span><br><span class="line">package zsh is not installednon-zero <span class="built_in">return</span> code</span><br><span class="line"></span><br><span class="line">192.168.206.10 | FAILED | rc=1 &gt;&gt;</span><br><span class="line">package zsh is not installednon-zero <span class="built_in">return</span> code</span><br></pre></td></tr></table></figure><p>这样就删除掉了.</p><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>这个模块可以用来获取主机的fact信息. 什么是fact呢? 为了能够管理各个主机, ansible会获取每一个主机的一些信息, 包括系统信息, 内核版本, IP地址, BIOS日期等等大量信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible all -m setup</span></span><br><span class="line">192.168.206.22 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;ansible_facts&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;ansible_all_ipv4_addresses&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;192.168.206.22&quot;</span></span><br><span class="line">        ], </span><br><span class="line">        <span class="string">&quot;ansible_all_ipv6_addresses&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;fe80::20c:29ff:feb0:b47f&quot;</span></span><br><span class="line">        ], </span><br><span class="line">        <span class="string">&quot;ansible_apparmor&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;status&quot;</span>: <span class="string">&quot;disabled&quot;</span></span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="string">&quot;ansible_architecture&quot;</span>: <span class="string">&quot;x86_64&quot;</span>, </span><br><span class="line">        <span class="string">&quot;ansible_bios_date&quot;</span>: <span class="string">&quot;07/02/2015&quot;</span>, </span><br><span class="line">        <span class="string">&quot;ansible_bios_version&quot;</span>: <span class="string">&quot;6.00&quot;</span>, </span><br><span class="line">        <span class="string">&quot;ansible_cmdline&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;KEYBOARDTYPE&quot;</span>: <span class="string">&quot;pc&quot;</span>, </span><br><span class="line">            <span class="string">&quot;KEYTABLE&quot;</span>: <span class="string">&quot;us&quot;</span>, </span><br><span class="line">            <span class="string">&quot;LANG&quot;</span>: <span class="string">&quot;en_US.UTF-8&quot;</span>, </span><br><span class="line">            <span class="string">&quot;SYSFONT&quot;</span>: <span class="string">&quot;latarcyrheb-sun16&quot;</span>, </span><br><span class="line">            <span class="string">&quot;quiet&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><h2 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h2><p>说了一些模块的使用, 接下来我们就可以开始尝试写一下playbook了. 但在此之前, 我们还是要了解一下playbook的格式 – YAML</p><p>如果你使用过hexo, 并且乐于配置的话. 相信对YAML挺熟悉的了.不过我们在说说这个东西吧.</p><blockquote><p>YAML也是一个递归缩写, 即YAML Ain’t Markup Language. </p></blockquote><p>YAML通过缩进和键值对来表示数据结构. 使用一个<code>-</code>来表示列表, 使用一个<code>:</code>来表示键值对, 一个示例:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Justin</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">gender:</span> <span class="string">Male</span></span><br><span class="line"><span class="attr">attr:</span></span><br><span class="line"><span class="attr">isAlive:</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">isHappy:</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">skills:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Linux</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Windows</span></span><br></pre></td></tr></table></figure><p>很简单了..</p><h2 id="Playbook"><a href="#Playbook" class="headerlink" title="Playbook"></a>Playbook</h2><p>想要写一个playbook, 我们先要了解到playbook涉及到那些东西, 请看下面:</p><ul><li>Inventory</li><li>Modules</li><li>Playbooks<ul><li>Tasks</li><li>Variable</li><li>Templates</li><li>Handlers</li><li>Roles</li></ul></li></ul><p>我们一个一个说, 首先还是我们的Inventory. 这个时候用来定义主机的对不上面说过了, 现在来补充一下. </p><p>首先我们可以把几个节点放在一起构成一个组:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[webservers]</span><br><span class="line">192.168.207.100:8080</span><br><span class="line">192.168.207.200</span><br><span class="line">web1.justin.com</span><br><span class="line">web2.justin.com</span><br></pre></td></tr></table></figure><p>如果主机遵循相同的命名规范, 我们还可以简写:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[webservers]</span><br><span class="line">web[1:10].justin.com</span><br></pre></td></tr></table></figure><p>另外, 我们还可以在inventory中定义一些主机变量供playbook使用,这些变量仅仅属于这些主机.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[frontend]</span><br><span class="line">web1.scuec.com http_port=80 maxRequestPerChild=1000</span><br><span class="line">web2.scuec.com http_port=8080 maxRequestPerChild=500</span><br></pre></td></tr></table></figure><p>除了主机变量, 还有组变量, 也就是属于一个组的变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[webservers]</span><br><span class="line">www[1:10].justin.com</span><br><span class="line"></span><br><span class="line">[webservers:vars]</span><br><span class="line">nfs_server=nfs.justin.com</span><br><span class="line">ntp_server=ntp.justin.com</span><br></pre></td></tr></table></figure><p>另外, Inventory还可以进行组嵌套:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Group1]</span><br><span class="line">www.douban.com</span><br><span class="line">www.zhihu.com</span><br><span class="line"></span><br><span class="line">[Group2]</span><br><span class="line">www.sciencenet.cn</span><br><span class="line">www.weather.com.cn</span><br><span class="line"></span><br><span class="line">[target:children]</span><br><span class="line">Group1</span><br><span class="line">Group2</span><br><span class="line"></span><br><span class="line">[target:vars]</span><br><span class="line">var=XXX</span><br></pre></td></tr></table></figure><p>还有一些属于Inventory的变量, 例如<code>ansible_ssh_port, ansible_ssh_host, ansible_ssh_pass</code>等等. </p><p>现在我们来看一个playbook的示例:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webnodes</span> <span class="comment"># 指明在哪些主机执行</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">http_port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">max_client:</span> <span class="number">256</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span> <span class="comment"># 指明是用什么用户的身份执行, 在tasks中也可以定义每一个task单独的执行者</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">at</span> <span class="string">the</span> <span class="string">latest</span> <span class="string">ver.</span></span><br><span class="line">    <span class="attr">yum:</span> <span class="string">name=httpd</span> <span class="string">state=latest</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">running</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=started</span></span><br><span class="line">  <span class="attr">Handlers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=restarted</span></span><br></pre></td></tr></table></figure><p>tasks就是任务了, 调用模块完成操作, vars就是声明变量的区域, handlers就是由某事件触发的一些处理器. 最后的roles就是角色之意. 我们继续往后.</p><p>先不说后面的处理器, 我们来写一个简单的playbook执行试试.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- hosts: testservers</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars:</span><br><span class="line">    ntp_server: edu.ntp.org.cn</span><br><span class="line">  tasks:</span><br><span class="line">  - name: install ntp client</span><br><span class="line">    yum: name=ntp state=latest</span><br><span class="line">  - name: update time immediately</span><br><span class="line">    <span class="built_in">command</span>: <span class="string">&quot;ntpdate &#123;&#123; ntp_server &#125;&#125;&quot;</span></span><br><span class="line">  - name: create cron</span><br><span class="line">    cron: hour=*/12 job=<span class="string">&quot;ntpdate &#123;&#123; ntp_server &#125;&#125;&quot;</span> name=ntp_sync state=present</span><br></pre></td></tr></table></figure><p>很简单的一个剧本, 就是安装ntp接着进行时间同步, 定制定时任务以及显示当前的时间.</p><p>我们来执行一下看看:</p><blockquote><p>执行playbook的时候, 我们使用ansible-playbook程序, 最直接的方法就是在后面跟上yml的playbook文件, 也可以使用-e(添加额外变量)等选项. 另外这个地方我把testservers的inventory做了一下小修改:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[testservers]</span></span><br><span class="line">VM-node<span class="section">[2:3]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[webservers]</span></span><br><span class="line">192.168.206.22</span><br><span class="line">192.168.206.10</span><br></pre></td></tr></table></figure></blockquote><p>就是这样的效果, 很简单吧:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ansible-playbook2.png" alt="ansible-playbook2"></p><p>再来写一个和tinyproxy相关的playbook, 接着引出我们的handler, </p><p><code>web_tinyproxy.yml</code>内容如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">testservers</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">tinyproxy</span> <span class="string">service</span></span><br><span class="line">    <span class="attr">yum:</span> <span class="string">name=tinyproxy</span> <span class="string">state=latest</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Copy</span> <span class="string">configuration</span> <span class="string">file</span></span><br><span class="line">    <span class="attr">copy:</span> <span class="string">src=/etc/tinyproxy/tinyproxy.conf</span> <span class="string">dest=/etc/tinyproxy/tinyproxy.conf</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Start</span> <span class="string">tinyproxy</span> <span class="string">service</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=tinyproxy</span> <span class="string">state=started</span></span><br></pre></td></tr></table></figure><p>执行效果: </p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ansible-playbook3.png" alt="ansible-playbook3"></p><p>有意思的是, 现在的配置文件监听端口是<code>2333</code>, 我们来验证一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible testservers -m shell -a &quot;ss -tnl | grep 2333&quot;</span></span><br><span class="line">VM-node3 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">0      128                      *:2333                    *:*     </span><br><span class="line"></span><br><span class="line">VM-node2 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">LISTEN     0      128          *:2333                     *:*      </span><br></pre></td></tr></table></figure><p>接着我们修改一下本地的配置, 将端口换成<code>23333</code>: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># sed -i &#x27;s/2333/23333/&#x27; /etc/tinyproxy/tinyproxy.conf </span></span><br></pre></td></tr></table></figure><p>再次执行一次playbook:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ansible-playbook4.png" alt="ansible-playbook4"></p><p>从转型结果我们可以看出来, 服务并没有得到重启. 尽管我们的配置文件是已经重新复制了( 因为文件被修改了 ). 这个时候就需要我们的Handler来根据task的执行情况来触发特定的task.</p><p>说来也简单, 当我们的配置文件被修改的时候, 显然是应该重启服务的, 所以我们应该<strong>通知</strong>一下, 从而去执行特定的操作, handler和我们的tasks同级别, 如果没有人**通知(notify)**它. 就不会执行里面的任务, 通知的方式就是通过notify关键字, 指明哪一个handler, 直接看我们的实例吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- hosts: testservers</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: Install tinyproxy service</span><br><span class="line">    yum: name=tinyproxy state=latest</span><br><span class="line">  - name: Copy configuration file</span><br><span class="line">    copy: src=/etc/tinyproxy/tinyproxy.conf dest=/etc/tinyproxy/tinyproxy.conf</span><br><span class="line">    notify:</span><br><span class="line">    - restart tinyproxy</span><br><span class="line">  - name: Start tinyproxy service</span><br><span class="line">    service: name=tinyproxy state=started</span><br><span class="line">  handlers:</span><br><span class="line">  - name: restart tinyproxy</span><br><span class="line">    service: name=tinyproxy state=restarted</span><br></pre></td></tr></table></figure><p>这个时候, 我们还需要修改一下配置文件, 比如随便再把端口换一换, 9990吧. 接着再次执行一次:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ansible-playbook6.png" alt="ansible-playbook6"></p><p>多了一个<code>RUNNING HANDLER</code>吧. 这个时候看一下, 端口也确实是改变了.</p><p>另外, 我们的playbook中还可以使用条件测试, 通过when关键字可以根据具体的一些情况来选择性的执行, 来看这样的一个playbook</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">root@VM-node1</span> <span class="string">~</span>]<span class="comment"># cat test.yml </span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">testservers</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">make</span> <span class="string">a</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">copy:</span> <span class="string">content=&quot;This</span> <span class="string">is</span> <span class="string">CentOS7&quot;</span> <span class="string">dest=/tmp/version.ansible</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">&quot;7&quot;</span></span><br></pre></td></tr></table></figure><p>执行之后就是这样的了:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ansible-playbook7.png" alt="ansible-playbook7"></p><p>其中<code>ansible_distribution_major_version</code>是fact中的变量, 我们可以直接进行引用. </p><p>从结果看出来了, 因为我们的两个节点一个是CentOS7, 一个是 CentOS6, 所以仅仅执行了一个.</p><p>除了条件测试 , playbook还可以使用迭代, 就像这样:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">testservers</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">users</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">name=&#123;&#123;</span> <span class="string">item.name</span> <span class="string">&#125;&#125;</span> <span class="string">groups=&#123;&#123;</span> <span class="string">item.groups</span> <span class="string">&#125;&#125;</span> <span class="string">state=present</span></span><br><span class="line">      <span class="attr">with-items:</span></span><br><span class="line">        <span class="bullet">-</span> &#123; <span class="attr">name:</span> <span class="string">&#x27;test1&#x27;</span>, <span class="attr">groups:</span> <span class="string">&#x27;wheel&#x27;</span> &#125;</span><br><span class="line">        <span class="bullet">-</span> &#123; <span class="attr">name:</span> <span class="string">&#x27;test2&#x27;</span>, <span class="attr">groups:</span> <span class="string">&#x27;testgroup&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>其中, item是一个固定的变量, 会从with-items中定义的变量中取值. 不仅如此, 我们的变量可以通过字典的形式来取值.</p><p>上面的迭代展开, 其实就像是两个差不多的task. 这样写就更加简洁.</p><p>接下来, 我们再来了解一下Jinja2的模板语言. 由于Ansible使用的就是Jinja2, 所以支持Jinja2的各种语法. 不过说真的, 用的地方用的不是很多, 我们使用最多的地方应该就是变量替换了吧.</p><p>来看看一个配置文件好了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Listen &#123;&#123; port &#125;&#125;</span><br><span class="line">ServerName &#123;&#123; servername &#125;&#125;</span><br></pre></td></tr></table></figure><p>还记得我们说过的Inventory中的变量吗, 在这里就可以派上用场了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[webservers]</span><br><span class="line">192.168.206.22 port=80 servername=VM-node3</span><br><span class="line">192.168.206.10 port=8080 servername=VM-node2</span><br></pre></td></tr></table></figure><p>这样我们就可以通过模板这个模块来展开变量, 从而达到不同配置的需求.</p><p>接着我们看一下Tag功能, 如果只想运行一个playbook中的一个单独的或者特定的task, 我们可以在task中写上tags关键字:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- hosts: webservers</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: Install httpd service</span><br><span class="line">    yum: name=httpd state=latest</span><br><span class="line">  - name: Copy configuration file</span><br><span class="line">    template: src=/root/templates/httpd.j2 dest=/etc/httpd/conf/httpd.conf</span><br><span class="line">  - name: Ensure apache service is running</span><br><span class="line">    service: name=httpd state=restarted</span><br></pre></td></tr></table></figure><p>假设说每次执行这个playbook他都会从头执行到尾, 但是假设我现在就指向执行其中的复制和重启, 而不像执行安装的话, 怎么办呢? 我们在template和service下加上tags关键字:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- hosts: testservers</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: Install tinyproxy service</span><br><span class="line">    yum: name=tinyproxy state=latest</span><br><span class="line">  - name: Copy configuration file</span><br><span class="line">    copy: src=/etc/tinyproxy/tinyproxy.conf dest=/etc/tinyproxy/tinyproxy.conf</span><br><span class="line">    notify:</span><br><span class="line">    - restart tinyproxy</span><br><span class="line">    tags:</span><br><span class="line">    - skip-install</span><br><span class="line">  - name: Start tinyproxy service</span><br><span class="line">    service: name=tinyproxy state=started</span><br><span class="line">  handlers:</span><br><span class="line">  - name: restart tinyproxy</span><br><span class="line">    service: name=tinyproxy state=restarted</span><br></pre></td></tr></table></figure><p>我们在复制文件的那个地方加入了tags, 接着我们执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ansible-playbook web_tinyproxy.yml --tags=&#x27;skip-install&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ansible-playbook8.png" alt="ansible-playbook8"></p><p>看, 只有加上tag的那一个任务才会执行.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCSI和iSCSI协议以及Linux IP SAN的实现</title>
      <link href="/2017/10/23/SCSI%E5%92%8CiSCSI%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8ALinux-IP-SAN%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/10/23/SCSI%E5%92%8CiSCSI%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8ALinux-IP-SAN%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>学习了好多集群的概念和理论…要好好消化一下, 所以来个小插曲转移一下注意点啦~</p><span id="more"></span><h2 id="SCSI和iSCSI协议"><a href="#SCSI和iSCSI协议" class="headerlink" title="SCSI和iSCSI协议"></a>SCSI和iSCSI协议</h2><p>我们曾经在很远很远的时候说过简单的计算机硬件基础, 当时我们就已经说过了总线这东西, 离CPU较近的那一边就叫做北桥, 而较远的那就叫做南桥. 下面是一个简单的图示:</p><p><img src="http://img.blog.csdn.net/20161108104700216" alt="总线"></p><p>不过虽然是这样画的 现代的服务器的架构肯定是和这个有一些不同的, 不过大体上是一样的. CPU通过局部总线(Local Bus)连接上缓存和北桥控制器, 而控制器通过内存总线和内存进行连接, 中间的叫做PCI总线又接上了很多控制器, 例如SCSI控制器, USB控制器, 等等. </p><p>我们之前在说存储类型的时候说过, DAS, NAS, 和SAN. DAS就好比我们直接把移动硬盘接进来, 这就是DAS, 即直接附加存储(Direct Attach Storage). 而NAS设备就是使用一些文件共享协议实现的文件服务器, 好比NFS, CIFS等. 有些NAS也可以使用应用层的HTTP协议进行文件传输. (RESTful). 还有就是SAN, 存储区域网络(Storage Area Network) 这些设备通过的网络, 就是SAN. SAN能够块级别的文件服务, 其实SAN主要就是做到对特定的物理层的解码和编码, 例如<code>FC SAN</code>就是为了光信号的文件传输的. 而IP层的就是可以提供IP层的协议报文的封装和解包.</p><p>为了搞清楚这些玩意, 我们就要来看看Linux(RHEL)的存储模型是个什么样的, 或者说调用接口是怎么组织的:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/RHELstorage.png" alt="RHELstorage"></p><p>首先我们从上层来看, 有存储数据或者读取数据的需求的显然是我们的应用程序, 接着我们的Linux为各种类型的文件系统抽象出统一的接口, 即上面的VFS. 接着的File System Driver就是我们的各种类型文件系统的具体实现了, 接着驱动实际的有存储能力的磁盘就是向下一层的Block Device Driver. 最后的Volume就不需要多说了.</p><p>而为了要是需要操作基本的存储卷的话, 就需要将DAS接到总线上, 这些接口有这些: IDE, SCSI ( 这两个都是并行的 ), 串行的: SATA, SAS, USB, eSATA. 我们今天的主角就是SCSI了, SCSI的全称是小型计算机接口(Small Computer System Interface)</p><p>刚刚也说了, SCSI是一种并行的IO技术, 并且规范了相关的协议. 对于SCSI而言, 他的数据传输是以块的方式进行的. SCSI有这些特点:</p><ul><li>设备无关性</li><li>多设备并行</li><li>高带宽 ( 和IDE相比较 )</li><li>低系统开销 全能总线, 可以自行执行很多操作, 几乎不需要CPU的参与, 是IDE的1&#x2F;10</li></ul><p>接下来我们来说说SCSI控制器的工作模式:</p><p>首先, 在逻辑上, 我们把SCSI控制器分为一个任务管理单元和多个逻辑管理单元. 对于每一个逻辑设备, 我们也为他们分配一个ID号码来辨识, 叫做LUN.</p><p>SCSI的通信模型是一个C&#x2F;S架构的模型, 也就是我们常说的客户端,服务器端架构, 我们把客户端叫做Initiator, 而另外一端, 即Target端, 他们之间通过SCSI通道连接互相的SCSI port进行通信. 更有意思的是, 理解SCSI十分容易, 如果你对网络分层的理解不错的话, 因为他们之间的分层架构和我们的网络十分相像:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/SCSI.png" alt="SCSI"></p><p>相信一看就能明白, 然而我想说的一点是, 现在的技术已经可以将物理层替换成其他的传输介质, 不一定非要是SCSI线缆. 也可以是FC光缆, iSCSI, IB什么的, 这样, 通过各种不同的组织方式, 我们就可以构建承载着存储协议SCSI的相关报文的网络, 这就是一个SAN了.</p><p>每一个SCSI硬盘, 他的内部都有一个或者数个由逻辑单元,任务管理器,服务器构成的组件, 和一个任务分发器.</p><p>为什么说这个呢?  我们来思考一个问题, 如果说不谈物理层面上那个具有存储能力的<em>磁盘</em>, 如果说我随便找一个磁盘, 但是我把它接到一个Linux主机上, 该主机实现了上面 我说的那些功能, 那么我说这个是一个SCSI盘也是没有什么毛病的.</p><p>换言之, 我们通过软件是完全可以把一个IDE硬盘驱动成SCSI的. 这个其实就是iSCSI.</p><p>来看下面的一个图:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/iSCSI.png" alt="iSCSI"></p><p>这是iSCSI和SCSI&#x2F;FC的对比. SCSI&#x2F;FC很简单了, 只要有FC或者SCSI驱动,光卡和专用线缆就可以了, 主要是看看我们的iSCSI.</p><p>首先, 为了封装得到SCSI报文, 我们需要SCSI驱动, 接着由iSCSI驱动承上启下转换成为TCP&#x2F;IP报文, 接着通过网卡传输到存储端, 而当然了, 存储端同样也是要求拥有网卡的. 也就是说我们要在原始的数据前面加上SCSI首部, iSCSI首部, TCP首部, IP首部, Ethernet首部. 这样多层封装的结果就是, 性能不会这么好.</p><p>接下来我们就来看看SAN和NAS的对比吧:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/SANvsNAS.png" alt="SANvsNAS"></p><p>主要的区别我们之前也都说过了, 向外输出的接口就是很不一样的, 一个是块级别的, 一个是文件级别.</p><p>最后 iSCSI协议监听在tcp的3260端口上.</p><h2 id="Linux-IP-SAN的实现"><a href="#Linux-IP-SAN的实现" class="headerlink" title="Linux IP SAN的实现"></a>Linux IP SAN的实现</h2><p>现在我就先来实现一下Target端, 并且在上面配置LUN. 接着我们在找一台主机当做Initiator端, 看他能不能发现网络上的SCSI设备并且格式化并使用, 以及当出现了另外一个Initiator时, 同时读写同一个文件会造成什么情况.</p><p>首先, 对于网络上的资源, 显然加密是必然的, 尤其是对于这样的共享存储, 一定是需要进行认证的. 我们的认证方式有两种, 一个是基于IP的, 一个是基于CHAP的.</p><p>我们的CentOS自带的程序包叫做<code>scsi-target-util</code>. 所提供的管理工具叫tgtadm, 他的配置结果保存在内核中, 一旦重启内核即失效. 另外一个叫做tgt-admin: 是通过读取配置文件来进行配置.</p><p>启动服务之后, 模拟的实际上是SCSI总线, 所以我们可以管理多个target, 而每个target也可以管理多个lun.</p><p>对于Initiator端, 我们也需要一个程序包<code>iscsi-initiator-utils</code>. 他有两个工具: iscsi和iscsid. 前者是为了建立连接, 后者是为了进程随时能够读取iSCSI服务.</p><p>那么怎么识别呢? 其实, 对于target和Initiator端都使用了一个叫做iqn的来进行标识. 即 iSCSI qualified name. 是这样的格式: </p><blockquote><p><code>iqn.YEAR-MONTH.tld.domain:string[.substring]</code></p></blockquote><p>例如: iqn.2017-10.com.baidu:i1.c1</p><p>接下来我就开始配置iSCSI server了.</p><p>大体的几个步骤下面列出的这几个:</p><ul><li>准备磁盘设备, 这个我们可以直接使用Vmware的虚拟磁盘来代替</li><li>安装程序包, 启动服务</li><li>创建target</li><li>创建lun</li><li>授权</li></ul><p>OK, 现在我们准备三台主机, 两台作为Initiator端, 一台作为Target端.</p><h3 id="Target端的配置"><a href="#Target端的配置" class="headerlink" title="Target端的配置"></a>Target端的配置</h3><p>在Initiator端, 我准备了两块磁盘每个大小是10G的. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># cat /dev/sd</span></span><br><span class="line">sda   sda1  sda2  sdb   sdc </span><br></pre></td></tr></table></figure><p>这两块磁盘不需要进行分区, 也不需要进行格式化. 接着就安装软件吧, 我们来看看生成了哪些东西:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># rpm -ql scsi-target-utils</span></span><br><span class="line">/etc/sysconfig/tgtd</span><br><span class="line">/etc/tgt/conf.d/sample.conf</span><br><span class="line">/etc/tgt/targets.conf</span><br><span class="line">/etc/tgt/tgtd.conf</span><br><span class="line">/usr/lib/systemd/system/tgtd.service</span><br><span class="line">/usr/sbin/tgt-admin</span><br><span class="line">/usr/sbin/tgt-setup-lun</span><br><span class="line">/usr/sbin/tgtadm</span><br><span class="line">/usr/sbin/tgtd</span><br><span class="line">/usr/sbin/tgtimg</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>反正这个守护进程无非就是在监听3260&#x2F;tcp端口, 所以我们可以直接启动它:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># systemctl start tgtd</span></span><br><span class="line">[root@VM-node2 ~]<span class="comment"># ss -tnl</span></span><br><span class="line">State       Recv-Q Send-Q                                        Local Address:Port                                                       Peer Address:Port              </span><br><span class="line">LISTEN      0      128                                                       *:22                                                                    *:*                  </span><br><span class="line">LISTEN      0      100                                               127.0.0.1:25                                                                    *:*                  </span><br><span class="line">LISTEN      0      128                                                       *:3260                                                                  *:*                  </span><br><span class="line">LISTEN      0      128                                                      :::22                                                                   :::*                  </span><br><span class="line">LISTEN      0      100                                                     ::1:25                                                                   :::*                  </span><br><span class="line">LISTEN      0      128                                                      :::3260                                                                 :::*  </span><br></pre></td></tr></table></figure><p>我们先来试试tgtadm这个命令行工具, 熟悉一下具体的工作流程, 接着再试试tgt-admin通过配置配置文件来简化流程.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm --help</span></span><br><span class="line">Linux SCSI Target administration utility, version 1.0.55</span><br><span class="line"></span><br><span class="line">Usage: tgtadm [OPTION]</span><br><span class="line">--lld &lt;driver&gt; --mode target</span><br><span class="line">--lld &lt;driver&gt; --mode logicalunit</span><br><span class="line">--lld &lt;driver&gt; --mode account</span><br></pre></td></tr></table></figure><p>基本上我们的tgtadm是一个模式化的工具, 一共提供了三个模式: </p><p>target, 用来管理target的; logicalunit就是用来管理lun的; account是用来进行用户账户管理的. </p><p>每个模式又有着对应的操作, show, new, delete, update, bind(授权), unbind(解除授权)</p><p>现在就来进行创建一个target试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm --lld iscsi --mode target --op show</span></span><br><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm --lld iscsi --mode target --op new --tid 1 --targetname iqn.2017-10.com.justin13wyx:s1.t1</span></span><br><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm --lld iscsi --mode target --op show</span></span><br><span class="line">Target 1: iqn.2017-10.com.justin13wyx:s1.t1</span><br><span class="line">    System information:</span><br><span class="line">        Driver: iscsi</span><br><span class="line">        State: ready</span><br><span class="line">    I_T nexus information:</span><br><span class="line">    LUN information:</span><br><span class="line">        LUN: 0</span><br><span class="line">            Type: controller</span><br><span class="line">            SCSI ID: IET     00010000</span><br><span class="line">            SCSI SN: beaf10</span><br><span class="line">            Size: 0 MB, Block size: 1</span><br><span class="line">            Online: Yes</span><br><span class="line">            Removable media: No</span><br><span class="line">            Prevent removal: No</span><br><span class="line">            Readonly: No</span><br><span class="line">            SWP: No</span><br><span class="line">            Thin-provisioning: No</span><br><span class="line">            Backing store <span class="built_in">type</span>: null</span><br><span class="line">            Backing store path: None</span><br><span class="line">            Backing store flags: </span><br><span class="line">    Account information:</span><br><span class="line">    ACL information:</span><br></pre></td></tr></table></figure><p>上面显示了当前target的信息, 可以看到, 默认已经有一个LUN了, 他的类型是控制器.</p><p>所以再添加LUN的时候就不能再使用这个0号了. 现在来添加一个:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 1 --backing-store /dev/sdb</span></span><br><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm --lld iscsi --mode target --op show</span></span><br><span class="line">Target 1: iqn.2017-10.com.justin13wyx:s1.t1</span><br><span class="line">    System information:</span><br><span class="line">        Driver: iscsi</span><br><span class="line">        State: ready</span><br><span class="line">    I_T nexus information:</span><br><span class="line">    LUN information:</span><br><span class="line">        LUN: 0</span><br><span class="line">            Type: controller</span><br><span class="line">            SCSI ID: IET     00010000</span><br><span class="line">            SCSI SN: beaf10</span><br><span class="line">            Size: 0 MB, Block size: 1</span><br><span class="line">            Online: Yes</span><br><span class="line">            Removable media: No</span><br><span class="line">            Prevent removal: No</span><br><span class="line">            Readonly: No</span><br><span class="line">            SWP: No</span><br><span class="line">            Thin-provisioning: No</span><br><span class="line">            Backing store <span class="built_in">type</span>: null</span><br><span class="line">            Backing store path: None</span><br><span class="line">            Backing store flags: </span><br><span class="line">        LUN: 1</span><br><span class="line">            Type: disk</span><br><span class="line">            SCSI ID: IET     00010001</span><br><span class="line">            SCSI SN: beaf11</span><br><span class="line">            Size: 10737 MB, Block size: 512</span><br><span class="line">            Online: Yes</span><br><span class="line">            Removable media: No</span><br><span class="line">            Prevent removal: No</span><br><span class="line">            Readonly: No</span><br><span class="line">            SWP: No</span><br><span class="line">            Thin-provisioning: No</span><br><span class="line">            Backing store <span class="built_in">type</span>: rdwr</span><br><span class="line">            Backing store path: /dev/sdb</span><br><span class="line">            Backing store flags: </span><br><span class="line">    Account information:</span><br><span class="line">    ACL information:</span><br></pre></td></tr></table></figure><p>这个时候就能看到我们添加的那个LUN了, 1号. 在添加的时候要使用<code>--backing-store</code>指明使用什么设备, 只要是块设备就行了, 也就是说LVM和RAID都是可以的.</p><p>删除操作也是很容易理解的, 现在我们把另外一个sdc也加进来.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 2 --backing-store /dev/sdc</span></span><br></pre></td></tr></table></figure><p>接下来做什么? 授权. 其实对IP授权是比较多见的, 我们先来看一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm --lld iscsi --mode target --op bind --tid 1 --initiator-address 192.168.206.0/24</span></span><br><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm --lld iscsi --mode target --op show</span></span><br><span class="line">...(omitted)</span><br><span class="line">    ACL information:</span><br><span class="line">        192.168.206.0/24</span><br></pre></td></tr></table></figure><p>这个时候ACL信息就有了.</p><blockquote><p>其实刚才的这些选项都是有短格式的, 例如:</p><ul><li>–lld, -L</li><li>–mode, -m</li><li>–op, -o</li><li>–tid, -t</li><li>–lun, -l</li><li>–backing-store, -b</li><li>–initiator-address, -i</li><li>–targetname, -T</li></ul></blockquote><p>这样我们的target就已经配置完了, 很easy吧. 接下来就是另外一边的initiator端了.</p><h3 id="Initiator端的配置"><a href="#Initiator端的配置" class="headerlink" title="Initiator端的配置"></a>Initiator端的配置</h3><p>显然我们还是要先安装软件程序包, 配置Initiator的名字, 并且启动服务. 接着再使用iscsiadm实现对Target端的发现和注册等.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># rpm -ql iscsi-initiator-utils</span></span><br><span class="line">/etc/NetworkManager/dispatcher.d/04-iscsi</span><br><span class="line">/etc/iscsi</span><br><span class="line">/etc/iscsi/iscsid.conf</span><br><span class="line">/usr/lib/systemd/system/iscsi-shutdown.service</span><br><span class="line">/usr/lib/systemd/system/iscsi.service</span><br><span class="line">/usr/lib/systemd/system/iscsid.service</span><br><span class="line">/usr/lib/systemd/system/iscsid.socket</span><br><span class="line">/usr/lib/tmpfiles.d/iscsi.conf</span><br><span class="line">/usr/lib64/libiscsi.so.0</span><br><span class="line">/usr/lib64/python2.7/site-packages/libiscsimodule.so</span><br><span class="line">/usr/libexec/iscsi-mark-root-nodes</span><br><span class="line">/usr/sbin/iscsi-iname</span><br><span class="line">/usr/sbin/iscsiadm</span><br><span class="line">/usr/sbin/iscsid</span><br><span class="line">/usr/sbin/iscsistart</span><br><span class="line">...(omitted)</span><br><span class="line">/var/lib/iscsi</span><br><span class="line">/var/lib/iscsi/ifaces</span><br><span class="line">/var/lib/iscsi/isns</span><br><span class="line">/var/lib/iscsi/nodes</span><br><span class="line">/var/lib/iscsi/send_targets</span><br><span class="line">/var/lib/iscsi/slp</span><br><span class="line">/var/lib/iscsi/static</span><br><span class="line">/var/lock/iscsi</span><br><span class="line">/var/lock/iscsi/lock</span><br></pre></td></tr></table></figure><p>这个玩意安装的东西有点多了吧, 提供了多个程序. 真正的管理工具就是那个iscsiadm. 有意思的是, 他有两个服务, 一个是iscsi, 一个是iscsid. 前者是为了实现在开机之后自动连入上一次连接的target, 而iscsid是为了实现数据的持久传输, 所以这些服务我们都需要启动.</p><p>iscsiadm也是一个模式化的工具, 一般我们使用的模式也就只有discovery和node模式, 偶尔可能会需要进行discoverydb的管理, 那就是discoverydb模式了.</p><p>首先查看一下<code>/etc/iscsi/initiatorname.iscsi</code>这个文件, 它里面是我们这个Initiator的名字, 不过这个显然不适合我们. 所以我们需要重新修改一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># cat /etc/iscsi/initiatorname.iscsi </span></span><br><span class="line">InitiatorName=iqn.1994-05.com.redhat:5a7eb857dcf1</span><br></pre></td></tr></table></figure><p>对于后面那个随机的字串, 我们可以使用<code>iscsi-iname</code>这个工具生成, 用法很简单, 只要使用<code>-p</code>指明前缀就行了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># echo &quot;InitiatorName=$(iscsi-iname -p iqn.2017-10.com.justin)&quot; &gt; /etc/iscsi/initiatorname.iscsi </span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># cat /etc/iscsi/initiatorname.iscsi </span></span><br><span class="line">InitiatorName=iqn.2017-10.com.justin:198a6172b789</span><br></pre></td></tr></table></figure><p>现在就可以启动服务并且尝试进行发现了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># systemctl start iscsi</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># systemctl start iscsid</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># iscsiadm -m discovery -d 3 -t st -p 192.168.206.10:3260</span></span><br><span class="line">iscsiadm: ip 192.168.206.10, port 3260, tgpt -1</span><br><span class="line">iscsiadm: Max file limits 1024 4096</span><br><span class="line">iscsiadm: starting sendtargets discovery, address 192.168.206.10:3260, </span><br><span class="line">iscsiadm: connecting to 192.168.206.10:3260</span><br><span class="line">iscsiadm: connected <span class="built_in">local</span> port 37670 to 192.168.206.10:3260</span><br><span class="line">iscsiadm: connected to discovery address 192.168.206.10</span><br><span class="line">iscsiadm: login response status 0000</span><br><span class="line">iscsiadm: discovery process to 192.168.206.10:3260 exiting</span><br><span class="line">iscsiadm: disconnecting conn 0x555e218a0aa0, fd 3</span><br><span class="line">192.168.206.10:3260,1 iqn.2017-10.com.justin13wyx:s1.t1</span><br></pre></td></tr></table></figure><p>来稍微解释一下, 这里的参数其实不止这些, 首选-d参数指明debug等级, 还有一个-P参数指定显示信息的等级, 接着-t指明类型, 这里我们使用到的是sendtargets(st)类型, 接着后面是使用-p参数指明IP和端口, 端口可省.</p><p>从输出信息中也可以看到, 已经发现了我们的s1, t1. 接着, 如果发现了target, 服务就会在<code>/var/lib/iscsi/send_targets</code>创建出来一个对应的IP和端口的目录文件, 里面会存在我们刚刚发现的target. 当然 这个时候我们还不会出现映射过来的磁盘.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ls /var/lib/iscsi/send_targets/192.168.206.10,3260/</span></span><br><span class="line">iqn.2017-10.com.justin13wyx:s1.t1,192.168.206.10,3260,1,default  st_config</span><br></pre></td></tr></table></figure><p>因为我们还没有登录进来, 所以这个时候就需要进入node模式了.</p><p>node的选项挺多, 但最后我们可以简化一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># iscsiadm -m node -d 1 -T iqn.2017-10.com.justin13wyx:s1.t1 -p 192.168.206.10:3260 -l</span></span><br><span class="line">Logging <span class="keyword">in</span> to [iface: default, target: iqn.2017-10.com.justin13wyx:s1.t1, portal: 192.168.206.10,3260] (multiple)</span><br><span class="line">Login to [iface: default, target: iqn.2017-10.com.justin13wyx:s1.t1, portal: 192.168.206.10,3260] successful.</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># fdisk /dev/sd[a-z] -l</span></span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x000d18bd</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048     2099199     1048576   83  Linux</span><br><span class="line">/dev/sda2         2099200    41943039    19921920   8e  Linux LVM</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 10.7 GB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sdc: 10.7 GB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure><p>其中, -T表示对应的target, -p指明IP地址和端口, 端口可省, 最后的-l表示进行登录(log), 除了登录, 还有-u登出(logout).</p><p>试一下吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># iscsiadm -m node -d 1 -T iqn.2017-10.com.justin13wyx:s1.t1 -p 192.168.206.10:3260 -u</span></span><br><span class="line">Logging out of session [sid: 1, target: iqn.2017-10.com.justin13wyx:s1.t1, portal: 192.168.206.10,3260]</span><br><span class="line">Logout of [sid: 1, target: iqn.2017-10.com.justin13wyx:s1.t1, portal: 192.168.206.10,3260] successful.</span><br></pre></td></tr></table></figure><p>当我们登录的时候, 我们就会建立一条持久连接. 而且, 即使我们现在登出了, 下一次还是会自动的连接过来. 如果不想自动连接过来, 还记得我们之前在<code>/var/lib/iscsi/send_targets</code>看到的那个目录下的软连接吗? 我们可以通过移除那个来搞定, 可以通过命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># iscsiadm -m node -d 1 -T iqn.2017-10.com.justin13wyx:s1.t1 -p 192.168.206.10:3260 -o delete</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ls /var/lib/iscsi/send_targets/192.168.206.10,3260/</span></span><br><span class="line">st_config</span><br></pre></td></tr></table></figure><p>这个时候就没有了.</p><p>那我们现在再次发现和登录一次, 接着进行分区和格式化并且挂载使用一下试试看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># iscsiadm -m discovery -t st -p 192.168.206.10</span></span><br><span class="line">192.168.206.10:3260,1 iqn.2017-10.com.justin13wyx:s1.t1</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># iscsiadm -m node -T iqn.2017-10.com.justin13wyx:s1.t1 -p 192.168.206.10 -l</span></span><br><span class="line">Logging <span class="keyword">in</span> to [iface: default, target: iqn.2017-10.com.justin13wyx:s1.t1, portal: 192.168.206.10,3260] (multiple)</span><br><span class="line">Login to [iface: default, target: iqn.2017-10.com.justin13wyx:s1.t1, portal: 192.168.206.10,3260] successful.</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># fdisk /dev/sdb</span></span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, <span class="keyword">until</span> you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">Building a new DOS disklabel with disk identifier 0x4feed587.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">Partition number (1-4, default 1): </span><br><span class="line">First sector (2048-20971519, default 2048): </span><br><span class="line">Using default value 2048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-20971519, default 20971519): +5G</span><br><span class="line">Partition 1 of <span class="built_in">type</span> Linux and of size 5 GiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># mkfs.ext4 /dev/sdb1</span></span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Fragment size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">327680 inodes, 1310720 blocks</span><br><span class="line">65536 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=1342177280</span><br><span class="line">40 block <span class="built_in">groups</span></span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">32768, 98304, 163840, 229376, 294912, 819200, 884736</span><br><span class="line"></span><br><span class="line">Allocating group tables: <span class="keyword">done</span>                            </span><br><span class="line">Writing inode tables: <span class="keyword">done</span>                            </span><br><span class="line">Creating journal (32768 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span> </span><br></pre></td></tr></table></figure><p>接着挂载上来:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># mkdir /data/iscsi -pv</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory ‘/data/iscsi’</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># mount /dev/sdb1 /data/iscsi/</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ls /data/iscsi/</span></span><br><span class="line">lost+found</span><br></pre></td></tr></table></figure><p>我们向里面写一个issue文件好了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 iscsi]<span class="comment"># echo &quot;RedHat CentOS7 (192.168.206.9)&quot; &gt; issue</span></span><br><span class="line">[root@VM-node1 iscsi]<span class="comment"># cat issue </span></span><br><span class="line">RedHat CentOS7 (192.168.206.9)</span><br></pre></td></tr></table></figure><p>接着我们开启另外一台主机, 同样也试试挂载使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ~]<span class="comment"># echo &quot;InitiatorName=$(iscsi-iname -p iqn.2017-10.com.justin13wyx)&quot; &gt; /etc/iscsi/initiatorname.iscsi </span></span><br><span class="line">[root@VM-node3 ~]<span class="comment"># cat /etc/iscsi/initiatorname.iscsi </span></span><br><span class="line">InitiatorName=iqn.2017-10.com.justin13wyx:a4fe8a6e623f</span><br><span class="line">[root@VM-node3 ~]<span class="comment"># iscsiadm -m discovery -t st -p 192.168.206.10</span></span><br><span class="line">192.168.206.10:3260,1 iqn.2017-10.com.justin13wyx:s1.t1</span><br><span class="line">[root@VM-node3 ~]<span class="comment"># iscsiadm -m node -T iqn.2017-10.com.justin13wyx:s1.t1 -p 192.168.206.10 -l</span></span><br><span class="line">Logging <span class="keyword">in</span> to [iface: default, target: iqn.2017-10.com.justin13wyx:s1.t1, portal: 192.168.206.10,3260] (multiple)</span><br><span class="line">Login to [iface: default, target: iqn.2017-10.com.justin13wyx:s1.t1, portal: 192.168.206.10,3260] successful.</span><br><span class="line">[root@VM-node3 ~]<span class="comment"># mount /dev/sdb1 /data/iscsi</span></span><br><span class="line">[root@VM-node3 iscsi]<span class="comment"># ls</span></span><br><span class="line">issue  lost+found</span><br></pre></td></tr></table></figure><p>没有任何问题, 所以说尽管我们知道不能进行两次挂载, 但是我们却仍然可以进行挂载!</p><p>接下来我们玩一个好玩的, node1对issue进行写入, 我们来看看node3的状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 iscsi]<span class="comment"># cat issue </span></span><br><span class="line">RedHat CentOS7 (192.168.206.9)</span><br><span class="line">----</span><br><span class="line">[root@VM-node1 iscsi]<span class="comment"># echo &quot;New line&quot; &gt;&gt; issue </span></span><br><span class="line">[root@VM-node1 iscsi]<span class="comment"># cat issue </span></span><br><span class="line">RedHat CentOS7 (192.168.206.9)</span><br><span class="line">New line</span><br><span class="line">----</span><br><span class="line">[root@VM-node3 iscsi]<span class="comment"># cat issue </span></span><br><span class="line">RedHat CentOS7 (192.168.206.9)</span><br></pre></td></tr></table></figure><p>果然是没有改变的, 因为我们说过这种共享存储都是在内存中进行的操作, 接下来我们把node1上的那个卸载掉:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 iscsi]<span class="comment"># cd ~</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># umount /data/iscsi/</span></span><br><span class="line">----</span><br><span class="line">[root@VM-node3 iscsi]<span class="comment"># cat issue </span></span><br><span class="line">RedHat CentOS7 (192.168.206.9)</span><br></pre></td></tr></table></figure><p>还是没有改变吧, 好吧, 另外一边也卸载掉.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 iscsi]<span class="comment"># echo &quot;node3&quot; &gt; issue </span></span><br><span class="line">[root@VM-node3 iscsi]<span class="comment"># cd ~</span></span><br><span class="line">[root@VM-node3 ~]<span class="comment"># umount /data/iscsi/</span></span><br></pre></td></tr></table></figure><p>接着node1重新恢复:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># mount /dev/sdb1 /data/iscsi/</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># cat /data/iscsi/issue </span></span><br><span class="line">node3</span><br></pre></td></tr></table></figure><p>看, 显示的node3最后修改的结果, 也就是说在互相挂载的状态下, 数据是不一致的, 这样就会发生错乱. 所以, 我们应该在一个target上提供多个硬盘来进行分开使用, 避免出现这种数据紊乱的情况.</p><p>以上, 就是我们说的使用命令行的方式进行的配置. 接下来我们再来看一下使用配置文件的方式, 现在就很简单了, 不过我们要先把现在的target删除:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm -m logicalunit -o delete -t 1 -l 1</span></span><br><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm -m logicalunit -o delete -t 1 -l 2</span></span><br><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm -m target -o delete -t 1</span></span><br><span class="line">tgtadm: this target is still active</span><br></pre></td></tr></table></figure><p>出现了错误提示, 因为我们还没有登出, 两台Initiator都执行了登出操作之后就可以删除了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm -m target -o delete -t 1</span></span><br><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm -m target -o show</span></span><br><span class="line">[root@VM-node2 ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>现在我们直接来看配置文件: (<code>/etc/tgt/targets.conf</code>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">default-driver iscsi</span><br><span class="line"></span><br><span class="line">&lt;target iqn.2017-10.com.justin13wyx&gt;</span><br><span class="line">    backing-store /dev/sdb</span><br><span class="line">    backing-store /dev/sdc</span><br><span class="line">    initiator-address 192.168.206.0/24</span><br><span class="line">&lt;/target&gt;</span><br></pre></td></tr></table></figure><p>十分好懂吧.</p><p>接着直接重启服务就行了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm -m target -o show</span></span><br><span class="line">[root@VM-node2 ~]<span class="comment"># systemctl restart tgtd</span></span><br><span class="line">[root@VM-node2 ~]<span class="comment"># tgtadm -m target -o show</span></span><br><span class="line">Target 1: iqn.2017-10.com.justin13wyx</span><br><span class="line">    System information:</span><br><span class="line">        Driver: iscsi</span><br><span class="line">        State: ready</span><br><span class="line">    I_T nexus information:</span><br><span class="line">    LUN information:</span><br><span class="line">        LUN: 0</span><br><span class="line">            Type: controller</span><br><span class="line">            SCSI ID: IET     00010000</span><br><span class="line">            SCSI SN: beaf10</span><br><span class="line">            Size: 0 MB, Block size: 1</span><br><span class="line">            Online: Yes</span><br><span class="line">            Removable media: No</span><br><span class="line">            Prevent removal: No</span><br><span class="line">            Readonly: No</span><br><span class="line">            SWP: No</span><br><span class="line">            Thin-provisioning: No</span><br><span class="line">            Backing store <span class="built_in">type</span>: null</span><br><span class="line">            Backing store path: None</span><br><span class="line">            Backing store flags: </span><br><span class="line">        LUN: 1</span><br><span class="line">            Type: disk</span><br><span class="line">            SCSI ID: IET     00010001</span><br><span class="line">            SCSI SN: beaf11</span><br><span class="line">            Size: 10737 MB, Block size: 512</span><br><span class="line">            Online: Yes</span><br><span class="line">            Removable media: No</span><br><span class="line">            Prevent removal: No</span><br><span class="line">            Readonly: No</span><br><span class="line">            SWP: No</span><br><span class="line">            Thin-provisioning: No</span><br><span class="line">            Backing store <span class="built_in">type</span>: rdwr</span><br><span class="line">            Backing store path: /dev/sdb</span><br><span class="line">            Backing store flags: </span><br><span class="line">        LUN: 2</span><br><span class="line">            Type: disk</span><br><span class="line">            SCSI ID: IET     00010002</span><br><span class="line">            SCSI SN: beaf12</span><br><span class="line">            Size: 10737 MB, Block size: 512</span><br><span class="line">            Online: Yes</span><br><span class="line">            Removable media: No</span><br><span class="line">            Prevent removal: No</span><br><span class="line">            Readonly: No</span><br><span class="line">            SWP: No</span><br><span class="line">            Thin-provisioning: No</span><br><span class="line">            Backing store <span class="built_in">type</span>: rdwr</span><br><span class="line">            Backing store path: /dev/sdc</span><br><span class="line">            Backing store flags: </span><br><span class="line">    Account information:</span><br><span class="line">    ACL information:</span><br><span class="line">        192.168.206.0/24</span><br></pre></td></tr></table></figure><p>target的名字, LUN还有ACL授权都已经OK了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> iSCSI </tag>
            
            <tag> SAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高可用集群和heartbeat</title>
      <link href="/2017/10/21/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E5%9F%BA%E7%A1%80%E5%92%8Cheartbeat/"/>
      <url>/2017/10/21/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E5%9F%BA%E7%A1%80%E5%92%8Cheartbeat/</url>
      
        <content type="html"><![CDATA[<p>继续探索Linux高可用集群</p><span id="more"></span><h2 id="HA集群概念review和扩展"><a href="#HA集群概念review和扩展" class="headerlink" title="HA集群概念review和扩展"></a>HA集群概念review和扩展</h2><p>之前我们说过LVS, 虽然可以使用director向后端做健康状态检查, 但是仍然不能把这个系统称作高可用. 首先我们的状态数据会被丢失, 而且director是SPOF对嘛, 我们之前说过这个概念, director是一个单点所在, 所以只要director出现故障, <strong>整个系统将会不可用</strong>. 对于电子设备来说, 出现故障的概率是很大的.</p><p>我们之前还说过一个公式: 可用性 &#x3D; 平均故障时间 &#x2F; 平均故障时间 + 平均修复时间. 而且还说过可用性的百分比概念: 90%, 95%, 99%, 99.9%, 99.99%, 99.999%.</p><p>一个典型的高可用方案就是<strong>冗余</strong>, 比如两台主机, 但是这还远远不够了, 有的时候, 还会有双网线, 双交换机, 双电源等等. 当然了后面的这些已经是比较大的规模了.</p><p>而我们现在关心的问题是, 怎么解决判定主机宕机, 或者说服务不可用呢? 而且, 当出现状况了, 怎么进行主机的更换呢? </p><p>这样的一种机制, 我们把它叫做heartbeat机制, 也就是心跳机制, 很形象对嘛? 主机之间发送一些极小的报文进行探测, 接着通过回应判断主机当前的状态, 这样的包我们把他们叫做心跳包. 然而, 很多问题需要进行解决: 例如, 如果对方没有回应, 或者说超时了, 我就直接认定为对方下线了吗? 如果后来对方又回来了呢? 这样的原因是很多的, 例如CPU超负载, 网络拥塞等等.</p><p>但是先不说细节. 现在我们就可以来说说高可用集群是个啥了, 也就是<strong>为了提升系统的可用性而组合多台主机构成的集群.</strong> </p><p>另外, 向我们之前做的keepalived实验, 假设两台keepalived节点之间出现了问题, 导致无法正常通信. 于是两个keepalived进程都认为对方挂掉了, 所以都主动的成为了Master, 这样就会将这个集群系统分裂开来, 我们把这种状态称为<strong>脑裂</strong>( split brain ). 集群就变成了partitioned cluster. 这样的话就会造成大量的问题. 比如会造成后端的数据写入紊乱导致整个文件系统损坏的情况就是很可能发生的一件事. </p><p>所以, 我们就要想办法解决脑裂的问题, 对于高可用集群而言, 一种解决方法就是, 一旦我要成为主节点, 那么就要确保原本的那个主节点是真的挂掉了, 所以就会想法设法把他搞死, 这样就可以放心的解决资源争用问题. 但是这样又存在一个问题, 这不就自相矛盾了吗? 我们原本为了得到高可用, 为节点添加了双电源的设定, 结果到了这个时候, 双电源反而成为了我们的绊脚石.</p><p>先不考虑这个情况, 我们来看另一种状态. 刚刚和以前我们一直都是在说两台director的场景, 这个时候其实到没有这么复杂. 而如果我们的前端负载均衡集群有5个或者更多呢? 这个时候假设主机之前通过心跳机制进行存活宣告, 突然. 节点1,2,3和节点4,5出现了断层: 123之间可以正常通信, 45之间也可以正常通信, 但是他们之间被分割了. 怎么办? 这个时候联想到我们之前说的vrrp协议, 我们需要进行<strong>投票和选举</strong>. 假如说原本我们的5台主机有一个主持人, 该主持人收集所有的心跳信息, 监控全部的主机. 突然发现一次收到的包只有123的了, 而没有了45的, 而45因为找不到了主持人, 于是他们之间又会互相选举出一个新的主持人, 这样出现两个主持, 对于一开始我们设定的主持人发现现在只有3个主机给自己发消息, 于是就会认定45两个节点是离开了自己的管理. 所以就会想办法把45毙掉. 也就是把他们干掉了.</p><p>在这个过程中, 一个核心是我们的<strong>vote system</strong>. 也就是解决的问题是在发生了脑裂的情况的时候, 怎么判定那些主机仍旧作为集群活动. 一般我们使用的还是少数服从多数的原则. 而且我们一般的节点数量都是奇数, 这样就可以确保不会出现票数一致的情况. 那么如果我确实就是2个节点怎么办? 一般在这种情况下, 我们可以选择一个第三方的公信机构来判定, 比如一个共享硬盘和一个网关都可以. 一旦节点发现共享硬盘可写, 或者网关可以访问就说明另外一边没有过来, 也就是我现在就是主节点.</p><p>事实上, 对现在的高可用集群框架, 也主要分成这两个流派, 其中社区最活跃, 最丰富的一个就是<strong>少数服从多数</strong>的原则. 对于这个原则我们提出的一个概念就是<code>quorum</code> 也就是法定人数, 法定票数. 而获得多数票数的状态就被称为with quorum. 另外一个的状态就是without quorum.</p><p>另外一个流派就是使用仲裁设备的流派, 也就是使用一个quorum disk( qdisk for short ), 或者一个ping node来进行判定. 但是除了这两个, 难道就没有别的吗? 当然不是, 我们前几天玩的那个keepalived, 就不属于这两种的. 我们知道keepalived提供的高可用方案是基于vrrp协议实现的. 当然这不是今天讨论的主题, 就不说了.</p><p>现在回到我们说的资源转移的问题, 当一个节点服务不可用( 注意:这里我说的是服务不可用, 机器可能是好的 )的时候, 另一台主机一定是需要将IP地址夺过来, 相同的调度规则, 配置文件保持一致, 甚至需要将保持页面文件的一致. 在这一段时间内, 服务必然是不可用的. 这一转移的过程我们称作fail over. 在原先的节点恢复正常了之后, 如果两台主机的性能一样我也未必需要将资源转移回去, 但是一般我们的主节点的性能都是优于备用节点的嘛, 这一转移回来的过程, 我们把它叫做fail back. </p><p>但是, 当一方出现了without quorum的情况下, 这一方的资源该如何处理? 是否应该转移过去? 如果资源是存在在内存中的, 岂不是就不能转移过去了? 这个时候 我们要注意到的一点, 他们的服务是正常的, 也就是说其实仍然可用, 只不过发生了隔离. 所以说对于像这样的状况, 我们有多种方法除了上面的资源: <strong>停止(stop), 忽略(ignore), 冻结(freeze), 自杀(suicide)</strong>. 所谓冻结其实就是原先建立的连接仍然在上面, 只不过如果有新的连接到了的话, 就去有法定票数的那一方.</p><p>对于我们的集群模型, 也分成很多工作模型, 例如常见的A&#x2F;P, 即两节点模型Active和Passive, 例如A&#x2F;A, 双主模型, 例如N-M, N个节点M个服务, 通常N&gt;M, 再如, N-N, N节点N服务. </p><p>我们进行监控和心跳, 不仅是监测服务是否可用, 还需要想办法监控资源的可用状态, 对于这些资源本身而言, 他们需要意识到自己是否是可用的, 以及自己如何根据高可用集群的心跳机制做出自己的转移决策. 也就是在两个主机都安装相同的服务, 他们工作在同一层, 并且互相通信, 我们就把这一个层面称作高可用集群的集群事务信息层. 有了这么一个层次, 我们就可以面向这个信息层的API进行程序设计使得我们可以实现对资源的探测以及转移决策了</p><p>但是, 我们之前不论说nginx, httpd的时候都没有提到过他们有这样的功能呀? 事实就是如此, 如果说想要实现高可用我都要面向这个一个层面去进行编程, 那局限性也太大了. 所以就有人在这个层面的上层进行了一层通用的抽象出现了一个叫做CRM的层面, 也就是cluster resource manager. 这样一来只要这些服务和应用程序纳入manager的管理范围, 我们就可以根据配置, 根据程序特性判定那些硬件资源对于他们来说是优先级更高的. 也就是说, 启动CRM之后, 资源就会被得到监控以及如果出现问题, CRM会帮助他们进行决策和转移.</p><p>而且在转移的时候, 各个资源之间还必然存在这先后顺序, 以及依赖关系, 除此之外, 还会有一个资源粘性的概念. 这些顺序和关系一般都这几种:</p><ul><li>location: 位置约束, 资源更倾向于哪一个节点 ( -00, +00 )</li><li>colocation: 排列约束, 资源彼此之间的倾向性. ( -00, +00 ). 还可以使用分组的方式来绑定资源</li><li>order: 顺序约束, 资源在同一个节点上的启动顺序. 在这种情况下, 如果前面的资源无法启动, 后面的也不会启动, 停止亦是如此.</li></ul><p>除了顺序和关系, 资源还有根据工作模式的不同, 分成很多种类:</p><ul><li>primitive: 主资源. 只能运行在一个节点上 (native)</li><li>group: 组资源, 包含一个或者多个资源. 他们可以通过<em>组</em>这个资源进行统一调度</li><li>clone: 克隆资源, 可以在同一个集群的多个节点运行多个克隆</li><li>master&#x2F;slave: 主从资源, 在同一个集群内部运行在两个节点, 其中一个为主一个为从.</li></ul><p>这样再加上我们的CRM承上启下, 构成一个资源和决策的全貌图. 以上就是我们的高可用集群的一个基础概念了. </p><p>这样就完了? 当然不, 其实在我们的CRM上面还有一个层面. 这个层面的存在意义是什么? 先来想这样的问题, 我们启动一个服务就是使用<code>systemctl start/stop XX.service</code>或者<code>service XX start/stop</code>. 但是对于文件系统 , 对于IP地址, 我们就不能进行start&#x2F;stop了. 如果每一资源都由管理员手动告诉CRM怎么启动, 挂载, 设置. 那也太麻烦了. 所以我们抽象出一个新的层次, 也就是<strong>LRM</strong>. local resource manager. 这个层面一般都是集群服务提供的. 但是他仍然不能直接做出资源启动关闭的决策, 所以向上再加一个层次, 也就是RA, resource agent. 这个代理能够实现对资源的管理,  一般RA的实现都是通过脚本. 这些脚本其实就是RA.</p><p>也就是这样的架构:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ha.png" alt="ha"></p><p>说完了整个组成, 之前关于毙掉, <em>补刀</em>机制 我们没怎么详说, 现在来补充一下, 在高可用集群中, 这种机制被称作<strong>资源隔离</strong>机制. 隔离也是存在级别的, 比如:</p><ul><li>节点隔离 , 最彻底的一种机制: STONITH ( Shooting The Other Node In The Head ) 典型的方案是断电, 通过电源交换机</li><li>资源隔离,  fencing. 典型的方案是, 关闭共享存储的连接, 例如 FC SAN Switch</li></ul><h2 id="HA集群的解决方案"><a href="#HA集群的解决方案" class="headerlink" title="HA集群的解决方案"></a>HA集群的解决方案</h2><p>我们将这个HA架构分成了这些层面,  其实每一个层面都会有一个单独的程序来运行, 当然也有全栈的程序. 现在我们就来说说比较有名的一些解决方案:<br>首先是我们的基础架构层, 也就是信息传递的层面:</p><ul><li>heartbeat v1 v2 v3, 其中, v1和v2都可以实现全栈的HA解决方案 而v3中, heartbeat分成三个组件, 然而作为信息传递层, heartbeat已经不再具有优势</li><li>corosync, 是目前比较流行的解决方案, 比heartbeat v3更灵活, 功能更强大</li><li>cman, 是红帽的集群解决方案(RedHat, RHCS)中的一个部件.</li><li>接着还有我们之前玩过的keepalived, 但是这个玩意的工作模式和上面的三个完全不一样, 只不过他同样实现了信息传递的功能.</li></ul><p>接着来看一下我们的CRM层:</p><ul><li>heartbeat v1 haresources, 他的配置接口是通过配置文件, 文件名就是haresoources</li><li>heartbeat v2 crm (就叫做crm, 在各个节点都会由一个crmd进程, 这样各节点都可以通过crmd完成各个crm的衔接, 配置接口有CLI: crmsh, 还有GUI: hb_gui)</li><li>heartbeat v3 pacemaker, 从hb中独立出来, 十分受欢迎的一个解决方案, pacemaker可以通过插件或者独立的方式运行, 配置接口CLI: crmsh, pcs. GUI: hawk(webgui))</li><li>rgmanager, 红帽的套件之一, 配置接口CLI: clustat, cman_tool. GUI: Conga ( luci+ricci ), 可以实现全生命周期管理.</li></ul><p>而我们的组合方式有这些:</p><ul><li>heartbeat v1</li><li>heartbeat v2</li><li>heartbeat + pacemaker</li><li>corosync + pacemaker</li><li>cman + rgmanager</li><li>cman + pacemaker</li></ul><p>而LRM基本上都是由CRM的子程序提供的.</p><p>最后还有一个RA, 主要有这些:</p><ul><li>heartbeat legacy: heartbeat传统类型的RA, 通常位于&#x2F;etc&#x2F;ha.d&#x2F;haresources.d下</li><li>LSB: Linux Standard Base, &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;目录下, 至少接受四种参数: {start|stop|restart|status}</li><li>OCF</li><li>STONITH: 转用于实现调用STONITH设备功能的资源, 通常为clone类型.</li></ul><p>另外, 我们在之前的keepalived中说道过, 如果是配置HA集群, 要求主机名必须能够解析到IP地址, 所以推荐把主机名和IP地址写到hosts中, 另外, 现在我们有了上面的概念, 再次补充两条不过只是建议罢了, 首先我们的节点之间root用户能够使用密钥进行认证, 还有如果是偶数节点考虑是否会用到仲裁设备.</p><p>另外, 作为集群服务的资源, 绝对不能开机自动启动, 他们是由crm管理的.</p><h2 id="基于Heartbeat-v1实现HA-Cluster"><a href="#基于Heartbeat-v1实现HA-Cluster" class="headerlink" title="基于Heartbeat v1实现HA Cluster"></a>基于Heartbeat v1实现HA Cluster</h2><p>之前说过, heartbeat其实现在热度不是很高, 所以选择CentOS6作为我们的节点. 在epel源上有我们的heartbeat,, 所以可以直接使用yum安装.</p><p>安装过程很简单, 我就省略了.</p><p>安装完成之后我们来看一下,:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ~]<span class="comment"># cd /etc/ha.d/</span></span><br><span class="line">[root@VM-node3 ha.d]<span class="comment"># ls</span></span><br><span class="line">harc  rc.d  README.config  resource.d  shellfuncs</span><br><span class="line">[root@VM-node3 ha.d]<span class="comment"># ls resource.d/</span></span><br><span class="line">apache        db2    Filesystem    ICP  IPaddr   IPsrcaddr  LinuxSCSI  MailTo  portblock  SendArp    WAS       Xinetd</span><br><span class="line">AudibleAlarm  Delay  hto-mapfuncs  ids  IPaddr2  IPv6addr   LVM        OCF     Raid1      ServeRAID  WinPopup</span><br></pre></td></tr></table></figure><p>在他的配置目录&#x2F;etc&#x2F;ha.d下, 我们需要用到的文件默认一个也没有, 但是我们是可以从resource.d中看到heartbeat用来进行资源代理的脚本.</p><p>heartbeat所需要的配置文件有三个: <strong>ha.cf</strong> 这个是主配置文件, 用来定义各个节点上的heartbeat HA集群的基本属性, <strong>authkeys</strong> 这个是用来鉴别心跳信息的, 也就是个签名罢了, 使用的是单向加密算法, 即指纹, <strong>haresource</strong> 并不是必须的, 为heartbeat v1提供的资源管理器接口.</p><p>在安装完成的文件中, 有生成的hb配置文件的样例, 我们把他们复制出来看一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ha.d]<span class="comment"># cp /usr/share/doc/heartbeat-3.0.4/&#123;authkeys,haresources,ha.cf&#125; /etc/ha.d/</span></span><br><span class="line">[root@VM-node3 ha.d]<span class="comment"># ls</span></span><br><span class="line">authkeys  ha.cf  harc  haresources  rc.d  README.config  resource.d  shellfuncs</span><br></pre></td></tr></table></figure><p>接下来要说一点, 我们的authkeys必须将权限设置成600才可以, 否则集群会直接拒绝启动.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ha.d]<span class="comment"># chmod 600 authkeys </span></span><br></pre></td></tr></table></figure><p>好了, 现在从authkey开始, 我们来配置一下我们的heartbeat. 通过使用不同的算法来指定密钥. auth关键字指定使用哪种方式的密钥.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auth 2</span><br><span class="line"><span class="comment">#1 crc</span></span><br><span class="line">2 sha1 CPdolTm2dLkGUg</span><br><span class="line"><span class="comment">#3 md5 Hello!</span></span><br></pre></td></tr></table></figure><p>可以使用openssl生产随机字串:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ha.d]<span class="comment"># openssl rand -base64 10</span></span><br><span class="line">CPdolTm2dLkGUg==</span><br></pre></td></tr></table></figure><p>这样就可以了. 接着我们来看一下主角 – ha.cf :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">debugfile /var/log/ha-debug <span class="comment"># debug信息的输出</span></span><br><span class="line">logfile/var/log/ha-log <span class="comment"># 日志文件位置</span></span><br><span class="line">logfacility     local0 <span class="comment"># rsyslog的facility属性, 如果指明了日志文件这个就不用说明了</span></span><br><span class="line">keepalive 2 <span class="comment"># 发送心跳包的时间间隔</span></span><br><span class="line">deadtime 30 <span class="comment"># 死亡时间: 宣言对方主机死亡的时间间隔</span></span><br><span class="line">warntime 10 <span class="comment"># 警告时间: 没有收到心跳包之后多久发送</span></span><br><span class="line">initdead 120 <span class="comment"># 首次死亡时间, 最小应该是死亡时间的2倍 (考虑刚启动的时候网络服务启动)</span></span><br><span class="line">udpport694 <span class="comment"># UDP端口, 该694是标准</span></span><br><span class="line">baud19200 <span class="comment"># 使用串口的频率</span></span><br><span class="line">serial/dev/ttyS0<span class="comment"># 串口位置</span></span><br><span class="line">bcasteth1 eth2<span class="comment"># 广播的网卡, 可以写多个</span></span><br><span class="line">mcast eth0 225.0.0.1 694 1 0 <span class="comment"># 组播, 值有: 接口 地址 端口 ttl 是否循环</span></span><br><span class="line">ucast eth0 192.168.1.2<span class="comment"># 也支持单播</span></span><br><span class="line">auto_failback on <span class="comment"># 是否开启自动资源回滚</span></span><br><span class="line">nodeken3 <span class="comment"># 集群中有哪些节点 这里的值需要和hostname一致</span></span><br><span class="line">ping 10.10.10.254 <span class="comment"># ping node, 仲裁设备之ping node</span></span><br><span class="line">ping_group group1 10.10.10.254 10.10.10.253 <span class="comment"># 如果一个不够可以指定一组</span></span><br><span class="line">compressionbz2 <span class="comment"># 是否压缩, 以及使用哪种算法</span></span><br><span class="line">compression_threshold 2 <span class="comment"># 压缩的门槛, 单位是Kb.</span></span><br></pre></td></tr></table></figure><p>主要就是上面的那些配置, 注释都直接写上了.</p><p>我最后的配置结果是这样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">logfile /var/log/ha-log</span><br><span class="line">keepalive 2</span><br><span class="line">deadtime 10</span><br><span class="line">warntime 5</span><br><span class="line">initdead 20</span><br><span class="line">mcast eth0 225.1.206.1 694 1 0</span><br><span class="line">auto_failback on</span><br><span class="line">node    VM-node3</span><br><span class="line">node    VM-node4</span><br><span class="line">ping 192.168.206.2</span><br><span class="line">compression     bz2</span><br><span class="line">compression_threshold 4</span><br></pre></td></tr></table></figure><p>OK, 接下来就是最后一个配置了, 我们来瞅瞅haresource:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#just.linux-ha.org      135.9.216.3/28/eth0/135.9.216.12 httpd</span></span><br></pre></td></tr></table></figure><p>文件很短, 核心就是这样的配置, 现在我们先简单的配置一下, 更复杂的语法过会说, 这里配置的就是:</p><blockquote><p>节点名 IP地址&#x2F;子网掩码&#x2F;网卡接口&#x2F;广播地址 服务</p></blockquote><p>这个是存在顺序的, 也就是从左到右顺序执行.</p><p>那么对于我们的情况应该这样配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VM-node3        192.168.206.11/24/eth0/192.168.206.255  httpd</span><br></pre></td></tr></table></figure><p>现在就可以启动了. 但是别急, 我们需要另一台主机也保持几乎一样的配置才行, 所以先复制过去:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ha.d]<span class="comment"># scp authkeys ha.cf haresources VM-node4:/etc/ha.d/</span></span><br><span class="line">authkeys                                                                                                                                 100%  655     0.6KB/s   00:00    </span><br><span class="line">ha.cf                                                                                                                                    100%  200     0.2KB/s   00:00    </span><br><span class="line">haresources                                                                                                                              100% 5959     5.8KB/s   00:00</span><br></pre></td></tr></table></figure><p>接着, 由于另一边的网卡名称不一样, 所以我稍作了修改.</p><p>接着两边就可以启动服务了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@VM-node3 ha.d]<span class="comment"># tail /var/log/ha-log </span></span><br><span class="line">harc(default)[11491]:2017/10/21_22:10:20 info: Running /etc/ha.d//rc.d/ip-request-resp ip-request-resp</span><br><span class="line">ip-request-resp(default)[11491]:2017/10/21_22:10:20 received ip-request-resp 192.168.206.11/24/eth0/192.168.206.255 OK <span class="built_in">yes</span></span><br><span class="line">ResourceManager(default)[11512]:2017/10/21_22:10:20 info: Acquiring resource group: vm-node3 192.168.206.11/24/eth0/192.168.206.255 httpd</span><br><span class="line">/usr/lib/ocf/resource.d//heartbeat/IPaddr(IPaddr_192.168.206.11)[11539]:2017/10/21_22:10:20 INFO:  Resource is stopped</span><br><span class="line">ResourceManager(default)[11512]:2017/10/21_22:10:20 info: Running /etc/ha.d/resource.d/IPaddr 192.168.206.11/24/eth0/192.168.206.255 start</span><br><span class="line">IPaddr(IPaddr_192.168.206.11)[11663]:2017/10/21_22:10:20 INFO: Adding inet address 192.168.206.11/24 with broadcast address 192.168.206.255 to device eth0</span><br><span class="line">IPaddr(IPaddr_192.168.206.11)[11663]:2017/10/21_22:10:20 INFO: Bringing device eth0 up</span><br><span class="line">IPaddr(IPaddr_192.168.206.11)[11663]:2017/10/21_22:10:20 INFO: /usr/libexec/heartbeat/send_arp -i 200 -r 5 -p /var/run/resource-agents/send_arp-192.168.206.11 eth0 192.168.206.11 auto not_used not_used</span><br><span class="line">/usr/lib/ocf/resource.d//heartbeat/IPaddr(IPaddr_192.168.206.11)[11637]:2017/10/21_22:10:21 INFO:  Success</span><br><span class="line">ResourceManager(default)[11512]:2017/10/21_22:10:21 info: Running /etc/init.d/httpd  start</span><br><span class="line">[root@VM-node3 ha.d]<span class="comment"># ss -tnl</span></span><br><span class="line">Recv-Q Send-Q                                                          Local Address:Port                                                            Peer Address:Port </span><br><span class="line">0      128                                                                        :::80                                                                        :::*     </span><br></pre></td></tr></table></figure><p>httpd服务也自动启动了.</p><p>访问试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>现在我们把第一个节点的heartbeat服务停掉, 继续访问, 几乎没有延迟:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;web on Node4&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;web on Node4&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>也可以看到夺取资源相关的日志记录:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node4 ha.d]<span class="comment"># tail /var/log/ha-log </span></span><br><span class="line">IPaddr(IPaddr_192.168.206.11)[8311]:2017/10/21_22:14:19 INFO: Bringing device eth2 up</span><br><span class="line">IPaddr(IPaddr_192.168.206.11)[8311]:2017/10/21_22:14:19 INFO: /usr/libexec/heartbeat/send_arp -i 200 -r 5 -p /var/run/resource-agents/send_arp-192.168.206.11 eth2 192.168.206.11 auto not_used not_used</span><br><span class="line">/usr/lib/ocf/resource.d//heartbeat/IPaddr(IPaddr_192.168.206.11)[8285]:2017/10/21_22:14:19 INFO:  Success</span><br><span class="line">ResourceManager(default)[8160]:2017/10/21_22:14:19 info: Running /etc/init.d/httpd  start</span><br><span class="line">mach_down(default)[8134]:2017/10/21_22:14:19 info: /usr/share/heartbeat/mach_down: nice_failback: foreign resources acquired</span><br><span class="line">mach_down(default)[8134]:2017/10/21_22:14:19 info: mach_down takeover complete <span class="keyword">for</span> node vm-node3.</span><br><span class="line">Oct 21 22:14:19 VM-node4 heartbeat: [8018]: info: mach_down takeover complete.</span><br><span class="line">Oct 21 22:14:29 VM-node4 heartbeat: [8018]: WARN: node vm-node3: is dead</span><br><span class="line">Oct 21 22:14:29 VM-node4 heartbeat: [8018]: info: Dead node vm-node3 gave up resources.</span><br><span class="line">Oct 21 22:14:29 VM-node4 heartbeat: [8018]: info: Link vm-node3:eth2 dead.</span><br></pre></td></tr></table></figure><p>这个时候我们回复Node3的服务, 由于设置了fail back, 所以资源会重新夺回来才对:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ha.d]<span class="comment"># service heartbeat start &amp;&amp; tail -f /var/log/ha-log </span></span><br><span class="line">Starting High-Availability services: INFO:  Resource is stopped</span><br><span class="line">Done.</span><br><span class="line"></span><br><span class="line">Oct 21 22:17:33 VM-node3 heartbeat: [12105]: info: Configuration validated. Starting heartbeat 3.0.4</span><br><span class="line">Oct 21 22:17:33 VM-node3 heartbeat: [12106]: info: heartbeat: version 3.0.4</span><br><span class="line">Oct 21 22:17:34 VM-node3 heartbeat: [12106]: info: Heartbeat generation: 1508594079</span><br><span class="line">Oct 21 22:17:34 VM-node3 heartbeat: [12106]: info: glib: UDP multicast heartbeat started <span class="keyword">for</span> group 225.1.206.1 port 694 interface eth0 (ttl=1 loop=0)</span><br><span class="line">Oct 21 22:17:34 VM-node3 heartbeat: [12106]: info: glib: ping heartbeat started.</span><br><span class="line">Oct 21 22:17:34 VM-node3 heartbeat: [12106]: info: G_main_add_TriggerHandler: Added signal manual handler</span><br><span class="line">Oct 21 22:17:34 VM-node3 heartbeat: [12106]: info: G_main_add_TriggerHandler: Added signal manual handler</span><br><span class="line">Oct 21 22:17:34 VM-node3 heartbeat: [12106]: info: G_main_add_SignalHandler: Added signal handler <span class="keyword">for</span> signal 17</span><br><span class="line">Oct 21 22:17:34 VM-node3 heartbeat: [12106]: info: Local status now <span class="built_in">set</span> to: <span class="string">&#x27;up&#x27;</span></span><br><span class="line">Oct 21 22:17:34 VM-node3 heartbeat: [12106]: info: Link 192.168.206.2:192.168.206.2 up.</span><br><span class="line">Oct 21 22:17:34 VM-node3 heartbeat: [12106]: info: Status update <span class="keyword">for</span> node 192.168.206.2: status ping</span><br><span class="line">Oct 21 22:17:36 VM-node3 heartbeat: [12106]: info: Link vm-node4:eth0 up.</span><br><span class="line">Oct 21 22:17:36 VM-node3 heartbeat: [12106]: info: Status update <span class="keyword">for</span> node vm-node4: status active</span><br><span class="line">harc(default)[12118]:2017/10/21_22:17:36 info: Running /etc/ha.d//rc.d/status status</span><br><span class="line">Oct 21 22:17:36 VM-node3 heartbeat: [12106]: info: Comm_now_up(): updating status to active</span><br><span class="line">Oct 21 22:17:36 VM-node3 heartbeat: [12106]: info: Local status now <span class="built_in">set</span> to: <span class="string">&#x27;active&#x27;</span></span><br><span class="line">Oct 21 22:17:37 VM-node3 heartbeat: [12106]: info: remote resource transition completed.</span><br><span class="line">Oct 21 22:17:37 VM-node3 heartbeat: [12106]: info: remote resource transition completed.</span><br><span class="line">Oct 21 22:17:37 VM-node3 heartbeat: [12106]: info: Local Resource acquisition completed. (none)</span><br><span class="line">Oct 21 22:17:37 VM-node3 heartbeat: [12106]: info: vm-node4 wants to go standby [foreign]</span><br><span class="line">Oct 21 22:17:38 VM-node3 heartbeat: [12106]: info: standby: acquire [foreign] resources from vm-node4</span><br><span class="line">Oct 21 22:17:38 VM-node3 heartbeat: [12137]: info: acquire <span class="built_in">local</span> HA resources (standby).</span><br><span class="line">ResourceManager(default)[12150]:2017/10/21_22:17:38 info: Acquiring resource group: vm-node3 192.168.206.11/24/eth0/192.168.206.255 httpd</span><br><span class="line">/usr/lib/ocf/resource.d//heartbeat/IPaddr(IPaddr_192.168.206.11)[12177]:2017/10/21_22:17:38 INFO:  Resource is stopped</span><br><span class="line">ResourceManager(default)[12150]:2017/10/21_22:17:38 info: Running /etc/ha.d/resource.d/IPaddr 192.168.206.11/24/eth0/192.168.206.255 start</span><br><span class="line">IPaddr(IPaddr_192.168.206.11)[12301]:2017/10/21_22:17:38 INFO: Adding inet address 192.168.206.11/24 with broadcast address 192.168.206.255 to device eth0</span><br><span class="line">IPaddr(IPaddr_192.168.206.11)[12301]:2017/10/21_22:17:38 INFO: Bringing device eth0 up</span><br><span class="line">IPaddr(IPaddr_192.168.206.11)[12301]:2017/10/21_22:17:38 INFO: /usr/libexec/heartbeat/send_arp -i 200 -r 5 -p /var/run/resource-agents/send_arp-192.168.206.11 eth0 192.168.206.11 auto not_used not_used</span><br><span class="line">/usr/lib/ocf/resource.d//heartbeat/IPaddr(IPaddr_192.168.206.11)[12275]:2017/10/21_22:17:38 INFO:  Success</span><br><span class="line">ResourceManager(default)[12150]:2017/10/21_22:17:38 info: Running /etc/init.d/httpd  start</span><br><span class="line">Oct 21 22:17:38 VM-node3 heartbeat: [12137]: info: <span class="built_in">local</span> HA resource acquisition completed (standby).</span><br><span class="line">Oct 21 22:17:38 VM-node3 heartbeat: [12106]: info: Standby resource acquisition <span class="keyword">done</span> [foreign].</span><br><span class="line">Oct 21 22:17:38 VM-node3 heartbeat: [12106]: info: Initial resource acquisition complete (auto_failback)</span><br><span class="line">Oct 21 22:17:39 VM-node3 heartbeat: [12106]: info: remote resource transition completed.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次访问也可以看出来:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>OK, 以上就是heartbeat基本的设定和一个简单的实现.</p><p>现在,我们继续. 假设网页文件来源于一个NFS怎么样呢?</p><p>开启一台新的主机作为共享存储. 首先我们先进行一下NFS的相关设定, 接着试着用Web主机进行挂载, 接着直接访问IP试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ~]<span class="comment"># mount -t nfs 192.168.206.9:/data/web /var/www/html/</span></span><br><span class="line">[root@VM-node3 ~]<span class="comment"># mount</span></span><br><span class="line">...(omitted)</span><br><span class="line">192.168.206.9:/data/web on /var/www/html <span class="built_in">type</span> nfs (rw,vers=4,addr=192.168.206.9,clientaddr=192.168.206.22)</span><br><span class="line">[root@VM-node3 ~]<span class="comment"># service httpd restart</span></span><br><span class="line">Stopping httpd:                                            [  OK  ]</span><br><span class="line">Starting httpd:                                            [  OK  ]</span><br></pre></td></tr></table></figure><p>访问的结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.22</span><br><span class="line">&lt;h1&gt;Web Page on NFS&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>行了, 另外一个节点也可以做这样的操作试试. 试完了之后一定要记得把服务停止, 卸载NFS.</p><p>接着我们来编辑一下haresource, 可是文件系统的挂载怎么写啊? 在&#x2F;etc&#x2F;ha.d&#x2F;resource.d中有一个脚本叫做Filesystem, 这就是为了挂载文件系统的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VM-node3        192.168.206.11/24/eth0/192.168.206.255  Filesystem::192.168.206.9:/data/web::/var/www/html::nfs httpd</span><br></pre></td></tr></table></figure><p>另外一边要保持一致.</p><p>接着开启服务 ( 开启之前要确定httpd服务关闭, 并且没有挂载到NFS )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;Web Page on NFS&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>访问是正常的, 而且可以看到node4没有挂载到NFS,只有node3绑定IP, 挂载上了NFS. 接着尝试关闭node3的heartbeat服务, 可以发现, 挂载自动消失, 另外一边(node4)已经挂载上了NFS, 并且也工作正常. 当服务恢复的时候, 资源被夺回, node4上的挂载也消失了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Cluster </tag>
            
            <tag> heartbeat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keepalived</title>
      <link href="/2017/10/20/keepalived%E4%B8%8Evrrp%E5%8D%8F%E8%AE%AE/"/>
      <url>/2017/10/20/keepalived%E4%B8%8Evrrp%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>打开高可用的探索之门~</p><span id="more"></span><h2 id="高可用集群基础"><a href="#高可用集群基础" class="headerlink" title="高可用集群基础"></a>高可用集群基础</h2><p>我们已经了解了LB集群的实现, 使用了lvs, nginx, haproxy等等. 其实这些服务或者功能都十分轻量. 但是director作为整个系统的单点所在, 我们需要考虑下对这个调度器做高可用 (HA).</p><p>但是高可用的架构有很多, 例如今天要说的keepalived, 还有heartbeat, corosync, cman等等. 这些中最为轻量的就是这个keepalived. 在这样的场景下, 真心没有必要去使用后面的那些. 所以 我们选择使用keepalived来构建这么一个小型的高可用集群. 事实上 keepalived原本设计的面向就是为了LVS实现的高可用解决方案. 只不过现在他已经拓展了很多功能了, 通过外置脚本和插件的形式, 只不过在配置文件中, keepalived原本就已经支持对LVS的种种高可用操作. 所以十分适合. 至于后面那些, 都是为了10几个, 几百个这样的大型服务器集群.</p><p>在高可用的场景中, 我们经常会将一个节点做双份, 这个时候我们把正在使用的那一个定义成**<code>active</code><strong>的, 而冗余的那一台就是</strong><code>passive</code>**的, 也可以叫做backup节点. 回到那个问题, 备用节点怎么得知活动节点服务出现问题, 并且通过什么方式来取代其作为服务.  现在我们就很好回答这个问题了, 只要两个或者多个节点都有相同的服务, 例如我们的LVS, 一个director需要一个VIP和ipvs规则才可以, 在例如我们的nginx, 他也需要一个VIP和自己的nginx服务, 再如haproxy, 还是需要一个VIP和自己的服务配置.  那么也就是说, 从节点需要获得和主节点一样的IP, 一样的服务配置或者规则.</p><p>但是, 以现在的认知, 两个节点拥有同一个IP地址似乎是存在问题的. 先不管这个, 一个主机想要作为负载均衡调度的节点的话, 是需要我们上面 说的那些的, 我们把这个东西称作<strong>资源(<code>resource</code>)</strong>, 高可用集群中的资源. 所以一个高可用集群中最珍贵的资源就是我们的VIP了.</p><p>那么, 如果当发现主节点出现问题, 从节点将IP配置上, 这个时候我们漏掉了一个很重要的部分的, <strong>存储</strong>.我们说过存储的数据分两种, 结构化数据和非结构化数据. 结构化的数据都是存储在数据库中的, 数据库对于并发控制是存在的, 所以我们也先不考虑这个, 问题在于非结构化数据, 如果是挂载的共享存储, 这个时候两台节点都有进程都在对文件系统进读写, 我们知道Linux对于文件系统的数据读写是在内存中完成的, 这样在并发的情况下就会出现大量脏数据的情况, 导致结果不一致, 从而使得数据损坏. 除了共享存储, 我们也可以使用同步, 不过仅仅适合于数据量很少的情况.</p><p>这个时候, 我们就需要分布式存储的协力, 或者支持并发访问的文件系统了. 所以, 我们现在稍作总结, 在这样的高可用场景中, 最重要的资源就是IP和存储了, 至于服务, 我们只要运行相同, 配置文件也保持一致就行了.</p><p>接着在回到之前说的配置IP这一点上, 如果直接就这么配置上, 一个明显的问题就是我们director之前的路由器就傻了, 可能会出现一段时间是第一台节点, 一段时间路由到第二台节点的情况. 这怎么办呢? 很简单了, 只要确保必须是一台活动, 一台备用就行了, 也就是说只要一台得到了IP, 另外一台就不能进行工作. 这样的话就回到了那个老话题 – 如何判断主备状态.</p><p>监控, 对. 显然, 监控就可以解决问题. 但是监控也是分很多形式的, 比如可以一问一答, 也可以进行单方向发送状态信息. 一般情况下, 我们选择的方式是后者. 而且还是基于组播的发送. 另外, 这个机制的一个重要的考量因素就是<strong>时间</strong>. 主机之间的时间必须同步. 否则极大几率会出现误判. 那么如何实现时间同步? 简单, 只要指向同一台ntp服务器就行了. 我不管这个时间是否准确, 只要<strong>你们的</strong>时间一样就行了. </p><p>要说到keepalived, 首先我们要说说vrrp, 也就是虚拟路由冗余协议.</p><h2 id="keepalived和vrrp简述"><a href="#keepalived和vrrp简述" class="headerlink" title="keepalived和vrrp简述"></a>keepalived和vrrp简述</h2><p>网络工程师肯定是很熟悉这个vrrp了, 在华为, H3C, Cisco都有相关的技术文档. 事实上vrrp的工作原理和上面说的那些差不多了, 作为网关的路由器可以说是很重要的设备, 所以为了后端服务器的高可用, 我们会对网关进行一个冗余, 只要正在运行的, 也就是active的路由设备一直向冗余的路由设备发送心跳, 就认定成是可用的, 一段周期内, 备份的路由器如果没有心跳数据包, 就会取代这个网关路由, 保持这个通道的连续和可靠. </p><p>那么vrrp怎么工作的? 核心的思想就是将两个路由器构建成一个或者多个虚拟路由. 具体的实施过程是这样的, 首先, 配置成虚拟路由的多台路由器之间协商, 选举出一台Master节点, 选举主要依靠他们的优先级, 如果优先级相同, IP地址大的成为Master. 接着, Master路由周期性的发送vrrp报文, 通报自己的配置信息和工作状态. 如果Master路由出现故障, 剩余的Backup路由重新进行选举出新的Master, 并且发布一个携带虚拟IP和自己的虚拟MAC地址的免费ARP报文从而更新网络中的ARP信息. 这里的ARP报文也可以理解成是ARP欺骗.</p><p>当然直接这样发送报文, 不是这么的安全, 所以vrrp也支持认证功能. 包括简单的字符认证, 和MD5认证. 不过对于一个频繁发送的心跳包来说, MD5计算显然是一个很消耗性能和带宽的方式. 所以一般都会选择简单的字符认证. </p><p>另外, 考虑到backup路由一直处于闲置的状态, 我们可以构建<strong>双主模型</strong>. 就是说, R1和R2两台路由器, 我们可以配置两个虚拟路由器, 其中一个R1做主, 另一个R2做主. 这样还可以实现负载均衡, 还充分运用了资源.</p><p>keepalived就是对vrrp协议在Linux主机上的以守护进程的方式的一种实现. 能够根据配置文件自动生成ipvs规则, 并且可以对各个RS做健康状态检测.</p><p><img src="http://www.keepalived.org/images/Software%20Design.gif" alt="img"></p><p>上图就是keepalived官方的一张架构图. 可以很清楚的看到, 核心组件就是那个VRRP stack了.</p><h2 id="keepalived配置"><a href="#keepalived配置" class="headerlink" title="keepalived配置"></a>keepalived配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># yum info keepalived</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">...(omitted)</span><br><span class="line">Available Packages</span><br><span class="line">Name        : keepalived</span><br><span class="line">Arch        : x86_64</span><br><span class="line">Version     : 1.3.5</span><br><span class="line">Release     : 1.el7</span><br><span class="line">Size        : 327 k</span><br><span class="line">Repo        : base/7/x86_64</span><br><span class="line">Summary     : Load balancer and high availability service</span><br><span class="line">URL         : http://www.keepalived.org/</span><br><span class="line">License     : GPLv2+</span><br><span class="line">Description : Keepalived provides simple and robust facilities <span class="keyword">for</span> load balancing</span><br><span class="line">            : and high availability.  The load balancing framework relies on the</span><br><span class="line">            : well-known and widely used Linux Virtual Server (IPVS) kernel module</span><br><span class="line">            : providing layer-4 (transport layer) load balancing.  Keepalived</span><br><span class="line">            : implements a <span class="built_in">set</span> of checkers to dynamically and adaptively maintain</span><br><span class="line">            : and manage a load balanced server pool according their health.</span><br><span class="line">            : Keepalived also implements the Virtual Router Redundancy Protocol</span><br><span class="line">            : (VRRPv2) to achieve high availability with director failover.</span><br></pre></td></tr></table></figure><p>安装就直接yum install就行了.</p><p>来看看安装了那些东西吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">root@VM-node1 ~]<span class="comment"># rpm -ql keepalived</span></span><br><span class="line">/etc/keepalived</span><br><span class="line">/etc/keepalived/keepalived.conf</span><br><span class="line">/etc/sysconfig/keepalived</span><br><span class="line">/usr/bin/genhash</span><br><span class="line">/usr/lib/systemd/system/keepalived.service</span><br><span class="line">/usr/libexec/keepalived</span><br><span class="line">/usr/sbin/keepalived</span><br><span class="line">/usr/share/doc/keepalived-1.3.5</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/AUTHOR</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/CONTRIBUTORS</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/COPYING</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/ChangeLog</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/NOTE_vrrp_vmac.txt</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/README</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/TODO</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/keepalived.conf.SYNOPSIS</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.HTTP_GET.port</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.IPv6</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.SMTP_CHECK</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.SSL_GET</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.fwmark</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.inhibit</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.misc_check</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.misc_check_arg</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.quorum</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.sample</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.status_code</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.track_interface</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.virtual_server_group</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.virtualhost</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp.localcheck</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp.lvs_syncd</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp.routes</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp.rules</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp.scripts</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp.static_ipaddress</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/keepalived.conf.vrrp.sync</span><br><span class="line">/usr/share/doc/keepalived-1.3.5/samples/sample.misccheck.smbcheck.sh</span><br><span class="line">/usr/share/man/man1/genhash.1.gz</span><br><span class="line">/usr/share/man/man5/keepalived.conf.5.gz</span><br><span class="line">/usr/share/man/man8/keepalived.8.gz</span><br><span class="line">/usr/share/snmp/mibs/KEEPALIVED-MIB.txt</span><br><span class="line">/usr/share/snmp/mibs/VRRP-MIB.txt</span><br><span class="line">/usr/share/snmp/mibs/VRRPv3-MIB.txt</span><br></pre></td></tr></table></figure><p>也很简洁, 直接看看他的配置文件吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># grep &quot;^[^[:space:]]&quot; /etc/keepalived/keepalived.conf </span></span><br><span class="line">! Configuration File <span class="keyword">for</span> keepalived</span><br><span class="line">global_defs &#123;</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">&#125;</span><br><span class="line">virtual_server 192.168.200.100 443 &#123;</span><br><span class="line">&#125;</span><br><span class="line">virtual_server 10.10.10.2 1358 &#123;</span><br><span class="line">&#125;</span><br><span class="line">virtual_server 10.10.10.3 1358 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是全局配置 接着是vrrp相关配置, 接着就是和LVS相关的vs设定.</p><p>其中vrrp的配置主要分成两个部分, 一个是vrrp实例的设定, 一个是vrrp同步组的设定. 在上面的生成的文件列表中, 可以看到还有很多配置文件的示例.</p><p>现在我们先来说几个HA集群的配置的前提:</p><ul><li>本机主机名要和hostname以及uname -r保持一致, 并且各个节点需要能够互相解析主机名, 建议使用hosts文件进行解析.</li><li>各个节点的时间同步</li></ul><p>这里我们使用两台CentOS7主机, 首先我们Check一下时间:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># date; ssh 192.168.206.21 &#x27;date&#x27;</span></span><br><span class="line">Fri Oct 20 18:43:55 CST 2017</span><br><span class="line">Fri Oct 20 18:43:55 CST 2017</span><br></pre></td></tr></table></figure><p>没有问题, 是同步的. </p><p>接着检查hosts文件 ( 这一步骤对于keepalived来说没这么重要 )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># cat /etc/hosts</span></span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.206.9VM-node1</span><br><span class="line">192.168.206.21VM-node2</span><br></pre></td></tr></table></figure><p>接着我们要确保iptables和SELinux不会成为阻碍.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># getenforce </span></span><br><span class="line">Enforcing</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># setenforce 0</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># iptables -F</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># iptables -X</span></span><br></pre></td></tr></table></figure><p>双节点安装keepalived. </p><p>好了, 准备的差不多了. 开始吧~</p><p>开始编辑配置文件, 先不使用后面的virtual server, 我们来看看前面的两个部分:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># cp /etc/keepalived/keepalived.conf&#123;,.bak&#125;</span></span><br><span class="line">(In-Vim):.,<span class="variable">$s</span>/^/<span class="comment">#/g  [从virtual server那一行开始操作]</span></span><br></pre></td></tr></table></figure><p>从第一个全局配置来看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123; <span class="comment"># 如果keepalived发现VIP进行了更换把邮件发送给谁.</span></span><br><span class="line">       root@localhost</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from kaadmin@localhost <span class="comment"># 发信人</span></span><br><span class="line">   smtp_server 127.0.0.1 <span class="comment"># 邮件服务器地址</span></span><br><span class="line">   smtp_connect_timeout 30 <span class="comment"># 连接到邮件服务器的超时时长</span></span><br><span class="line">   router_id node1 <span class="comment"># id</span></span><br><span class="line">   vrrp_skip_check_adv_addr <span class="comment"># 如果指明,跳过先前接受过的同一个主路由的通告</span></span><br><span class="line">   vrrp_strict <span class="comment"># 严格模式, 阻止单播的对端, 0VIP, IPv6在VRRP V2</span></span><br><span class="line">   vrrp_garp_interval 0 <span class="comment"># 免费ARP报文发送间隔.</span></span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还有很多配置, 在man手册中可以看到. 我们就先这样, 主要是下面的设置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123; <span class="comment"># 这里需要协商实例的名字.</span></span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass </span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">    192.168.206.100/24 dev eth0 label ens33:0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于vrrp实例的配置, 我们来看看.</p><p>首先是<code>state</code>, 该选项的意思是初始状态标记. 后面的<code>interface</code>标识接口也就是VIP的绑定位置. 接着后面的<code>virtual_router_id</code> 该ID就比较重要了, 因为这个玩意首先是作为虚拟MAC的末尾那一位 ( 虚拟MAC的前几位是固定的00-00-5E-00-01-{VRID} ) 所以是需要保持一致的, 再往后的<code>priority</code>标识优先级, 越大的越高. <code>advert_int</code>通告的发送时间间隔.  后面的一个上下文环境是进行认证的, 类型有字符认证和md5认证, 这里使用的是简单的字符认证. 后面的虚拟IP也就是比较重要的了. 其实这里指定的就是我们的VIP. 默认使用的是抢占模式, 如果不想使用抢占模式, 那么可以指定<code>nopreempt</code>. </p><p>我最后修改完成的配置如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 1</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 700c8be7b5</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.206.100/24 dev eth0 label ens33:0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中, 随机字串是使用<code>openssl</code>输出的. OK, 接下来把配置文件拷贝到第二台主机上.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># scp /etc/keepalived/keepalived.conf VM-node2:/etc/keepalived/</span></span><br></pre></td></tr></table></figure><p>备用节点需要做稍微的修改:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 1</span><br><span class="line">    priority 99</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 700c8be7b5</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.206.100/24 dev ens33 label ens33:0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来, 启动服务吧!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># systemctl start keepalived ; ssh VM-node2 &#x27;systemctl start keepalived&#x27;</span></span><br></pre></td></tr></table></figure><p>查看一下进程和接口:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># ps aux | grep keepalived</span></span><br><span class="line">root       3092  0.0  0.1 120740  1408 ?        Ss   19:32   0:00 /usr/sbin/keepalived -D</span><br><span class="line">root       3093  0.0  0.2 120740  2764 ?        S    19:32   0:00 /usr/sbin/keepalived -D</span><br><span class="line">root       3094  0.0  0.2 125104  2660 ?        S    19:32   0:00 /usr/sbin/keepalived -D</span><br></pre></td></tr></table></figure><p>在node1上:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ifconfig </span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.206.9  netmask 255.255.255.0  broadcast 192.168.206.255</span><br><span class="line">        inet6 fe80::1c:8a20:479a:ddc0  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:0c:29:b0:97:f6  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 116014  bytes 20485653 (19.5 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 144513  bytes 10838375 (10.3 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">ens33:0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.206.100  netmask 255.255.255.0  broadcast 0.0.0.0</span><br><span class="line">        ether 00:0c:29:b0:97:f6  txqueuelen 1000  (Ethernet)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而在node2上, 你是看不到的. 为什么? 因为node2是从节点啊~</p><p>这个时候 我们手动关闭node1的keepalived服务, 接着立即去node2查看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># ifconfig </span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.206.21  netmask 255.255.255.0  broadcast 192.168.206.255</span><br><span class="line">        inet6 fe80::1c:8a20:479a:ddc0  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        inet6 fe80::2e92:22f5:af33:2394  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:0c:29:71:99:af  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 88514  bytes 14361599 (13.6 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 70290  bytes 5571477 (5.3 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">ens33:0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.206.100  netmask 255.255.255.0  broadcast 0.0.0.0</span><br><span class="line">        ether 00:0c:29:71:99:af  txqueuelen 1000  (Ethernet)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从passive变成了active了. 然而, 当我们重新恢复node1的服务的时候, 由于默认是抢占模式, 所以node1就重新变成active状态了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># systemctl start keepalived</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ifconfig </span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.206.9  netmask 255.255.255.0  broadcast 192.168.206.255</span><br><span class="line">        inet6 fe80::1c:8a20:479a:ddc0  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:0c:29:b0:97:f6  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 116439  bytes 20524771 (19.5 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 145291  bytes 10898289 (10.3 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">ens33:0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.206.100  netmask 255.255.255.0  broadcast 0.0.0.0</span><br><span class="line">        ether 00:0c:29:b0:97:f6  txqueuelen 1000  (Ethernet)</span><br></pre></td></tr></table></figure><p>但是有的时候, 我们希望能够进行服务的升级, 所以就需要让主服务器暂时成为从的, 升级之后, 再成为主的, 升级从服务器. 这个时候我就需要平滑的修改主从服务器的优先级, 而vrrp脚本功能就能满足我们的需求, 来看一个示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vrrp_script chk_maintenance &#123;</span><br><span class="line">    script <span class="string">&quot;[[ -f /etc/keepalived/mt ]] &amp;&amp; exit 0 || exit 1&quot;</span></span><br><span class="line">    interval 1 </span><br><span class="line">    weight -2</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">...(omitted)</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_maintenance</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>只要脚本返回值不是0, 就会执行下面的操作, 也就是将权重-2, 接着在实例中启动这个脚本.</p><blockquote><p>在这里插一句, 首先新版本似乎不支持这种方式了, 仅允许在这里指定文件系统中的脚本路径. 第二, 不知道是我的操作有问题还是这个版本的keepalived有Bug(当然我觉得还是我的问题), 当我每次重启动keepalived的时候, 首次执行就会判定脚本执行成功, 于是执行下面的语句调整, 接着就一直正常执行, 但是这个时候我们的优先级是调整过的了, 所以说, 当我们把文件创建的时候, 反而会将减少的优先级加出来 ( 也就是说脚本的功能完全发生了相反的效果??. ) 于是我就在这里debug了很长时间. 还是不知道是怎么回事. 烦死了 </p></blockquote><p>就先当做keepalived没有这个功能吧. 继续往后.</p><blockquote><p>于是不甘于失败的我又进行了尝试. 结论是: <strong>脚本失败的时候, 会执行后面的指令. 如果脚本执行成功就不会触发.</strong> 所以上面的结论没要毛病, 所以完完全全是我的错, 所以我真的好气哦, 所以上面的脚本写反了 应该是<code>&quot;[[ -f /etc/keepalived/mt ]] &amp;&amp; exit 1 || exit 0&quot;</code> ( 耽误了好多时间烦死了 )</p></blockquote><p>行吧, 这样我们只要在指定的地方touch一个mt就可以实现主从切换了. </p><p>接下来来看一下同步组的设定. 我们知道当VIP发生改变的时候, 必须把后面接口的DIP也做转交, 这两个过程是同步的, 所以就需要绑定成组. 方法很简单, 只要使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vrrp_sync_group VG_1 &#123;</span><br><span class="line">VI_1</span><br><span class="line">VI_2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就行了, 同样这个也有一些选项的. 不过就先不说了.</p><p>接着我们看一下发生状态了之后 怎么进行通知呢? 我们发现, 当刚刚做实验得时候 好像没有出现接收到邮件的情况. 这是以为, 邮件的发送是需要我们自行定义邮件内容和发送脚本的.</p><p>具体的定制选项在这里: ( 可以在vrrp实例和同步组中定义 )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">notify_master <span class="string">&quot;PATH/TO/SCRIPT master&quot;</span></span><br><span class="line">notify_backup <span class="string">&quot;PATH/TO/SCRIPT backup&quot;</span></span><br><span class="line">notify_fault <span class="string">&quot;PATH/TO/SCRIPT fault&quot;</span></span><br></pre></td></tr></table></figure><p>一个典型的脚本实例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">vip=192.168.206.100</span><br><span class="line">contact=<span class="string">&quot;root@localhost&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">notify</span></span> () &#123;</span><br><span class="line">  mailsubject=<span class="string">&quot;`hostname` to be <span class="variable">$1</span>: <span class="variable">$vip</span> floating.&quot;</span></span><br><span class="line">  mailbody=<span class="string">&quot;`date &#x27;+%F %H:%M:%S&#x27;` : vrrp transition, `hostname` changed to be <span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$mailbody</span> | mail -s <span class="string">&quot;<span class="variable">$mailsubject</span>&quot;</span> <span class="variable">$contact</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  master)</span><br><span class="line">      notify master</span><br><span class="line">      <span class="comment"># haproxy start</span></span><br><span class="line">      <span class="built_in">exit</span> 0</span><br><span class="line">  ;;</span><br><span class="line">  backup)</span><br><span class="line">      notify backup</span><br><span class="line">      <span class="comment"># haproxy stop</span></span><br><span class="line">      <span class="built_in">exit</span> 0</span><br><span class="line">  ;;</span><br><span class="line">  fault)</span><br><span class="line">      notify fault</span><br><span class="line">      <span class="comment"># haproxy stop</span></span><br><span class="line">      <span class="built_in">exit</span> 0</span><br><span class="line">  ;;</span><br><span class="line">  *)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;Usage: `basename <span class="variable">$0</span>` &#123;master|backup|fault&#125;&quot;</span></span><br><span class="line">      <span class="built_in">exit</span> 1</span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>但是到现在为止, 我们都只是在玩玩而已, 还没有发挥keepalived作为LVS的高可用功能. 所以现在就来看下关于LVS的设定吧.</p><p>在manual中, LVS的设定都用virtual server这个关键字来说明, 可以使用IP地址, 也可以使用防火墙标记.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delay timer for service polling</span></span><br><span class="line">delay_loop &lt;INT&gt; <span class="comment"># 健康状态探查的时间间隔.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LVS scheduler</span></span><br><span class="line">lb_algo rr|wrr|lc|wlc|lblc|sh|dh <span class="comment"># 负载均衡的调度算法.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable One-Packet-Scheduling for UDP (-O in ipvsadm)</span></span><br><span class="line">ops <span class="comment"># 每一个报文单独调度, 也就是对UDP的追踪</span></span><br><span class="line"><span class="comment"># LVS forwarding method</span></span><br><span class="line">lb_kind NAT|DR|TUN <span class="comment"># LVS的类型</span></span><br><span class="line"><span class="comment"># LVS persistence timeout in seconds, default 6 minutes</span></span><br><span class="line">persistence_timeout [&lt;INT&gt;] <span class="comment"># 持久的延时</span></span><br><span class="line"><span class="comment"># L4 protocol</span></span><br><span class="line">protocol TCP|UDP|SCTP <span class="comment"># 协议</span></span><br><span class="line"><span class="comment"># If VS IP address is not set,</span></span><br><span class="line"><span class="comment"># suspend healthchecker&#x27;s activity</span></span><br><span class="line">ha_suspend <span class="comment"># 如果IP没有就不做测试</span></span><br><span class="line"><span class="comment"># VirtualHost string for HTTP_GET or SSL_GET</span></span><br><span class="line"><span class="comment"># eg virtualhost www.firewall.loc</span></span><br><span class="line">virtualhost &lt;STRING&gt;</span><br><span class="line"><span class="comment"># RS to add when all realservers are down</span></span><br><span class="line">sorry_server &lt;IPADDR&gt; &lt;PORT&gt; <span class="comment"># 这里就是设定最后的错误页面提供服务器的</span></span><br><span class="line"><span class="comment"># one entry for each realserver</span></span><br><span class="line">real_server &lt;IPADDR&gt; &lt;PORT&gt; <span class="comment"># 这就是最重要的real server的设定了</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># relative weight to use, default: 1</span></span><br><span class="line">    weight &lt;INT&gt; <span class="comment"># 权重设定</span></span><br><span class="line">    <span class="comment"># Set weight to 0 when healthchecker detects failure</span></span><br><span class="line">    inhibit_on_failure</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Script to execute when healthchecker</span></span><br><span class="line">    <span class="comment"># considers service as up.</span></span><br><span class="line">    notify_up &lt;STRING&gt;|&lt;QUOTED-STRING&gt;</span><br><span class="line">    <span class="comment"># Script to execute when healthchecker</span></span><br><span class="line">    <span class="comment"># considers service as down.</span></span><br><span class="line">    notify_down &lt;STRING&gt;|&lt;QUOTED-STRING&gt; <span class="comment"># 同样也是发通知的</span></span><br><span class="line"></span><br><span class="line">    uthreshold &lt;INTEGER&gt; <span class="comment"># maximum number of connections to server</span></span><br><span class="line">    lthreshold &lt;INTEGER&gt; <span class="comment"># minimum number of connections to server # 设定最大最小连接数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pick one healthchecker</span></span><br><span class="line">    <span class="comment"># HTTP_GET|SSL_GET|TCP_CHECK|SMTP_CHECK|DNS_CHECK|MISC_CHECK # 这里就是设定健康状态检查的.</span></span><br><span class="line">    HTTP_GET|SSL_GET</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment"># An url to test</span></span><br><span class="line">      <span class="comment"># can have multiple entries here</span></span><br><span class="line">      url &#123;</span><br><span class="line">        <span class="comment">#eg path / , or path /mrtg2/</span></span><br><span class="line">        path &lt;STRING&gt; <span class="comment"># 请求的资源</span></span><br><span class="line">        <span class="comment"># healthcheck needs status_code</span></span><br><span class="line">        <span class="comment"># or status_code and digest</span></span><br><span class="line">        <span class="comment"># Digest computed with genhash</span></span><br><span class="line">        <span class="comment"># eg digest 9b3a0c85a887a256d6939da88aabd8cd</span></span><br><span class="line">        digest &lt;STRING&gt; <span class="comment"># 对返回的页面做摘要计算, 如果和这里一样就是健康的</span></span><br><span class="line">        <span class="comment"># status code returned in the HTTP header</span></span><br><span class="line">        <span class="comment"># eg status_code 200. Default is any 2xx value</span></span><br><span class="line">        status_code &lt;INT&gt; <span class="comment"># 对响应码做匹配, 什么样的认定为是健康的, 一般和摘要选择一个就行了, 但是两者都有可以的</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment"># number of get retries</span></span><br><span class="line">      nb_get_retry &lt;INT&gt;</span><br><span class="line">      <span class="comment"># delay before retry</span></span><br><span class="line">      delay_before_retry &lt;INT&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们再看看TCP的健康检查:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TCP healthchecker</span></span><br><span class="line">TCP_CHECK</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># ======== generic connection options</span></span><br><span class="line">    <span class="comment"># Optional IP address to connect to.</span></span><br><span class="line">    <span class="comment"># The default is the realserver IP</span></span><br><span class="line">    connect_ip &lt;IP ADDRESS&gt;</span><br><span class="line">    <span class="comment"># Optional port to connect to</span></span><br><span class="line">    <span class="comment"># The default is the realserver port</span></span><br><span class="line">    connect_port &lt;PORT&gt;</span><br><span class="line">    <span class="comment"># Optional interface to use to</span></span><br><span class="line">    <span class="comment"># originate the connection</span></span><br><span class="line">    bindto &lt;IP ADDRESS&gt;</span><br><span class="line">    <span class="comment"># Optional source port to</span></span><br><span class="line">    <span class="comment"># originate the connection from</span></span><br><span class="line">    bind_port &lt;PORT&gt;</span><br><span class="line">    <span class="comment"># Optional connection timeout in seconds.</span></span><br><span class="line">    <span class="comment"># The default is 5 seconds</span></span><br><span class="line">    connect_timeout &lt;INTEGER&gt;</span><br><span class="line">...(omitted)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上我们也就使用这两种了. </p><h2 id="项目-LVS-keepalived实现基础高可用"><a href="#项目-LVS-keepalived实现基础高可用" class="headerlink" title="项目: LVS + keepalived实现基础高可用"></a>项目: LVS + keepalived实现基础高可用</h2><p>我们一共开启四台虚拟机, 首先做director的有两台, 一台主节点, 一台做备份. 另外两台后端real server跑Web服务(httpd).</p><p>他们的IP分别是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VIP:  192.168.206.11</span><br><span class="line">DIP1: 192.168.206.9</span><br><span class="line">DIP2: 192.168.206.10</span><br><span class="line">RIP1: 192.168.206.22</span><br><span class="line">RIP2: 192.168.206.23</span><br></pre></td></tr></table></figure><p>哦 对了,这里我们选择使用DR集群.</p><p>先来确保需要使用的软件包存在: httpd, ipvsadm(不是必须的,仅仅是为了观察实验效果), keepalived, mailx.</p><p>接着先配置director的VIP, real server的内核参数, 添加VIP, 添加路由, 添加ipvs规则. 现在是很熟练了.</p><p>好了, 现在我们的第一个director就没问题了, 接着我们把规则清空, IP拿掉. 进入另外一个director, 进行同样的配置, 进行测试, 如果没有问题的话, 我们就可以进行配置sorry server了, 对于两个director, 安装httpd, 写入一个sorry页面, 并且启动服务.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># echo &quot;Sorry, under maintenance&quot; &gt; /var/www/html/index.html </span></span><br><span class="line">[root@VM-node2 ~]<span class="comment"># httpd</span></span><br></pre></td></tr></table></figure><p>好了, 主角上场了, 我们最后的配置是这样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File <span class="keyword">for</span> keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     root@127.0.0.1</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from kaadmin@localhost</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_maintenance &#123;</span><br><span class="line">    script /etc/keepalived/chk_maintenance</span><br><span class="line">    interval 1</span><br><span class="line">    weight -5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 1</span><br><span class="line">    priority 98</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 700c8be7b5</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.206.11/32 dev ens33 label ens33:0</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_maintenance</span><br><span class="line">    &#125;</span><br><span class="line">    notify_master <span class="string">&quot;/etc/keepalived/notify.sh master&quot;</span></span><br><span class="line">    notify_backup <span class="string">&quot;/etc/keepalived/notify.sh backup&quot;</span></span><br><span class="line">    notify_fault <span class="string">&quot;/etc/keepalived/notify.sh fault&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.206.11 80 &#123;</span><br><span class="line">    delay_loop 6</span><br><span class="line">    lb_algo wrr</span><br><span class="line">    lb_kind DR</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server 192.168.206.22 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            url &#123;</span><br><span class="line">              path /</span><br><span class="line">              status_code 200</span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    real_server 192.168.206.23 80 &#123;</span><br><span class="line">        weight 2</span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            url &#123;</span><br><span class="line">              path /</span><br><span class="line">              status_code 200</span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这份配置复制连同脚本拷贝到另一个director上, 并且稍作修改.</p><p><strong>激动人心的时候到来了! 启动服务</strong></p><p>尝试访问, 成功了! 我们的ipvs规则, 自动的被填充了.</p><p>访问效果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;web on Node4&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;web on Node4&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;web on Node4&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;web on Node4&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>好, 现在我们把其中一个real server下线:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ~]<span class="comment"># service httpd stop</span></span><br><span class="line">Stopping httpd:                                            [  OK  ]</span><br></pre></td></tr></table></figure><p>这个时候连规则都会进行重写:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  192.168.206.11:80 wrr</span><br><span class="line">  -&gt; 192.168.206.23:80            Route   2      0          3      </span><br></pre></td></tr></table></figure><p>访问自然是没有问题的. </p><p>同时维护第一台主机也是可以的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># cd /etc/keepalived/</span></span><br><span class="line">[root@VM-node1 keepalived]<span class="comment"># touch down</span></span><br><span class="line">[root@VM-node1 keepalived]<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:b0:97:f6 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.206.9/24 brd 192.168.206.255 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::1c:8a20:479a:ddc0/64 scope <span class="built_in">link</span> </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>这个是就是第二台从节点顶替上来了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;web on Node4&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;web on Node4&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>访问仍然正常. 最后我们加上sorry_server的设定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">virtual_server 192.168.206.11 80 &#123;</span><br><span class="line">...(omitted)</span><br><span class="line">    sorry_server 127.0.0.1 80</span><br><span class="line">    real_server 192.168.206.22 80 &#123;</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>两边都做一样的设定, 接着我们重启服务之后将两个real server都手动关闭服务.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">Sorry, under maintenance</span><br></pre></td></tr></table></figure><p>同时, 我们的调度规则也发生改变.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 keepalived]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  192.168.206.11:80 wrr</span><br><span class="line">  -&gt; 127.0.0.1:80                 Route   1      0          0    </span><br></pre></td></tr></table></figure><p>就是这样的一个过程. </p><blockquote><p>中途关于邮件我一直没有提到, 其实会在实验中一直受到邮件的, 当然了, 前提是你要安装邮件程序包.</p></blockquote><p>接下来把两台的服务开起来, 瞬间复活~.</p><h2 id="项目-Nginx-keepalived实现基础高可用"><a href="#项目-Nginx-keepalived实现基础高可用" class="headerlink" title="项目: Nginx + keepalived实现基础高可用"></a>项目: Nginx + keepalived实现基础高可用</h2><p>首先, 我们很清楚了, Nginx是不需要real server的, 他需要的是upstream server就行了. 所以我们要先把之前的操作, 也就是那些IP地址删除, 路由删除, 内核参数还原. </p><p>好了 环境恢复了之后, 安装必要的软件包: Nginx.</p><p>开始配置Nginx的上游服务器组和调度, 这也是很熟练了的.</p><p>尝试访问, 是正常的就可以继续了. nginx和keepalived的基础高可用是很简单的.</p><p>这里, 由于我们不需要ipvs, 所以不需要virtual server了, 可以全部注释掉:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line">    script /etc/keepalived/chk_nginx</span><br><span class="line">    interval 1</span><br><span class="line">    weight -10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 1</span><br><span class="line">    priority 98</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 700c8be7b5</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.206.11/24 dev ens33 label ens33:0</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_maintenance</span><br><span class="line">    &#125;</span><br><span class="line">    notify_master <span class="string">&quot;/etc/keepalived/notify.sh master&quot;</span></span><br><span class="line">    notify_backup <span class="string">&quot;/etc/keepalived/notify.sh backup&quot;</span></span><br><span class="line">    notify_fault <span class="string">&quot;/etc/keepalived/notify.sh fault&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的脚本也很简单, 你也可以添加更复杂的机制. 主要的原理就是想nginx发送0号信号, 如果返回值不是0, 就说明nginx存活. 这样我们连exit语句也可以省略:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 keepalived]<span class="comment"># cat chk_nginx </span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">$(killall -0 nginx)</span><br></pre></td></tr></table></figure><p>接下来启动keepalived服务吧. 访问是正常的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;web on Node4&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;web on Node4&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>然而, 当我们关闭主节点的nginx服务的时候:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 keepalived]<span class="comment"># nginx -s stop</span></span><br><span class="line">[root@VM-node1 keepalived]<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:b0:97:f6 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.206.9/24 brd 192.168.206.255 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::1c:8a20:479a:ddc0/64 scope <span class="built_in">link</span> </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">You have new mail <span class="keyword">in</span> /var/spool/mail/root</span><br></pre></td></tr></table></figure><p>继续访问:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;web on Node4&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl 192.168.206.11</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>仍然没有问题. VIP也已经转交给了次节点:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Oct 21 11:49:04 VM-node2 Keepalived_vrrp[68777]: VRRP_Script(chk_maintenance) succeeded</span><br><span class="line">Oct 21 11:50:11 VM-node2 Keepalived_vrrp[68777]: VRRP_Instance(VI_1) forcing a new MASTER election</span><br><span class="line">Oct 21 11:50:12 VM-node2 Keepalived_vrrp[68777]: VRRP_Instance(VI_1) Transition to MASTER STATE</span><br><span class="line">Oct 21 11:50:13 VM-node2 Keepalived_vrrp[68777]: VRRP_Instance(VI_1) Entering MASTER STATE</span><br><span class="line">Oct 21 11:50:13 VM-node2 Keepalived_vrrp[68777]: VRRP_Instance(VI_1) setting protocol iptable drop rule</span><br><span class="line">Oct 21 11:50:13 VM-node2 Keepalived_vrrp[68777]: VRRP_Instance(VI_1) setting protocol VIPs.</span><br></pre></td></tr></table></figure><p>但是这样其实有个问题的. 想一下, 如果我们两边的Nginx服务都死了. 于是双方的weight都下降最后还是没有区别啊, 所以, 这样的一种解决方案就是在notify脚本中添加当状态发生改变的时候自动重启Nginx服务. 但是这很强硬, 有点太粗糙了.</p><p>不过起码可用.</p><p>接下来我们玩一个好玩的, 我们继续Nginx+Keepalived的组合, 组建一个双主模型的高可用集群.</p><p>首先当然我们需要两个vrrp实例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line">    script /etc/keepalived/chk_nginx</span><br><span class="line">    interval 1</span><br><span class="line">    weight -10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 1</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 700c8be7b5</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.206.11/24 dev ens33 label ens33:0</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_nginx</span><br><span class="line">    &#125;</span><br><span class="line">    notify_master <span class="string">&quot;/etc/keepalived/notify.sh master&quot;</span></span><br><span class="line">    notify_backup <span class="string">&quot;/etc/keepalived/notify.sh backup&quot;</span></span><br><span class="line">    notify_fault <span class="string">&quot;/etc/keepalived/notify.sh fault&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 2</span><br><span class="line">    priority 98</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 700c8be7b50</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.206.12/24 dev ens33 label ens33:0</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_nginx</span><br><span class="line">    &#125;</span><br><span class="line">    notify_master <span class="string">&quot;/etc/keepalived/notify.sh master&quot;</span></span><br><span class="line">    notify_backup <span class="string">&quot;/etc/keepalived/notify.sh backup&quot;</span></span><br><span class="line">    notify_fault <span class="string">&quot;/etc/keepalived/notify.sh fault&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个做主, 一个做备. 另外一个节点也是如此, 只不过主备颠倒. 这样就可以实现一个双主的模型.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Cluster </tag>
            
            <tag> keepalived </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HAProxy的配置和应用</title>
      <link href="/2017/10/19/HAProxy%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%BA%94%E7%94%A8/"/>
      <url>/2017/10/19/HAProxy%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>说完了Nginx, 接下来就来看看另外一个性能优越的load balancer – HAProxy吧.</p><span id="more"></span><h2 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h2><p>首先要说一下啊, 这个玩意虽然叫做HA, 但是他不是任何高可用服务器, 归结到底 HAProxy只是一个代理服务器罢了. 同时, 也是http层的一个负载均衡调度器. 既然这样, HAProxy为什么要叫做HA呢? 原因很简单, HAProxy能够在http层实现健康状态检测, 从而认为这也是能够提供高可用的一个能力, 从而将自己命名为HAProxy ( 我猜的hhh )</p><p>说到代理, 我们说过有正向和反向两种. 由于之前解释过了, 所以这里就不再展开了. 来着重介绍今天的主角-HAProxy. 这个玩意<strong>是个非常纯正的http反向代理服务器, 不能进行缓存. 但是也额外支持对TCP通信的负载均衡.</strong></p><p>继续说说HAProxy的特性, 由于Haproxy是基于事件驱动和单一进程模式的, 所以省去了进程间切换, 使得支持的并发连接数非常大 ( 但是用户也可以调整成为多进程的 ). 不过, Haproxy对于应用层的内容处理和动态资源和静态资源分离是做不到了. </p><p>但是由于是单一进程, 所以所有的连接会话都由一个进程维护, 如果会话非常多, 那么存储的数据结构就是一个很重要的考虑部分. 不同的数据结构会很大程度上影响到检索存储在内存中的会话节点, 而且还会有增加, 删除, 修改的操作. HAProxy选择的数据结构是<strong>弹性二叉树</strong>. 由HAProxy作者自己研发的数据结构.</p><p>还是直接装上看看吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># rpm -ql haproxy</span></span><br><span class="line">/etc/haproxy</span><br><span class="line">/etc/haproxy/haproxy.cfg</span><br><span class="line">/etc/logrotate.d/haproxy</span><br><span class="line">/etc/sysconfig/haproxy</span><br><span class="line">/usr/bin/halog</span><br><span class="line">/usr/bin/iprange</span><br><span class="line">/usr/lib/systemd/system/haproxy.service</span><br><span class="line">/usr/sbin/haproxy</span><br><span class="line">/usr/sbin/haproxy-systemd-wrapper</span><br><span class="line">...(omitted)</span><br><span class="line">/usr/share/haproxy</span><br><span class="line">/usr/share/haproxy/400.http</span><br><span class="line">/usr/share/haproxy/403.http</span><br><span class="line">/usr/share/haproxy/408.http</span><br><span class="line">/usr/share/haproxy/500.http</span><br><span class="line">/usr/share/haproxy/502.http</span><br><span class="line">/usr/share/haproxy/503.http</span><br><span class="line">/usr/share/haproxy/504.http</span><br><span class="line">/usr/share/haproxy/README</span><br><span class="line">/usr/share/man/man1/halog.1.gz</span><br><span class="line">/usr/share/man/man1/haproxy.1.gz</span><br><span class="line">/var/lib/haproxy</span><br></pre></td></tr></table></figure><p>从生成的文件也可以看出, haproxy是一个十分轻量化的程序, 除了配置文件和主程序其他就没有什么了.</p><p>先来从配置文件入手, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 haproxy]<span class="comment"># grep &quot;^[^#][^[:space:]].*$&quot; haproxy.cfg</span></span><br><span class="line">global</span><br><span class="line">defaults</span><br><span class="line">frontend  main *:5000</span><br><span class="line">backend static</span><br><span class="line">backend app</span><br></pre></td></tr></table></figure><p>这就是配置文件的组成部分.</p><p>其实很好理解层次结构, 例如前端(也就是自己了), 后端静态服务器组, 后端动态服务器组啥啥的.</p><p>我们在Nginx中 是用了什么proxy_pass配合upstream来进行的调度, 而haproxy更好理解了, 直接使用frontend, backend来定义. 通过在前端中定义使用那些后端服务器组来建立联系, 另外这种联系还支持条件式建立, 还可以配置默认连接. default就是为frontend和backend设置的各个选项了. 总之, 熟悉了Nginx的我们, 现在肯定能炒鸡快速的上手Haproxy的.</p><p>现在就直接来试试吧, 还是想之前那样, 我们开启两台Web服务器.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">frontend  main *:80</span><br><span class="line">    default_backend             webservers</span><br><span class="line"></span><br><span class="line">backend webservers</span><br><span class="line">    balance     roundrobin</span><br><span class="line">    server      static 192.168.206.21:80 check</span><br><span class="line">    server      static 192.168.206.22:80 check</span><br></pre></td></tr></table></figure><p>这就是最简单的一个配置了, 我们启动haproxy服务, 访问试试.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://192.168.206.9/</span><br><span class="line">&lt;h1&gt;This is node2(NEW)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://192.168.206.9/</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://192.168.206.9/</span><br><span class="line">&lt;h1&gt;This is node2(NEW)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://192.168.206.9/</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>由于我们使用了roundrobin算法, 所以是轮询访问. </p><h2 id="HAProxy的配置"><a href="#HAProxy的配置" class="headerlink" title="HAProxy的配置"></a>HAProxy的配置</h2><p>现在就来好好看看HAProxy的配置项吧, 首先第一行就是日志记录的配置. HAProxy和其他的不太一样, 他只能基于网络进行日志记录 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line"><span class="built_in">log</span>         127.0.0.1 local2</span><br></pre></td></tr></table></figure><p>所以, 为了使得日志能够记录下去. 我们还要配置一下rsyslog才行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Provides UDP syslog reception</span></span><br><span class="line"><span class="variable">$ModLoad</span> imudp</span><br><span class="line"><span class="variable">$UDPServerRun</span> 514</span><br><span class="line">...(omitted)</span><br><span class="line">local2.*                                                /var/log/haproxy.log</span><br></pre></td></tr></table></figure><p>首先开启监听, 接着要把我们的haproxy配置日志路径.</p><p>接着重启服务, 访问一下. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 haproxy]<span class="comment"># tail /var/log/haproxy.log </span></span><br><span class="line">Oct 19 23:09:12 localhost haproxy[2764]: Proxy main started.</span><br><span class="line">Oct 19 23:09:12 localhost haproxy[2764]: Proxy webservers started.</span><br><span class="line">Oct 19 23:09:25 localhost haproxy[2765]: 192.168.206.1:5842 [19/Oct/2017:23:09:25.979] main webservers/static 0/0/2/5/7 200 319 - - ---- 1/1/0/1/0 0/0 <span class="string">&quot;GET / HTTP/1.1&quot;</span></span><br><span class="line">Oct 19 23:09:26 localhost haproxy[2765]: 192.168.206.1:5843 [19/Oct/2017:23:09:26.645] main webservers/static 0/0/1/2/3 200 298 - - ---- 1/1/0/0/0 0/0 <span class="string">&quot;GET / HTTP/1.1&quot;</span></span><br><span class="line">Oct 19 23:09:27 localhost haproxy[2765]: 192.168.206.1:5844 [19/Oct/2017:23:09:27.228] main webservers/static 0/0/1/2/3 200 319 - - ---- 1/1/0/0/0 0/0 <span class="string">&quot;GET / HTTP/1.1&quot;</span></span><br><span class="line">Oct 19 23:09:27 localhost haproxy[2765]: 192.168.206.1:5845 [19/Oct/2017:23:09:27.809] main webservers/static 0/0/1/3/4 200 298 - - ---- 1/1/0/0/0 0/0 <span class="string">&quot;GET / HTTP/1.1&quot;</span></span><br></pre></td></tr></table></figure><p>这样就有日志了.</p><p>接着往后看一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    <span class="built_in">log</span>         127.0.0.1 local2 <span class="comment"># 日志</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">chroot</span>      /var/lib/haproxy <span class="comment"># 根切换, 这样更加安全</span></span><br><span class="line">    pidfile     /var/run/haproxy.pid <span class="comment"># pid文件</span></span><br><span class="line">    maxconn     4000 <span class="comment"># 最大连接数</span></span><br><span class="line">    user        haproxy <span class="comment"># 运行用户</span></span><br><span class="line">    group       haproxy <span class="comment"># 运行组</span></span><br><span class="line">    daemon <span class="comment"># 标记为后台守护进程</span></span><br><span class="line"></span><br><span class="line">    stats socket /var/lib/haproxy/stats <span class="comment"># 访问本地的时候基于共享内存进行socket通信</span></span><br></pre></td></tr></table></figure><p>但是, 可以使用的参数还有很多.  比如<code>quiet</code>, <code>debug</code>, 还可以调整连接参数, 运行参数等等. 但是很多参数都不建议修改, 可能会用到的参数很少, 例如: 上面列出来的这些, 还有<code>spread-check</code>: 这个是用来修改健康状态检查的延时的 ( 因为大量同时的检查可能会拥塞网络, 这个选项可以进行随机的后退. )</p><h3 id="balance"><a href="#balance" class="headerlink" title="balance"></a>balance</h3><p>首先来看balance关键字. 这个是用来指定调度算法的, HAProxy支持的调度算法也很多, 并且也分成动态和静态两类. HAProxy理解的动态静态是根据是否可进行权重的改变. 能够则被认为是动态的.</p><ul><li><code>roundrobin</code>:  轮询, 动态算法, 会追踪后端主机的连接, 所以每个主机最大支持4192条连接. </li><li><code>static-rr</code>:  静态的轮询算法. </li><li><code>least-conn</code>:  最小连接, 适合长连接场景. </li><li><code>source</code>:  源地址哈希, 默认是静态算法. 但是可以根据哈希算法来改变 <ul><li><code>map-based</code> 除模取余</li><li><code>consistent</code>: 一致性哈希</li></ul></li><li><code>url</code>:  这是一个对HAProxy而言, 很有竞争力的算法. 这个算法就是将请求的URL的前半段或者全部进行Hash运算, 接着和服务器的总权重进行运算最终得到rs. 这样的一个应用就是缓存服务器. 不管来源是什么, 只要你请求那个缓存的内容, 我就把你调度到缓存服务器那里去. 这个算法也一样可以进行两种hash_type.</li></ul><blockquote><p>这里我做了个测试, 我们在后端的两个主机都新建了10个页面, 接着访问几个, 会发现一旦第一次被定向到了哪一个主机, 就会被绑定到那一台. 这个时候我们关闭Web2的httpd服务, 于是再次访问, 一开始堵塞了一会, 接着就访问到了Web1的页面, 另外其他原本是Web2的页面也立即就被转向到了Web1的页面. 然而, 当服务恢复了之后, 立即被定向到了原本的页面, 恢复绑定了.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node3 ~]<span class="comment"># for n in [1..10]; do echo &quot;&lt;h1&gt;Page $n on Web2&lt;/h1&gt;&quot; &gt; /var/www/html/test$n.html ; done</span></span><br></pre></td></tr></table></figure><ul><li><code>url_param</code>:  也是一个从URL中计算哈希的方法, 通过取得URL中被赋值的键的值进行运算接着除以总权重得到的结果. 同样也是支持两种哈希类型. </li><li><code>hdr(&lt;name&gt;)</code>:  可以根据请求报文中的指定首部进行调度, 强大吧. 比如host, referer, user-agent等等.</li></ul><blockquote><p>做个实验吧, 配置成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backend webservers</span><br><span class="line">    balance     hdr(User-Agent)</span><br><span class="line">    hash-type   consistent</span><br><span class="line">    server      static 192.168.206.21:80 check</span><br><span class="line">    server      static 192.168.206.22:80 check</span><br></pre></td></tr></table></figure><p>接着访问:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 haproxy]<span class="comment"># curl http://192.168.206.9</span></span><br><span class="line">&lt;h1&gt;This is node2(NEW)&lt;/h1&gt;</span><br><span class="line">[root@VM-node1 haproxy]<span class="comment"># curl http://192.168.206.9 -A &quot;Hello&quot;</span></span><br><span class="line">&lt;h1&gt;This is node2(NEW)&lt;/h1&gt;</span><br><span class="line">[root@VM-node1 haproxy]<span class="comment"># curl http://192.168.206.9 -A &quot;Hello Hi&quot;</span></span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line">[root@VM-node1 haproxy]<span class="comment"># curl http://192.168.206.9 -A &quot;Hello Hi1&quot;</span></span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line">[root@VM-node1 haproxy]<span class="comment"># curl http://192.168.206.9 -A &quot;Hello Hi~~&quot;</span></span><br><span class="line">&lt;h1&gt;This is node2(NEW)&lt;/h1&gt;</span><br><span class="line">[root@VM-node1 haproxy]<span class="comment"># curl http://192.168.206.9 -A &quot;Hello hhh&quot;</span></span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind就是监听的套接字位置, 其实和我们在frontend后面加上的那个玩意是一个东西, bind可以出现多次.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frontend  main </span><br><span class="line">    <span class="built_in">bind</span> *:80</span><br><span class="line">    <span class="built_in">bind</span> 192.168.206.9:8080</span><br><span class="line">    default_backend             webservers</span><br></pre></td></tr></table></figure><h3 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h3><p>指明haproxy运行的模式, 一共支持三种: { http | tcp | health }</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defaults</span><br><span class="line">    mode                    http</span><br><span class="line">    ...(omitted)</span><br></pre></td></tr></table></figure><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p>定义日志, 单个实例最多定义两个. 而且如果在global中定义了两个, 后面的都会被忽略.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span> &lt;address&gt;&lt;facility&gt;[&lt;level&gt;[&lt;minlevel&gt;]]</span><br></pre></td></tr></table></figure><p>也可以在后面导向global的定义:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span> global</span><br></pre></td></tr></table></figure><h3 id="maxconn"><a href="#maxconn" class="headerlink" title="maxconn"></a>maxconn</h3><p>设定前端的最大连接数, 如果在global中写, 那就说明整个HAProxy的前端最大并发, 如果在单个实例中写, 最终就会加起来算作整个服务器的前端最大并发. <strong>每个连接大致是17Kb的大小</strong></p><h3 id="default-backend"><a href="#default-backend" class="headerlink" title="default_backend"></a>default_backend</h3><p>默认的后端服务器. 一个使用案例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use_backend dynamic <span class="keyword">if</span> url_dyn</span><br><span class="line">use_backend static <span class="keyword">if</span> url_img url_css</span><br><span class="line">default_backend dynamic</span><br></pre></td></tr></table></figure><p>这里的use_backend是另外一个指令, 和后面的连用. 只要匹配到请求的URL符合后面定义的ACL中, 就会使用那个后端服务器组. 如果都没有匹配的到, 就会使用最后的那个后端服务器组.</p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>这个server参数非常重要, 支持超多的选项, 格式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server &lt;name&gt; &lt;address&gt;[:port] [param*...]</span><br></pre></td></tr></table></figure><p>前面都很好理解, 主要是后面的参数, 我们提取几个重要的来看一下:</p><p><code>backup</code>：设定为备用服务器，仅在负载均衡场景中的其它server均不可用于启用此server；<br><code>check</code>：启动对此server执行健康状态检查，其可以借助于额外的其它参数完成更精细的设定，如：</p><ul><li><code>inter &lt;delay&gt;</code>：设定健康状态检查的时间间隔，单位为毫秒，默认为2000；也可以使用fastinter和downinter来根据服务器端状态优化此时间延迟；</li><li><code>rise &lt;count&gt;</code>：设定健康状态检查中，某离线的server从离线状态转换至正常状态需要成功检查的次数；</li><li><code>fall &lt;count&gt;</code>：确认server从正常状态转换为不可用状态需要检查的次数；</li></ul><p><code>cookie &lt;value&gt;</code>：为指定server设定cookie值，此处指定的值将在请求入站时被检查，第一次为此值挑选的server将在后续的请求中被选中，其目的在于实现持久连接的功能；<br><code>maxconn &lt;maxconn&gt;</code>：指定此服务器接受的最大并发连接数；如果发往此服务器的连接数目高于此处指定的值，其将被放置于请求队列，以等待其它连接被释放；<br><code>maxqueue &lt;maxqueue&gt;</code>：设定请求队列的最大长度；<br><code>observe &lt;mode&gt;</code>：通过观察服务器的通信状况来判定其健康状态，默认为禁用，其支持的类型有“layer4”和“layer7”，“layer7”仅能用于http代理场景；<br><code>redir &lt;prefix&gt;</code>：启用重定向功能，将发往此服务器的GET和HEAD请求均以302状态码响应；需要注意的是，在prefix后面不能使用&#x2F;，且不能使用相对地址，以免造成循环；例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server srv1 172.16.100.6:80 redir http://imageserver.justin.com check</span><br></pre></td></tr></table></figure><p><code>weight &lt;weight&gt;</code>：权重，默认为1，最大值为256，0表示不参与负载均衡； </p><p>另外 在进行健康检查的时候, 我们还可以更加细致的定义:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">backend https_relay</span><br><span class="line">mode tcp</span><br><span class="line">option httpchk OPITONS * HTTP/1.1\r\nHost:\ www.yaoxuannn.com</span><br><span class="line">server httpd1 192.168.1.1:443 check port 80 inter 1000</span><br></pre></td></tr></table></figure><h3 id="option"><a href="#option" class="headerlink" title="option"></a>option</h3><p><code>httplog</code>, 如果使用的模式是httpd, 就可以开启这个选项. 该选项会将日志的记录格式变得十分详细. </p><p><code>logasap</code>,  用于如果传输的数据较大, 日志记录会有延时, 这个选项可以提前记录日志, </p><p><code>forwardfor [except &lt;network&gt;][header &lt;name&gt;][if-none]</code>,  在首部中添加<code>X-Forwarded-For</code></p><p><code>http-server-close</code> 可以允许服务器端(HAProxy)主动关闭连接, 会在头部加入Connection: close的标识, 有些服务器见到这个标识 会返回一个不可用的数据. 这里是指HAProxy -&gt; 后端服务器.</p><p><code>http-pretend-keepalive</code> 字面意思了, 在头部加入Connection: Keep-Alive的标识. 经常和上面的选项连用.</p><p><code>redisatch</code> 如果一台服务器宕机, 会进行重新分发</p><p>接下来我们说说访问控制:</p><h3 id="http-request"><a href="#http-request" class="headerlink" title="http-request"></a>http-request</h3><p>格式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-request &#123; allow | deny | auth [realm &lt;realm&gt;]&#125; [ &#123;<span class="keyword">if</span> | unless&#125; &lt;condition&gt; ]</span><br></pre></td></tr></table></figure><p>不过这里的定义会用到acl指令, 上面也略微提过, 其实很好理解的: [ src就是说源地址嘛 ]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">acl nagios src 192.168.129.3</span><br><span class="line">acl local_net src 192.168.0.0/16</span><br><span class="line">acl auth_ok http_auth(L1)</span><br><span class="line">http-request allow <span class="keyword">if</span> nagios</span><br><span class="line">http-request allow <span class="keyword">if</span> local_net auth_ok</span><br><span class="line">http-request deny</span><br></pre></td></tr></table></figure><h3 id="redirect-amp-acl"><a href="#redirect-amp-acl" class="headerlink" title="redirect &amp; acl"></a>redirect &amp; acl</h3><p>除了指明来源, acl还可以这么写:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">acl login dst_port 8080</span><br><span class="line">acl secure dst_port 80</span><br><span class="line">acl login_page url_beg /login</span><br><span class="line">acl <span class="built_in">logout</span> url_beg /logout</span><br><span class="line">acl uid_given url_reg /login?uid=[^&amp;]+</span><br><span class="line">acl cookie_set hdr_sub(cookie) SEEN=1</span><br></pre></td></tr></table></figure><p>最后一个的意思是说, 取头部的cookie字串.</p><p>结合这些我们就可以做到灵活的重定向请求:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redirect prefix https://yaoxuannn.com set-cookie SEEN=1 <span class="keyword">if</span> !cookie_set</span><br><span class="line">redirect prefix https://yaoxuannn.com <span class="keyword">if</span> login_page !secure</span><br><span class="line">redirect location / clear-cookie USERID= <span class="keyword">if</span> <span class="built_in">logout</span></span><br></pre></td></tr></table></figure><p>不止这些, acl还可以更加强大. 我们可以使用下面的acl进行会话速率的检测:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acl begin_scanned be_sess_rate gt 50</span><br><span class="line">redirect locaiton /error_pages/denied.html <span class="keyword">if</span> begin_scanned</span><br></pre></td></tr></table></figure><p><code>be_sess_rate</code>就是说每秒创建的会话数.</p><p>还可以使用<code>method</code>匹配方法, 还可以仅匹配</p><h3 id="reqadd-rspadd"><a href="#reqadd-rspadd" class="headerlink" title="reqadd rspadd"></a>reqadd rspadd</h3><p>这两个选项可以在头部添加内容, 同样支持if条件判断.</p><p>另外, 还有很多超时选项:</p><h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p> http-request</p><p>connect</p><p>http-keep-alive</p><p>…(omitted)</p><h2 id="基于Cookie实现单客户端绑定"><a href="#基于Cookie实现单客户端绑定" class="headerlink" title="基于Cookie实现单客户端绑定"></a>基于Cookie实现单客户端绑定</h2><p>现在我们来使用cookie+HAProxy实现一下单客户端绑定. </p><p>首先我们做如下配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backend webservers</span><br><span class="line">    balance     roundrobin</span><br><span class="line">    cookie SERVERID insert</span><br><span class="line">    server      static1 192.168.206.21:80 check cookie web1</span><br><span class="line">    server      static2 192.168.206.22:80 check cookie web2</span><br></pre></td></tr></table></figure><p>然后我们重启服务, 第一次访问:</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/cookiereq.png" alt="cookiereq"></p><p>可以看到服务器返回了一个设置Cookie的字段, 接着第二次访问:</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/cookieres.png" alt="cookieres"></p><p>这个时候, 我们无论访问什么URL都会被带到这个服务器上, 因为我们是带着Cookie访问的.</p><p>很简单吧.</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/HAProxy_mind.png" alt="HAProxy_mind.png"></p><p>AProxy_mind.png)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> HAProxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx反向代理和缓存及其他应用</title>
      <link href="/2017/10/18/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8A%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8/"/>
      <url>/2017/10/18/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8A%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>让我们继续聊聊架构和Nginx吧.</p><span id="more"></span><h2 id="Web站点架构"><a href="#Web站点架构" class="headerlink" title="Web站点架构"></a>Web站点架构</h2><p>首先还是来从大的方面来说说. 我们之前其实是说过的, LVS是工作在传输层的, 所以对应用层的协议报文是没有什么处理能力, 而Nginx是工作在应用层的, 所以和LVS相比拥有更加高层的能力. 而且不仅如此, 我们的LVS仅仅是一个调度器, 最终和客户端进行通信的主机还是我们的后端主机, 也就是那些real server. 但是Nginx是不一样的, 之前也提到过, Nginx会自己做请求, 将资源抓取到自己的本地, 接着在组装响应报文发送给客户端.  这个就是我们说的<strong>反向代理</strong>. 对于Nginx而言, 后端的那些服务器都被称为upstream server, 也就是<strong>上游服务器</strong>.  </p><p>而且不仅如此, 我们说过存在动态和静态的资源, 这样Nginx还可以将我们对于静态的动态的资源分开, <strong>分别</strong>进行调度. 对于静态内容的服务器集群, 我们还可以省去考虑session保持的问题. 仅仅使用最简单的轮询算法都是OK的.</p><p>另外, 我们之前还说过, 现代互联网系统是相当依赖于缓存的. 而Nginx也是拥有缓存功能的, 因为将资源赚取过来之后, 在一点时间内只要还有请求, 且请求同一资源, 那么就可以不需要进行后端的请求, 而可以直接进行响应. 这对于硬盘而言是个很大的减负了, 有的时候还可以使得响应数量翻倍. 但是同样对于这么一个缓存节点而言, 一旦他挂了, 那么整个系统也就相继崩掉了. 这个就是<strong>雪崩效应</strong> </p><p>但是这个缓存的存储要比后端更快速, 因为存储的方式是经过hash计算的, 然后以K-V方式存储的. 而从upstream server取数据的时候, 由于资源存储在文件系统上, 会进行树的检索, 显然没有K-V方式的快.</p><p>显然, 这个前端的Nginx负载均衡节点是个高压力的节点.  所以一般都会对这么一个节点做高可用. 而且,我们还可以结合DNS进行内容分发来减少压力. 如果还是不行, 那么就可以考虑在前端再加上一个LVS来抗压力, 当然这么一个LVS还是要做冗余备份. 这么算来节点的数量已经非常多了. 所以在系统变的越来越大的时候, 就要先考虑如何将我们的功能该进行拆分, 要不然系统的一个节点会导致全局不可用. 所以可以根据不同的功能来进行拆分.</p><p>而且, 考虑一个电商网站. 他需要存储大量的图片资源(几十万+), 这些图片我们还需要进行<strong>分布式的存储</strong>. 而结构化的数据, 我们需要存储到数据库中, 这个时候我们还要做<strong>主从复制, 读写分离</strong>等.这些都是后话了.</p><h2 id="Nginx的代理功能"><a href="#Nginx的代理功能" class="headerlink" title="Nginx的代理功能"></a>Nginx的代理功能</h2><p>Nginx的代理功能依靠一个模块:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_proxy_module</span><br></pre></td></tr></table></figure><p>我们之前说定义location里面加上了<code>root</code>来指定从本地的文件系统取得哪些资源, 但是如果不是从本地取资源的话, 也可以转交给后端的server来应付, 这个指令就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  proxy_pass http://192.168.206.100:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了可以直接这样转发出去 ,我们还可以自行来改变HTTP报文的头部信息. 我们提到过nginx是自行再次封装报文进行的反向代理. 比如, 我们后台响应的服务器是需要进行日志记录的, 但是来源IP显然是我们的负载均衡衡器nginx. 显然是没有意义的, 这个时候, 第一种方法就是让Nginx去记录日志, 另一种就是添加自定义的头部, 从而使后端服务器了解到真是的客户端IP是多少.</p><p>官网的doc给了一个例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass       http://localhost:8000;</span><br><span class="line">    proxy_set_header Host      <span class="variable">$host</span>;</span><br><span class="line">    proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个选项有时也是一个很重要的头部信息, 因为说不定我们的后端会开多个虚拟主机呢. 如果使用IP, 就访问不到了. 现在我们就简单的试一下:</p><p>后端主机开启httpd:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 html]<span class="comment"># ls</span></span><br><span class="line">forum  index.html</span><br><span class="line">[root@VM-node2 html]<span class="comment"># ls forum/</span></span><br><span class="line">index.html</span><br><span class="line">[root@VM-node2 html]<span class="comment"># systemctl start httpd</span></span><br></pre></td></tr></table></figure><p>在前端Nginx主机配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    rewrite ^/bbs/(.*)$ /forum/<span class="variable">$1</span> <span class="built_in">break</span>;</span><br><span class="line">    proxy_pass http://192.168.206.21;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在代理至上游服务器的时候也进行了URL重写的话, 发送给后面的请求就是已经重写之后的. 我们来验证一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://192.168.206.9</span><br><span class="line">&lt;h1&gt;It works! (From node2)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://192.168.206.9/bbs/</span><br><span class="line">&lt;h1&gt;Forum&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://192.168.206.9/forum/</span><br><span class="line">&lt;h1&gt;Forum&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>这个是直接写location的URL, 但是如果改成模式匹配就不能这么写了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.txt$ &#123;</span><br><span class="line">    proxy_pass http://192.168.206.21/forum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果在验证的时候:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: [emerg] <span class="string">&quot;proxy_pass&quot;</span> cannot have URI part <span class="keyword">in</span> location given by regular expression, or inside named location, or inside <span class="string">&quot;if&quot;</span> statement, or inside <span class="string">&quot;limit_except&quot;</span> block <span class="keyword">in</span> /etc/nginx/nginx.conf:58</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> failed</span><br></pre></td></tr></table></figure><p>这个时候, 仅仅只能写upstream server的地址了. </p><p>现在查看一下日志, 所有的来源IP都是我们的前端代理主机, 这样是没有什么信息的, 所有我们使用内嵌的变量来加上自定义的HTTP头部:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.txt$ &#123;</span><br><span class="line">    proxy_pass http://192.168.206.21;</span><br><span class="line">    proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候记录还是没有变化的, 因为我们还需要修改一下httpd的日志记录:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogFormat <span class="string">&quot;%&#123;X-Real-IP&#125;i %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot;&quot;</span> combined</span><br></pre></td></tr></table></figure><p>这个时候访问:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.206.9 - - [19/Oct/2017:03:06:46 +0800] <span class="string">&quot;GET /test.txt HTTP/1.0&quot;</span> 304 - <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36&quot;</span></span><br><span class="line">192.168.206.1 - - [19/Oct/2017:03:08:01 +0800] <span class="string">&quot;GET /test.txt HTTP/1.0&quot;</span> 304 - <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36&quot;</span></span><br></pre></td></tr></table></figure><p>就改变了.</p><p>如果我们的后端服务器迟迟不给回应, 怎么办? 我们由一个超时时长超过了就不再等待了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_connect_timeout time;</span><br></pre></td></tr></table></figure><p>默认的值是60s.</p><p>另外, 我们还可以隐藏头部:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_hide_header field;</span><br></pre></td></tr></table></figure><p>而且, 我们还可以对于返回响应的头部报文, 还可以自定义添加头部:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    rewrite ^/bbs/(.*)$ /forum/<span class="variable">$1</span> <span class="built_in">break</span>;</span><br><span class="line">    proxy_pass http://http;</span><br><span class="line">    add_header X-Via <span class="string">&quot;Justin13&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样受到的报文就会带上我们的自定义头:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://192.168.206.9/ -I</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.12.1</span><br><span class="line">Date: Wed, 18 Oct 2017 15:24:52 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Content-Length: 32</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Last-Modified: Mon, 16 Oct 2017 11:20:12 GMT</span><br><span class="line">ETag: <span class="string">&quot;7f47-20-55ba830a82afc&quot;</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">X-Via: Justin13</span><br></pre></td></tr></table></figure><p>很简单吧, 这其实就是nginx对于代理转发的基本指令和注意点了.</p><h2 id="Nginx的代理缓存"><a href="#Nginx的代理缓存" class="headerlink" title="Nginx的代理缓存"></a>Nginx的代理缓存</h2><p>之前说过的Nginx除了能够把资源从后端请求过来, 还可以进行本地的缓存, 从而加速下一次的访问, 关于代理缓存的设定现在就来看一下吧.</p><p>先来看看几个重要的选项,</p><p><strong>proxy_cache <code>zone | off</code>;</strong> </p><p>这个选项就是用来定义是否开启缓存的, 这里的zone就是在后面要定义的路径中必须携带的参数, 其实就是一段命名空间用来存放你的缓存的.</p><p><strong>proxy_cache_methods <code>GET | HEAD | POST ...</code>;</strong> </p><p>指明什么样的请求方法才会进行缓存, 默认是GET和HEAD.</p><p><strong>proxy_cache_min_uses <code>number</code>;</strong> </p><p>意思就是说当资源比请求多少次之后才会进行缓存, 默认就是一次.</p><p><strong>proxy_cache_path <code>path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time]</code>;</strong> </p><p>这应该是最重要的选项了(?) 指明缓存存储的路径, 挨? 不是说是键值对存储吗? 其实缓存最终还是存储在磁盘上的啊, 但是他的目录层级非常少, 所以寻找起来不会这么费时, 这个层级一般都是2层, 当然1层和3层的也有, 就在选项中的levels中定义. 一个示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;</span><br></pre></td></tr></table></figure><p>这样的话, 存储的结果就像这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/nginx/cache/c/29/b7f54b2df7773722d382f4809d65029c</span><br></pre></td></tr></table></figure><p>来看一下, 里面的levels写法, 每一个冒号就是开启一个新目录层级的意思, 数字就是该目录的长度. 其实就是想之前我们说过的哈希桶那样了. 最后的那个文件其实就是URL的MD5摘要.</p><p><strong>这个选项只能使用在server中.</strong></p><p><strong>proxy_cache_purge <code>string ...</code>;</strong></p><p>该选项是为了<strong>手动清理缓存</strong>存在的, 因为nginx在缓存尚未失效前都不会删除Cache. 除非是缓存过期或者说到达最大值, 这个时候Cache Manager会进行LRU清理. 这个时候如果后端更新了资源, 但是用户访问的时候得到的还是旧的资源. 所以我们可以使用该选项定义一个修剪方法, 该方法请求的资源都会被从缓存中删除.</p><p>一个示例是这样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path /data/nginx/cache keys_zone=cache_zone:10m;</span><br><span class="line"></span><br><span class="line">map <span class="variable">$request_method</span> <span class="variable">$purge_method</span> &#123;</span><br><span class="line">    PURGE   1;</span><br><span class="line">    default 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">        proxy_cache cache_zone;</span><br><span class="line">        proxy_cache_key <span class="variable">$uri</span>;</span><br><span class="line">        proxy_cache_purge <span class="variable">$purge_method</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>proxy_cache_revalidate <code>on | off</code>;</strong></p><p>该选项挺有用的. 在缓存有效期到期的时候, Manager没有删除掉缓存. 如果用户请求该资源, 明知道有效期到期, Nginx用不用呢? 要知道, 这些资源不一定是真的<strong>过期了</strong>, 因为有可能后端没有更新. 这个时候就会需要这个选项了, 如果开启, Nginx就会去询问后端, 资源是否更新过? 这样就可以达到节省后端的带宽的目的. 如果请求中携带了: “If-Modified-Since” 和“If-None-Match” 这样的, 也会进行验证.</p><p><strong>proxy_cache_use_stale <code>error | timeout | invalid_header | updating | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | off ...</code>;</strong></p><p>这个选项就是在缓存已经过期, 但是这个时候后端的上游服务器出毛病了, 这个时候用不用呢 ? 怎么返回给客户端呢?</p><p><strong>proxy_cache_valid <code>[code ...] time</code>;</strong></p><p>缓存的时间由后端的服务器决定, 但是我们也可以不遵从他的指示, 你说你的图片缓存10分钟, 可以哪有这么快就会改变啊, 所以我偏偏缓存10天. 这个时候就可以使用该选项了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_valid 200 302 10m;</span><br><span class="line">proxy_cache_valid 404      1m;</span><br></pre></td></tr></table></figure><p>如果后端返回了200或者302, 我就保存10min 如果是404, 我就缓存1min.</p><p>选项就这么多, 接下来我们就实际跑一个试试就知道了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_cache mycache;</span><br><span class="line">    proxy_cache_valid 200 30m;</span><br><span class="line">    proxy_cache_valid 301 302 10m;</span><br><span class="line">    proxy_cache_valid any 1m;</span><br><span class="line">    proxy_cache_use_stale error <span class="built_in">timeout</span> http_500 http_502 http_503 http_504;</span><br><span class="line">    rewrite ^/bbs/(.*)$ /forum/<span class="variable">$1</span> <span class="built_in">break</span>;</span><br><span class="line">    proxy_pass http://192.168.206.21;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在http中定义:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path /cache/nginx levels=1:1 keys_zone=mycache:36m;</span><br></pre></td></tr></table></figure><p>我们创建目录, 并且改变属组. 因为这个目录的缓存写入是Worker进程定义的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># mkdir -pv /cache/nginx</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory ‘/cache’</span><br><span class="line"><span class="built_in">mkdir</span>: created directory ‘/cache/nginx’</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># chown -R nginx:nginx /cache/</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># nginx -s reload</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># cd /cache/nginx/</span></span><br><span class="line">[root@VM-node1 nginx]<span class="comment"># ls</span></span><br><span class="line">[root@VM-node1 nginx]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>显然这个目录是空的.</p><p>接着我们随便的访问一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 nginx]<span class="comment"># ls</span></span><br><span class="line">2  4  6  a  b</span><br><span class="line">[root@VM-node1 nginx]<span class="comment"># du .</span></span><br><span class="line">4./4/4</span><br><span class="line">4./4</span><br><span class="line">4./6/0</span><br><span class="line">4./6</span><br><span class="line">4./2/5</span><br><span class="line">4./2</span><br><span class="line">4./a/a</span><br><span class="line">4./a</span><br><span class="line">4./b/7</span><br><span class="line">4./b</span><br><span class="line">20.</span><br></pre></td></tr></table></figure><p>看, 缓存已经建立了. ‘接着我们修改后端的资源:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 html]<span class="comment"># echo &quot;&lt;h1&gt;This is node2(NEW)&lt;/h1&gt;&quot; &gt; /var/www/html/index.html </span></span><br></pre></td></tr></table></figure><p>再次访问:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://192.168.206.9/</span><br><span class="line">&lt;h1&gt;It works! (From node2)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://192.168.206.9/</span><br><span class="line">&lt;h1&gt;It works! (From node2)&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>访问的就是缓存了. 你可以尝试着把缓存删除掉, 结果就会发生改变. 但是这不是好的建议.</p><blockquote><p>出去玩了一会, 回来的时候试了一下, 页面得到了刷新.</p></blockquote><h2 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a>upstream</h2><p>我们说过Nginx可以进行负载均衡, 支持多种调度方法. 现在就是应用的时候了, 如果我们把之前的特定的<code>proxy_pass</code>主机搞成一个集群, 不就可以实现动态调度了吗? 这就是upstream指令所定义的.</p><p>upstream可以把诸多主机定义在一起, 但是该选项只能用在http中. 在upstream中使用server指令来定义主机, 还可以传递参数. 现在我们一边搭建一边介绍好了.</p><p>首先为了负载均衡的效果, 我们需要把缓存功能关闭. 接着开启第三台主机充当后端的上游服务器.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> upstream http &#123;</span><br><span class="line">     server 192.168.206.21;</span><br><span class="line">     server 192.168.206.22;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">...(omitted)</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    rewrite ^/bbs/(.*)$ /forum/<span class="variable">$1</span> <span class="built_in">break</span>;</span><br><span class="line">    proxy_pass http://http;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着重载配置, 访问试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://192.168.206.9/</span><br><span class="line">&lt;h1&gt;This is node2(NEW)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://192.168.206.9/</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://192.168.206.9/</span><br><span class="line">&lt;h1&gt;This is node2(NEW)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://192.168.206.9/</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>我们还可以为特定的上游服务器加上权重, 比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream http &#123;</span><br><span class="line">  server 192.168.206.21 weight=2;</span><br><span class="line">  server 192.168.206.22;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着效果就会发生改变:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo                   </span><br><span class="line">λ curl http://192.168.206.9/      </span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;   </span><br><span class="line">                                  </span><br><span class="line">C:\Users\lenovo                   </span><br><span class="line">C:\Users\lenovo  2.168.206.9/     </span><br><span class="line">λ curl http://192.168.206.9/      </span><br><span class="line">&lt;h1&gt;This is node2(NEW)&lt;/h1&gt;       </span><br><span class="line">                                  </span><br><span class="line">C:\Users\lenovo                   </span><br><span class="line">λ curl http://192.168.206.9/      </span><br><span class="line">&lt;h1&gt;This is node2(NEW)&lt;/h1&gt;       </span><br><span class="line">                                  </span><br><span class="line">C:\Users\lenovo                   </span><br><span class="line">λ curl http://192.168.206.9/      </span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;   </span><br><span class="line">                                  </span><br><span class="line">C:\Users\lenovo                   </span><br><span class="line">λ curl http://192.168.206.9/      </span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;   </span><br><span class="line">                                  </span><br><span class="line">C:\Users\lenovo                   </span><br><span class="line">λ curl http://192.168.206.9/      </span><br><span class="line">&lt;h1&gt;This is node2(NEW)&lt;/h1&gt;       </span><br><span class="line">                                  </span><br><span class="line">C:\Users\lenovo                   </span><br><span class="line">λ curl http://192.168.206.9/      </span><br><span class="line">&lt;h1&gt;This is node2(NEW)&lt;/h1&gt;       </span><br><span class="line">                                  </span><br><span class="line">C:\Users\lenovo                   </span><br><span class="line">λ curl http://192.168.206.9/      </span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;   </span><br></pre></td></tr></table></figure><p>由此可见, 默认使用的调度算法是rr. 其实这个我们也是可以改的呀, 只要在upstream的头部加上算法就行了, 例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream http &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line"></span><br><span class="line">    server 192.168.206.21 weight=2;</span><br><span class="line">    server 192.168.206.22;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源地址哈希, 这样的话就会变成:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo                </span><br><span class="line">λ curl http://192.168.206.9/   </span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line">                               </span><br><span class="line">C:\Users\lenovo                </span><br><span class="line">λ curl http://192.168.206.9/   </span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line">                               </span><br><span class="line">C:\Users\lenovo                </span><br><span class="line">λ curl http://192.168.206.9/   </span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line">                               </span><br><span class="line">C:\Users\lenovo                </span><br><span class="line">λ curl http://192.168.206.9/   </span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line">                               </span><br><span class="line">C:\Users\lenovo                </span><br><span class="line">λ curl http://192.168.206.9/   </span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>除此之外, server后面还可以跟上很多参数, 例如:</p><blockquote><p>**weight: ** 权重.</p><p>**max_failure: ** 最大的失败尝试次数, 默认是1次.</p><p>**fail_timeout: ** 最大的失败超时时长, 默认是10s</p><p>**backup: ** 带这个标记的服务器被认定为备用服务器, 只有当主服务器宕机才会被调度.</p><p><strong>down:</strong> 带有这个标记的服务器不会得到调度.</p></blockquote><p>upstream同样可以定义我们之前说过的Session绑定. Nginx位于应用层, 于是能够识别请求, Session的绑定的原理是Cookie, 所以我们只要能够绑定Cookie, 就能够建立session了. 是这样用的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line"></span><br><span class="line">    sticky cookie srv_id expires=1h domain=.example.com path=/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sticky</code>指令第一种应用: 能够实现Cookie的绑定. </p><p>第二种就是路由携带:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">map <span class="variable">$cookie_jsessionid</span> <span class="variable">$route_cookie</span> &#123;</span><br><span class="line">    ~.+\.(?P&lt;route&gt;\w+)$ <span class="variable">$route</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map <span class="variable">$request_uri</span> <span class="variable">$route_uri</span> &#123;</span><br><span class="line">    ~jsessionid=.+\.(?P&lt;route&gt;\w+)$ <span class="variable">$route</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com route=a;</span><br><span class="line">    server backend2.example.com route=b;</span><br><span class="line"></span><br><span class="line">    sticky route <span class="variable">$route_cookie</span> <span class="variable">$route_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了这两种, 还有一个炒鸡厉害的 – learn 学习:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">   server backend1.example.com:8080;</span><br><span class="line">   server backend2.example.com:8081;</span><br><span class="line"></span><br><span class="line">   sticky learn</span><br><span class="line">          create=<span class="variable">$upstream_cookie_examplecookie</span></span><br><span class="line">          lookup=<span class="variable">$cookie_examplecookie</span></span><br><span class="line">          zone=client_sessions:1m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nginx可以通过分析客户端和上游服务器数据传输来维护一个session表.</p><p>接着Nginx还可以和后端的主机实现持久连接进行保活, 使用<code>keepalive</code>关键字 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream memcached_backend &#123;</span><br><span class="line">    server 127.0.0.1:11211;</span><br><span class="line">    server 10.0.0.2:11211;</span><br><span class="line"></span><br><span class="line">    keepalive 32;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    location /memcached/ &#123;</span><br><span class="line">        <span class="built_in">set</span> <span class="variable">$memcached_key</span> <span class="variable">$uri</span>;</span><br><span class="line">        memcached_pass memcached_backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过, 一般情况下, 我们不会对http做持久连接. 这样有可能会影响我们的并发性能. 一般都是数据查询这样的会选择长连接.</p><p>我们之前还说过, nginx支持应用层的健康状态检查, 也就是<code>health_check</code> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://backend;</span><br><span class="line">    health_check;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般, 我们要单独建立一个location用来执行健康状态检查, 而且, 要明确的把日志记录关闭. </p><p>health_check也支持很多选项:</p><blockquote><p><strong>interval</strong>: 检查间隔</p><p><strong>fails</strong>: 几次认定是不健康</p><p><strong>passes</strong>: 几次认定成是健康</p><p><strong>uri</strong>: 请求哪些资源</p><p><strong>match</strong>: 返回什么认定是健康.</p></blockquote><h2 id="fastcgi"><a href="#fastcgi" class="headerlink" title="fastcgi"></a>fastcgi</h2><p>关于fastcgi的相关不再赘述, 因为之前已经说过了. 现在就直接来进行Nginx和php-fpm的连接吧. </p><p>首先, 这里的实验假定php-fpm和Nginx是一个主机了, 如果是不同的主机的话, 需要改变监听地址的哦. 默认是127.0.0.1:9000端口.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># systemctl start php-fpm</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ss -tnl</span></span><br><span class="line">State       Recv-Q Send-Q                                        Local Address:Port                                                       Peer Address:Port              </span><br><span class="line">LISTEN      0      128                                                       *:8080                                                                  *:*                  </span><br><span class="line">LISTEN      0      128                                                       *:80                                                                    *:*                  </span><br><span class="line">LISTEN      0      128                                                       *:22                                                                    *:*                  </span><br><span class="line">LISTEN      0      100                                               127.0.0.1:25                                                                    *:*                  </span><br><span class="line">LISTEN      0      128                                                       *:443                                                                   *:*                  </span><br><span class="line">LISTEN      0      128                                               127.0.0.1:9000                                                                  *:*                  </span><br><span class="line">LISTEN      0      128                                                      :::22                                                                   :::*                  </span><br><span class="line">LISTEN      0      100                                                     ::1:25                                                                   :::*                  </span><br></pre></td></tr></table></figure><p>确定已经启动了, 接着就是主要的步骤了, 配置Nginx吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    root           /usr/share/nginx/html;</span><br><span class="line">    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    fastcgi_param  SCRIPT_FILENAME  $document_root<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">    include        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是默认的设置. 当然你需要改一下<code>fastcgi_param</code>的脚本路径. 这个是常识了, 就这样的带过去了.</p><p>我们的fastcgi模块也提供了缓存功能, 基本上的关键字和之前说的那个没什么不同, 基本上是一样的.(只要把之前的proxy_换成fastcgi _就行了) </p><h2 id="生产环境配置-2016"><a href="#生产环境配置-2016" class="headerlink" title="生产环境配置(2016)"></a>生产环境配置(2016)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">user                              nobody nobody;</span><br><span class="line">worker_processes                  4;</span><br><span class="line">worker_rlimit_nofile              51200;</span><br><span class="line"></span><br><span class="line">error_log                         logs/error.log  notice;</span><br><span class="line"></span><br><span class="line">pid                               /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">  use                             epoll;</span><br><span class="line">  worker_connections              51200;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">  server_tokens                   off;</span><br><span class="line">  include                         mime.types;</span><br><span class="line"></span><br><span class="line">  proxy_redirect                off;</span><br><span class="line">  proxy_set_header              Host <span class="variable">$host</span>;</span><br><span class="line">  proxy_set_header              X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">  proxy_set_header              X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">  client_max_body_size          20m;</span><br><span class="line">  client_body_buffer_size       256k;</span><br><span class="line">  proxy_connect_timeout         90;</span><br><span class="line">  proxy_send_timeout            90;</span><br><span class="line">  proxy_read_timeout            90;</span><br><span class="line">  proxy_buffer_size             128k;</span><br><span class="line">  proxy_buffers                 4 64k;</span><br><span class="line">  proxy_busy_buffers_size       128k;</span><br><span class="line">  proxy_temp_file_write_size    128k;</span><br><span class="line"></span><br><span class="line">  default_type                    application/octet-stream;</span><br><span class="line">  charset                         utf-8;</span><br><span class="line">  </span><br><span class="line">  client_body_temp_path           /var/tmp/client_body_temp 1 2;</span><br><span class="line">  proxy_temp_path                 /var/tmp/proxy_temp 1 2;</span><br><span class="line">  fastcgi_temp_path               /var/tmp/fastcgi_temp 1 2;</span><br><span class="line">  uwsgi_temp_path                 /var/tmp/uwsgi_temp 1 2;</span><br><span class="line">  scgi_temp_path                  /var/tmp/scgi_temp 1 2;</span><br><span class="line"></span><br><span class="line">  ignore_invalid_headers          on;</span><br><span class="line">  server_names_hash_max_size      256;</span><br><span class="line">  server_names_hash_bucket_size   64;</span><br><span class="line">  client_header_buffer_size       8k;</span><br><span class="line">  large_client_header_buffers     4 32k;</span><br><span class="line">  connection_pool_size            256;</span><br><span class="line">  request_pool_size               64k;</span><br><span class="line"></span><br><span class="line">  output_buffers                  2 128k;</span><br><span class="line">  postpone_output                 1460;</span><br><span class="line"></span><br><span class="line">  client_header_timeout           1m;</span><br><span class="line">  client_body_timeout             3m;</span><br><span class="line">  send_timeout                    3m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  log_format main                 <span class="string">&#x27;$server_addr $remote_addr [$time_local] $msec+$connection &#x27;</span></span><br><span class="line">                                  <span class="string">&#x27;&quot;$request&quot; $status $connection $request_time $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                                  <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  open_log_file_cache               max=1000 inactive=20s min_uses=1 valid=1m;</span><br><span class="line"></span><br><span class="line">  access_log                      logs/access.log      main;</span><br><span class="line">  log_not_found                   on;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  sendfile                        on;</span><br><span class="line">  tcp_nodelay                     on;</span><br><span class="line">  tcp_nopush                      off;</span><br><span class="line"></span><br><span class="line">  reset_timedout_connection       on;</span><br><span class="line">  keepalive_timeout               10 5;</span><br><span class="line">  keepalive_requests              100;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  gzip                            on;</span><br><span class="line">  gzip_http_version               1.1;</span><br><span class="line">  gzip_vary                       on;</span><br><span class="line">  gzip_proxied                    any;</span><br><span class="line">  gzip_min_length                 1024;</span><br><span class="line">  gzip_comp_level                 6;</span><br><span class="line">  gzip_buffers                    16 8k;</span><br><span class="line">  gzip_proxied                    expired no-cache no-store private auth no_last_modified no_etag;</span><br><span class="line">  gzip_types                      text/plain application/x-javascript text/css application/xml application/json;</span><br><span class="line">  gzip_disable                    <span class="string">&quot;MSIE [1-6]\.(?!.*SV1)&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  upstream tomcat8080 &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line"></span><br><span class="line">    server                        172.16.100.103:8080 weight=1 max_fails=2;</span><br><span class="line">    server                        172.16.100.104:8080 weight=1 max_fails=2;</span><br><span class="line">    server                        172.16.100.105:8080 weight=1 max_fails=2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  server &#123;</span><br><span class="line">    listen                        80;</span><br><span class="line">    server_name                   www.magedu.com;</span><br><span class="line">    <span class="comment"># config_apps_begin</span></span><br><span class="line">    root                          /data/webapps/htdocs;</span><br><span class="line">    access_log                    /var/logs/webapp.access.log     main;</span><br><span class="line">    error_log                     /var/logs/webapp.error.log      notice;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">    </span><br><span class="line">      location ~* ^.*/favicon.ico$ &#123;</span><br><span class="line">        root                      /data/webapps;</span><br><span class="line">        expires                   180d;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> ( !-f <span class="variable">$request_filename</span> ) &#123;</span><br><span class="line">        proxy_pass                http://tomcat8080;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page                    500 502 503 504  /50x.html;</span><br><span class="line">      location = /50x.html &#123;</span><br><span class="line">      root                        html;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  server &#123;</span><br><span class="line">    listen                        8088;</span><br><span class="line">    server_name                   nginx_status;</span><br><span class="line"></span><br><span class="line">      location / &#123;</span><br><span class="line">          access_log                  off;</span><br><span class="line">          deny                        all;</span><br><span class="line">          <span class="built_in">return</span>                      503;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      location /status &#123;</span><br><span class="line">          stub_status                 on;</span><br><span class="line">          access_log                  off;</span><br><span class="line">          allow                       127.0.0.1;</span><br><span class="line">          allow                       172.16.100.71;</span><br><span class="line">          deny                        all;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/MindMap/Nginx_LB_mind.png" alt="MindMap/Nginx_LB_mind.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux集群系统基础和调度方法</title>
      <link href="/2017/10/14/Linux%E9%9B%86%E7%BE%A4%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%92%8C%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95/"/>
      <url>/2017/10/14/Linux%E9%9B%86%E7%BE%A4%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%92%8C%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>从今天开始学习Linux集群知识 !</p><span id="more"></span><h2 id="集群-Cluster"><a href="#集群-Cluster" class="headerlink" title="集群 Cluster"></a>集群 Cluster</h2><p>什么是一个集群啊? 或者说为什么需要集群啊? 首先我们先来从一个普通的LAMP&#x2F;LNMP看:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lamp.png" alt="lamp"></p><p>我们的httpd是一个前端服务器同时也是一个反向代理服务器, 也就是说所有的请求都要经过它. 当请求的数量就很大的时候, httpd就会有点吃不消了. 除此之外, 我们说说后面的动态资源– php. 动态资源一般只有20%的请求. 由于处理起来是需要时间的, 所以这个的最大并发量也是有一个限制的, 甚至有可能前端服务器还没有到达瓶颈, 后端服务已经承载不住了. 当超出了之后, 整体的性能也会急剧下降.</p><p>于是在这样的场景下, 我们有两种扩展的方式:</p><ul><li>scale up: 向上扩展. 也就是找个性能更好的主机, 但是性价比很不高, 往往会花大价钱, 不推荐.</li><li>scale out: 向外扩展. 也就是多加机器, 分散请求 ,但是先要分散就需要一个接入点, 将服务进行分散.</li></ul><p>比如这里的PHP服务, 我可以多来几台, 由httpd来调度, 这就需要httpd能够提供调度, 也就是将受到的请求发散到各个PHP服务器上, 其中httpd有个模块就是做这个事情的.</p><p>由于http协议是个无状态的协议, 因此他需要进行追踪. 一种可行的是cookie, 但是不是很安全. 而且考虑到以某宝为例, 并且假设其使用PHP做动态资源, 我们可以在浏览网页的时候, 加入购物车对么, 假设这个时候用户的请求被调度到了第一台PHP服务器, 于是这个操作被存储到了一个特殊的空间, 我们叫做<strong>session</strong>. 而后第二次访问的时候, 还是被调度到了第一台PHP服务器, 但是他携带的第一次访问服务端给的cookie, 就依然可以得到自己上一次访问的相关信息. 接着用户第三次访问, 但是这一次他被导向了第二台PHP服务器, 这个时候Cookie就没用了. 那么, session里的数据呢? 也没了, 自己的购物车就这样的清空了, 显然是不行的. 那怎么办? </p><p>使用数据库吧, 这样就解决了. 但是我的MySQL数据库也有很多啊. 怎么知道我的数据在哪一个数据库服务器里? 这个时候我们的所使用的一般是<strong>主从复制</strong>的架构. 也就是写操作都是写到一个固定的MySQL服务器上, 而其他的MySQL会自动进行同步和复制, 一般情况下, 我们的正常业务中都是读多写少的模型, 所以我们采取这样的操作, 只有主服务器可以进行写操作, 只有从服务器可以进行读操作, 而从服务器有多个.</p><p>但是这样又太麻烦了, 我们的程序怎么进行读操作啊? 多台MySQL, 虽然可以在程序中进行轮询或者不管怎么方式访问, 耦合度又太高了, 如果日后这些从服务器进行了改变, 难道还要修改程序的代码? 因此, 我们可以搞出来一个中间件. 所有的请求都发向这个中间件就好, 接着由这个middleware进行调度和分发, 最后返回结果就行了. 除了提供这样的功能, 中间件还可以提供消息队列的功能, 当流量很大的时候还是可以进行排队, 然后挨个处理.</p><p>这还只是后端就已经这么过分了, 如果我们把httpd分成两台, 那问题就更加严重了. 首先, 我需要两倍的静态页面? 还是其他的处理方法? 接着, 后端的服务器又怎么部署? 如果我想要进行程序的改版, 那岂不是n倍部署? 另外, 两台前端服务器? 怎么将用户均匀调度呢? 我们想到之前说过DNS的A记录, 我可以将一个域名绑定多个IP, 这样就可以轮询了. 事实上, 这种方法是一个会很不好的解决方案, 因为DNS存在缓存, 而大量用户使用运营商的DNS缓存, 所有我们不能达到期待的效果.</p><p>于是, 我们又在httpd前面加了一个<strong>负载均衡器</strong>. 但是这样的话, 负载均衡器又会变成性能瓶颈. 而且, 我们的负载均衡器作为网络入口, 还需要进行nat转换.另外, 既然是作为入口, 那么万一这台负载均衡器炸了怎么办, 整个系统就完了? 所以, 我们还需要对着这一台负载均衡器进行备份. 也就是<strong>冗余</strong> 而当活动主机出现了故障, 冗余主机怎么知道呢? 更严重的是, 如果负载均衡器是一个有状态的服务的话, 这个状态如何在冗余切换进行来的时候进行传递呢 ? 是很麻烦啊..</p><p>说到这里为止, 什么是个集群, 就差不多可以来说说了. <strong>多台主机,为了满足某个特定目的,而组合起来使用. 这样一个计算机集合</strong>, 我们就叫做<strong>集群(cluster)</strong>.</p><h3 id="集群的类型"><a href="#集群的类型" class="headerlink" title="集群的类型"></a>集群的类型</h3><p>LB集群: 负载均衡集群, 通过scale out形式, 主要分摊负载.</p><p>HA集群: 高可用集群, 通过冗余, 能够做到服务一直可用, 一直在线.</p><p>为了衡量服务的可用性(availability), 我们需要考虑无故障时间和修复时间. </p><p>HP集群: 高性能集群…略</p><p>大规模并行处理集群: 分布式 map-reduce (hadoop等) …略</p><p>我们在这一部分先来说说负载集群. 还是先来考虑之前的数据库读写分离. 为什么我们说只有MySQL需要进行读写分离呢? 到底区别在哪里? </p><p><strong>httpd不需要存储数据</strong> 正是因为这个, 所以我们才要对MySQL进行分离, 因为需要得到数据集. 读写不分离行吗? 如果每一个MySQL主机既可以读, 也可以写. 那么结果集是离散的. 所以我们 在这个情况下, 可以使用一个大的框架进行统筹, 将离散的数据集拼成一个完整的. 但是这还不够. 如果我们 需要进行大数据的排序结果集, 每一个MySQL服务器将排好序的部分结果集提交给集合器, 但是集合器这个时候拿到的只是三个结果集, 没有索引. 怎么排序? </p><p>所以一旦使用这种方式, 我们的访问模型就会发生改变, 其实仔细想想, 我们不会去访问2年前的微博, 也不会去查看你几个月之前的淘宝商品. 也就是说, 只有20%左右的商品是热点数据, 而这些当中可能也有20%是热点中的热点. 是最频繁访问的数据. 所以说<strong>业务模型决定数据的存储方式</strong>. </p><p>当我们在考虑一个系统的时候, 我们往往会考虑下面的几个:</p><ul><li>可扩展性</li><li>可用性</li><li>容量</li><li>性能</li></ul><p>作为一个系统运维: 我们在进行运维的时候, 首先要确保<strong>服务可用</strong>, 这是最重要的, <strong>稳定大于一切</strong>, 这个达成之后, 我们就要进行<strong>标准化</strong>, 能够标准了, 就可以<strong>自动化</strong>了. </p><p>构建高可用扩展系统的重要原则:</p><ul><li><strong>在系统内部尽量避免串行化和交互</strong></li></ul><p>考虑负载均衡器成为了瓶颈, 这时候我们就要考虑使用多地部署, 多机房冗余部署. 多系统部署. 例如, 华北地区走华北机房的流量, 华南地区走华南机房的流量, 一旦华南机房挂掉了, 我们就需要一个大的, 全局的服务能够将华南地区的流量引到华北地区. 这里的全局服务, 我们把它叫做<code>GSLB</code>, 也就是<code>Global Service Load Balancing</code>  比如基于View的DNS. 同时还有小型的<code>SLB</code>, 也就是<code>Service Load Balancing</code>. </p><p>另外, http静态资源还是可以进行缓存的, 所以我们就可以把对静态资源的请求结果缓存到离用户最近的服务器上. 这样有极大部分的请求都会直接命中缓存, 而最终到达负载均衡器的只有一部分的请求了.</p><h2 id="LVS集群的实现-概述"><a href="#LVS集群的实现-概述" class="headerlink" title="LVS集群的实现(概述)"></a>LVS集群的实现(概述)</h2><p>首先我们来说说负载均衡集群的实现, 这里主要分成软件和硬件两个层次来说.</p><h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><p>硬件上比较有名的就是F5 BIG-IP了, 但是价格昂贵; 还例如Citrix Netscaler, A10, Array, Redware等等.</p><p>这个不是重点了,略过了</p><h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><p>主要是 lvs, haproxy, nginx, ats(Apache traffic server). 我们可以对这些软件(当然硬件也可以)按照工作的协议层次划分:</p><ul><li>传输层: LVS, haproxy(mode tcp)</li><li>应用层: 基本上都是反向代理: nginx, haproxy, ats</li></ul><p>于是, 我们开始正式介绍<strong>lvs</strong>.</p><h2 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h2><p>LVS是一个工作在四层的负载均衡器. 我们之前在说iptables的时候说过, iptables在内核中工作的框架&#x2F;组件叫做netfilter, 这个LVS其实也是工作在netfilter之上的. 由于工作在内核, 所以LVS必须理解来访的请求, 从而根据规则进行转发. 正常情况下, 我们的数据包是经过预先路由到入站接着进入用户空间, 但是如果LVS, 就不会将数据包发向用户空间而直接进行FORWARD.</p><p>LVS的全称是Linux Virtual Server. 为什么叫这个名字呢? 其实就和我们理解反向代理差不多.他不提供那个服务但是对外宣称自己提供.LVS基于请求的IP和端口进行转发, 而(三层)路由器基于目的IP进行转发, (二层)交换机基于MAC地址进行转发. 所以我们也可以把LVS称为是四层交换, 或者四层路由. 当然无非都是转发.</p><p>原先我们使用iptables进行nat转发的时候, 是在PREROUTING进行DNAT, 也就是在还没来得及路由的时候就把数据包的流向进行更改. 但是LVS并不是这样玩的, 他实际上工作在INPUT上. 在INPUT链上, LVS定义了集群规则, 从而强行改变正常流向. 直接扔到特定的网卡上. 所以如果需要使用LVS, 我们需要定义好哪些端口是需要进行LVS转发的, 以及扔到哪些real server去, 这些主机有多少个, 以及挑选方式是什么等等</p><p>和iptables一样, LVS也有两个部分构成, 一个工作在内核空间, 叫做<code>ipvs</code>; 一个工作在用户空间, 叫做<code>ipvsadm</code>. </p><p>所以如果想要使用LVS, 前提是我们需要这个用户空间的命令行工具, 管理集群服务. LVS依附在netfilter上工作, 所以如果想使用此功能当然你要确保netfilter时启用的, 当然了LVS在内核选项中也是启用的. 怎么判断呢? 在我们编译内核的时候, 还记得生成的<code>.config</code>吗? 对了, 我可以从这里面获得相关的信息.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># grep -i -A 5 &quot;ipvs&quot; /boot/config-3.10.0-693.2.2.el7.x86_64 </span></span><br><span class="line">CONFIG_NETFILTER_XT_MATCH_IPVS=m</span><br><span class="line">CONFIG_NETFILTER_XT_MATCH_LENGTH=m</span><br><span class="line">CONFIG_NETFILTER_XT_MATCH_LIMIT=m</span><br><span class="line">CONFIG_NETFILTER_XT_MATCH_MAC=m</span><br><span class="line">CONFIG_NETFILTER_XT_MATCH_MARK=m</span><br><span class="line">CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m</span><br><span class="line">--</span><br><span class="line"><span class="comment"># IPVS transport protocol load balancing support</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">CONFIG_IP_VS_PROTO_TCP=y</span><br><span class="line">CONFIG_IP_VS_PROTO_UDP=y</span><br><span class="line">CONFIG_IP_VS_PROTO_AH_ESP=y</span><br><span class="line">CONFIG_IP_VS_PROTO_ESP=y</span><br><span class="line">--</span><br><span class="line"><span class="comment"># IPVS scheduler</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">CONFIG_IP_VS_RR=m</span><br><span class="line">CONFIG_IP_VS_WRR=m</span><br><span class="line">CONFIG_IP_VS_LC=m</span><br><span class="line">CONFIG_IP_VS_WLC=m</span><br><span class="line">--</span><br><span class="line"><span class="comment"># IPVS SH scheduler</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">CONFIG_IP_VS_SH_TAB_BITS=8</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># IPVS application helper</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">CONFIG_IP_VS_FTP=m</span><br><span class="line">CONFIG_IP_VS_NFCT=y</span><br><span class="line">CONFIG_IP_VS_PE_SIP=m</span><br></pre></td></tr></table></figure><p>也看到了 这里使用的是CentOS7做的实验. 可以很清楚的看出来, LVS功能是开启的, 支持诸多协议: TCP, UDP, AH_ESP, ESP~ 而且他的负载均衡算法都是编译成了模块存在的. </p><p>在使用LVS之前, 我们先来看一下整个LVS的工作架构, 有关一些名词等等:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvs_ip.png" alt="lvs_ip"></p><h3 id="LVS的类型"><a href="#LVS的类型" class="headerlink" title="LVS的类型"></a>LVS的类型</h3><p>然后看看LVS的类型, 有四种:</p><ul><li>lvs-nat: 其实就是多目标的DNAT(iptables)</li><li>lvs-dr(direct routing直接路由)</li><li>lvs-tun(ip tunneling)</li><li>lvs-fullnat(扩展功能)</li></ul><h4 id="lvs-nat"><a href="#lvs-nat" class="headerlink" title="lvs-nat"></a>lvs-nat</h4><p>首先我们先来看一下lvs-nat, 其实这个过程和我们之前的iptables的nat转换没什么太大的不同呀~我们来过一遍过程. 首先, 客户端CIP像向VIP发出请求, 请求报文到达VIP, 由LVS强行将报文进行修改之后送到POSTROUTING. 此时报文的源地址还是CIP, 但是目的地址RIP. 后面的real server收到请求, 将响应结果报文封装. 注意啊, 此时的报文目的地址是CIP, 而源地址是RIP. 而且RS的网关一定要是前面的director才行(否则报文送不出去啊), 接着就是正常的过程了, director走正常流程经由FORWARD, 最后从外部接口发送到目的地址CIP. 一次通信结束.</p><p>不管怎么说, 我们要在director中, (准确的说是LVS专用的), 维护一张nat转换表.</p><p>如果基于nat的方式, 显然RS和DIP应该使用私网地址, 且RS的网关需要指向DIP. 另外请求和响应报文都要经由director转发, 这样极高的负载的场景中, director将会成为系统瓶颈. diretor还要支持端口映射才行.</p><h4 id="lvs-dr"><a href="#lvs-dr" class="headerlink" title="lvs-dr"></a>lvs-dr</h4><p>接着我们看一下lvs-dr, 这种模型是LVS默认使用的, 在大规模场景中经常使用. 而且也是一种较难理解的模型.</p><p>这个的原理是<strong>修改请求报文的目标MAC地址</strong>进行转发. 在说这个之前, 我们要先来看一下这个模型的架构图:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvs-dr.png" alt="lvs-dr"></p><p>这里我们把director, real server都连接到一个交换机上(此时他们都只需要一个网卡), 首先先来回忆一下用户的请求是怎么到达我们的服务器的:</p><p>首先, 用户那边将包的目的地址设置成为我们的服务器的公网IP地址, 接着经过变换, 重重路由和网关, 请求到达图中的最后一个路由, 我们知道, 每一次经过一个路由, 包的源MAC地址都会变成那个路由的MAC地址对吗? 所以当最后一个路由想要将包发送过来的时候, 这个时候转换成为本地网络通信. 也就是说从图中右边那个接口出来的包头前需要再次附着一个MAC头(源MAC和目的MAC). 源MAC就是路由接口的那个MAC了BUT. 路由器怎么知道目的MAC是多少呢? 先来想下他知道什么. 对哦, 目的IP. 所以这个时候就可以做ARP广播了, 接着只有director发出回应, 路由器得到MAC地址, 完成通信.</p><p>那么, 接着过程是这样走的, 请求发到director之后, director从和都连接在一个交换机上的RS中挑选一台发出响应, 过程结束.</p><p>也就是说:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvs_dr.png" alt="lvs_dr"></p><p>这样的一个过程, 明确的一点是, 响应报文不会经过director了, 由RS直接发出. 这样会存在一个致命的问题. 源IP地址不是VIP了. 怎么办? 处理方法是这样的: <strong>每一个RS和Director的地址是一样的, 都是VIP.</strong> </p><p>问题就这样解决了? 当然不是, 这会引入一个新的问题. 当路由器做ARP广播的时候, 所有的主机都给了响应, 这怎么行? </p><p>其实, 我们的解决方法是这样的: 其实每一个主机都有两个IP, 对于director来说, 他有一个VIP和一个DIP, 而每一个RS也有一个VIP, 还有一个RIP. 这样当请求到达director的时候, 他会进行ARP广播获得挑选出来的那个RIP的主机的MAC地址, 接着IP包头依然是CIP-&gt;VIP, 封装MAC帧的时候, 将目的MAC封装成挑选出来的主机的那个MAC, 交换机是而二层设备, 只能转发帧, 所以就将请求报文发向挑选好的RS, RS收到报文之后解开MAC帧, 查看内部的IP包头, 源IP: CIP, 目的IP: VIP, VIP是不是自己的IP? <strong>是的</strong> !所以进入用户空间进行处理~.</p><p>可能还是有点问题, 来想一想RIP, DIP和VIP能够是同一网段吗? 其实这些倒不是十分重要的问题, 我的VIP, DIP, RIP全都是公网IP都是可行的, 而且这样还方便我们做远程管理. 实际上, 我们要确保VIP, DIP以及RIP必须要在一个物理网段中, 这样director的ARP广播才可以到达啊, 另外一般情况下, 我们会把DIP和RIP规划到一个子网段中 因为这样更好理解, 但是这并不绝对, 不在同一网段也无所谓.</p><p>既然RIP和VIP不在同一网段,那么显然网关, 出口路由就不能是进来的那个了, 所以我们需要再添加一个路由器, 充当出口路由了. 挨? 可是这样不对啊?我们要求出去的响应报文的源IP一定要是VIP才行啊? 我们的主机是Linux主机, 内核会遵从一个原则: 响应报文从哪一个网卡出去, 那么源地址就一定是那个网卡的IP地址.</p><p>对于每一个RS来说, 我们的RIP是配置在物理网卡上的, 而VIP是配置在lo这样的接口上的. 因此分发下来的报文是经由物理网卡转向lo, 最终发向上层用户空间的. 接着, 响应报文默认是从物理接口出去的, 我们强行将其规定成先走lo, 在转向物理网卡出去. 这是必须的一步.</p><p>最后我们稍微总结一下dr集群的几个特点:</p><ul><li>保证前端路由器将目标IP为VIP的请求报文发送到director上</li><li>解决方法: <ul><li>静态绑定</li><li>arptables</li><li>修改内核参数</li></ul></li><li>RS的RIP可以使用私网地址, 也可以使用公网地址</li><li>RS和directors一定要在同一个物理网络中</li><li>请求报文经过director调度, 但是响应报文一定不经过director</li><li>不支持端口映射</li><li>RS的网关不能指向RIP</li></ul><p>以上就是最常见的两种集群类型啦, 接着我们再来看看剩下的:</p><h4 id="lvs-tun"><a href="#lvs-tun" class="headerlink" title="lvs-tun"></a>lvs-tun</h4><p>先来想想之前的两种, 他们都有一个共同的缺点, director和RS之间的距离不可能很长, 对嘛? 甚至第二种连路由器都不能连接.</p><p>而tun就可以解决这样的问题, 我们不修改请求报文的IP首部, 而是通过在原有的ip首部之外, 再封装一个ip首部. 大体的原理就是这样. 其实只要理解了之前的 理解这个tun就不难了:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvs-tun.png" alt="lvs-tun"></p><p>其实就有点像是加强版的 lvs-dr 了. 只不过由于是走IP隧道, 所以要求director和RS需要支持IP隧道协议. RS主机依然是物理网卡RIP, lo接口VIP的模式, 接着响应的时候就会有RS直接一口气发向User.</p><p>但是这样其实也会有一个问题, 就是<strong>MTU</strong>. 当然这是所有隧道的问题, 由于包头增大(多了一个IP包头[20字节]), 导致MTU相对来说不够就会进行<strong>IP分组分片操作</strong>.</p><h4 id="lvs-fullnat"><a href="#lvs-fullnat" class="headerlink" title="lvs_fullnat"></a>lvs_fullnat</h4><p>最后一个full-nat , 就是director同时修改源地址和目标IP. 怎么搞的呢? 其实就是在进去的时候把源IP换一下, 出去的时候把目的IP和源IP都换一下.</p><p>这样的话, 就可以跨机房(director和RS不在同一个机房), 而且支持端口映射机制.</p><h3 id="session保持"><a href="#session保持" class="headerlink" title="session保持"></a>session保持</h3><p>接着我们聊聊之前说过的session保持. 一般有三种session保持的方式:</p><ul><li>session绑定<ul><li>就是说将来自该用户的请求全部定向到某个特定的RS上, 追踪用户的方法就是维护一个session表, 通过定时器机制来维持. 这种机制也即: <code>ip_hash</code> 对来源IP进行hash之后存表. 但是现在我们有很多连接互联网的方式是使用SNAT的呀, 也就是说一个IP可能后面是几百台机器. 这样一点都不均衡了, 力度还十分粗糙.</li><li>所以还可以使用cookie_hash. (进程级别, 应用层)</li></ul></li><li>session集群<ul><li>上面的session绑定有个严重的问题, 就是一旦RS宕机, 整个session就全部都没了.所以需要进行session复制和同步就好了每一个主机都有每一个用户的session.但是这个模式会影响性能和网络拥塞.</li></ul></li><li>session服务器<ul><li>上面的session集群虽然可行, 但是如果电源中断, 整个集群宕掉, 所有的session还是一样全体消失. 所以我们需要进行session的持久化. 具体说来就是找一台第三方的存储服务器. 这样每一台主机都去找这个存储服务器就行了.而且我们可以使用memcache或者redis这样的键值存储. 当然缺点也是有的: 一来引入了单点, 二来会带来延迟. 所以还是要慢慢的进行新的架构或者研发.</li></ul></li></ul><h3 id="LVS-调度器-Scheduler"><a href="#LVS-调度器-Scheduler" class="headerlink" title="LVS 调度器(Scheduler)"></a>LVS 调度器(Scheduler)</h3><p>其实所谓的调度器, 就是一些算法的程序实现罢了.我们之前也看到了LVS支持的一些调度算法. 当然那些并不是全部. 我们将调度算法分成<strong>静态的方法</strong>和<strong>动态的方法</strong>. 其中静态的方法就是说仅根据算法本身进行调度. 而动态方法能够根据算法和各个RS当前的负载状态来进行调度. 显然, 静态方法能够保证起点是公平的, 而动态方法能够尽可能使得结果更加公平.</p><p>静态方法有这些: </p><ul><li>RR(<code>round robin轮调</code>), </li><li>WRR(<code>weighted RR,加权的RR</code>),  </li><li>SH(<code>source hash, 实现session保持的机制会损害负载均衡的效果</code>), </li><li>DH(<code>destination hash, 对同一个目标的请求是始终发向同一RS</code>).</li></ul><p>对于动态方法, 其实就是一开始直接调用算法, 接着在后面就会开始讲各个RS负载状态加入考虑. 这就引入了Overhead, 通过这个来量化RS的负载情况. 经过计算Overhead最小的主机就会优先纳入考虑.</p><p>而动态方法有这些: </p><ul><li>LC(<code>Least connection, 最小连接, 如果每一个都是0, 就自上而下: Overhead=Active * 256+Inactive</code>), </li><li>WLC(<code>Weighted LC, 加权的LC: Overhead=(Active * 256 + Inactive)/weight, 但是这样的算法会有一个缺点, 那就是由于自上而下的策略, 会使得最开始的时候(也就是0连接), 会直接选择第一台主机, 然而万一这个第一台主机就是性能最差的那一台怎么办?于是就需要下面的SED来补救.</code>), </li><li>SED(<code>Shortest Expectation Delay, 也就是最小希望延迟: Overhead=(Active+1)*256/weight. 其实就是尽量保证权重最大的来响应请求.但是这样其实也有问题</code>), </li><li>NQ(<code>Never Queue.永不排队, 十分独特, 先把权重从大到小来一遍, 接着使用SED逐渐排除所有的RS. 接着循环就行了.</code>), </li><li>LBLC(<code>Locality-Base LC, 就是动态的DH算法</code>), </li><li>LBLCR(<code>LBLC with  Replication, 带复制的LBLC.两台缓存服务器互相复制.</code>).</li></ul><h3 id="LVS的调度"><a href="#LVS的调度" class="headerlink" title="LVS的调度"></a>LVS的调度</h3><p> 接下来终于要来说说如何使用ipvsadm啦~由于我们已经会写iptables了, 所以ipvsadm其实是很简单的. 无非也就是一些规则的增删查改了. 而ipvsadm也无非就是管理集群服务, 和管理集群服务中的RS.</p><p>一个ipvs主机可以同时定义多个cluster service, 这主要依靠tcp和udp的端口决定. 另外一个cluster service上至少应该由一个real server. 定义时, 只要指明lvs-type 以及lvs-scheduler就行了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 管理集群服务</span></span><br><span class="line">ipvsadm -A|E -t|u|f service-address [-s scheduler]</span><br><span class="line">        [-p [<span class="built_in">timeout</span>]] [-M netmask] [-b sched-flags]</span><br><span class="line">ipvsadm -D -t|u|f service-address</span><br><span class="line"></span><br><span class="line">[service-address]</span><br><span class="line">  tcp: -t ip:port</span><br><span class="line">  udp: -u ip:port</span><br><span class="line">  fwm: -f 防火墙标记, 也就是经过netfilter的时候的一个token类似的东西.</span><br><span class="line"></span><br><span class="line">[scheduler]</span><br><span class="line">  default wlc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 管理集群服务中的RS</span></span><br><span class="line">ipvsadm -a|e -t|u|f service-address -r server-address</span><br><span class="line">        [-g|i|m] [-w weight] [-x upper] [-y lower]</span><br><span class="line">ipvsadm -d -t|u|f service-address -r server-address</span><br><span class="line"></span><br><span class="line">[server-address]:</span><br><span class="line">  ip[:port]</span><br><span class="line">  </span><br><span class="line">[lvs-type]:</span><br><span class="line">  -g: gateway, dr</span><br><span class="line">  -i: ipip, tun</span><br><span class="line">  -m: masquerade, nat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空和查看</span></span><br><span class="line">ipvsadm -C</span><br><span class="line">ipvsadm -L|l [options]</span><br><span class="line"><span class="comment"># restore 和 save</span></span><br><span class="line">ipvsadm -R</span><br><span class="line">ipvsadm -S [-n]</span><br><span class="line"><span class="comment"># 置零计数器</span></span><br><span class="line">ipvsadm -Z [-t|u|f service-address]</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">ipvsadm --<span class="built_in">set</span> tcp tcpfin udp</span><br><span class="line">ipvsadm --start-daemon state [--mcast-interface interface]</span><br><span class="line">        [--syncid syncid]</span><br><span class="line">ipvsadm --stop-daemon state</span><br></pre></td></tr></table></figure><p>基本上大写选项都是在管理集群服务的, 而小写选项都是在管理集群服务中的RS. 而且这个玩意也有一个save和一个restore.</p><h2 id="构建LVS集群"><a href="#构建LVS集群" class="headerlink" title="构建LVS集群"></a>构建LVS集群</h2><p>终于开始了, 来亲手构造一个nat和dr模型的集群吧.</p><h3 id="NAT模型"><a href="#NAT模型" class="headerlink" title="NAT模型"></a>NAT模型</h3><p>首先来看一下我们的实验拓扑图:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lva_nat_lab.png" alt="lva_nat_lab"></p><p>由于使用Vmware, 所以这里使用建立不同的虚拟网络来做隔离. 信息图中已经很明白了, </p><p>现在先来是构建环境, 先要把网络拓扑搭建完成. </p><p>接着就开启后端两个服务器的httpd服务, 并且配置默认页面(先设置成为不同的可区分的页面).</p><p>接着清空所有iptables规则. 接着使用director去访问后面的两个节点.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># curl http://192.168.20.7</span></span><br><span class="line">&lt;h1&gt;It works! (From node2)&lt;/h1&gt;</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># curl http://192.168.20.8</span></span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>接着我们要确认核心转发功能是开启的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># cat /proc/sys/net/ipv4/ip_forward</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>接下来就简单了, 请看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -A -t 172.16.100.9:80 -s rr</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -L -n</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  172.16.100.9:80 rr</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -a -t 172.16.100.9:80 -r 192.168.20.7:80 -m</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -a -t 172.16.100.9:80 -r 192.168.20.8:80 -m</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -L -n</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  172.16.100.9:80 rr</span><br><span class="line">  -&gt; 192.168.20.7:80              Masq    1      0          0         </span><br><span class="line">  -&gt; 192.168.20.8:80              Masq    1      0          0    </span><br></pre></td></tr></table></figure><p>接下来访问试试: ( 因为我担心会有缓存的影响, 所以使用本机的shell来跑 )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://172.16.100.9</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://172.16.100.9</span><br><span class="line">&lt;h1&gt;It works! (From node2)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://172.16.100.9</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://172.16.100.9</span><br><span class="line">&lt;h1&gt;It works! (From node2)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://172.16.100.9</span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://172.16.100.9</span><br><span class="line">&lt;h1&gt;It works! (From node2)&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>可以看到, 交替出现node2和node3, 这就是rr算法, 轮询. 接着我还用ab跑了一个简单的1000次访问:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -L -n</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  172.16.100.9:80 rr</span><br><span class="line">  -&gt; 192.168.20.7:80              Masq    1      0          504       </span><br><span class="line">  -&gt; 192.168.20.8:80              Masq    1      0          501    </span><br></pre></td></tr></table></figure><p>可以看到基本上平摊了请求. 其实, 当我们进行ipvsadm的停止操作的时候, 默认service unit会执行保存操作, 而开启时会进行重读上次保存的配置的操作. 但是终究没有我们手动保存来的靠谱:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -S &gt; ~/ipvsadm</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -C</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -L -n</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -R &lt; ~/ipvsadm </span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -L -n</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  192.168.20.1:80 rr</span><br><span class="line">  -&gt; 192.168.20.7:80              Masq    1      0          0         </span><br><span class="line">  -&gt; 192.168.20.8:80              Masq    1      0          0         </span><br><span class="line">[root@VM-node1 ~]<span class="comment"># cat ipvsadm </span></span><br><span class="line">-A -t VM-node1:http -s rr</span><br><span class="line">-a -t VM-node1:http -r 192.168.20.7:http -m -w 1</span><br><span class="line">-a -t VM-node1:http -r 192.168.20.8:http -m -w 1</span><br></pre></td></tr></table></figure><p>和iptables基本上是一样的, 但是这个地方, 建议在保存的时候 加上-n参数, 这样就不用进行反向解析了. 而Unit就是这样做的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># cat /usr/lib/systemd/system/ipvsadm.service </span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Initialise the Linux Virtual Server</span><br><span class="line">After=syslog.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/bin/bash -c <span class="string">&quot;exec /sbin/ipvsadm-restore &lt; /etc/sysconfig/ipvsadm&quot;</span></span><br><span class="line">ExecStop=/bin/bash -c <span class="string">&quot;exec /sbin/ipvsadm-save -n &gt; /etc/sysconfig/ipvsadm&quot;</span></span><br><span class="line">ExecStop=/sbin/ipvsadm -C</span><br><span class="line">RemainAfterExit=<span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>接下来我们试试进行更改功能, 这里就使用另一种调度算法(SH)来试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -E -t 172.16.100.9:80 -s sh</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  172.16.100.9:80 sh</span><br><span class="line">  -&gt; 192.168.20.7:80              Masq    1      0          0         </span><br><span class="line">  -&gt; 192.168.20.8:80              Masq    1      0          0   </span><br></pre></td></tr></table></figure><p>接着访问就会起到效果了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://172.16.100.9</span><br><span class="line">&lt;h1&gt;It works! (From node2)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://172.16.100.9</span><br><span class="line">&lt;h1&gt;It works! (From node2)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://172.16.100.9</span><br><span class="line">&lt;h1&gt;It works! (From node2)&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo</span><br><span class="line">λ curl http://172.16.100.9</span><br><span class="line">&lt;h1&gt;It works! (From node2)&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>更改集群服务中的rs也很简单, 就不做演示了.</p><p>接着我们把他们删除, 顺便过一遍删除操作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -d -t 172.16.100.9:80 -r 192.168.20.7:80</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -d -t 172.16.100.9:80 -r 192.168.20.8:80</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -D -t 172.16.100.9:80</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br></pre></td></tr></table></figure><p>除了-n参数是不进行解析之外, 还有这些选项:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -L --stats -n</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port               Conns   InPkts  OutPkts  InBytes OutBytes</span><br><span class="line">  -&gt; RemoteAddress:Port</span><br><span class="line">TCP  172.16.100.9:80                  1002     5008     5004   358432   568724</span><br><span class="line">  -&gt; 192.168.20.7:80                   501     2504     2502   179216   285612</span><br><span class="line">  -&gt; 192.168.20.8:80                   501     2504     2502   179216   283112</span><br></pre></td></tr></table></figure><p>以及显示连接:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -L -n -c</span></span><br><span class="line">IPVS connection entries</span><br><span class="line">pro expire state       <span class="built_in">source</span>             virtual            destination</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>还可以使用–rates显示速率:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -L -n --rate</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port                 CPS    InPPS   OutPPS    InBPS   OutBPS</span><br><span class="line">  -&gt; RemoteAddress:Port</span><br><span class="line">TCP  172.16.100.9:80                     1        4        3      241      333</span><br><span class="line">  -&gt; 192.168.20.7:80                     0        1        1       96      140</span><br><span class="line">  -&gt; 192.168.20.8:80                     0        2        2      145      193</span><br></pre></td></tr></table></figure><p>这里补充一个https负载均衡的小提示:</p><blockquote><p>如果在这个情况下使用https的话, 要确保后面的Web server的证书是同一个, 私钥也是同一个.</p></blockquote><h3 id="DR模型"><a href="#DR模型" class="headerlink" title="DR模型"></a>DR模型</h3><p>下面就来看一下DR模型的实现吧. 会比我们的LB模型复杂一些, 在展示我们的实验拓扑图之前, 我们先来看一下, 之前提到的内核参数:</p><ul><li>arp_announce: 该选项改变内核对于arp分组的请求, 通告</li><li>arp_ignore: 该选项改变内核对于arp分组的接受</li></ul><p>arp_announce这个选项有三个值: 0, 1, 2. 默认值是0, 表示将自己所有的IP进行通告.  显然我们不能使用这个值. 1表示尽量避免不把本机除了接口网段以外的网络进行通告, 但是这是<strong>尽量</strong>. 所以也不启用. 最后是2这个值, 意味, 始终使用最佳本地地址. 这才是我们所使用的, 不将自己的lo上的IP通告出去.</p><p>arp_ignore有很多值, 我们来看看. 首先还是默认值0, 就是如果接收到自己本地的IP的查询就提供. 接着是1, 只有询问到的地址正是自己配置在这个接口上的地址的时候, 才进行回应. 这正是我们所需要的. 还有2-8,  不过既然都找到了合适的值, 就略了.</p><p>最终, 我们需要: arp_ignore &#x3D; 1, arp_announce &#x3D; 2.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvs_dr_lab.png" alt="lvs_dr_lab"></p><p>还是惯例, 我现在先去配置环境啦~ 这里关于虚拟接口的设定在之前的网络配置中也是说过的.</p><p>但是这里要插一句, 我们是应该先配置real server的lo接口的IP地址呢? 还是先进行参数配置呢? 当然是先配置参数啦. 原因很简单的.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore </span></span><br><span class="line">[root@VM-node2 ~]<span class="comment"># echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce </span></span><br></pre></td></tr></table></figure><p>配置完成了之后, 找一台位于同于网络的主机( 如果你桥接的话, 就使用物理机就行了. ), 分别去ping一下director的vip和dip. 不出意外的话, 查看arp表的时候, MAC应该是一样的:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvs_arp.png" alt="lvs_arp"></p><p>接下来就可以开启Web服务了, 并且这里要使用rip才行.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># curl http://192.168.206.21</span></span><br><span class="line">&lt;h1&gt;It works! (From node2)&lt;/h1&gt;</span><br><span class="line">[root@VM-node1 ~]<span class="comment"># curl http://192.168.206.22</span></span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>接下来就简单了, 和之前差不多了, 但是部分参数改一下就好了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -A -t 192.168.206.10:80 -s rr</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -a -t 192.168.206.10:80 -r 192.168.206.21:80 -g</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -a -t 192.168.206.10:80 -r 192.168.206.22:80 -g</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  192.168.206.10:80 rr</span><br><span class="line">  -&gt; 192.168.206.21:80            Route   1      0          0         </span><br><span class="line">  -&gt; 192.168.206.22:80            Route   1      0          0 </span><br></pre></td></tr></table></figure><p>接着就可以测试了:</p><p>接着…你就会发现, 奇怪, 怎么会连接不到服务器?</p><p>原因很简单, 因为响应报文没有经过lo接口啊~所以要加上路由:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node2 ~]<span class="comment"># route add -host 192.168.206.10/32 dev lo:0</span></span><br><span class="line">[root@VM-node3 ~]<span class="comment"># route add -host 192.168.206.10/32 dev lo:0</span></span><br></pre></td></tr></table></figure><p>接着就可以了: ( 注意iptables )</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvs_dr_res.png" alt="lvs_dr_res"></p><h2 id="LVS的防火墙标记和Session绑定"><a href="#LVS的防火墙标记和Session绑定" class="headerlink" title="LVS的防火墙标记和Session绑定"></a>LVS的防火墙标记和Session绑定</h2><p>我们之前是不是漏了一个-f参数呀? 当时说这个是叫做防火墙标记的东西. 其实在我们的数据包到达LVS之前, 他还是经过了PREROUTING的. 而且我们还说过, LVS是工作在INPUT上的, 所以也就是说, LVS发生在PREROUTING之后, 这样我们还可以通过在PREROUTING上对某个特定的数据包进行mangle, 也就是拆开之后打上标记再安装回去, 这个标记就是防火墙标记.  在iptables的扩展TARGET中, 有一个就叫做<code>MARK</code> 该扩展能用来实现对报文加上标记从而实现诸多辨识功能.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MARK</span><br><span class="line">    This target is used to <span class="built_in">set</span> the Netfilter mark value associated with the packet.  It can, <span class="keyword">for</span> example, be used <span class="keyword">in</span>  conjunction  with  routing  based  on  fwmark</span><br><span class="line">    (needs iproute2). If you plan on doing so, note that the mark needs to be <span class="built_in">set</span> <span class="keyword">in</span> the PREROUTING chain of the mangle table to affect routing.  The mark field is</span><br><span class="line">    32 bits wide.</span><br><span class="line"></span><br><span class="line">    --set-xmark value[/mask]</span><br><span class="line">           Zeroes out the bits given by mask and XORs value into the packet mark (<span class="string">&quot;nfmark&quot;</span>). If mask is omitted, 0xFFFFFFFF is assumed.</span><br><span class="line"></span><br><span class="line">    --set-mark value[/mask]</span><br><span class="line">           Zeroes out the bits given by mask and ORs value into the packet mark. If mask is omitted, 0xFFFFFFFF is assumed.</span><br></pre></td></tr></table></figure><p>这样的话, 我们在定义规则的时候就可以更加灵活, 而且有的时候还可以进行规则的合并, 比如: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PREROUTING:</span><br><span class="line"> -j MARK --set-mark 10</span><br><span class="line">ipvs:</span><br><span class="line"> -A -f 10</span><br></pre></td></tr></table></figure><p>当我们把http(80)和https(443)都打上10的标记的时候, 我们就可以一起来写规则, 而不需要一次是vip:80, 一次是vip:443了.</p><p>做一下这个小实验吧~ 接着在观察结果时会出现新的问题:</p><p><strong>Session保持的问题</strong>, 怎么会说到这个? 因为我们</p><p>使用SH调度算法的时候, 你会发现在访问http和https的时候还是不会绑定在一个real server的. </p><p>那么现在就来解决这个问题, 我们可以使用<strong>LVS的持久连接功能</strong>来解决, 对于多个共享同一组RS的服务器, 我们进行Session绑定.</p><p>这个持久连接功能, 可以确保在一段特定的时间内, 不论使用什么调度算法, 都可以使得同一个客户端访问到第一次被定向的RS上. 与iptables类似, 这个功能也需要一个持久连接模板, 该模板独立于算法本身 ,像这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srcIPrstimer</span><br></pre></td></tr></table></figure><p>如果该模板中没有记录就直接带入算法. 如果能够查看到记录存在, 就会直接调度至该RS.</p><p>声明一个持久连接很简单, 直接加上一个-p参数就行了: [ 后面指定时长, 如果不指定就是默认的360s ]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -A -t 192.168.206.10:80 -s rr -p 30</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -a -t 192.168.206.10:80 -r 192.168.206.21 -g</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -a -t 192.168.206.10:80 -r 192.168.206.22 -g</span></span><br><span class="line">[root@VM-node1 ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  192.168.206.10:80 rr persistent 30</span><br><span class="line">  -&gt; 192.168.206.21:80            Route   1      0          0         </span><br><span class="line">  -&gt; 192.168.206.22:80            Route   1      0          0         </span><br></pre></td></tr></table></figure><p>实施之后的效果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># curl 192.168.206.10</span></span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line">[root@node2 ~]<span class="comment"># curl 192.168.206.10</span></span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line">[root@node2 ~]<span class="comment"># curl 192.168.206.10</span></span><br><span class="line">&lt;h1&gt;It works! (From node3)&lt;/h1&gt;</span><br><span class="line">[root@node2 ~]<span class="comment"># </span></span><br><span class="line">[root@node2 ~]<span class="comment"># # After 30 seconds</span></span><br><span class="line">[root@node2 ~]<span class="comment"># curl 192.168.206.10</span></span><br><span class="line">&lt;h1&gt;It works! (From node2)&lt;/h1&gt;</span><br><span class="line">[root@node2 ~]<span class="comment"># curl 192.168.206.10</span></span><br><span class="line">&lt;h1&gt;It works! (From node2)&lt;/h1&gt;</span><br><span class="line">[root@node2 ~]<span class="comment"># curl 192.168.206.10</span></span><br><span class="line">&lt;h1&gt;It works! (From node2)&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>对于这个持久连接, 我们有多种实现方式:</p><ul><li>每端口持久, PPC, 单服务持久调度</li><li>每FWM持久, PFWMC, 防火墙标记持久: 只要你的标记一样 那么就是统一调度的</li><li>每客户端持久: PCC, 单客户端持久调度<ul><li>director会将用户的任何请求都识别成集群服务, 并且向RS中进行调度.</li></ul></li></ul><p>最后一个其实最好实现, 只要把一开始的端口设置成0就行了, 也就是所有服务之意. 每端口持久已经在之前演示过了, 那么现在还剩一个FWM持久. 其实就是在定义规则的时候指定标记,并且加上-p参数指明要进行持久化就行了.</p><h2 id="LVS的HA解决方案"><a href="#LVS的HA解决方案" class="headerlink" title="LVS的HA解决方案"></a>LVS的HA解决方案</h2><p>接下来我们再来聊聊LVS集群的高可用解决方案.</p><p>事实上, 通过之前的几次实验, 我们也可以看出来, LVS的隐患之一就是我们的director是SPOF, 也就是 单点故障所在(Single Point Of Failure). 当然了, 现在的所谓解决方案只是简单的说说一说, 以后会多次聊这个话题. 毕竟现在也快要万字了, 再扯下去也不太合适了. 所以就简单的介绍下:</p><p>首先从我们的director来看, 他是整个系统的关键. 首先我们为了做高可用, 说白了也就是做冗余. 首先就想到双份, 当然这是要花价钱的. 除了这个, 还有一种就是缩短平均修复时间, 但是这样需要一个技能过硬的运维攻城狮才行, 而且使用人来做这样的事情其实是不明智的, 我们应该选择自动化的方式进行. 这是前端主机.</p><p>另外, 如果我们的后端real server出现问题, 首先还是做双份, 但是这样就会变成整个的双份. 还可以再开一只主机, 同来充当冗余, 只要有主机宕掉, 就用它来顶替. 但是这样是需要考虑数据的存储问题. 还可以考虑director进行后端主机的健康状态检查, 只要发现有主机出现问题, 告警并且将该主机从调度列表中剔除, 完成自动的上下线. 那么, 如何进行健康状态检查呢?  首先我们想到了ping, 但是这样不能说明服务是OK的, 那么就考虑进行端口扫描, 比如使用nmap这样的来扫描, 但是端口响应了, 也不能说资源是OK的, 所以干脆直接对资源进行请求好了, 由此, 我们可以从IP层, 传输层, 应用层进行检查. 检查层次越高, 消耗越大, 但是精度也越高, 这个就要根据具体的业务来说了.</p><p>除了检查的方式 我们还需要考虑检查的频度以及状态判断. 多少时间检查一次呢? 如何才会判定一个主机是宕机了呢? 会出现误判断呢?</p><p>就先这样啦.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/MindMap/Cluster1_mind.png" alt="MindMap/Cluster1_mind.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Cluster </tag>
            
            <tag> LVS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx初识和Web服务配置</title>
      <link href="/2017/10/12/Nginx%E5%88%9D%E8%AF%86%E5%92%8CWeb%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/10/12/Nginx%E5%88%9D%E8%AF%86%E5%92%8CWeb%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>**<code>Engine-X</code>  not  <a href="https://www.nginx.com/resources/wiki/community/faq/#how-do-you-pronounce-nginx"><code>en-jinks</code></a>. ** </p><span id="more"></span><h2 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h2><p>Nginx, 我们可以说是一个Web Server, 不仅如此, 他还可以作为web reverse proxy. 关于反向代理以及一些缓存功能, 这里先不做涉及, 留在后面说. 不管怎么说, 我们还是先把HTTP协议复习一遍?</p><p><a href="https://yaoxuannn.com/2017/09/23/http%E5%8D%8F%E8%AE%AE%E5%92%8Chttpd/">HTTP协议</a></p><p>我们说过, HTTP Wed服务能够进行认证, 其中有基于IP的, 有基于用户的, 而这又分为基本认证(basic)和摘要认证(digest). 除了这个, 还有资源映射, 我们说过有Alias和DocumentRoot的映射. 另外,在现在各大站点的访问分析中, 一定会有PV和UV这两个重要的指标. PV就是指Page  View, 而UV就是User View了. 值得注意的是, 一个页面中肯定有很多资源, 我们说过浏览器会开启多线程去请求这些资源, 但是对于一个域名的线程上限是存在的. 正因为此, 有些网站为了提高用户的浏览速度, 就会把资源放在不同域名的服务器上, 这样浏览器就会对每一个域名开启多线程, 对于整个网站来说相当于是数倍的速度提升.</p><p>在说Apache httpd的时候, 我们说过有一个叫做MPM的模块. 三种: prefork, worker, event.</p><p>现在来看一下web I&#x2F;O模型相关.</p><h2 id="I-x2F-O模型"><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><p>显然, 我们先这样划分: 同步和异步 以及 阻塞和非阻塞(synchronous and asynchronous, block and nonblock)</p><p>对于异步IO, 他更多的关注的消息通知机制. 其实所谓IO, 就是存在一个调用方和一个提供服务方, 而调用方向服务方请求调用一个资源就是IO了. 主要是, 被调用方需要在自己的一方进行处理, 之后才会将结果返回到调用方, 那么问题就是, 调用方怎么知道他请求的资源已经被处理结束了呢? 所以这就是同步和异步的两种模式的区别, 同步就<strong>被调用方不会立即返回结果, 但是只要返回, 返回的就是最终结果</strong>; 而异步就不一样了, 被调用方<strong>会立即返回结果, 但是返回的结果只是消息, 不是最终结果. 当被调用方结束处理之后, 会通过状态, 通知机制来通知调用者, 或者通过回调函数的方式来处理结果</strong>.</p><p>接着我们再说说阻塞和非阻塞这两个家伙. 他们关注的东西其实是<strong>调用者等待被调用者返回调用结果的状态</strong>. 所谓阻塞, 调用者在结果返回之前, 会被挂起; 而这个时候调用者进入了一种<strong>不可中断的睡眠态</strong>, 只有当等到结果之后才能继续. 而非阻塞就相反了, 他不会被挂起, 也就是说调用不会阻塞自己.</p><p>要特别加一句: <strong>阻塞非阻塞和同步异步关注的点根本就不是一个, 所以他们之间其实没有什么必然的关系.</strong></p><p>这样的话, 我们就可以把IO模型分成5种:</p><ul><li>阻塞IO</li><li>非阻塞IO</li><li>IO多路复用</li><li>(信号|事件)驱动IO</li><li>异步IO</li></ul><p>接下来来解释一下他们. 以磁盘IO为例: <strong>read()操作</strong></p><p>用户空间是没有权限读取磁盘的对不? 所以应用程序发起IO请求的时候, 分成两步骤: ①请求内核但是内核没有数据, 所以内核加载内容到内核内存中, ②可是进程无法读取内核内存, 所以再次将数据复制到进程内存中. 这里被称作IO的过程是第二步.</p><p>首先是阻塞IO:</p><p><img src="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/files/06fig01.gif" alt="graphics/06fig01.gif"></p><p>在这种模型下, 进程挂起, 等到最终结果好了之后才继续. 很好理解, 接着来看非阻塞IO:</p><p><img src="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/files/06fig02.gif" alt="graphics/06fig02.gif"></p><p>在这种模式下, 进程虽然不会挂起, 但是会进入到一种忙等待的状态, 被调用方不会进行通知, 为了知道结果是否处理完成, 进程会进行长轮询, 这样的状态其实也是很消耗资源的, <strong>非阻塞不一定有阻塞的效率高</strong>. 根据情况, 这个时候可能阻塞了更好. 而且不仅如此, 看第二个阶段,其实还是阻塞的.</p><p>上面的两种都很好理解, 而且他们都很古老. 接着来看复用型IO.</p><p><img src="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/files/06fig03.gif" alt="graphics/06fig03.gif"></p><p>这个IO模型是一个比较稳定的IO模型, 很多应用都是基于这种模式构建的. 到底什么叫多路复用? 可以这么理解: 前两种模型都是把请求发给内核, 但是现在我们在内核和调用者之间加进了一个<em>代理</em> 这个代理,能够将用户的请求发给内核, 这样的好处是, 用户进程如果有多个请求, 他可以在代理发送结束之后, 将请求发送过去, 尽管内核是阻塞的, 但是我们却可以通过这个代理实现多路的请求. 不太明白吗? 我们来看一段代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先我们创建好套接字</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.setblocking(<span class="literal">False</span>)</span><br><span class="line">server.bind((<span class="string">&quot;localhost&quot;</span>, <span class="number">44444</span>))</span><br><span class="line"><span class="comment"># 接着声明三个list, 也就是注册在select上的读写异常事件</span></span><br><span class="line">inputs = [server]</span><br><span class="line">outputs = []</span><br><span class="line">exceptions = []</span><br><span class="line"><span class="comment"># 用作socket的消息队列</span></span><br><span class="line">msg_queue = &#123;&#125;</span><br><span class="line">server.listen()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Server listening on 127.0.0.1:44444&quot;</span>)</span><br><span class="line"><span class="comment"># 开始循环</span></span><br><span class="line"><span class="keyword">while</span> inputs:</span><br><span class="line">    readable, writable, exceptional = select.select(inputs, outputs, exceptions)</span><br><span class="line">    <span class="keyword">for</span> sock <span class="keyword">in</span> readable:</span><br><span class="line">        <span class="keyword">if</span> sock <span class="keyword">is</span> server:</span><br><span class="line">            conn, addr = sock.accept()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Connect from %s&quot;</span> % conn.getsockname()[<span class="number">0</span>])</span><br><span class="line">            conn.setblocking(<span class="literal">False</span>)</span><br><span class="line">            inputs.append(conn)</span><br><span class="line">            msg_queue[conn] = Queue()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = sock.recv(<span class="number">2048</span>)</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                msg_queue[sock].put(data)</span><br><span class="line">                <span class="keyword">if</span> sock <span class="keyword">not</span> <span class="keyword">in</span> outputs:</span><br><span class="line">                    outputs.append(sock)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;recv empty data, close&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> sock <span class="keyword">in</span> outputs:</span><br><span class="line">                    outputs.remove(sock)</span><br><span class="line">                inputs.remove(sock)</span><br><span class="line">                sock.close()</span><br><span class="line">                <span class="keyword">del</span> msg_queue[sock]</span><br><span class="line">    <span class="keyword">for</span> sock <span class="keyword">in</span> writable:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg_queue[sock].empty():</span><br><span class="line">            sock.send(msg_queue[sock].get_nowait())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            outputs.remove(sock)</span><br><span class="line">    <span class="keyword">for</span> sock <span class="keyword">in</span> exceptional:</span><br><span class="line">        <span class="keyword">if</span> sock <span class="keyword">in</span> outputs:</span><br><span class="line">            outputs.remove(sock)</span><br><span class="line">        inputs.remove(sock)</span><br><span class="line">        sock.close()</span><br><span class="line">        <span class="keyword">del</span> msg_queue[sock]</span><br></pre></td></tr></table></figure><p>这里我们使用的select做的演示. select是最早的一个多路复用系统调用, 我们注册想要获得响应的socket&#x2F;IO请求. 这个最早使用BSD实现的, 后来SysV模仿着搞出来了poll(), 他们两个其实没有什么太大的区别. select的最大限制1024个并发.</p><p>接着再来看看事件驱动式的IO:</p><p><img src="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/files/06fig04.gif" alt="graphics/06fig04.gif"></p><p>这个也好理解, 就是当第一阶段OK了, 发送一个信号就行了,当然了第二阶段还是阻塞的. 看看图就能理解了.</p><p>但是事件驱动IO有一个显而易见的问题: 当内核向进程发送第二个请求的通知的时候, 如果进程此时堵塞在第一个请求的第二个阶段. 那么会怎么样? 对于这样的情况, 有这样的解决方法, 我们提出两种通知机制:</p><ul><li>水平触发: 一直通知, 直到接受为止</li><li>边缘触发: 只通知一次, 如果没有回应, 就使用回调或者让调用者自己去取结果.</li></ul><p>我们今天的主角(?) – Nginx就是用了事件驱动IO和下面的异步IO.</p><p>为了解决阻塞的问题, 最后一种:</p><p><img src="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/files/06fig05.gif" alt="graphics/06fig05.gif"></p><p>异步IO. 用户进程只需要发出请求, 等到内核悄悄的根据进程的要求把一切都完成了之后, 发出信号通知就好了.</p><p>最后总结一下:</p><p><img src="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/files/06fig06.gif" alt="graphics/06fig06.gif"></p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx是个俄罗斯人搞出来的, 这个程序使用了当时最新的网络编程技术, 所以使得它在一开始就很受欢迎, 直到现在也依然是全球前三的Web服务器.</p><p>Nginx依靠一个高性能的网络编程库 – libevent, 其中调用的就是epoll().</p><p>现在就先来聊聊Nginx的特性:</p><p>模块化设计(非DSO), 较好的扩展性.</p><p>有着高可靠的应用, 使用一个主进程(master), 该进程不接受任何请求, 要做的是读取配置文件生成子进程(工作进程worker) 这些worker进程有多个用途: 缓存 反代, …</p><p>低内存消耗: 10000+keep-alive模式的connection, Nginx仅仅需要2.5M内存来维持.</p><p>支持热部署: 不停机使得配置文件更新, 日志文件滚动, 甚至支持<strong>版本</strong>平滑升级</p><p>支持事件驱动, 支持async, 支持内存映射机制.</p><p>缓存打开的fd文件描述符</p><p>http,smtp,pop3协议的反向代理服务器</p><blockquote><p><strong>反向代理</strong>是什么?</p><p>原先我们访问服务器, 是直接访问. 这样有很多缺点, 比如服务器的压力会变的很大, 而且不是那么安全. 于是我们就想到在服务器和用户之间加上一个隔离层, 这个隔离自己也有Web服务, 但是却不提供任何内容, 他会将请求重新构建报文发向后面的真正的Web服务器, 同时对静态内容作缓存, 使得下次访问更快速, 这个缓存一般都是以键值对的形式存储在内存中, 所以很快. </p></blockquote><p>支持缓存加速和负载均衡机制</p><p>支持fastcgi(fpm,LNMP), uWSGI(python)</p><p>过滤器, 图像大小调整, SSI.</p><p>支持url, rewrite, 路径别名, 基于IP和用户的访问控制</p><p>支持速率限制, 支持并发限制</p><p>来看看Nginx的架构特性:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/nginx.png" alt="nginx"></p><p>一个Master进程生成多个Worker进程. 下层可以看到缓存manger和loader.</p><p>之前说过了Nginx是基于模块的, 那么核心模块是什么? </p><p>核心模块被叫做<strong>Standard HTTP modules</strong>, 除了核心模块, 还有Optional HTTP modules, Mail modules以及3rd party modules.</p><h3 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h3><p>nginx在epel源中可以找到, 直接yum install就行. </p><blockquote><p>在这里扯一句..不知道为什么, 阿里的yum源教育网总是很慢?? 反而是Fedora官方的源稳定速度快..</p></blockquote><p>也可以使用rpm包, 也可以使用源码编译~ 这里我们来试试源码编译.</p><p>首先要确保开发环境包组已经安装, 接着nginx依靠一个<code>pcre-devel</code>, 所以需要先把这个装了.</p><p>首先我们还是添加nginx用户和组:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-CentOS7 ~]<span class="comment"># groupadd -r nginx</span></span><br><span class="line">[root@VM-CentOS7 ~]<span class="comment"># useradd -g nginx -r nginx</span></span><br><span class="line">[root@VM-CentOS7 ~]<span class="comment"># id nginx</span></span><br><span class="line">uid=997(nginx) gid=995(nginx) <span class="built_in">groups</span>=995(nginx)</span><br></pre></td></tr></table></figure><p>接下来就开始配置了, 关于选项可以查看<code>./configure --help</code>获得.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-CentOS7 nginx-1.12.1]<span class="comment"># ./configure --prefix=/usr/local/nginx --conf-path=/etc/nginx/nginx.conf --user=nginx --group=nginx --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx/nginx.pid --lock-path=/var/lock/nginx.lock --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module --with-http_flv_module --with-http_mp4_module --http-client-body-temp-path=/var/tmp/nginx/client --http-proxy-temp-path=/var/tmp/nginx/proxy --http-fastcgi-temp-path=/var/tmp/nginx/fastcgi --http-uwsgi-temp-path=/var/tmp/nginx/uwsgi</span></span><br></pre></td></tr></table></figure><p>这里我们开启流媒体支持, ssl支持, 指定临时文件目录等等…</p><p>接着就是<code>make &amp;&amp; make install</code>了. 完成了之后我们需要手动创建那些临时目录:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-CentOS7 nginx-1.12.1]<span class="comment"># mkdir -pv /var/tmp/nginx/&#123;fastcgi,uwcgi,proxy&#125;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory ‘/var/tmp/nginx’</span><br><span class="line"><span class="built_in">mkdir</span>: created directory ‘/var/tmp/nginx/fastcgi’</span><br><span class="line"><span class="built_in">mkdir</span>: created directory ‘/var/tmp/nginx/uwcgi’</span><br><span class="line"><span class="built_in">mkdir</span>: created directory ‘/var/tmp/nginx/proxy’</span><br></pre></td></tr></table></figure><p>接着启动nginx~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-CentOS7 nginx-1.12.1]<span class="comment"># PATH=/usr/local/nginx/sbin:$PATH</span></span><br><span class="line">[root@VM-CentOS7 nginx-1.12.1]<span class="comment"># nginx</span></span><br><span class="line">[root@VM-CentOS7 nginx-1.12.1]<span class="comment"># ps aux | grep nginx</span></span><br><span class="line">root      29262  0.0  0.1  45912  1128 ?        Ss   20:07   0:00 nginx: master process nginx</span><br><span class="line">nginx     29263  0.0  0.1  46360  1904 ?        S    20:07   0:00 nginx: worker process</span><br></pre></td></tr></table></figure><p>可以看到有启动了两个进程, 一个主进程, 一个工作进程. 而且, 工作进程的用户是nginx, 只有主进程的用户才是root.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-CentOS7 nginx-1.12.1]<span class="comment"># curl -I http://192.168.206.138</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.13.6</span><br><span class="line">Date: Fri, 13 Oct 2017 12:13:25 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 612</span><br><span class="line">Last-Modified: Fri, 13 Oct 2017 12:04:37 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: <span class="string">&quot;59e0abd5-264&quot;</span></span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><p>就是这么简单~ 接下来按照惯例, 我们来看看配置文件吧:</p><p>nginx的配置文件主要有下面的几个部分构成:</p><ul><li>main配置: 全局配置</li><li>event配置: 定义event工作模型的相关特性</li><li>http {}: 定义http协议的相关设定</li></ul><p>要注意的是: nginx的配置指令需要使用分号作为结尾:</p><p><code>derective value1 [value2...]</code></p><p>配置同样支持使用变量: 首先会有很多内置变量, 接着还可以使用set指令进行自定义变量的声明.</p><p><code>set var_name value</code> </p><p>我们先从主配置段开始, 主要分成四类:</p><p><strong>用于调试,定位问题的, 正常运行的必备配置, 优化性能的配置, 事件相关的配置</strong></p><h3 id="Nginx的配置"><a href="#Nginx的配置" class="headerlink" title="Nginx的配置"></a>Nginx的配置</h3><p>首先来看主配置段的设置, </p><p>| Syntax:  | <strong><code>user</code></strong> <em>user</em> [<em>group</em>]; |<br>| Default: | <code>user nobody nobody;</code>        |</p><p>声明启动用户, 用户组可选. 由于我们在配置的时候已经指明了, 所以这个选项在我们的配置文件中已经被注释掉了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br></pre></td></tr></table></figure><p>| Syntax:  | <strong>pid</strong> <em>file</em>;  |<br>| Default: | <code>pid nginx.pid;</code> |</p><p>声明nginx守护进程的pid文件. 很好理解</p><p>| Syntax:  | <strong>worker_rlimit_nofile</strong> <em>number</em>; |<br>| Default: | —                                  |</p><p>就是所有worker进程的最大文件句柄数, 默认是1024来着. 用户能打开的(ulimit -n)</p><p>与此相关的还有一个:</p><p>| Syntax:  | <strong>worker_rlimit_core</strong> <em>size</em>; |<br>| Default: | —                              |</p><p>这个是在说打开的文件大小峰值, 不过一般都不需要调整.</p><p>以上是我们说的<strong>正常运行的必备配置</strong>. 接着来看一下<strong>性能优化相关</strong></p><p>| Syntax:  | <strong>worker_processes</strong> <em>number</em> | auto; |<br>| Default: | <code>worker_processes 1;</code>                  |</p><p>worker进程的数量, 通常 这个值略少于物理CPU的核心数.</p><p>| Syntax:  | <strong>worker_cpu_affinity</strong> <em>cpumask</em>; <strong>worker_cpu_affinity</strong> auto [<em>cpumask</em>]; |</p><p>整个选项主要是为了将一个Nginx的进程绑定到某个CPU上, 这样的好处是, 可以提升命中该CPU的cache的命中率.而不会随着CPU切换导致缓存丢失</p><p>什么是cpumask啊, 如果你有三颗CPU, 那么他们的掩码就是<code>00000001</code>, <code>00000010</code>, <code>00000100</code>, 如果还有第四颗那就是<code>00001000</code>. </p><p>| Syntax:  | <strong>timer_resolution</strong> <em>interval</em>; |<br>| Default: | —                                |</p><p>这个是说调整进程的计时器解析度, 什么玩意? 其实就是发起<code>gettimeofday()</code>这么一个系统调用的频率, 我们知道发起系统调用就一定伴随着软中断. 通过降低这个, 就可以达到优化性能的要求.</p><p>| Syntax:  | <strong>worker_priority</strong> <em>number</em>; |<br>| Default: | <code>worker_priority 0;</code>          |</p><p>听名字就知道是干什么的, 其实这个选项就是NICE值, 我们之前说过nice这个命令, 从-20到20.</p><p>接着我们看一下<strong>事件相关的设定</strong></p><p>| Syntax:  | <strong>accept_mutex</strong> on | off; |<br>| Default: | <code>accept_mutex off;</code>         |</p><p>mutex叫做互斥锁(?), 简单的说, 如果开启, worker就会进行轮流的响应, 也就是master调度用户请求负载均衡的到每一个worker上, workers序列化的响应. 但是如果你的系统支持 <code>EPOLLEXCLUSIVE</code> (Linux 4.5, glibc 2.24) 就不需要开启这个选项了.</p><p>| Syntax:  | <strong>accept_mutex_delay</strong> <em>time</em>; |<br>| Default: | <code>accept_mutex_delay 500ms;</code>    |</p><p>如果上面的互斥锁开启了, 那么这个选项指定的就是当请求轮到下一个worker, 但是该worker正忙,等到多少时间的选项, 如果超时选择下一个. 不是那么关键了</p><p>| Syntax:  | <strong>lock_file</strong> <em>file</em>;        |<br>| Default: | <code>lock_file logs/nginx.lock;</code> |</p><p>这个就是上面的那个锁文件的路径.</p><p>| Syntax:  | <strong>use</strong> <em>method</em>; |<br>| Default: | —                 |</p><p>用来指定使用的事件模型. 不过这个选项不推荐手动执行, 因为Nginx会选择最优化最有效的机制.</p><p>| Syntax:  | <strong>worker_connections</strong> <em>number</em>; |<br>| Default: | <code>worker_connections 512;</code>        |</p><p>单个worker能处理的最大连接数.  这也是一个很重要的参数.</p><p>接着来看看<strong>用于调试, 定位问题</strong>的选项:</p><p>这个调试不是说调就调的, 首先你需要在编译的时候加上选项才可以:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-CentOS7 nginx-1.12.1]<span class="comment"># ./configure --help | grep debug</span></span><br><span class="line">  --with-debug                       <span class="built_in">enable</span> debug logging</span><br></pre></td></tr></table></figure><p>| Syntax:  | <strong>daemon</strong> on | off; |<br>| Default: | <code>daemon on;</code>          |</p><p>很好理解了, 就是说是否作为后台进程. 有点像很多进程的-D -d区别. 反正就是前台后台了</p><p>| Syntax:  | <strong>master_process</strong> on | off; |<br>| Default: | <code>master_process on;</code>          |</p><p>是否使用master-worker进程模型.</p><p>| Syntax:  | <strong>error_log</strong> <em>file</em> [<em>level</em>];   |<br>| Default: | <code>error_log logs/error.log error;</code> |</p><p>配置错误日志功能. 如果想要获得debug的级别, 需要在编译的时候加上–with-debug的选项.</p><p>接着我们稍微做一下修改:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  2;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  10240;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是要使得nginx能够重读配置文件了, 这里我们可以向nginx发送信号:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-CentOS7 ~]<span class="comment"># nginx -s reload</span></span><br></pre></td></tr></table></figure><p>接着查看ps aux:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-CentOS7 ~]<span class="comment"># ps aux | grep nginx</span></span><br><span class="line">root      32061  0.0  0.1  45944  1952 ?        Ss   Oct13   0:00 nginx: master process nginx</span><br><span class="line">nginx     33065  0.0  0.5  50196  5724 ?        S    02:35   0:00 nginx: worker process</span><br><span class="line">nginx     33066  0.1  0.5  50196  5724 ?        S    02:35   0:00 nginx: worker process</span><br></pre></td></tr></table></figure><p>worker多了一个吧~</p><blockquote><p>如果你提示nginx: command not found. 原因很简单了, 我们编译安装的嘛~所以需要添加到PATH里哦.</p></blockquote><p>除了reload, 还有 quit, stop, reopen这些.</p><p>现在我们说说Nginx作为Web服务器的相关配置:</p><p>所有的相关配置都在http {}中(我们把他叫做上下文), 由http的核心模块 – <code>ngx_http_core_module</code>引入. 这个模块的选项特别多, 而且引入了很多内嵌变量.</p><p>上下文里面还可以添加上下文, http其中会出现server这么个上下文,  而在server上下文中又会出现location上下文, 一个server上下文有点类似httpd中的<code>&lt;VirtualHost&gt;</code>, 这里的location类似httpd的<code>&lt;Location&gt;</code>, 用于定义URL与本地文件系统的映射关系. 而localtion也可以不只有一个, 并且还可以搭配if条件判断语句使用.</p><p>我们来整体看一下配置框架 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  upstream &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  server &#123;</span><br><span class="line">    location URL &#123;</span><br><span class="line">      root <span class="string">&quot;/path/to/somedir&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    location URL &#123;</span><br><span class="line">      <span class="keyword">if</span> ... &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  server &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>框架就是这样了, 现在就这个框架看看常见的配置项目. 我们直接把默认的配置贴着说:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line">    ...(omitted)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在后面加上一个最小化的server:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name www.yaoxuannn.com;</span><br><span class="line">    root <span class="string">&quot;/vhost/web1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们创建一下目录和index文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-CentOS7 ~]<span class="comment"># mkdir -pv /vhost/web1/</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory ‘/vhost’</span><br><span class="line"><span class="built_in">mkdir</span>: created directory ‘/vhost/web1/’</span><br><span class="line">[root@VM-CentOS7 ~]<span class="comment"># echo &quot;&lt;h1&gt;It works WEB1&lt;/h1&gt;&quot; &gt; /vhost/web1/index.html</span></span><br></pre></td></tr></table></figure><p>这个时候, 我们可以在重新载入文件之前检查一下配置, 没有问题的话就重启吧.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-CentOS7 ~]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">[root@VM-CentOS7 ~]<span class="comment"># nginx -s reload</span></span><br></pre></td></tr></table></figure><p>这么简单的一个虚拟主机就建好了, 是不是超简单. 但是回过头来, 其实这些选项都很有说头:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name www.yaoxuannn.com;</span><br><span class="line">    root <span class="string">&quot;/vhost/web1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><p>首先: listen, 这里可以跟地址(加端口, 不加默认80), 也可以直接端口, 也可以直接写上Unix套接字. 不仅如此, 后面可以跟上超多的选项, 但是..应该用的不多吧.</p><h4 id="server-name"><a href="#server-name" class="headerlink" title="server_name"></a>server_name</h4><p>接着: server_name, 这个选项可以使用多个值, 也可以使用通配符, 甚至可以使用正则表达式, 但是要写上<code>~</code>来说明后面跟着正则表达式. 而匹配的顺序就是先做精确匹配, 接着做左侧通配符检查, 然后是右侧通配符检查, 再然后是正则表达式匹配检查, 最后使用default server, 没有的话就用第一个.</p><h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><p>接下来我们说说**<code>location</code>**这个是一个很重要的属性, 而且有些难以理解:</p><p>location其实有两种用法, 但是一般都只是用第一个:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;</span><br><span class="line">location @name &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>location可以根据用户的请求URL的不同来匹配不同的配置项. 一个server中有多个location, 每一个location块客户已实现访问控制等等诸多功能. 由于可以存在多个, 他也有自己的优先级. </p><p>可以看到后面有很多不同的符号, 这些符号的意义不一. <code>=</code>表示请求匹配检查, 一个字符不一样就不匹配. <code>~</code>正则表达式匹配, 区分大小写. <code>~*</code>正则表达式匹配, 不区分大小写. <code>^~</code>: URI的前半部分匹配, 不检查正则.</p><p>优先级最高的就是精确匹配(&#x3D;), 接着依次是<code>^~</code>, <code>~</code>, <code>~*</code>,以及最后的不携带符号的.</p><h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4><p>接着我们说一说别名(alias),  这个玩意同样是为了实现路径映射的. 这里我们对root和alias做一个对比你就知道是区别是什么了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location /image &#123;</span><br><span class="line">  root <span class="string">&quot;/web/static&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request: http://localhost/image/pic.png --&gt; <span class="string">&quot;/web/static/image/pic.png&quot;</span></span><br><span class="line"></span><br><span class="line">location /image/ &#123;</span><br><span class="line">  <span class="built_in">alias</span> <span class="string">&quot;/web/static/&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request: http://locahost/image/pic.png --&gt; <span class="string">&quot;/web/static/pic.png&quot;</span></span><br></pre></td></tr></table></figure><p>注意到我在写alias的时候在右边加上了&#x2F;. 这就是alias所替换的地方, 而root替换的是左边的根.</p><h4 id="index"><a href="#index" class="headerlink" title="index"></a>index</h4><p>在httpd的时候, 我们使用index来指定哪一个做默认主页, 但是在Nginx中, 这个事情有一个专门的模块在负责.</p><p>来看一下 <a href="http://nginx.org/en/docs/http/ngx_http_index_module.html">http_index_module</a> 其实很简单:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">    index index.html index.php;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先搜索左边的, 没有的话就继续找后面的.</p><h4 id="error-page"><a href="#error-page" class="headerlink" title="error_page"></a>error_page</h4><p>接着再说说错误页面, 也很简单:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error_page 404             /404.html;</span><br><span class="line">error_page 500 502 503 504 /50x.html;</span><br></pre></td></tr></table></figure><p>通过错误码和位置就可以了. 同时, 我们也可以重定向到别的位置. 不仅如此, 我们还可以覆盖状态码, 在状态码和位置的中加上<code>=code</code>就行了(但是要求必须是自定义404页面才可以), 我们试一试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">error_page  404              /404.html;</span><br><span class="line"><span class="comment"># 这是默认的配置</span></span><br><span class="line"><span class="comment"># 接着我们访问一下</span></span><br><span class="line">[root@VM-CentOS7 ~]<span class="comment"># curl -I http://192.168.206.138/non-exist.html</span></span><br><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">Server: nginx/1.12.1</span><br><span class="line">Date: Fri, 13 Oct 2017 20:45:30 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 169</span><br><span class="line">Connection: keep-alive</span><br><span class="line"><span class="comment"># 404状态码, 接着我们修改配置</span></span><br><span class="line">error_page  404     =200         /404.html;</span><br><span class="line">[root@VM-CentOS7 ~]<span class="comment"># curl -I http://192.168.206.138/non-exist.html</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.12.1</span><br><span class="line">Date: Fri, 13 Oct 2017 20:51:55 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 3</span><br><span class="line">Last-Modified: Fri, 13 Oct 2017 20:51:16 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: <span class="string">&quot;59e12744-3&quot;</span></span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><p>于是就变成200了.</p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>接着我们扯扯 <strong>访问控制</strong>.</p><p>首先是基于IP的访问控制, 很简单的两个指令. allow和deny.我们只要在后面加上{主机IP|网络地址|ALL}就可以实现了. 这就是基于IP的访问控制. 接着看看基于用户的访问控制, 和httpd一样, Nginx也支持basic和digest两种形式的认证. 有趣的是, basic的密码文件建议使用htpasswd来创建. 对于basic认证, 需要指明两个选项:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth_basic <span class="string">&quot;Only for admin.&quot;</span>;</span><br><span class="line">auth_basic_user_file /etc/nginx/users/.htpasswd;</span><br></pre></td></tr></table></figure><p>我们使用htpasswd来创建那个密码文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-CentOS7 <span class="built_in">users</span>]<span class="comment"># htpasswd -c -m /etc/nginx/users/.htpasswd justin</span></span><br><span class="line">New password: </span><br><span class="line">Re-<span class="built_in">type</span> new password: </span><br><span class="line">Adding password <span class="keyword">for</span> user justin</span><br><span class="line">[root@VM-CentOS7 <span class="built_in">users</span>]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">[root@VM-CentOS7 <span class="built_in">users</span>]<span class="comment"># nginx -s reload</span></span><br></pre></td></tr></table></figure><p>接着再次访问就可以了.</p><h4 id="ssl"><a href="#ssl" class="headerlink" title="ssl"></a>ssl</h4><p>接着我们再试试把nginx设置成为ssl. 已经搞过好几次了, 这次还是直接走流程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-CentOS7 ~]<span class="comment"># cd /etc/pki/CA/</span></span><br><span class="line">[root@VM-CentOS7 CA]<span class="comment"># (umask 077; openssl genrsa -out ./private/cakey.pem 2048)</span></span><br><span class="line">Generating RSA private key, 2048 bit long modulus</span><br><span class="line">.............+++</span><br><span class="line">..................................................+++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">[root@VM-CentOS7 CA]<span class="comment"># openssl req -x509 -new -key private/cakey.pem -out cacert.pem -days 3650</span></span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter <span class="string">&#x27;.&#x27;</span>, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [XX]:CN</span><br><span class="line">State or Province Name (full name) []:HB</span><br><span class="line">Locality Name (eg, city) [Default City]:WH</span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:NetCool</span><br><span class="line">Organizational Unit Name (eg, section) []:Ops</span><br><span class="line">Common Name (eg, your name or your server<span class="string">&#x27;s hostname) []:ca.yaoxuannn.com</span></span><br><span class="line"><span class="string">Email Address []:admin@yaoxuannn.com    </span></span><br><span class="line"><span class="string">[root@VM-CentOS7 CA]# echo 01 &gt; serial </span></span><br><span class="line"><span class="string">[root@VM-CentOS7 CA]# touch index.txt</span></span><br></pre></td></tr></table></figure><p>自签证书创建完成. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-CentOS7 CA]<span class="comment"># cd /etc/nginx/</span></span><br><span class="line">[root@VM-CentOS7 nginx]<span class="comment"># mkdir ssl</span></span><br><span class="line">[root@VM-CentOS7 nginx]<span class="comment"># cd ssl/</span></span><br><span class="line">[root@VM-CentOS7 ssl]<span class="comment"># (umask 077; openssl genrsa -out nginx.key 1024)</span></span><br><span class="line">Generating RSA private key, 1024 bit long modulus</span><br><span class="line">..............++++++</span><br><span class="line">..............++++++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">[root@VM-CentOS7 ssl]<span class="comment"># openssl req -new -key nginx.key -out nginx.csr</span></span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter <span class="string">&#x27;.&#x27;</span>, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [XX]:CN</span><br><span class="line">State or Province Name (full name) []:HB</span><br><span class="line">Locality Name (eg, city) [Default City]:WH    </span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:NetCool</span><br><span class="line">Organizational Unit Name (eg, section) []:Ops</span><br><span class="line">Common Name (eg, your name or your server<span class="string">&#x27;s hostname) []:yaoxuannn.com</span></span><br><span class="line"><span class="string">Email Address []:admin@yaoxuannn.com</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Please enter the following &#x27;</span>extra<span class="string">&#x27; attributes</span></span><br><span class="line"><span class="string">to be sent with your certificate request</span></span><br><span class="line"><span class="string">A challenge password []:</span></span><br><span class="line"><span class="string">An optional company name []:</span></span><br><span class="line"><span class="string">[root@VM-CentOS7 ssl]# openssl ca -in nginx.csr -out nginx.crt -days 3650</span></span><br><span class="line"><span class="string">Using configuration from /etc/pki/tls/openssl.cnf</span></span><br><span class="line"><span class="string">Check that the request matches the signature</span></span><br><span class="line"><span class="string">Signature ok</span></span><br><span class="line"><span class="string">Certificate Details:</span></span><br><span class="line"><span class="string">        Serial Number: 1 (0x1)</span></span><br><span class="line"><span class="string">        Validity</span></span><br><span class="line"><span class="string">            Not Before: Oct 14 04:27:39 2017 GMT</span></span><br><span class="line"><span class="string">            Not After : Oct 12 04:27:39 2027 GMT</span></span><br><span class="line"><span class="string">        Subject:</span></span><br><span class="line"><span class="string">            countryName               = CN</span></span><br><span class="line"><span class="string">            stateOrProvinceName       = HB</span></span><br><span class="line"><span class="string">            organizationName          = NetCool</span></span><br><span class="line"><span class="string">            organizationalUnitName    = Ops</span></span><br><span class="line"><span class="string">            commonName                = yaoxuannn.com</span></span><br><span class="line"><span class="string">            emailAddress              = admin@yaoxuannn.com</span></span><br><span class="line"><span class="string">        X509v3 extensions:</span></span><br><span class="line"><span class="string">            X509v3 Basic Constraints: </span></span><br><span class="line"><span class="string">                CA:FALSE</span></span><br><span class="line"><span class="string">            Netscape Comment: </span></span><br><span class="line"><span class="string">                OpenSSL Generated Certificate</span></span><br><span class="line"><span class="string">            X509v3 Subject Key Identifier: </span></span><br><span class="line"><span class="string">                89:29:C1:01:5D:B9:B6:07:00:53:16:A0:49:3C:D2:D9:FB:50:49:0F</span></span><br><span class="line"><span class="string">            X509v3 Authority Key Identifier: </span></span><br><span class="line"><span class="string">                keyid:CE:97:5A:DC:80:5A:A0:A1:F9:3A:8E:76:0E:89:5E:F7:29:62:4E:65</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Certificate is to be certified until Oct 12 04:27:39 2027 GMT (3650 days)</span></span><br><span class="line"><span class="string">Sign the certificate? [y/n]:y</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1 out of 1 certificate requests certified, commit? [y/n]y</span></span><br><span class="line"><span class="string">Write out database with 1 new entries</span></span><br><span class="line"><span class="string">Data Base Updated</span></span><br></pre></td></tr></table></figure><p>证书签署完成. 接下来就是配置nginx了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    server_name  yaoxuannn.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate      /etc/nginx/ssl/nginx.crt;</span><br><span class="line">    ssl_certificate_key  /etc/nginx/ssl/nginx.key;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证配置接着重载配置就行了 ( 当然了, 这是自签的. 所以浏览器肯定会提示不安全. 你也可以选择把自己加入进去~ )</p><h4 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h4><p>没有问题了, 接着来看看rewrite, 这个指令可以URL重写, 来看一个示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^/image/(.*\.jpg)$ /img/<span class="variable">$1</span> <span class="built_in">break</span>;</span><br></pre></td></tr></table></figure><p>这个指令会将: XXXX.com&#x2F;image&#x2F;1.jpg &#x3D;&#x3D;&gt; XXXX.com&#x2F;img&#x2F;1.jpg</p><p>这种操作对于用户而言是透明的, 也就是说用户并不能发觉自己访问的地方是另外一个位置, 服务器悄悄的更换了URL.</p><p>前面的好说, 就是查找替换嘛, 主要说说最后面的那个flag.</p><ul><li>last : 就是说在更换了之后, 不再进行后面的规则匹配, 接着User Agent重发请求, 在从头开始执行前面的过程, <strong>有可能会进入死循环</strong>. </li><li>break : 一旦此规则重写完成就不会再被任何重写规则进行检查, 新请求也不会被当前location中的任何规则检查.</li><li>redirect : 以302响应码返回新的URL.</li><li>permanent : 以301响应码进行永久重定向.</li></ul><p> 一般情况下, redirect和permanent用的不多, 他们会直接改变用户请求的URL, 因为30X状态码嘛~</p><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>接着我们再来说说if条件判断, 可以在server和location中使用. 语法是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>先来看一下condition有哪些: </p><ul><li>变量名, 空值和0起始的(包括0)认定为False, 否则均为True</li><li>以变量为操作数的比较表达式, 可以使用 &#x3D;, !&#x3D;类似的比较操作符</li><li>以正则表达式的模式匹配, 还是那两个 <code>~</code> 和 <code>~*</code> .也可以在前面加上<code>!</code>取反. </li><li>测试指定路径是否为文件, -f和!-f</li><li>测试指定路径是否为目录, -d和!-d</li><li>测试文件存在性, -e和!-e</li><li>检查文件是否有执行权限, -x和!-x</li></ul><p>一个典型应用就像这样: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~* IE) &#123;</span><br><span class="line">    rewrite ^(.*)$ /msie/<span class="variable">$1</span> <span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h4><p>如何为站点加上防盗链呢? 其实防盗的原理就是根据请求的referer判断的, 因此我们只需要设定允许访问的来源就好了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~*(gif|jpeg|png|jpg)$ &#123;</span><br><span class="line">  valid_referer none blocked yaoxuannn.com;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">$invalid_referer</span>) &#123;</span><br><span class="line">    rewrite ^/ http://yaoxuannn.com/403.html</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定制日志格式"><a href="#定制日志格式" class="headerlink" title="定制日志格式"></a>定制日志格式</h4><p>回过头来有说到了日志格式, 在httpd的时候我们说使用%符来说明, 但是现在我们使用的就是nginx的各个内建变量了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                  <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                  <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line">access_log  logs/access.log  main;</span><br></pre></td></tr></table></figure><p><strong>以上就是对http相关的一些基本的设定选项了. 除了http, 还有一些关于连接的设定也很重要</strong></p><p>(我知道我写的很乱…但是都试一试就行了~)</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">keepalive_timeout</span> <span class="comment">#; # 长连接的超时时长</span></span><br><span class="line">keepalive_requests <span class="comment">#; # 一个长连接上所能够允许的请求的</span></span><br><span class="line">keepalive_disable [msie6|safari|<span class="literal">none</span>]; <span class="comment"># 为指定类型的UserAgent禁用长连接</span></span><br><span class="line"><span class="attribute">tcp_nodelay</span> <span class="literal">on</span>|<span class="literal">off</span>; <span class="comment"># 是否对长连接使用TCP_NODELAY选项</span></span><br><span class="line"><span class="attribute">client_header_timeout</span> <span class="comment">#; # 读取http请求报文首部的超时时长</span></span><br><span class="line">client_body_timeout <span class="comment">#; # 读取http请求报文主体的超时时长</span></span><br><span class="line">send_timeout <span class="comment">#; 发送响应报文的超时</span></span><br></pre></td></tr></table></figure><p>更多的选项以后再说道反向代理的时候再说.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/MindMap/Nginx_mind.png" alt="MindMap/Nginx_mind.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Nginx </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iptables</title>
      <link href="/2017/10/10/iptables/"/>
      <url>/2017/10/10/iptables/</url>
      
        <content type="html"><![CDATA[<p>Linux的防火墙 – iptables.</p><span id="more"></span><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>说道iptables, 自然就会想到这个词 – <strong>Firewall</strong>. 那么自然就会有一个疑问, 什么是防火墙? 类比我们商场里的防火卷帘门, 防火墙就是起到隔离的作用的.</p><p>既然是隔离作用, 那么自然防火墙就会工作在主机或者网络的边缘 这样才可以对进出的网络报文进行检查, 接着而按照使用者指定的规则做响应的决策. 这个防火墙不一定非要是软件, 也有可能是硬件或者两者综合.</p><p>在Linux中, 网络功能由内核提供, 所以自然这个防火墙就是工作在内核空间的. </p><p>那么, 防火墙是由网卡驱动程序提供的吗? 或者说网卡驱动程序能够提供防火墙的功能吗? 肯定是不能的, 原因很简单, 所谓驱动程序本身是没有理解报文的能力的, 而且作为驱动, 同时提供隔离匹配(这要求理解协议), 这显然是不合设计的. 这样, TCP&#x2F;IP协议栈十分庞大, 我们到底应该把防火墙的位置放到哪里呢?</p><p>我们来顺一遍网络上发向本机的报文是怎么走的: 首先发送到网卡, 接着顺着协议栈经过内核到达<strong>注册在某端口上的某应用程序上.</strong> 除了这个, 还可能会有目标不是本机, 但是我们负责转发的一种(也就是核心转发). 这也要求经过拆包查看目的地址, 区别在于, 这种情况没有经过用户空间.</p><p>反过来, 我们也是可以访问别人的. 这就是发出去的报文, 同样会经过TCP&#x2F;IP协议栈.</p><p>情形很多, 所以我们就不得不在<strong>入口, 出口, 转发通道</strong>上都做检查. 这样也就构成了一个防火墙的<strong>框架</strong>. 并不是一个单独的软件. </p><p>也即是说: 防火墙是设计者在TCP&#x2F;IP协议栈中精心选择多个地方放置了一些<strong>钩子函数</strong>.</p><p>回到正题, iptables是什么?  我们能够使用iptables命令, 这就说明iptables是工作在用户空间的. 我们所说的iptables其实是两个部分构成的:</p><ul><li>一个是内核中的钩子, 也就是netfilter</li><li>另外一个就是负责管理规则的工具iptables</li></ul><p>真正实现拦截检测的框架是netfilter, 但是没有规则, 这些钩子一点用处都没有. 所以他们两个缺谁都不行.</p><p>另外, 我们申明一个很重要的点: <strong>iptables不是服务, 他没有在你的主机上运行任何进程! 只不过是在开机的时候, 你的配置文件被重新读取了一遍, 规则被重新加载了一遍罢了. 一个在内核中实现的功能, 根本不需要进程和服务!</strong></p><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p>现在回到正题, 我们来说说今天的主角. 早期的Linux版本, 内核中是没有这个神奇的小玩意的 而著名的BSD中有一个版本, 号称最安全的BSD发行版中, 存在一个防火墙. 这个时期, Linux刚刚诞生, 所以也模仿着这个做了一个ipfw, 过一段时间之后, 大家发现这个ipfw过于简陋, 也是开始添加一些规则, 规则多了之后就形成了一条条的链子, 因此改名叫做ipchains. 再后来, 为了扩展防火墙的功能, 能使每一个钩子的用法更加多元化.(过滤,转换.) 这样就使得每一个钩子上既有链(行), 又有一条条不同的规则(列). 即形成了一张行列交错的表. 这就是iptables的由来.</p><p>之所以叫table, 就是因为他可以过滤(filter), 转换(nat), 拆分重组(mangle), 关闭连接追踪(raw, 不过用的不多,因为连接追踪是防火墙一个很重要的功能, 但是对于前端大并发的负载均衡服务器上,应该关闭此功能), 这些就是我们说的4表.(其实还以一个security功能, 但不常用)</p><p>接下来就来说说很多人都听说过的内置的5链:</p><p><strong>PREROUTING</strong><br><strong>INPUT</strong><br><strong>FORWARD</strong><br><strong>OUTPUT</strong><br><strong>POSTROUTING</strong> </p><p>我们报文的状态有以下三种: 流入, 流出, 转发. 其中转发的报文有流出也有流入的. 所有流入的报文都会经过PREROUTING –&gt; INPUT, 而流出的报文会经过OUTPUT –&gt; POSTROUTING, 最后, 转发的报文的状态是PREROUTING –&gt; FORWARD –&gt; POSTROUTING. 这就是对链的说明.</p><p>而结合这些链, 对于表的功能, 我们做如下的说明: filter, 过滤的适用范围一般只有INPUT, FORWARD, OUTPUT这些, 对于剩下的两个, 由于有点远, 所以尽量就不做设定. nat仅在PREROUTING, OUTPUT, POSTROUTING这些时刻做设定, raw从功能看, 也仅仅作用在PREROUTING和OUTPUT.</p><p>我们用一张图来说明: ( 不知道为什么我在网上找的图都是raw可用于POSTROUTING, 可是实验表明不能, 很疑惑, 可能是版本问题? )</p><p><img src="http://images.cnitblog.com/blog2015/569491/201503/071933304925554.png" alt="img"></p><blockquote><p>附: 实验结果:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/iptables6.png" alt="iptables6"></p><p>和CentOS7的:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/iptables7.png" alt="iptables7"></p></blockquote><p>其实在这些过程中, 最令人产生疑惑的地方就是: <strong>路由发生的时刻</strong> 就这个问题, 我们来看看:</p><p>当报文进入本机的时候, 我们要判断目标主机; 在报文发出之前, 我们要判断经过哪个接口送往下一跳.</p><p>这样就对整个报文的流经过程很清晰了, 但是现在遗漏了一个重要的问题: iptables的规则检查机制.</p><h3 id="iptables-的法则"><a href="#iptables-的法则" class="headerlink" title="iptables 的法则"></a>iptables 的法则</h3><p>链: 链上的规则次序, 即使检查的次序, 因此隐含一定的法则</p><p><strong>(1)</strong> 同类规则, 匹配范围小的放下面; 比如说: 172.16.0.0&#x2F;16:ssh ACCEPT 172.16.0.1&#x2F;16:ssh REJECT. 这个时候就会优先匹配1那一台主机的, 但是如果是172.16.0.2:http ACCEPT就和这些一点关系都没有. 因为不是同类.</p><p><strong>(2)</strong> 不同类规则, 频率大的报文放上面(优先)</p><p><strong>(3)</strong> 设置默认策略, 如果没有规则, 则使用默认规则. 有两种: 白名单和黑名单. <em>白名单也不一定就是放行规则</em> </p><p>如同路由聚合一样, 我们也可以将多个规则合并成一个. 这样更快, 更整洁.</p><p>还是马哥的图好:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/iptables0.png" alt="iptables0"></p><p>接下来的一个匹配规则就是表级的, 对于一个一个表来说, 有很多链, 这些链的优先级如上图所示, 用文字表示就是:</p><blockquote><p>**<code>raw --&gt; mangle --&gt; nat --&gt; filter</code> ** </p></blockquote><p>除了iptables和netfilter, 我们需要手写规则, 这些规则是特定的组成部分的, 首先最必要的就是报文的匹配条件, 说白了就是协议报文的特征指定, 最根本的就是源IP, 源端口,目标IP,目标端口, 这些称作基本匹配. 严格一点的, 我可以进行连接追踪, 状态追踪, MAC探查,甚至硬件特性等, 这些就是扩展匹配.</p><p>匹配完毕之后就是处理机制: DROP, REJECT, ACCEPT 这些是内建处理机制, 还有自定义(也就是自定义链)机制. 由于我们的自定义链不能出现在报文流经的地方, 所以仅仅只能通过引用来生效.</p><p>iptables能够使我们编辑规则, 接着即时生效, 所以叫做规则管理工具嘛~ 包括添加, 修改, 删除, 显示. 他还可以进行规则编写的语法检查.</p><p>有意思的是, 我们的规则和链是有计数器的, 还有两种, 一种就是按照包的个数计数的, 一种就是按照报文大小之和计数的.</p><p>OK, 接下来就进入正题.</p><h2 id="iptables命令"><a href="#iptables命令" class="headerlink" title="iptables命令"></a>iptables命令</h2><p>命令格式很好记:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -h</span></span><br><span class="line">iptables v1.4.21</span><br><span class="line"></span><br><span class="line">Usage: iptables -[ACD] chain rule-specification [options]</span><br><span class="line">       iptables -I chain [rulenum] rule-specification [options]</span><br><span class="line">       iptables -R chain rulenum rule-specification [options]</span><br><span class="line">       iptables -D chain rulenum [options]</span><br><span class="line">       iptables -[LS] [chain [rulenum]] [options]</span><br><span class="line">       iptables -[FZ] [chain] [options]</span><br><span class="line">       iptables -[NX] chain</span><br><span class="line">       iptables -E old-chain-name new-chain-name</span><br><span class="line">       iptables -P chain target [options]</span><br><span class="line">       iptables -h (<span class="built_in">print</span> this <span class="built_in">help</span> information)</span><br></pre></td></tr></table></figure><p>都是一个大写字母跟着一个链名, 把上面的结果抽象一下就是:</p><blockquote><p><strong><code>iptables SUBCOMMAND CHAIN CRETERIA -j TARGET</code></strong></p></blockquote><p>现在我们就根据这些主要的子命令来作说明吧 主要分成两类: 链管理和规则管理 (这里先列一下, 后再实验和实例)</p><p><strong>链管理</strong> : -F flush 清空规则链, 可以在后面指定哪个链甚至还可以在链后面指定标号, 不指定即清空全表.</p><p>-Z zero 置零规则计数器.</p><p>-N new 自定义规则链, 创建一条新的规则链.</p><p>-X drop 删除用户自定义链, 要求是空链.</p><p>-P policy, 为指定的链设定默认策略</p><p>-E rename, 重命名自定义链(看参数也能知道是干嘛的hh), 但是计数器不是0的自定义链, 不能改名, 也没法删除.</p><p>以上就是<strong>链管理</strong>, 接下来就是<strong>规则管理</strong>:</p><p>-A append 将规则插入到尾部</p><p>-I insert 将规则插入到指定位置, 如果不指定位置就是首部</p><p>-D delete 删除特定规则, 可以指定匹配条件, 要么通过规则序号, 要么通过指定具体规则.</p><p>-R replace 替换指定规则. 通过序号+新规则来实现</p><p>除了这些, 还有一些其他的命令:</p><p>-L list 列出指定链的所有规则.  其中可以使用-n要求不进行反解, 也支持-v和-vv显示详细信息. 如果不想自己数, 也可以加上–list-numbers来显示规则编号. 还有一个显示计数器计数结果的精确值的选项, 就是-x啦.</p><p>举个例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># iptables -t filter -nL</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED </span><br><span class="line">ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:22 </span><br><span class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">[root@localhost ~]<span class="comment"># iptables -t filter -N IN_PUBLIC</span></span><br><span class="line">[root@localhost ~]<span class="comment"># iptables -t filter -nL</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED </span><br><span class="line">ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:22 </span><br><span class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain IN_PUBLIC (0 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination   </span><br></pre></td></tr></table></figure><p>我们在filter表中新建了一个自定义的链 – IN_PUBLIC, 可以很清晰的看到, 只要是自定义的链上面写的都是引用数量, 而凡是内置的几个链上写的都是POLICY. 接下来试试改名和删除:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># iptables -t filter -E IN_PUBLIC OUT_PUBLIC</span></span><br><span class="line">[root@localhost ~]<span class="comment"># iptables -t filter -nL</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED </span><br><span class="line">ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:22 </span><br><span class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUT_PUBLIC (0 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">[root@localhost ~]<span class="comment"># iptables -t filter -X OUT_PUBLIC</span></span><br><span class="line">[root@localhost ~]<span class="comment"># iptables -t filter -nL</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED </span><br><span class="line">ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:22 </span><br><span class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br></pre></td></tr></table></figure><p>如果在-X后面不加参数, 他是会清空所有的自定义链的. 比如我们的CentOS7由一个firewalld服务, 这个会再重启的时候去自动加载一些iptables的规则, 也就是说:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -F</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -X</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -nL</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">[root@WWW ~]<span class="comment"># systemctl restart firewalld</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -nL</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED</span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">INPUT_direct  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">INPUT_ZONES_SOURCE  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">INPUT_ZONES  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0            ctstate INVALID</span><br><span class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED</span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FORWARD_direct  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FORWARD_IN_ZONES_SOURCE  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FORWARD_IN_ZONES  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FORWARD_OUT_ZONES_SOURCE  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FORWARD_OUT_ZONES  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0            ctstate INVALID</span><br><span class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">OUTPUT_direct  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain FORWARD_IN_ZONES (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">FWDI_public  all  --  0.0.0.0/0            0.0.0.0/0           [goto] </span><br><span class="line"></span><br><span class="line">Chain FORWARD_IN_ZONES_SOURCE (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD_OUT_ZONES (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">FWDO_public  all  --  0.0.0.0/0            0.0.0.0/0           [goto] </span><br><span class="line"></span><br><span class="line">Chain FORWARD_OUT_ZONES_SOURCE (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD_direct (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDI_public (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">FWDI_public_log  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FWDI_public_deny  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FWDI_public_allow  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain FWDI_public_allow (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDI_public_deny (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDI_public_log (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDO_public (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">FWDO_public_log  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FWDO_public_deny  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FWDO_public_allow  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain FWDO_public_allow (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDO_public_deny (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDO_public_log (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain INPUT_ZONES (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">IN_public  all  --  0.0.0.0/0            0.0.0.0/0           [goto] </span><br><span class="line"></span><br><span class="line">Chain INPUT_ZONES_SOURCE (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain INPUT_direct (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain IN_public (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">IN_public_log  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">IN_public_deny  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">IN_public_allow  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain IN_public_allow (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22 ctstate NEW</span><br><span class="line"></span><br><span class="line">Chain IN_public_deny (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain IN_public_log (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT_direct (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br></pre></td></tr></table></figure><p>说了这么多, 我们还不知道iptables上面的是什么意思:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -nL -v</span></span><br><span class="line">Chain INPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">  158 12536 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED</span><br><span class="line">    0     0 ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">    3   740 INPUT_direct  all  --  *      *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">    3   740 INPUT_ZONES_SOURCE  all  --  *      *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">    3   740 INPUT_ZONES  all  --  *      *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">    0     0 DROP       all  --  *      *       0.0.0.0/0            0.0.0.0/0            ctstate INVALID</span><br><span class="line">    2   636 REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited</span><br><span class="line">    ...(omitted)</span><br></pre></td></tr></table></figure><p>加了-v参数之后, 我们可以看到计数器了, pkts就是报文数量, bytes就是报文大小, target就是处理方法, 有基本的ACCEPT, DROP, REJECT还有引用特定的自定义链的, 接着prot就是协议, 一般有三种:tcp, udp, icmp. 接着opt就是选项了, 后面两个星其实就是在说接口, 接着就是来源地址和目的地址了, 有的后面还有一段话, 关于这段话的相关 我们在后面再说.</p><p>现在发现所有的默认链的默认策略都是ACCEPT, 我们来试着修改一下:</p><p><strong>注意: 清空之后 别改INPUT和OUTPUT, 如果你是用SSH在连接的话.</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -nL</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -P FORWARD DROP</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -nL</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -P FORWARD ACCEPT</span></span><br></pre></td></tr></table></figure><p>接下来就差一个删除操作了, 我们重启firewalld服务, 来删除一条规则吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># systemctl restart firewalld </span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -nL --line-numbers</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">1    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED</span><br><span class="line">2    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">3    INPUT_direct  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">4    INPUT_ZONES_SOURCE  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">5    INPUT_ZONES  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">6    DROP       all  --  0.0.0.0/0            0.0.0.0/0            ctstate INVALID</span><br><span class="line">7    REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited</span><br><span class="line">...(omitted)</span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -D INPUT 7</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -nL --line-numbers</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">num  target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">1    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED</span><br><span class="line">2    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">3    INPUT_direct  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">4    INPUT_ZONES_SOURCE  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">5    INPUT_ZONES  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">6    DROP       all  --  0.0.0.0/0            0.0.0.0/0            ctstate INVALID</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><h2 id="iptables的匹配和规则"><a href="#iptables的匹配和规则" class="headerlink" title="iptables的匹配和规则"></a>iptables的匹配和规则</h2><h3 id="基本匹配"><a href="#基本匹配" class="headerlink" title="基本匹配"></a>基本匹配</h3><p>[!] -s, –src, –source IP|Netaddr: 检查报文中的源IP地址, 加上!来进行取反.</p><p>[!] -d. –dst, –destination IP|Netaddr: 检查报文中的目的IP地址, 加上!来进行取反.</p><p>-p –protocol {tcp|udp|icmp} 检查报文中的协议, 是说IP首部中protocol所指明的那个.</p><p>-i –in-interface IFACE: 数据报文的流入接口. 仅用于PREROUTING, INPUT, FORWARD.</p><p>-o –out-interface IFACE: 数据报文的流出接口, 仅用于FORWARD, OUTPUT, POSTROUTING.</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>使用-j TARGET来指明(jump的意思): ACCEPT接受, DROP丢弃, REJECT拒绝, RETURN返回调用链, REDIRECT端口重定向, LOG记录日志, MARK做防火墙标记, DNAT目标地址转换, SNAT源地址转换, MASQUERADE地址伪装, 还有自定义链..</p><p><strong>至此, 我们就可以开始写简单的规则了.</strong> 下面就来试试: (  先清空所有规则和自定义链 )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -t filter -A INPUT -p tcp -d 192.168.56.103 -j ACCEPT</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -t filter -A OUTPUT -p tcp -s 192.168.56.103 -j ACCEPT</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -P INPUT DROP</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -P OUTPUT DROP</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -P FORWARD DROP</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -nL -v</span></span><br><span class="line">Chain INPUT (policy DROP 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">  378 30392 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.56.103      </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy DROP 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">  111 11776 ACCEPT     tcp  --  *      *       192.168.56.103       0.0.0.0/0           </span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -nL -v</span></span><br><span class="line">Chain INPUT (policy DROP 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">  382 30720 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.56.103      </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy DROP 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">  114 12728 ACCEPT     tcp  --  *      *       192.168.56.103       0.0.0.0/0     </span><br></pre></td></tr></table></figure><p>会发现第二次的包数量和大小增大了, 显然SSH也是符合这些规则的, 这个时候PING这台机器就不会通了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[c:\~]$ ping 192.168.56.103</span><br><span class="line"></span><br><span class="line">Pinging 192.168.56.103 with 32 bytes of data:</span><br><span class="line">Request timed out.</span><br><span class="line">Request timed out.</span><br><span class="line">Request timed out.</span><br><span class="line">Request timed out.</span><br><span class="line"></span><br><span class="line">Ping statistics <span class="keyword">for</span> 192.168.56.103:</span><br><span class="line">    Packets: Sent = 4, Received = 0, Lost = 4 (100% loss)</span><br></pre></td></tr></table></figure><p>此时回到主机, 会发现:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -nL -v</span></span><br><span class="line">Chain INPUT (policy DROP 4 packets, 240 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">  405 32656 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.56.103      </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy DROP 1 packets, 76 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">  134 17152 ACCEPT     tcp  --  *      *       192.168.56.103       0.0.0.0/0 </span><br></pre></td></tr></table></figure><p>DROP了4个包, 其实就是我们的ICMP包.</p><p>接着如果想要让PING能显示主机可达怎么办? 添加一条规则! 如果你是这么想的就错了, 比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -t filter -A INPUT -p icmp -d 192.168.56.103 -j ACCEPT</span></span><br><span class="line"><span class="comment"># 5s后</span></span><br><span class="line">[c:\~]$ ping 192.168.56.103</span><br><span class="line"></span><br><span class="line">Pinging 192.168.56.103 with 32 bytes of data:</span><br><span class="line">Request timed out.</span><br><span class="line">Request timed out.</span><br><span class="line">Request timed out.</span><br><span class="line">Request timed out.</span><br><span class="line"></span><br><span class="line">Ping statistics <span class="keyword">for</span> 192.168.56.103:</span><br><span class="line">    Packets: Sent = 4, Received = 0, Lost = 4 (100% loss)</span><br></pre></td></tr></table></figure><p>为什么? 原因很简单啊, 在之前的CCNA实验中这个其实就已经说明过了, 因为我们发送的响应报文出不去, 所我们需要:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -t filter -A OUTPUT -p icmp -s 192.168.56.103 -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>这样就可以通信了. 这样的规则虽然有用但是没有不灵活, 所以现在我们来说说<strong>扩展匹配</strong>.</p><h3 id="扩展匹配"><a href="#扩展匹配" class="headerlink" title="扩展匹配"></a>扩展匹配</h3><p>扩展匹配分成两种: 隐式扩展和显示扩展. iptables有很多扩展模块:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># rpm -ql iptables</span></span><br><span class="line">...(omitted)</span><br><span class="line">/usr/lib64/xtables/libipt_CLUSTERIP.so</span><br><span class="line">/usr/lib64/xtables/libipt_DNAT.so</span><br><span class="line">/usr/lib64/xtables/libipt_ECN.so</span><br><span class="line">/usr/lib64/xtables/libipt_LOG.so</span><br><span class="line">/usr/lib64/xtables/libipt_MASQUERADE.so</span><br><span class="line">/usr/lib64/xtables/libipt_MIRROR.so</span><br><span class="line">/usr/lib64/xtables/libipt_NETMAP.so</span><br><span class="line">/usr/lib64/xtables/libipt_REDIRECT.so</span><br><span class="line">/usr/lib64/xtables/libipt_REJECT.so</span><br><span class="line">/usr/lib64/xtables/libipt_SAME.so</span><br><span class="line">/usr/lib64/xtables/libipt_SNAT.so</span><br><span class="line">/usr/lib64/xtables/libipt_TTL.so</span><br><span class="line">/usr/lib64/xtables/libipt_ULOG.so</span><br><span class="line">/usr/lib64/xtables/libipt_ah.so</span><br><span class="line">/usr/lib64/xtables/libipt_icmp.so</span><br><span class="line">/usr/lib64/xtables/libipt_realm.so</span><br><span class="line">/usr/lib64/xtables/libipt_ttl.so</span><br><span class="line">/usr/lib64/xtables/libipt_unclean.so</span><br><span class="line">/usr/lib64/xtables/libxt_AUDIT.so</span><br><span class="line">/usr/lib64/xtables/libxt_CHECKSUM.so</span><br><span class="line">/usr/lib64/xtables/libxt_CLASSIFY.so</span><br><span class="line">/usr/lib64/xtables/libxt_CONNMARK.so</span><br><span class="line">/usr/lib64/xtables/libxt_CONNSECMARK.so</span><br><span class="line">/usr/lib64/xtables/libxt_CT.so</span><br><span class="line">/usr/lib64/xtables/libxt_DSCP.so</span><br><span class="line">/usr/lib64/xtables/libxt_HMARK.so</span><br><span class="line">/usr/lib64/xtables/libxt_IDLETIMER.so</span><br><span class="line">/usr/lib64/xtables/libxt_LED.so</span><br><span class="line">/usr/lib64/xtables/libxt_MARK.so</span><br><span class="line">/usr/lib64/xtables/libxt_NFLOG.so</span><br><span class="line">/usr/lib64/xtables/libxt_NFQUEUE.so</span><br><span class="line">/usr/lib64/xtables/libxt_NOTRACK.so</span><br><span class="line">/usr/lib64/xtables/libxt_RATEEST.so</span><br><span class="line">/usr/lib64/xtables/libxt_SECMARK.so</span><br><span class="line">/usr/lib64/xtables/libxt_SET.so</span><br><span class="line">/usr/lib64/xtables/libxt_SYNPROXY.so</span><br><span class="line">/usr/lib64/xtables/libxt_TCPMSS.so</span><br><span class="line">/usr/lib64/xtables/libxt_TCPOPTSTRIP.so</span><br><span class="line">/usr/lib64/xtables/libxt_TEE.so</span><br><span class="line">/usr/lib64/xtables/libxt_TOS.so</span><br><span class="line">/usr/lib64/xtables/libxt_TPROXY.so</span><br><span class="line">/usr/lib64/xtables/libxt_TRACE.so</span><br><span class="line">/usr/lib64/xtables/libxt_addrtype.so</span><br><span class="line">/usr/lib64/xtables/libxt_bpf.so</span><br><span class="line">/usr/lib64/xtables/libxt_cgroup.so</span><br><span class="line">/usr/lib64/xtables/libxt_cluster.so</span><br><span class="line">/usr/lib64/xtables/libxt_comment.so</span><br><span class="line">/usr/lib64/xtables/libxt_connbytes.so</span><br><span class="line">/usr/lib64/xtables/libxt_connlabel.so</span><br><span class="line">/usr/lib64/xtables/libxt_connlimit.so</span><br><span class="line">/usr/lib64/xtables/libxt_connmark.so</span><br><span class="line">/usr/lib64/xtables/libxt_conntrack.so</span><br><span class="line">/usr/lib64/xtables/libxt_cpu.so</span><br><span class="line">/usr/lib64/xtables/libxt_dccp.so</span><br><span class="line">/usr/lib64/xtables/libxt_devgroup.so</span><br><span class="line">/usr/lib64/xtables/libxt_dscp.so</span><br><span class="line">/usr/lib64/xtables/libxt_ecn.so</span><br><span class="line">/usr/lib64/xtables/libxt_esp.so</span><br><span class="line">/usr/lib64/xtables/libxt_hashlimit.so</span><br><span class="line">/usr/lib64/xtables/libxt_helper.so</span><br><span class="line">/usr/lib64/xtables/libxt_iprange.so</span><br><span class="line">/usr/lib64/xtables/libxt_ipvs.so</span><br><span class="line">/usr/lib64/xtables/libxt_length.so</span><br><span class="line">/usr/lib64/xtables/libxt_limit.so</span><br><span class="line">/usr/lib64/xtables/libxt_mac.so</span><br><span class="line">/usr/lib64/xtables/libxt_mark.so</span><br><span class="line">/usr/lib64/xtables/libxt_multiport.so</span><br><span class="line">/usr/lib64/xtables/libxt_nfacct.so</span><br><span class="line">/usr/lib64/xtables/libxt_osf.so</span><br><span class="line">/usr/lib64/xtables/libxt_owner.so</span><br><span class="line">/usr/lib64/xtables/libxt_physdev.so</span><br><span class="line">/usr/lib64/xtables/libxt_pkttype.so</span><br><span class="line">/usr/lib64/xtables/libxt_policy.so</span><br><span class="line">/usr/lib64/xtables/libxt_quota.so</span><br><span class="line">/usr/lib64/xtables/libxt_rateest.so</span><br><span class="line">/usr/lib64/xtables/libxt_recent.so</span><br><span class="line">/usr/lib64/xtables/libxt_rpfilter.so</span><br><span class="line">/usr/lib64/xtables/libxt_sctp.so</span><br><span class="line">/usr/lib64/xtables/libxt_set.so</span><br><span class="line">/usr/lib64/xtables/libxt_socket.so</span><br><span class="line">/usr/lib64/xtables/libxt_standard.so</span><br><span class="line">/usr/lib64/xtables/libxt_state.so</span><br><span class="line">/usr/lib64/xtables/libxt_statistic.so</span><br><span class="line">/usr/lib64/xtables/libxt_string.so</span><br><span class="line">/usr/lib64/xtables/libxt_tcp.so</span><br><span class="line">/usr/lib64/xtables/libxt_tcpmss.so</span><br><span class="line">/usr/lib64/xtables/libxt_time.so</span><br><span class="line">/usr/lib64/xtables/libxt_tos.so</span><br><span class="line">/usr/lib64/xtables/libxt_u32.so</span><br><span class="line">/usr/lib64/xtables/libxt_udp.so</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>其中, 大写的都是TARGET, 小写的都是匹配条件. 上面就可以清晰的看到udp和tcp啦 就在这个文字的上面.</p><p>如果想要使用扩展匹配, 就需要先指定**-m**在后面加上你的match_name, 接着就是各个扩展的专用选项了. 几乎每个拓展都是这样使用的. 例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-m tcp --dport 22</span><br></pre></td></tr></table></figure><p>但是, 如果你之前已经指定了-p tcp协议, 那么-m参数是可以不用写的, 这就叫做<strong>隐式扩展</strong>啦  而<strong>显式扩展</strong>就是必须通过-m参数来指定的扩展.</p><p>那么我们现在就要挨个来说这些扩展的选项了.</p><p>首先是tcp的扩展. 最常用的就是端口匹配, 其中使用–dport和–sport来分别制定目的和源端口, 后面可以跟上单独的一个端口号, 也可以使用-PORT来说明一段<strong>连续</strong>的端口.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -I INPUT -d 192.168.56.103 -p tcp --dport 22 -j ACCEPT</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -I OUTPUT -s 192.168.56.103 -p tcp --sport 22 -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>接着就可以把原来的删除掉了. 现在的状态就是只有22端口开放了, 于是我们现在开启http服务:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># systemctl start httpd</span></span><br></pre></td></tr></table></figure><p>现在访问显然是不能访问的. 因为我们没有开启80端口的访问权限.</p><p>添加下面的规则:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -I INPUT -d 192.168.56.103 -p tcp --dport 80 -j ACCEPT</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -I OUTPUT -s 192.168.56.103 -p tcp --sport 80 -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>这样就可以看到了.</p><p>这两个选项是最多人都知道的烂大街选项, 接下来说一个大家没怎么见过的选项: 也就是–tcp-flag, 也就是ACK, SYNC, RST, FIN, PSH, URG这些, 即匹配标识字段. 这个选项的格式是这样:</p><p><code>--tcp-flag LIST1 LIST2</code></p><p>意义是这样, 检查LIST1中所指明的所有标志位, <strong>且这其中</strong>, LIST2所表示出的所有标志位必须为1, 其他必须为0, LIST1中没有列出的, <strong>不做检查</strong> </p><p>实例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--tcp-flags SYN,ACK,FIN,RST SYN</span><br></pre></td></tr></table></figure><p>这是什么意思啊, 这就是匹配TCP三次握手的第一个包.(请求建立连接的那个)</p><p>上述实例 其实有一个简写: <code>--syn</code>.</p><p>接下来看看icmp的一个扩展选项, –icmp-type 在后面可以指定数字来表示类型, 最常见的就是0和8, 一个回送报文, 一个是请求报文.</p><p>通过这个选项, 我们就可以实现<strong>只允许我们主机去Ping别的主机, 别的主机不能Ping我们:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -I INPUT -p icmp -d 192.168.56.103 --icmp-type 0 -j ACCEPT</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -I OUTPUT -p icmp -s 192.168.56.103 --icmp-type 8 -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>上面就是常见的隐式扩展, 而另一个显式扩展就要复杂一点了, 我们来看看.</p><p>不过这么多拓展我们用到的也不是全部, 就从其中找一些最常使用的扩展来说吧:</p><p><strong>multiport</strong> </p><p>我们在上面指定端口的时候, 说过只能指定连续的一段或者一个特定的端口, 这个扩展就是为了实现指定离散端口的, 使用方法如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[!] --source-ports,--sports port[,port|,port:port]...</span><br><span class="line">[!] --destination-ports,--dports port[,port|,port:port]...</span><br><span class="line">[!] --ports port[,port|,port:port]...</span><br></pre></td></tr></table></figure><p>使用逗号来进行分割不同的端口, 使用冒号来进行端口范围声明. 我们现在所加载的规则允许Web服务和SSH服务, 但是他们是分开的, 现在加一条两者都说明的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -I INPUT -d 192.168.56.103 -s 192.168.56.0/24 -p tcp -m multiport --dports 22,80 -j ACCEPT</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -I OUTPUT -s 192.168.56.103 -d 192.168.56.0/24 -p tcp -m multiport --sports 22,80 -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>删除旧规则, 于是我们的iptables就会变成这个样子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -nL</span></span><br><span class="line">Chain INPUT (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     tcp  --  192.168.56.0/24      192.168.56.103       multiport dports 22,80</span><br><span class="line">ACCEPT     icmp --  0.0.0.0/0            192.168.56.103       icmptype 0</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     tcp  --  192.168.56.103       192.168.56.0/24      multiport sports 22,80</span><br><span class="line">ACCEPT     icmp --  192.168.56.103       0.0.0.0/0            icmptype 8</span><br></pre></td></tr></table></figure><p>这样就好看多了.</p><p><strong>iprange</strong></p><p>这也是一个常用拓展, 听名字也知道是干嘛的了, 一般我们只能指定网段, 但是如果遇到不是一个网段的情况就不行了, 这个时候我们就可以使用iprange来声明一段连续IP地址.</p><p>用法也很简单:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[!] --src-range from[-to]</span><br><span class="line">[!] --dst-range from[-to]</span><br></pre></td></tr></table></figure><p>实例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -I INPUT -d 192.168.56.103 -p tcp -m multiport --dports 22:23,80 -m iprange --src-range 192.168.56.1-192.168.56.10 -j ACCEPT</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -I OUTPUT -s 192.168.56.103 -p tcp -m multiport --sports 22:23,80 -m iprange --dst-range 192.168.56.1-192.168.56.10 -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>这样就只允许前10台主机进行访问了. 很简单吧.</p><p><strong>string</strong></p><p>这个string扩展可以用来检查报文中出现的字符,就是说如果你没有进行加密, 那么一般来说所有的数据传输对于网络上的所有主机来说都是可以查看的, 因为所有数据包封装只是在源数据的最前面附上了一段协议头部而已. 使用这个string扩展, 我们就可以对进出的数据包进行审查, 寻找匹配我们指定的字符的数据.</p><p>使用方法就像这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--algo &#123;bm|kmp&#125;</span><br><span class="line">[!] --string pattern</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line"><span class="comment"># The string pattern can be used for simple text characters.</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m string --algo bm --string <span class="string">&#x27;GET /index.html&#x27;</span> -j LOG</span><br></pre></td></tr></table></figure><p>其实还有很多选项, 只不过使用的不多. 其中算法是必须要指定的.</p><p>我们来做个实验, 在Web服务器中加上一个页面:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># echo &quot;haha&quot; &gt; /var/www/html/jiang.html</span></span><br></pre></td></tr></table></figure><p>接着尝试访问:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/jianghaha.png" alt="jianghaha"></p><p>没有问题, 接着我们加上这样的规则:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -I OUTPUT -m string --algo kmp --string &#x27;haha&#x27; -j REJECT</span></span><br></pre></td></tr></table></figure><p>接着我们<strong>强行刷新</strong>, 或者更换浏览器或者打开开发者模式强行不请求缓存. 你会发现被拒绝了.</p><p>但是:</p><p>![itworks](<a href="http://hexopic.s3-ap-northeast-1.amazonaws.com/">http://hexopic.s3-ap-northeast-1.amazonaws.com/</a>itworks.png)</p><p>没有haha的就可以正常访问.</p><p><strong>time</strong></p><p>什么是time扩展呢~简单的一个应用就是可以在一定的时间内开启数据传输, 其他时间不行. 可以匹配标准时间(包括年月日小时分钟秒钟), 仅仅匹配时间, 仅仅匹配星期, 可以组合使用.</p><p>这个拓展支持的选项很多:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--datestart YYYY[-MM[-DD[Thh[:mm[:ss]]]]]</span><br><span class="line">--datestop YYYY[-MM[-DD[Thh[:mm[:ss]]]]] <span class="comment">#注意这里需要加一个T才行</span></span><br><span class="line">--timestart hh:mm[:ss]</span><br><span class="line">--timestop hh:mm[:ss]</span><br><span class="line">[!] --monthdays day[,day...]</span><br><span class="line">[!] --weekdays day[,day...]</span><br><span class="line">--kerneltz <span class="comment"># 不使用UTC而是使用内核所在使用的时区</span></span><br></pre></td></tr></table></figure><p>现在就来试试, 不过我们先把之前的那个haha删掉, 接着添加规则:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -R INPUT 1 -d 192.168.56.103 -p tcp --dport 80 -m time --timestart 23:00 --timestop 23:35 --kerneltz -j REJECT</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -nL</span></span><br><span class="line">Chain INPUT (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">REJECT     tcp  --  0.0.0.0/0            192.168.56.103       tcp dpt:80 TIME from 23:00:00 to 23:35:00 reject-with icmp-port-unreachable</span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0            192.168.56.103       multiport dports 22:23,80 <span class="built_in">source</span> IP range 192.168.56.1-192.168.56.10</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     tcp  --  192.168.56.103       0.0.0.0/0            multiport sports 22:23,80 destination IP range 192.168.56.1-192.168.56.10</span><br><span class="line">[root@WWW ~]<span class="comment"># date</span></span><br><span class="line">Tue Oct 10 23:31:27 CST 2017</span><br></pre></td></tr></table></figure><p>于是现在测试显然是不能访问的, 但是35之后就可以了. 这个可以自己测试.</p><p><strong>connlimit</strong></p><p>连接限制扩展, 可以对单个IP的并发访问限制. 使用方法也很简单.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--connlimit-upto n</span><br><span class="line">--connlimit-above n</span><br></pre></td></tr></table></figure><p>upto就是&lt;&#x3D;, above就是&gt;. 这样就允许不同的访问控制机制, 一般都是upto放行, above拒绝.</p><p>我们可以这样做一个实验, 在当前22端口放行的规则之前加一条, 只允许单IP最大2条连接:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -I INPUT -d 192.168.56.103 -s 192.168.56.1 -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECT</span></span><br></pre></td></tr></table></figure><p>接着我们进行连接:(在已有一条连接的基础上)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connecting to 192.168.56.103:22...</span><br><span class="line">Connection established.</span><br></pre></td></tr></table></figure><p>成功! 接着再来一条:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connecting to 192.168.56.103:22...</span><br><span class="line">Could not connect to <span class="string">&#x27;192.168.56.103&#x27;</span> (port 22): Connection failed.</span><br></pre></td></tr></table></figure><p>被拒绝.</p><p><strong>limit</strong></p><p>这个扩展更加常用, 是对收发报文的速率做匹配.而connlimit是对连接数做匹配. 它基于令牌桶过滤器.</p><blockquote><p>令牌桶是个什么玩意? </p><p>可以把它理解成是看3D小电影的时候, 每个人会发一个塑料片, 当塑料片发完了之后, 就不能再入场了(因为没有塑料片了就看不了了), 只有当前面的人看完了, 把塑料片还回来的时候才可以继续入场. 这里,每一个塑料片就是令牌. 而所有的塑料片就是令牌桶.</p></blockquote><p>对于速率的控制还是挺灵活的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--<span class="built_in">limit</span> rate[/second|/minute|/hour|/day]</span><br><span class="line">--limit-burst number</span><br></pre></td></tr></table></figure><p>上面的好说, 关于这个burst, 可以理解成是一种容忍, 一开始我不做限制, 但是当你一直在挑战底线的时候, 我就做限制. 做做实验就明白了.</p><p>我们现在试试进行Ping速率的限制, 限制到2s一个, 峰值设置成5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -A INPUT -d 192.168.56.103 -p icmp --icmp-type 8 -m limit --limit 30/minute --limit-burst 5 -j ACCEPT</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -A OUTPUT -s 192.168.56.103 -p icmp --icmp-type 0 -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>接下来用另外一台主机做个测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ping 192.168.56.103</span></span><br><span class="line">PING 192.168.56.103 (192.168.56.103) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.56.103: icmp_seq=1 ttl=64 time=1.48 ms</span><br><span class="line">64 bytes from 192.168.56.103: icmp_seq=2 ttl=64 time=1.21 ms</span><br><span class="line">64 bytes from 192.168.56.103: icmp_seq=3 ttl=64 time=1.16 ms</span><br><span class="line">64 bytes from 192.168.56.103: icmp_seq=4 ttl=64 time=1.63 ms</span><br><span class="line">64 bytes from 192.168.56.103: icmp_seq=5 ttl=64 time=1.34 ms</span><br><span class="line">64 bytes from 192.168.56.103: icmp_seq=6 ttl=64 time=1.25 ms</span><br><span class="line">64 bytes from 192.168.56.103: icmp_seq=7 ttl=64 time=2.42 ms</span><br><span class="line">64 bytes from 192.168.56.103: icmp_seq=8 ttl=64 time=2.71 ms</span><br><span class="line">64 bytes from 192.168.56.103: icmp_seq=9 ttl=64 time=1.31 ms</span><br><span class="line">64 bytes from 192.168.56.103: icmp_seq=11 ttl=64 time=1.71 ms</span><br><span class="line">64 bytes from 192.168.56.103: icmp_seq=13 ttl=64 time=3.82 ms</span><br><span class="line">64 bytes from 192.168.56.103: icmp_seq=15 ttl=64 time=1.42 ms</span><br></pre></td></tr></table></figure><p>我们来分析一下结果, 首先前9个包很正常, 这是因为其中有2s一个的包(4个)加上我允许的5个包, 也就是4+5&#x3D;9. 后面就可以理解了.</p><p><strong>state</strong></p><p>这个扩展是一个至关重要的扩展, 根据连接追踪机制, 可以检查连接状态. 这个追踪和TCP的挥手状态不一样, 他是iptables在内核中的一块空间, 会记录每一个连接的来源,状态和计时器. 当计时器归零的时候就会删除这个记录. 但是想想啊, 这一块记录是存在内核的内存空间的, 如果来了几百万个连接都进行记录, 一下就把内核的内存空间占掉了, 那就是个大麻烦了. 所以对于繁忙的服务器来说, 连接追踪这个功能不应该开放, 如果非要使用, 那就一定要把内核参数<code>nd_conntrack_max</code>调整的大一些, 否则, 一旦这一块爆了, 会造成很多严重的后果.</p><p>先来看看这个值的默认:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># cat /proc/sys/net/nf_conntrack_max </span></span><br><span class="line">65536</span><br></pre></td></tr></table></figure><p>如果我想要知道当前在追踪哪些连接可以:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># cat /proc/net/nf_conntrack</span></span><br><span class="line">ipv4     2 tcp      6 299 ESTABLISHED src=192.168.56.1 dst=192.168.56.103 sport=9058 dport=22 src=192.168.56.103 dst=192.168.56.1 sport=22 dport=9058 [ASSURED] mark=0 zone=0 use=2</span><br></pre></td></tr></table></figure><p>如果你没有关闭SELINUX, 你应该还可以看到其他相关信息.</p><p>那么我们可以追踪那些状态呢?</p><p><strong>NEW</strong>:新发出的请求, 在连接追踪模板中没有的会被认作NEW</p><p><strong>ESTABLISHED</strong>: 连接追踪模板中失效之前的状态</p><p><strong>RELATED</strong>: 相关的连接. 例如: ftp的命令连接和数据连接, 他们互相独立但是存在相关性.</p><p><strong>INVALID</strong>: 无法识别的连接.</p><p>关于连接追踪, 有一种很简单的用法就是防范反弹木马, 我们22,80端口肯定是只能被动的出数据,不应该主动发出请求的, 所以我们可以做这样的规则:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -I INPUT -d 192.168.56.103 -p tcp -m multiport --dports 22,80 -m state --state NEW,ESTABLISHED -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>而出口:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -I OUTPUT -s 192.168.56.103 -p tcp -m multiport --sports 22,80 -m state --state ESTABLISHED -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>确定无误之后删除原来的规则.</p><p>于是变成了这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -nL -v</span></span><br><span class="line">Chain INPUT (policy DROP 8 packets, 1168 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">  865 72596 ACCEPT     tcp  --  *      *       0.0.0.0/0            192.168.56.103       multiport dports 22,80 state NEW,ESTABLISHED</span><br><span class="line">    3   176 REJECT     tcp  --  *      *       192.168.56.1         192.168.56.103       tcp dpt:22 <span class="comment">#conn src/32 &gt; 2 reject-with icmp-port-unreachable</span></span><br><span class="line">  144 11208 ACCEPT     icmp --  *      *       0.0.0.0/0            192.168.56.103       icmptype 8 <span class="built_in">limit</span>: avg 30/min burst 5</span><br><span class="line">    2   168 ACCEPT     icmp --  *      *       0.0.0.0/0            192.168.56.103       icmptype 0</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy DROP 4 packets, 1312 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line">  125 15888 ACCEPT     tcp  --  *      *       192.168.56.103       0.0.0.0/0            multiport sports 22,80 state ESTABLISHED</span><br><span class="line">  251 20028 ACCEPT     icmp --  *      *       192.168.56.103       0.0.0.0/0            icmptype 0</span><br><span class="line">    2   168 ACCEPT     icmp --  *      *       192.168.56.103       0.0.0.0/0            icmptype 8</span><br></pre></td></tr></table></figure><p>现在访问Web服务试试吧. 也是可以的.</p><p>但是仔细看看iptables, 是不是可以优化一下呢? 其实对于出站请求而言, 只要是可以入站的, 应该是都允许放行的, 那么我们可以用一条简单的规则来覆盖上述三条:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -I OUTPUT -m state --state ESTABLISHED -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>这就是连接追踪机制的好处, 同理, 只要是ESTABLISHED的连接, 我也可以在INPUT的开头加上, 这样就不用一直向下匹配了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -I INPUT -m state --state ESTABLISHED -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>但是现在还是有一些问题的, 例如: 各个协议的不同等待时间是不一样的啊, 比如http的时间肯定是比tcp的时间短的. 关于此, 可以从<code>/proc/sys/net/netfilter/</code>这个目录下看到关于各种设置的选项. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># ls /proc/sys/net/netfilter/nf_</span></span><br><span class="line">nf_conntrack_acct                        nf_conntrack_frag6_timeout               nf_conntrack_tcp_max_retrans             nf_conntrack_tcp_timeout_time_wait</span><br><span class="line">nf_conntrack_buckets                     nf_conntrack_generic_timeout             nf_conntrack_tcp_timeout_close           nf_conntrack_tcp_timeout_unacknowledged</span><br><span class="line">nf_conntrack_checksum                    nf_conntrack_helper                      nf_conntrack_tcp_timeout_close_wait      nf_conntrack_timestamp</span><br><span class="line">nf_conntrack_count                       nf_conntrack_icmp_timeout                nf_conntrack_tcp_timeout_established     nf_conntrack_udp_timeout</span><br><span class="line">nf_conntrack_events                      nf_conntrack_icmpv6_timeout              nf_conntrack_tcp_timeout_fin_wait        nf_conntrack_udp_timeout_stream</span><br><span class="line">nf_conntrack_events_retry_timeout        nf_conntrack_log_invalid                 nf_conntrack_tcp_timeout_last_ack        nf_log/</span><br><span class="line">nf_conntrack_expect_max                  nf_conntrack_max                         nf_conntrack_tcp_timeout_max_retrans     </span><br><span class="line">nf_conntrack_frag6_high_thresh           nf_conntrack_tcp_be_liberal              nf_conntrack_tcp_timeout_syn_recv        </span><br><span class="line">nf_conntrack_frag6_low_thresh            nf_conntrack_tcp_loose                   nf_conntrack_tcp_timeout_syn_sent        </span><br></pre></td></tr></table></figure><p>这个问题解决了, 那新的问题又来了. 怎么进行被动模式下FTP服务的防火墙设置?</p><p>我们知道, 被动模式的FTP是说服务端随机开放端口. 肯定不能去对特定的端口进行匹配.</p><p>其实啊, 对于FTP服务的连接追踪,显然是使用RELATED状态, 而且这个其实由一个专门的模块来做:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># ls /lib/modules/3.10.0-514.el7.x86_64/kernel/net/netfilter/</span></span><br><span class="line">nf_conntrack_ftp.ko</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>这个模块就是专门用来做ftp连接追踪的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># modinfo nf_conntrack_ftp</span></span><br><span class="line">filename:       /lib/modules/3.10.0-514.26.2.el7.x86_64/kernel/net/netfilter/nf_conntrack_ftp.ko</span><br><span class="line"><span class="built_in">alias</span>:          nfct-helper-ftp</span><br><span class="line"><span class="built_in">alias</span>:          ip_conntrack_ftp</span><br><span class="line">description:    ftp connection tracking helper</span><br><span class="line">author:         Rusty Russell &lt;rusty@rustcorp.com.au&gt;</span><br><span class="line">license:        GPL</span><br><span class="line">rhelversion:    7.3</span><br><span class="line">srcversion:     D43BF56A22E3D137BA1227B</span><br><span class="line">depends:        nf_conntrack</span><br><span class="line">intree:         Y</span><br><span class="line">vermagic:       3.10.0-514.26.2.el7.x86_64 SMP mod_unload modversions </span><br><span class="line">signer:         CentOS Linux kernel signing key</span><br><span class="line">sig_key:        61:8F:5D:DF:77:2E:4B:E8:25:FB:1B:B0:95:91:86:27:24:ED:1E:97</span><br><span class="line">sig_hashalgo:   sha256</span><br><span class="line">parm:           ports:array of ushort</span><br><span class="line">parm:           loose:bool</span><br></pre></td></tr></table></figure><p>可能, 我是说可能, 你会需要手动装载模块:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># modprobe nf_conntrack_ftp</span></span><br></pre></td></tr></table></figure><p>好了, 接下来开始做这个实验.</p><p>首先我们试试在没有防火墙的时候状态怎么样, 但是这个时候我们之前写的那些规则怎么办? 可以先把他们存起来, 这样做:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables-save &gt; /root/iptable.1</span></span><br><span class="line">[root@WWW ~]<span class="comment"># </span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -P INPUT ACCEPT</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -P OUTPUT ACCEPT</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -P FORWARD ACCEPT</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -F</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -nL</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination  </span><br></pre></td></tr></table></figure><p>好了,启动vsftpd服务, 尝试访问.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ftp 192.168.56.103</span></span><br><span class="line">Connected to 192.168.56.103 (192.168.56.103).</span><br><span class="line">220 Welcome to blah FTP service.</span><br><span class="line">Name (192.168.56.103:root): ftp</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; <span class="built_in">cd</span> upload</span><br><span class="line">250 Directory successfully changed.</span><br><span class="line">ftp&gt; <span class="built_in">ls</span></span><br><span class="line">227 Entering Passive Mode (192,168,56,103,174,187).</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">-rw-rw-rw-    1 0        0               0 Sep 29 06:41 <span class="built_in">test</span></span><br><span class="line">226 Directory send OK.</span><br><span class="line">ftp&gt; get <span class="built_in">test</span></span><br><span class="line"><span class="built_in">local</span>: <span class="built_in">test</span> remote: <span class="built_in">test</span></span><br><span class="line">227 Entering Passive Mode (192,168,56,103,132,29).</span><br><span class="line">150 Opening BINARY mode data connection <span class="keyword">for</span> <span class="built_in">test</span> (0 bytes).</span><br><span class="line">226 Transfer complete.</span><br></pre></td></tr></table></figure><p>没有任何问题.</p><p>那么, 现在我们还原规则, 并且修改规则使得命令连接可以进入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables-restore &lt; /root/iptable.1</span></span><br><span class="line">[root@WWW ~]<span class="comment"># iptables -R INPUT 2 -d 192.168.56.103 -p tcp -m multiport --dports 21,22,80 -m state --state NEW -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>接着, 只要把数据连接放行就行了, 修改第一条:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># iptables -R INPUT 1 -m state --state ESTABLISHED,RELATED -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ftp 192.168.56.103</span></span><br><span class="line">Connected to 192.168.56.103 (192.168.56.103).</span><br><span class="line">220 Welcome to blah FTP service.</span><br><span class="line">Name (192.168.56.103:root): ftp</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; <span class="built_in">cd</span> upload</span><br><span class="line">250 Directory successfully changed.</span><br><span class="line">ftp&gt; get <span class="built_in">test</span></span><br><span class="line"><span class="built_in">local</span>: <span class="built_in">test</span> remote: <span class="built_in">test</span></span><br><span class="line">227 Entering Passive Mode (192,168,56,103,69,254).</span><br><span class="line">150 Opening BINARY mode data connection <span class="keyword">for</span> <span class="built_in">test</span> (0 bytes).</span><br><span class="line">226 Transfer complete.</span><br></pre></td></tr></table></figure><p>没问题了.</p><p>刚刚我们不仅设置了ftp的放行规则, 而且还把保存和恢复过了一遍, 其实保存和恢复就是使用的输出重定向的方式, 那么到底输出了什么内容? 这个直接cat一下就可以了, 其实就是封装了一层的规则罢了.</p><h2 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h2><p>对于CentOS7, 使用了一个新的iptables的前端管理服务工具. 有基于图形的, 有基于命令行的. 这个玩意引入了一些新的机制, 面向Docker, Openstack等等一些云环境的新概念. 如果只是本机. 倒不是那么需要, 所以还是使用iptables先.</p><p>关于firewalld的相关信息, 可参考 <a href="https://www.ibm.com/developerworks/cn/linux/1507_caojh/">firewalld_ibm</a> </p><h2 id="网络防火墙和nat实现"><a href="#网络防火墙和nat实现" class="headerlink" title="网络防火墙和nat实现"></a>网络防火墙和nat实现</h2><p>上面的都是在说主机防火墙, 那么现在再试着搭建一个网络防火墙试试?? 我们打开三台虚拟机, 其中一台充当网关, 另外两台处于网关服务器另一个内网网卡的子网中, 且默认网关设置成为这一台.</p><p>现在的我的网络情况是这样:</p><p>外网: CentOS6 (node2)– 外网IP: 192.168.206.131</p><p>网关: CentOS7 (localhost)– 外网IP: 192.168.206.137  内网IP: 172.16.100.254&#x2F;24</p><p>内网: CentOS6 (node1)– 内网IP: 172.16.100.254</p><p>重要: <strong>网关开启了核心转发功能, 且外网服务器加入了到内网IP的路由.</strong> </p><p>现在内网和外网主机可以随意互相访问. 如果没有请检查路由表和是否开启<code>net.ipv4.ip_forward</code></p><p>接着我们在内网服务器开启http服务, 尝试用外网访问:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># curl 172.16.100.10</span></span><br><span class="line">&lt;h1&gt;It works!&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>好, 这很显然.  那么回到我们的主题: iptables. 我现在不希望外部主机能够进行ping我们内网的主机, 但是它能够访问Web服务.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># iptables -P FORWARD DROP</span></span><br><span class="line">[root@localhost ~]<span class="comment"># iptables -I FORWARD -s 172.16.100.10 -p tcp --sport 80 -j ACCEPT</span></span><br><span class="line">[root@localhost ~]<span class="comment"># iptables -I FORWARD -d 172.16.100.10 -p tcp --dport 80 -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>这样就好了 一进一出:</p><p>测试一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># ping 172.16.100.10 -w 5</span></span><br><span class="line">PING 172.16.100.10 (172.16.100.10) 56(84) bytes of data.</span><br><span class="line"></span><br><span class="line">--- 172.16.100.10 ping statistics ---</span><br><span class="line">5 packets transmitted, 0 received, 100% packet loss, time 5001ms</span><br><span class="line"></span><br><span class="line">[root@node2 ~]<span class="comment"># curl 172.16.100.10</span></span><br><span class="line">&lt;h1&gt;It works!&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>这只是在做实验, 实际上一个网络防火墙是这样的功能才对:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># iptables -I FORWARD -m state --state ESTABLISHED -j ACCEPT       </span></span><br><span class="line">[root@localhost ~]<span class="comment"># iptables -A FORWARD -d 172.16.100.10 -p tcp -m multiport --dports 22,80 -m state --state NEW -j ACCEPT</span></span><br></pre></td></tr></table></figure><p>这就是一个比较标准的防火墙应用啦~. 其他的设定就和之前其实是很相似的, 所以可以举一反三的哦.</p><p>但是现在的配置是个有问题的配置, 我们假设外网服务器是个公网IP, 而且中间的路由器有可能很多可能是公网路由. 这样我们的内网主机是无法获得外网的响应的, 因为公网服务器得到的报文源地址是个私有地址, 路由往哪里走啊?</p><p>那么为了解决这个问题, 有什么好办法吗? 对了, 我们想到了nat和proxy. 其中, nat其实是为了隐藏本地网络的主机的(最早), 而proxy一般是在应用层实现不同于nat在网络层和传输层实现. 现在我们先说说nat.</p><p>NAT就是网络地址转换了, 现在主要有地址转换[SNAT, DNAT]和端口转换两种, SNAT和DNAT两种其实是相互对应的. 一般情况下, 我们内网的主机发起对外网的通信请求, 这些请求都会先到达网关, 这个网关服务器现在扮演的角色就是nat server. 他不监听在任何一个套接字上, 也不是一个服务或者进程, 而是内核中的一些转发规则的实现. </p><p>当报文发送到网关的时候, 源地址被改成网关的外网通信IP, 目的地址不变, 接着外网服务器的响应报文将携带着目的地址为网关服务器的外网通信IP发送回来, 于是该响应报文再次被修改成目的地址为内网IP从内网接口被发送出去.</p><p>那么问题来了, 网关服务器或者说nat server怎么知道这个报文是发给谁的? 如果内网中有很多台主机的话, 决定报文流向的机制其实就是我们说过的<strong>连接追踪机制</strong> 因为这个报文是内网主机先发送的, 所以内核中是存在追踪记录的话, 就好办了. 这样也就造成一个非常难办的问题: <strong>IP协议变成了不公平的协议.</strong> 只有内网主机才可以主动发送请求.</p><p>显然, DNAT只能运行在PREROUTING上, 而SNAT也只能运行在POSTROUTING上. </p><p>简单的说一下proxy吧. 刚刚说过了proxy是运行在应用层的, 因为网关服务器需要理解客户请求的协议到底是什么协议的, 所以报文会径直到达网关的用户空间的代理进程, 接着重新封装发向目的地址. 注意啦 这里的请求发出者就是网关, 所以不存在什么转换的问题. 接着同样服务器也会把响应报文径直发向代理服务器(网关服务器), 接着代理进程重新封装报文发送给客户. 就是这样的过程.</p><p>现在切入正题, 来使用iptables实现nat功能. 我们在外网服务器开启httpd服务, 清空三台主机所有的iptables规则, 并且在内网主机配置默认路由, 设置网关. 现在我想做的事情是在网关服务器配置一条nat规则, 将内网的主机源地址转换成为网关的IP地址.</p><p>在做这个事情之前我们先在外网服务器加上一条能够到达内网服务器的路由:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># route add -net 172.16.100.0/24 gw 192.168.206.137 dev eth2</span></span><br></pre></td></tr></table></figure><p>接着内网请求Web服务:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># curl http://192.168.206.131</span></span><br><span class="line">&lt;h1&gt;Test&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>于是我们可以在外网的访问日志中看到:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">172.16.100.10 - - [12/Oct/2017:14:04:15 +0800] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 14 <span class="string">&quot;-&quot;</span> <span class="string">&quot;curl/7.19.7 (x86_64-unknown-linux-gnu) libcurl/7.19.7 NSS/3.12.7.0 zlib/1.2.3 libidn/1.18 libssh2/1.2.2&quot;</span></span><br></pre></td></tr></table></figure><p>来源IP是172.16.100.10, 好的. 删除刚才添加的路由. 这个时候就不能互相通信了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># route del -net 172.16.100.0/24 dev eth2</span></span><br></pre></td></tr></table></figure><p>那么, 现在就来进行转换:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># iptables -t nat -I POSTROUTING -s 172.16.100.0/24 ! -d 172.16.100.0/24 -j SNAT --to-source 192.168.206.137</span></span><br></pre></td></tr></table></figure><p>简单的说明一下吧, SNAT就是target了, 后面的参数就是将源地址改成192.168.206.137的意思了.</p><p>现在再进行访问:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># curl http://192.168.206.131</span></span><br><span class="line">&lt;h1&gt;Test&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>同时我们检查日志:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.206.137 - - [12/Oct/2017:14:34:39 +0800] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 14 <span class="string">&quot;-&quot;</span> <span class="string">&quot;curl/7.19.7 (x86_64-unknown-linux-gnu) libcurl/7.19.7 NSS/3.12.7.0 zlib/1.2.3 libidn/1.18 libssh2/1.2.2&quot;</span></span><br></pre></td></tr></table></figure><p>来自192.168.206.137的访问记录~成功了. 那么现在再来玩一个, 我们把他们翻转过来, 内网服务器开Web服务, 然后外网服务器去访问, 由于内网IP是私有的, 所以对于外网服务器而言, 他只能去访问网关的那个公网IP, 但是我们知道网关是没有开启80端口的. 那么我们就需要将发往网关服务器的80端口的请求转换成访问内网的IP这样的一个操作.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># iptables -t nat -I PREROUTING -d 192.168.206.137 -p tcp --dport 80 -j DNAT --to-destination 172.16.100.10:80</span></span><br></pre></td></tr></table></figure><p>在添加此条规则之前:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># curl 192.168.206.137</span></span><br><span class="line">curl: (7) couldn<span class="string">&#x27;t connect to host</span></span><br></pre></td></tr></table></figure><p>在添加之后我们就可以看到:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># curl 192.168.206.137</span></span><br><span class="line">&lt;h1&gt;It works!&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>需要再次说明的是, 137上没有开启httpd服务, 80端口也没有进程在监听.</p><p>同理, 我们也可以进行端口映射, 如果内网Web服务的监听端口不在80, 就映射到那个端口就好了. 很简单了.</p><p>DNAT没什么了, 回到SNAT, 考虑这样的一个问题. 有些网关的网络地址并不一定是固定的, 他有可能随着拨号的不同会有不同的IP, 面对这样的情况难道我们要每一次修改一次–to-source吗? 显然不能, 这个时候就需要进行来源地址伪装, 即<strong>MASQUERADE</strong> </p><p>假设现在我们的网关地址变了, 那么内网主机就不能访问外网服务器了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ip addr del 192.168.206.137/24 dev ens37</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ip addr add 192.168.206.133/24 dev ens37</span></span><br></pre></td></tr></table></figure><p>在这种情况下, 由于配置了下面的项目:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># iptables -t nat -I POSTROUTING -s 172.16.100.0/24 ! -d 172.16.100.0/24 -j MASQUERADE</span></span><br></pre></td></tr></table></figure><p>我们的内网主机依然可以访问外网Web服务.</p><h2 id="TCP-wrapper"><a href="#TCP-wrapper" class="headerlink" title="TCP_wrapper"></a>TCP_wrapper</h2><p>最后我们再简单说说TCP_wrapper这个玩意. 这是一个基于tcp协议开发并提供服务的应用程序, 提供一层访问控制的工具, 基于库调用实现功能. – <strong>libwrap</strong></p><p>那么我们怎么知道哪些服务可以用tcp_wrapper实现控制呢?</p><p>我们知道在编译的时候, 如果使用到共享库, 那么有两种方式: 一种是进行链接, 一种是进行静态编译,即编译进程序. 对于动态的好办,直接ldd就行了. 而静态的就稍微麻烦一点: 我们要使用strings查看应用程序, 如果出现hosts.allow和hosts.deny就是可以的.</p><p>比如现在试试sshd和vsftpd:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ldd `which sshd`</span></span><br><span class="line">linux-vdso.so.1 =&gt;  (0x00007fff325a1000)</span><br><span class="line">libfipscheck.so.1 =&gt; /lib64/libfipscheck.so.1 (0x00007ff6d2088000)</span><br><span class="line">libwrap.so.0 =&gt; /lib64/libwrap.so.0 (0x00007ff6d1e7d000)</span><br><span class="line">...(omitted)</span><br><span class="line">[root@localhost ~]<span class="comment"># ldd `which vsftpd`</span></span><br><span class="line">linux-vdso.so.1 =&gt;  (0x00007fffb97ca000)</span><br><span class="line">libssl.so.10 =&gt; /lib64/libssl.so.10 (0x00007ff14f6c7000)</span><br><span class="line">libwrap.so.0 =&gt; /lib64/libwrap.so.0 (0x00007ff14f4bc000)</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>而httpd就不可以. </p><p>使用tcp_wrapper来做访问控制要比iptables简单多了, 只要编辑&#x2F;etc&#x2F;hosts.deny和&#x2F;etc&#x2F;hosts.allow就可以了.</p><p>配置文件的语法格式就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemon_list: client_list [:options]</span><br></pre></td></tr></table></figure><p>听名字也知道allow就是白名单, deny就是黑名单. 那么如果我两个文件里都写了, 怎么样呢? 其实是有匹配次序的, 优先匹配allow, 如果有则直接放行, 如果没有则匹配deny, 如果有则拒绝, 没有则默认策略放行.</p><p>这里的daemon_list一定是文件名称, 不能是服务名, 多个可以使用逗号分隔:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sshd, vsftpd: 172.16.0.0/255.255.0.0|ALL|KNOWN|UNKNOWN|PARANOID</span><br></pre></td></tr></table></figure><p>另外, 对于client_list, 可以在后面加上EXCEPT关键字:</p><blockquote><p>EXCEPT: 除了. 这个选项还可以连续使用两次 双重否定 &#x3D; 肯定</p></blockquote><p>现在就直接试试吧:</p><p>先用另外一台主机访问sshd服务:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># ssh 192.168.206.133</span></span><br><span class="line">root@192.168.206.133<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string">Last login: Thu Oct 12 15:49:50 2017 from 192.168.206.131</span></span><br><span class="line"><span class="string">[root@localhost ~]# logout</span></span><br><span class="line"><span class="string">Connection to 192.168.206.133 closed.</span></span><br></pre></td></tr></table></figure><p>接着编辑:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/hosts.deny </span></span><br><span class="line">sshd: 192.168.206.131</span><br></pre></td></tr></table></figure><p>接着:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># ssh 192.168.206.133</span></span><br><span class="line">ssh_exchange_identification: Connection closed by remote host</span><br></pre></td></tr></table></figure><p>很简单吧.</p><p>接着我们看一下后面的选项有哪些:</p><blockquote><p>deny: 在allow中使用</p><p>allow: 在deny中使用.</p><p>spawn: 启动额外程序, 例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hosts.deny</span></span><br><span class="line">vsftpd: ALL :spawn /bin/echo `<span class="built_in">date</span>` login attempt from %c to %s ,%d &gt;&gt; /var/log/vsftpd.deny.log</span><br></pre></td></tr></table></figure><p>这里的%c: client IP;  %s: server IP;  %d: daemon name</p></blockquote><p><strong>17-10-13的更新:</strong></p><p>在书上看到了关于iptables的案例, 在这里说一说: 案例是说用户使用公网传输文件正常, 但是使用自建GRE VPN大内网只能传输2Kb大小文件, 停止iptables之后可以传输大文件. 而且在开启iptables之后的10分钟内, 可以继续传输大文件, 10分钟后传输被卡住.</p><p>通过抓包, 发现出现了下面的情况: <code>ICMP Destination unreachable (Fragmentation needed)</code></p><p>而iptables对ICMP的设定和我们之前设定的是一样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p icmp --icmp-type echo-reply -j ACCEPT</span><br><span class="line">iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT</span><br></pre></td></tr></table></figure><p>所以说, GRE封装的24字节(GRE报文+IP包头)在默认的1500中减去, 网关的MTU应该是1476才对. 但是这个案例中网络管理员将路由器的MTU设置成为了1400, 而协商MTU的ICMP报文又无法到达, 导致协商失败.</p><p>为什么10分钟之内可以呢? 因为存在一个叫做PMTU的东西, 这个叫做两台通信主机之间最小的MTU, 即路径MTU. 默认的老化时间就是10分钟.</p><p>之前所说的ICMP协商MTU, 这个被叫做路径最大传输单元发现, PMTUD.</p><p>为了解决问题, 添加规则:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p icmp --icmp-type fragmentation-needed -j ACCEPT</span><br></pre></td></tr></table></figure><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/iptables_mind.png" alt="iptables_mind"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来,搭建一个DHCP服务器和PXE吧</title>
      <link href="/2017/10/07/%E6%9D%A5-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AADHCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8CPXE%E5%90%A7/"/>
      <url>/2017/10/07/%E6%9D%A5-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AADHCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8CPXE%E5%90%A7/</url>
      
        <content type="html"><![CDATA[<p>DHCP服务器建立起来特别简单啦, 就当放松心情来搭建一个吧! 另外 这一次顺便来看看神奇的网络引导究竟是怎么实现的~</p><span id="more"></span><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>都到这个时候了, DHCP都在熟悉不过了, 不过还是简单的说一说吧, 以后自己看的时候也能顺便回忆一波~</p><p>DHCP的全称是Dynamic Host Configure Protocol. 即为动态主机配置协议. 我们不可能手动配置局域网内每一台机器的网络属性, 所以, 这里就需要一个专门的东西来分发这些. </p><p>需要特别说一下的是, DHCP绝对不是为主机分配IP地址的协议, 他分配的是网络属性, 最重要的几个属性是:</p><ul><li>IP&#x2F;Netmask</li><li>Gateway</li><li>DNS Server</li></ul><p>除此之外还有很多, 但一般使用到的就是上面这些.</p><p>那么DHCP是如何工作的呢?</p><p>DHCP协议的前身是Bootp协议, 也就是bootstrap protocol. 这些协议存在很久远了, 那个时候硬盘较小且昂贵, 所以不能为每一个工作站都配置上一块硬盘, 也就是说<strong>没有操作系统</strong> 这个时候, 就会有一台网络上的主机(服务器). 这个服务器为每一个工作站提供一个共享的磁盘空间. 也就是说这些主机的操作系统都安装在他们自己的共享空间中. 像这样是存在问题的. 你能想到吗?</p><p>对了, 没有操作系统, 怎么会有IP地址? 没有地址, 如何通信?</p><p>我们没有IP地址, 但是我们有MAC地址啊. 这个场景中就需要RARP协议的援助(当然现在RARP已经淘汰了), 在本地主机开机启动时, 我们的网卡就会发送一个RARP协议的广播报文, 当请求发送到服务器时, bootp协议就会开始工作. 他会根据MAC地址, 从自己维护的一个特定范围的地址池中取一个交给本地主机. 从而获得IP地址, 得以通信. 接着就会加载操作系统了.</p><p>但是这样, 就又会存在一个问题了. 那就是每当我分配了一个IP地址, 这个IP地址就只能给这一台主机使用了, 为什么? 因为操作系统啊, 自己只能使用自己的操作系统啊. 所以这个IP是和操作系统绑定的.</p><p>后来硬盘变得越来越廉价, 所以这些都成为历史. 现在无盘工作站已经越来越少了.</p><p>不仅如此, 我们局域网中的机器也越来越多了, 有的时候总数量会超过我们可分配的地址范围, 那怎么办? 没关系, 只要保证在同一时间不会出现所有主机上线的情况就可以了. 这样bootp协议进行了升级, 也就是现在的DHCP协议.</p><p>DHCP协议无非就是引入了一个新的租期(租约)的概念. 主机被分配的地址是有使用期限的. 一般是2Hours, 而每次经过50%的时间, 客户端就会进行续租操作 也就是1hour的时候, 重新变成了2hours.</p><p>DHCP的流程也是很简单了, 我就以一个wireshark的包来做个展示吧:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/dhcptest.png" alt="dhcptest"></p><p>过程共有4步, 从抓包的结果来看, 似乎每一次都是广播报文.</p><p>接下来再说一个有用的技术, 叫做DHCP中继. 因为我们已经知道, 每一个DHCP报文都是广播报文, 但是路由器偏偏又是隔离广播域的一道天然屏障, 这样就没法跨路由器访问DHCP服务器了.</p><p>所以为了能够访问到另一网络的DHCP服务器, 我们需要路由器将我们的广播请求转换成为单播.</p><p>就是这样, 接下来看看我们的Linux时候怎么成为一台DHCP服务器的吧, 需要的软件就是<code>dhcp</code>这个名字了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum info dhcp</span></span><br><span class="line">Loaded plugins: fastestmirror, refresh-packagekit, security</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.cn99.com</span><br><span class="line"> * extras: mirrors.cn99.com</span><br><span class="line"> * updates: mirrors.cn99.com</span><br><span class="line">Available Packages</span><br><span class="line">Name        : dhcp</span><br><span class="line">Arch        : x86_64</span><br><span class="line">Epoch       : 12</span><br><span class="line">Version     : 4.1.1</span><br><span class="line">Release     : 53.P1.el6.centos.1</span><br><span class="line">Size        : 823 k</span><br><span class="line">Repo        : updates</span><br><span class="line">Summary     : Dynamic host configuration protocol software</span><br><span class="line">URL         : http://isc.org/products/DHCP/</span><br><span class="line">License     : ISC</span><br><span class="line">Description : DHCP (Dynamic Host Configuration Protocol) is a protocol <span class="built_in">which</span> allows</span><br><span class="line">            : individual devices on an IP network to get their own network</span><br><span class="line">            : configuration information (IP address, subnetmask, broadcast address,</span><br><span class="line">            : etc.) from a DHCP server. The overall purpose of DHCP is to make it</span><br><span class="line">            : easier to administer a large network.  The dhcp package includes the</span><br><span class="line">            : ISC DHCP service and relay agent.</span><br><span class="line">            : </span><br><span class="line">            : To use DHCP on your network, install a DHCP service (or relay agent),</span><br><span class="line">            : and on clients run a DHCP client daemon.  The dhcp package provides</span><br><span class="line">            : the ISC DHCP service and relay agent.</span><br></pre></td></tr></table></figure><p>我们把它安装一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpm -ql dhcp</span></span><br><span class="line">/etc/dhcp</span><br><span class="line">/etc/dhcp/dhcpd.conf</span><br><span class="line">/etc/dhcp/dhcpd6.conf</span><br><span class="line">/etc/openldap/schema/dhcp.schema</span><br><span class="line">/etc/portreserve/dhcpd</span><br><span class="line">/etc/rc.d/init.d/dhcpd</span><br><span class="line">/etc/rc.d/init.d/dhcpd6</span><br><span class="line">/etc/rc.d/init.d/dhcrelay</span><br><span class="line">/etc/rc.d/init.d/dhcrelay6</span><br><span class="line">/etc/sysconfig/dhcpd</span><br><span class="line">/etc/sysconfig/dhcpd6</span><br><span class="line">/etc/sysconfig/dhcrelay</span><br><span class="line">/etc/sysconfig/dhcrelay6</span><br><span class="line">/usr/bin/omshell</span><br><span class="line">/usr/sbin/dhcpd</span><br><span class="line">/usr/sbin/dhcrelay</span><br><span class="line">...(omitted)</span><br><span class="line">/var/lib/dhcpd</span><br><span class="line">/var/lib/dhcpd/dhcpd.leases</span><br><span class="line">/var/lib/dhcpd/dhcpd6.leases</span><br></pre></td></tr></table></figure><p>这是在CentOS6上的rpm包安装的文件, 显然存在两个daemon, 而且他们是不能同时启动的, 因为一个是做DHCP的, 一个是做DHCP中继的, 怎么可能同时跑呢.</p><p>而且DHCP对IPv4和IPv6都有不同的配置.</p><p>这个dhcp是一个重量级DHCP服务器程序, 而由一个非常轻量的程序也可以做到, 就是<code>dnsmasq</code> 听名字也可以看出来, 这个玩意还可以用来作为DNS服务器来搞, 配置很方便, 而且十分简单轻量. 但是这一次就先不说这个了, 还是来看看dhcp的使用.</p><p>配置文件默认是空的, 但是它提供了一个配置模板, 我们复制过来看一下吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cp -av /usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample  /etc/dhcp/</span></span><br><span class="line">`/usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample<span class="string">&#x27; -&gt; `/etc/dhcp/dhcpd.conf.sample&#x27;</span></span><br></pre></td></tr></table></figure><p>不同版本的内核, 可能dhcp程序的版本也不一致.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">option domain-name <span class="string">&quot;example.org&quot;</span>;</span><br><span class="line">option domain-name-servers ns1.example.org, ns2.example.org;</span><br></pre></td></tr></table></figure><p>这就是在声明搜索域和DNS服务器啦, 当然使用的时候我们要改成IP才行.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default-lease-time 600;</span><br><span class="line">max-lease-time 7200;</span><br></pre></td></tr></table></figure><p>这就是两个常用的关于租期的全局属性. 而一个内网的配置是这样的: (或者说作用域)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">subnet 10.5.5.0 netmask 255.255.255.224 &#123;</span><br><span class="line">  range 10.5.5.26 10.5.5.30;</span><br><span class="line">  option domain-name-servers ns1.internal.example.org;</span><br><span class="line">  option domain-name <span class="string">&quot;internal.example.org&quot;</span>;</span><br><span class="line">  option routers 10.5.5.1;</span><br><span class="line">  option broadcast-address 10.5.5.31;</span><br><span class="line">  default-lease-time 600;</span><br><span class="line">  max-lease-time 7200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有很多option 这些都是可选项, 另外你发现在这个配置中还有之前说的关于租期的设置, 也就是说, 声明在外面的属性就对所有的subnet有效, 但是优先使用自己子网的配置项~</p><p>除了subnet, 还有一种叫做host, 这个可以看作是保留的地址, 粗暴的说就是VIP地址, 仅仅分配给一台特定的主机.</p><p>现在就来设置一下, 由于本机处于192.168.56.0&#x2F;24网络中, 所以就这样写:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subnet 192.168.56.0 netmask 255.255.255.0 &#123;</span><br><span class="line">    range 192.168.56.10 192.168.56.20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就行了. 后面全部注释掉:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:.,<span class="variable">$s</span>/^[^<span class="comment">#]/#/</span></span><br></pre></td></tr></table></figure><p>行了, 现在就开启服务吧.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># netstat -anup</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name   </span><br><span class="line">udp        0      0 0.0.0.0:67                  0.0.0.0:*                               1159/dhcpd  </span><br></pre></td></tr></table></figure><p>监听在UDP的67号端口上.</p><p>那么现在开启另外一台主机, 使用dhclient来强行通过这个来获得这个DHCP服务器分配的IP.</p><p>在DHCP服务器上可以查看到日志:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Oct  8 13:53:21 node1 dhcpd: DHCPDISCOVER from 00:0c:29:a7:00:c1 via eth0</span><br><span class="line">Oct  8 13:53:21 node1 dhcpd: DHCPDISCOVER from 00:0c:29:a7:00:cb via eth0</span><br><span class="line">Oct  8 13:53:22 node1 dhcpd: DHCPOFFER on 192.168.230.100 to 00:0c:29:a7:00:c1 via eth0</span><br><span class="line">Oct  8 13:53:22 node1 dhcpd: DHCPOFFER on 192.168.230.135 to 00:0c:29:a7:00:cb via eth0</span><br><span class="line">Oct  8 13:53:22 node1 dhcpd: DHCPREQUEST <span class="keyword">for</span> 192.168.230.100 (192.168.230.133) from 00:0c:29:a7:00:c1 via eth0</span><br><span class="line">Oct  8 13:53:22 node1 dhcpd: DHCPACK on 192.168.230.100 to 00:0c:29:a7:00:c1 via eth0</span><br><span class="line">Oct  8 13:53:22 node1 dhcpd: DHCPREQUEST <span class="keyword">for</span> 192.168.230.135 (192.168.230.133) from 00:0c:29:a7:00:cb via eth0</span><br><span class="line">Oct  8 13:53:22 node1 dhcpd: DHCPACK on 192.168.230.135 to 00:0c:29:a7:00:cb via eth0</span><br></pre></td></tr></table></figure><p>那么我怎么知道现在地址池分配的情况呢? 在<code>/var/lib/dhcpd/dhcpd.leases</code>. 这个文件中记录了当前租出去的IP情况, 例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lease 192.168.230.100 &#123;</span><br><span class="line">  starts 0 2017/10/08 05:53:22;</span><br><span class="line">  ends 0 2017/10/08 07:33:22;</span><br><span class="line">  cltt 0 2017/10/08 05:53:22;</span><br><span class="line">  binding state active;</span><br><span class="line">  next binding state free;</span><br><span class="line">  hardware ethernet 00:0c:29:a7:00:c1;</span><br><span class="line">&#125;</span><br><span class="line">lease 192.168.230.135 &#123;</span><br><span class="line">  starts 0 2017/10/08 05:53:22;</span><br><span class="line">  ends 0 2017/10/08 07:33:22;</span><br><span class="line">  cltt 0 2017/10/08 05:53:22;</span><br><span class="line">  binding state active;</span><br><span class="line">  next binding state free;</span><br><span class="line">  hardware ethernet 00:0c:29:a7:00:cb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时, 回到客户端, 我们会发现他的resolve.conf文件内容也是重新生成的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/resolv.conf </span></span><br><span class="line"><span class="comment"># Generated by NetworkManager</span></span><br><span class="line">domain example.org</span><br><span class="line">search example.org</span><br><span class="line">nameserver 192.168.230.132</span><br></pre></td></tr></table></figure><p>OK, 现在我们就沿着dhcp来说说PXE网络引导的相关.</p><h2 id="PXE"><a href="#PXE" class="headerlink" title="PXE"></a>PXE</h2><p>在dhcp的配置选项中, 有两个配置选项分别叫做:</p><ul><li>filename: 指明引导文件的名称</li><li>next-server: 提供引导文件的服务器的IP地址.</li></ul><p>通过配置这个就可以实现网络引导服务器的搭建, 除了这个, filename之所以说是名称而不说是路径, 是因为这个服务器同时是一台tftp服务器, 也就是说一般这个文件都放在tftp的根目录下. 所以才说是名称的.</p><p>tftp我们之前也说过的, 即 简单文件传输协议( Trivial File Transfer Protocol ). 我们来看一下介绍:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># yum info tftp-server</span></span><br><span class="line">Loaded plugins: fastestmirror, refresh-packagekit, security</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">Available Packages</span><br><span class="line">Name        : tftp-server</span><br><span class="line">Arch        : x86_64</span><br><span class="line">Version     : 0.49</span><br><span class="line">Release     : 8.el6</span><br><span class="line">Size        : 39 k</span><br><span class="line">Repo        : base</span><br><span class="line">Summary     : The server <span class="keyword">for</span> the Trivial File Transfer Protocol (TFTP)</span><br><span class="line">URL         : http://www.kernel.org/pub/software/network/tftp/</span><br><span class="line">License     : BSD</span><br><span class="line">Description : The Trivial File Transfer Protocol (TFTP) is normally used only <span class="keyword">for</span></span><br><span class="line">            : booting diskless workstations.  The tftp-server package provides the</span><br><span class="line">            : server <span class="keyword">for</span> TFTP, <span class="built_in">which</span> allows <span class="built_in">users</span> to transfer files to and from a</span><br><span class="line">            : remote machine. TFTP provides very little security, and should not be</span><br><span class="line">            : enabled unless it is expressly needed.  The TFTP server is run from</span><br><span class="line">            : /etc/xinetd.d/tftp, and is disabled by default.</span><br></pre></td></tr></table></figure><p>安装完成了之后是这样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># rpm -ql tftp-server</span></span><br><span class="line">/etc/xinetd.d/tftp</span><br><span class="line">/usr/sbin/in.tftpd</span><br><span class="line">/usr/share/doc/tftp-server-0.49</span><br><span class="line">/usr/share/doc/tftp-server-0.49/CHANGES</span><br><span class="line">/usr/share/doc/tftp-server-0.49/README</span><br><span class="line">/usr/share/doc/tftp-server-0.49/README.security</span><br><span class="line">/usr/share/doc/tftp-server-0.49/README.security.tftpboot</span><br><span class="line">/usr/share/man/man8/in.tftpd.8.gz</span><br><span class="line">/usr/share/man/man8/tftpd.8.gz</span><br><span class="line">/var/lib/tftpboot</span><br></pre></td></tr></table></figure><p>很简单, 依靠xinetd来运行.</p><p>首先在配置文件中将disable改为no 接着启动xinetd服务即可:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># vim /etc/xinetd.d/tftp </span></span><br><span class="line">[root@node1 ~]<span class="comment"># service xinetd restart</span></span><br><span class="line">Stopping xinetd:                                           [  OK  ]</span><br><span class="line">Starting xinetd:                                           [  OK  ]</span><br><span class="line">[root@node1 ~]<span class="comment"># netstat -anup</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name   </span><br><span class="line">udp        0      0 192.168.230.133:39950       192.168.230.1:53            ESTABLISHED 1573/ManagementAgen </span><br><span class="line">udp        0      0 0.0.0.0:67                  0.0.0.0:*                               2572/dhcpd          </span><br><span class="line">udp        0      0 0.0.0.0:68                  0.0.0.0:*                               1794/dhclient       </span><br><span class="line">udp        0      0 0.0.0.0:68                  0.0.0.0:*                               1796/dhclient       </span><br><span class="line">udp        0      0 0.0.0.0:69                  0.0.0.0:*                               3350/xinetd         </span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>接下来找一台主机安装tftp就行了, 使用方法不需要说什么, 因为实在是太简单了.</p><p>有了这些铺垫, 我们就可以着手来搞一个PXE启动服务器了.</p><p>首先还是先从PXE说起, 什么是PXE呢, PXE的全称是Preboot eXecute Environment. 他需要之前说的DHCP, tftp以及一个file server(yum repo)的帮助.</p><p>首先为了能够达成引导的目的, 我们需要一个</p><p>这个在syslinux包中有提供:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># yum info syslinux</span></span><br><span class="line">Loaded plugins: fastestmirror, refresh-packagekit, security</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">Installed Packages</span><br><span class="line">Name        : syslinux</span><br><span class="line">Arch        : x86_64</span><br><span class="line">Version     : 4.02</span><br><span class="line">Release     : 4.el6</span><br><span class="line">Size        : 2.0 M</span><br><span class="line">Repo        : installed</span><br><span class="line">From repo   : base</span><br><span class="line">Summary     : Simple kernel loader <span class="built_in">which</span> boots from a FAT filesystem</span><br><span class="line">URL         : http://syslinux.zytor.com/wiki/index.php/The_Syslinux_Project</span><br><span class="line">License     : GPLv2+</span><br><span class="line">Description : SYSLINUX is a suite of bootloaders, currently supporting DOS FAT</span><br><span class="line">            : filesystems, Linux ext2/ext3 filesystems (EXTLINUX), PXE network boots</span><br><span class="line">            : (PXELINUX), or ISO 9660 CD-ROMs (ISOLINUX).  It also includes a tool,</span><br><span class="line">            : MEMDISK, <span class="built_in">which</span> loads legacy operating systems from these media.</span><br></pre></td></tr></table></figure><p>它包含了一大堆引导程序, 支持各种文件系统, 网络, 光盘等等. 这里面由一个叫做<code>pxelinux.0</code>的文件我们会用到:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/syslinux/pxelinux.0</span><br></pre></td></tr></table></figure><p>现在 就来配置一下我们的DHCP服务器吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/</span></span><br><span class="line">[root@node1 ~]<span class="comment"># rm -rf /var/lib/tftpboot/fstab </span></span><br><span class="line">[root@node1 ~]<span class="comment"># mount /dev/cdrom1 /media/</span></span><br><span class="line">mount: block device /dev/sr0 is write-protected, mounting read-only</span><br><span class="line">[root@node1 ~]<span class="comment"># cp -av /media/images/pxeboot/&#123;vmlinuz,initrd.img&#125; /var/lib/tftpboot/</span></span><br><span class="line">`/media/images/pxeboot/vmlinuz<span class="string">&#x27; -&gt; `/var/lib/tftpboot/vmlinuz&#x27;</span></span><br><span class="line">`/media/images/pxeboot/initrd.img<span class="string">&#x27; -&gt; `/var/lib/tftpboot/initrd.img&#x27;</span></span><br><span class="line">[root@node1 ~]<span class="comment"># cd /media/isolinux/</span></span><br><span class="line">[root@node1 isolinux]<span class="comment"># cp -av boot.cat vesamenu.c32 splash.jpg /var/lib/tftpboot/</span></span><br><span class="line">`boot.cat<span class="string">&#x27; -&gt; `/var/lib/tftpboot/boot.cat&#x27;</span></span><br><span class="line">`vesamenu.c32<span class="string">&#x27; -&gt; `/var/lib/tftpboot/vesamenu.c32&#x27;</span></span><br><span class="line">`splash.jpg<span class="string">&#x27; -&gt; `/var/lib/tftpboot/splash.jpg&#x27;</span></span><br><span class="line">[root@node1 isolinux]<span class="comment"># mkdir /var/lib/tftpboot/pxelinux.cfg</span></span><br><span class="line">[root@node1 isolinux]<span class="comment"># cp isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default</span></span><br></pre></td></tr></table></figure><p>接下来就可以修改DHCP配置文件了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">subnet 192.168.230.0 netmask 255.255.255.0 &#123;</span><br><span class="line">  range 192.168.230.100 192.168.230.200;</span><br><span class="line">  option routers 192.168.230.1;</span><br><span class="line">  filename <span class="string">&quot;pxelinux.0&quot;</span>;</span><br><span class="line">  next-server 192.168.230.133;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样重启服务之后, 新建一个虚拟机</p><p>确保使用同一网络之后, 就会看到激动人心的画面:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/pxe.png" alt="pxe"></p><p>接着就神奇的进入了:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/centos6.png" alt="CentOS6"></p><p>怎么样, 是不是很有趣. 等到加载完vmlinuz和initrd.img时候就可以进行安装了:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/installC6.png" alt="installC6"></p><p>这是CentOS6的安装流程.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>过程总结如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CentOS 6 PXE: </span><br><span class="line">  yum -y install syslinux tftp-server</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cp</span> /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/</span><br><span class="line">  <span class="built_in">cp</span> /media/cdrom/images/pxelinux/&#123;vmlinuz,initrd.img&#125; /var/lib/tftp/boot/</span><br><span class="line">  <span class="built_in">cp</span> /media/cdrom/isolinux/&#123;boot.cfg,vesamenu.c32,splash.png&#125; /var/lib/tftp/boot/</span><br><span class="line">  <span class="built_in">mkdir</span> /var/lib/tftpboot/pxelinux.cfg/</span><br><span class="line">  <span class="built_in">cp</span> /media/cdrom/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default/</span><br></pre></td></tr></table></figure><p>如果是CentOS7, 过程和C6不太一样, 但大体相同:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CentOS 7 PXE:</span><br><span class="line">  yum -y install syslinux tftp-server</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cp</span> /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/</span><br><span class="line">  <span class="built_in">cp</span> /media/cdrom/images/pxelinux/&#123;vmlinuz,initrd.img&#125; /var/lib/tftp/boot/</span><br><span class="line">  <span class="built_in">cp</span> /usr/share/syslinux/&#123;chain.c32,mboot.c32,menu.c32,memdisk&#125; /var/lib/tftpboot/</span><br><span class="line">  <span class="built_in">mkdir</span> /var/lib/tftpboot/pxelinux.cfg/</span><br><span class="line"></span><br><span class="line">  创建/var/lib/tftpboot/pxelinux.cfg/default</span><br><span class="line">  内容类似如下：</span><br><span class="line">  default menu.c32</span><br><span class="line">  prompt 5</span><br><span class="line">  <span class="built_in">timeout</span> 30</span><br><span class="line">  MENU TITLE CentOS 7 PXE Menu</span><br><span class="line"></span><br><span class="line">  LABEL linux</span><br><span class="line">  MENU LABEL Install CentOS 7 x86_64</span><br><span class="line">  KERNEL vmlinuz</span><br><span class="line">  APPEND initrd=initrd.img inst.repo=http://YUM_IP/centos7 ks=http://KS_IP/centos7.cfg</span><br></pre></td></tr></table></figure><h2 id="Cobbler的实现"><a href="#Cobbler的实现" class="headerlink" title="Cobbler的实现"></a>Cobbler的实现</h2><p>我们在上面已经实现了一个简单的PXE网络引导环境, 那么现在说的Cobbler又是个什么东西呢? 实际上, 这是一个对PXE的更高级封装, 包括了KS, YUM等等一统之下的系统集中部署的环境.</p><p>这个玩意是使用Python实现的, 十分小巧. 我们来看一下他的架构和一些名词:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/Cobbler_first.png" alt="Cobbler_first.png"></p><p>这里最重要的部分就是Profile了, 我们在上面都知道较完整的一个网络引导起码需要vmlinuz + initrd.img, YUM repo, KS文件等等. 而不同的发行版是需要不同的, 或者说对应版本的vmlinuz, initrd.img的, 我们不能将非对应版本的这些扔到一块去.</p><p>所以Cobbler就把他们集合在一起而组成了一个个Profile, 例如我们可以制定这样的Profile:</p><p><strong>用于Web的CentOS6</strong>: (CentOS6的)vmlinuz+initrd.img+kickstart_web+CentOS6的yum repo</p><p><strong>用于数据库的CentOS7</strong>: (CentOS7的)vmlinuz+initrd.img+kickstart_db+CentOS7的yum repo</p><p>等等. </p><p>所以我们还是关注Cobbler的三个核心组件:</p><ul><li>repository<ul><li>mirror: 指向一个yum源</li><li>import: 导入一个yum源</li></ul></li><li>distribution: cobbler可以从上面的repo中, 根据你的dist自动的抽出需要的文件. </li><li>Profile: 用户编写产生</li></ul><p>过程变得这么简单, 所以才说连修鞋匠都会使用. 接下来我们就来安装看一下:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># yum list epel cobbler*</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.sohu.com</span><br><span class="line"> * epel: mirrors.ustc.edu.cn</span><br><span class="line"> * extras: mirrors.cn99.com</span><br><span class="line"> * updates: mirrors.cn99.com</span><br><span class="line">Available Packages</span><br><span class="line">cobbler.x86_64                                                                  2.6.11-1.el6                                                              epel</span><br><span class="line">cobbler-web.noarch                                                              2.6.11-1.el6                                                              epel</span><br></pre></td></tr></table></figure><p>两个软件包, 其中第二个是他的GUI接口, cobbler所有的功能都可以在他的命令行接口上实现, 所以直接安装第一个就行了.</p><p>这样来执行安装步骤:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install cobbler pykickstart syslinux debmirror dhcp tftp-server</span><br></pre></td></tr></table></figure><p>接着我们确保cobblerd服务启动, tftp-server服务启动, 为了防止出现问题, 我们事先把TFTProot中的文件删除到后者挪到别的地方. 而且把dhcp服务的配置文件中的next-server注释掉. </p><p>接着就可以开始启动服务了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># systemctl start httpd</span></span><br><span class="line">[root@master ~]<span class="comment"># systemctl start tftp</span></span><br><span class="line">[root@master ~]<span class="comment"># systemctl start dhcpd</span></span><br><span class="line">[root@master ~]<span class="comment"># systemctl start cobblerd</span></span><br></pre></td></tr></table></figure><p>在cobbler的配置文件<code>/etc/cobbler/settings</code>中找到<code>server</code>这一行, 将他的地址改成是其他主机可以发现的IP地址, 接着重启服务, 来执行check子命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># cobbler check</span></span><br><span class="line">The following are potential configuration items that you may want to fix:</span><br><span class="line"></span><br><span class="line">1 : For PXE to be functional, the <span class="string">&#x27;next_server&#x27;</span> field <span class="keyword">in</span> /etc/cobbler/settings must be <span class="built_in">set</span> to something other than 127.0.0.1, and should match the IP of the boot server on the PXE network.</span><br><span class="line">2 : SELinux is enabled. Please review the following wiki page <span class="keyword">for</span> details on ensuring cobbler works correctly <span class="keyword">in</span> your SELinux environment:</span><br><span class="line">    https://github.com/cobbler/cobbler/wiki/Selinux</span><br><span class="line">3 : change <span class="string">&#x27;disable&#x27;</span> to <span class="string">&#x27;no&#x27;</span> <span class="keyword">in</span> /etc/xinetd.d/tftp</span><br><span class="line">4 : Some network boot-loaders are missing from /var/lib/cobbler/loaders, you may run <span class="string">&#x27;cobbler get-loaders&#x27;</span> to download them, or, <span class="keyword">if</span> you only want to handle x86/x86_64 netbooting, you may ensure that you have installed a *recent* version of the syslinux package installed and can ignore this message entirely.  Files <span class="keyword">in</span> this directory, should you want to support all architectures, should include pxelinux.0, menu.c32, elilo.efi, and yaboot. The <span class="string">&#x27;cobbler get-loaders&#x27;</span> <span class="built_in">command</span> is the easiest way to resolve these requirements.</span><br><span class="line">5 : <span class="built_in">enable</span> and start rsyncd.service with systemctl</span><br><span class="line">6 : comment out <span class="string">&#x27;dists&#x27;</span> on /etc/debmirror.conf <span class="keyword">for</span> proper debian support</span><br><span class="line">7 : comment out <span class="string">&#x27;arches&#x27;</span> on /etc/debmirror.conf <span class="keyword">for</span> proper debian support</span><br><span class="line">8 : The default password used by the sample templates <span class="keyword">for</span> newly installed machines (default_password_crypted <span class="keyword">in</span> /etc/cobbler/settings) is still <span class="built_in">set</span> to <span class="string">&#x27;cobbler&#x27;</span> and should be changed, try: <span class="string">&quot;openssl passwd -1 -salt &#x27;random-phrase-here&#x27; &#x27;your-password-here&#x27;&quot;</span> to generate new one</span><br><span class="line">9 : fencing tools were not found, and are required to use the (optional) power management features. install cman or fence-agents to use them</span><br><span class="line"></span><br><span class="line">Restart cobblerd and <span class="keyword">then</span> run <span class="string">&#x27;cobbler sync&#x27;</span> to apply changes.</span><br></pre></td></tr></table></figure><p>我们就根据他的提示来一步一步的看吧! 首先第一个, 我们需要在配置文件中指定<code>next_server</code>的地址. 接着第二个可以忽略, 我们先把SELINUX关闭就行了. 下一个, 我们可以通过chkconfig来执行, 或者直接修改配置文件.  第4个, 我们已经安装好了syslinux, 所以也没关系了. 第5个, 直接就启动和设置开机启动rsync服务就可以了. 接着下面两个都是为提供Debian系的支持, 按照他说的注释掉就行了. 接着第8个, 我们重新生成一个密码放到setting中, 使用openssl来做就行. 最后一个由于我们不需要STONITH设备 所以暂时忽略掉.</p><p><strong>你的check不一定和我的完全一样, 所以还是要根据具体的输出来执行和解决.</strong></p><p>执行之后我们就可以进行同步操作了, 来执行一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># cobbler sync</span></span><br><span class="line">task started: 2017-12-11_201043_sync</span><br><span class="line">task started (<span class="built_in">id</span>=Sync, time=Mon Dec 11 20:10:43 2017)</span><br><span class="line">running pre-sync triggers</span><br><span class="line">cleaning trees</span><br><span class="line"><span class="built_in">mkdir</span>: /var/lib/tftpboot/pxelinux.cfg</span><br><span class="line"><span class="built_in">mkdir</span>: /var/lib/tftpboot/grub</span><br><span class="line"><span class="built_in">mkdir</span>: /var/lib/tftpboot/images</span><br><span class="line"><span class="built_in">mkdir</span>: /var/lib/tftpboot/s390x</span><br><span class="line"><span class="built_in">mkdir</span>: /var/lib/tftpboot/ppc</span><br><span class="line"><span class="built_in">mkdir</span>: /var/lib/tftpboot/etc</span><br><span class="line">removing: /var/lib/tftpboot/grub/images</span><br><span class="line">copying bootloaders</span><br><span class="line">trying hardlink /usr/share/syslinux/pxelinux.0 -&gt; /var/lib/tftpboot/pxelinux.0</span><br><span class="line">trying hardlink /usr/share/syslinux/menu.c32 -&gt; /var/lib/tftpboot/menu.c32</span><br><span class="line">trying hardlink /usr/share/syslinux/memdisk -&gt; /var/lib/tftpboot/memdisk</span><br><span class="line">copying distros to tftpboot</span><br><span class="line">copying images</span><br><span class="line">generating PXE configuration files</span><br><span class="line">generating PXE menu structure</span><br><span class="line">rendering TFTPD files</span><br><span class="line">generating /etc/xinetd.d/tftp</span><br><span class="line">cleaning <span class="built_in">link</span> caches</span><br><span class="line">running post-sync triggers</span><br><span class="line">running python triggers from /var/lib/cobbler/triggers/sync/post/*</span><br><span class="line">running python trigger cobbler.modules.sync_post_restart_services</span><br><span class="line">running shell triggers from /var/lib/cobbler/triggers/sync/post/*</span><br><span class="line">running python triggers from /var/lib/cobbler/triggers/change/*</span><br><span class="line">running python trigger cobbler.modules.scm_track</span><br><span class="line">running shell triggers from /var/lib/cobbler/triggers/change/*</span><br><span class="line">*** TASK COMPLETE ***</span><br><span class="line">[root@master ~]<span class="comment"># tree /var/lib/tftpboot/</span></span><br><span class="line">/var/lib/tftpboot/</span><br><span class="line">├── boot</span><br><span class="line">│   └── grub</span><br><span class="line">│       └── menu.lst</span><br><span class="line">├── etc</span><br><span class="line">├── grub</span><br><span class="line">│   ├── efidefault</span><br><span class="line">│   └── images -&gt; ../images</span><br><span class="line">├── images</span><br><span class="line">├── memdisk</span><br><span class="line">├── menu.c32</span><br><span class="line">├── ppc</span><br><span class="line">├── pxelinux.0</span><br><span class="line">├── pxelinux.cfg</span><br><span class="line">│   └── default</span><br><span class="line">└── s390x</span><br><span class="line">    └── profile_list</span><br><span class="line"></span><br><span class="line">9 directories, 7 files</span><br><span class="line">[root@master ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>看吧, Cobbler已经帮助我们把文件丢进去了.</p><p>接下来, 我们就可以继续了, 创建一个repo. 这里我们选择导入(import)的方式, 通过挂载光盘来使得Cobbler自动建立文件树:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># cobbler import --name=CentOS7_x86_64 --path=/media/</span></span><br><span class="line">task started: 2017-12-11_203518_import</span><br><span class="line">task started (<span class="built_in">id</span>=Media import, time=Mon Dec 11 20:35:18 2017)</span><br><span class="line">Found a candidate signature: breed=redhat, version=rhel6</span><br><span class="line">Found a candidate signature: breed=redhat, version=rhel7</span><br><span class="line">Found a matching signature: breed=redhat, version=rhel7</span><br><span class="line">Adding distros from path /var/www/cobbler/ks_mirror/CentOS7_x86_64:</span><br><span class="line">creating new distro: CentOS7-x86_64</span><br><span class="line">trying symlink: /var/www/cobbler/ks_mirror/CentOS7_x86_64 -&gt; /var/www/cobbler/links/CentOS7-x86_64</span><br><span class="line">creating new profile: CentOS7-x86_64</span><br><span class="line">associating repos</span><br><span class="line">checking <span class="keyword">for</span> rsync repo(s)</span><br><span class="line">checking <span class="keyword">for</span> rhn repo(s)</span><br><span class="line">checking <span class="keyword">for</span> yum repo(s)</span><br><span class="line">starting descent into /var/www/cobbler/ks_mirror/CentOS7_x86_64 <span class="keyword">for</span> CentOS7-x86_64</span><br><span class="line">processing repo at : /var/www/cobbler/ks_mirror/CentOS7_x86_64</span><br><span class="line">need to process repo/comps: /var/www/cobbler/ks_mirror/CentOS7_x86_64</span><br><span class="line">looking <span class="keyword">for</span> /var/www/cobbler/ks_mirror/CentOS7_x86_64/repodata/*comps*.xml</span><br><span class="line">Keeping repodata as-is :/var/www/cobbler/ks_mirror/CentOS7_x86_64/repodata</span><br><span class="line">*** TASK COMPLETE ***</span><br><span class="line">[root@master ~]<span class="comment"># cd /var/www/</span></span><br><span class="line">[root@master www]<span class="comment"># ls</span></span><br><span class="line">cgi-bin  cobbler  html</span><br><span class="line">[root@master www]<span class="comment"># cd /etc/httpd/conf.d/</span></span><br><span class="line">[root@master conf.d]<span class="comment"># ls</span></span><br><span class="line">autoindex.conf  cobbler.conf  README  userdir.conf  welcome.conf</span><br><span class="line">[root@master conf.d]<span class="comment"># head cobbler.conf</span></span><br><span class="line"><span class="comment"># This configuration file allows cobbler data</span></span><br><span class="line"><span class="comment"># to be accessed over HTTP.</span></span><br><span class="line"></span><br><span class="line">AliasMatch ^/cblr(?!/svc/)(.*)?$ <span class="string">&quot;/var/www/cobbler<span class="variable">$1</span>&quot;</span></span><br><span class="line">AliasMatch ^/cobbler_track(.*)?$ <span class="string">&quot;/var/www/cobbler<span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="comment">#AliasMatch ^/cobbler(.*)?$ &quot;/var/www/cobbler$1&quot;</span></span><br><span class="line">Alias /cobbler /var/www/cobbler</span><br><span class="line">Alias /cobbler_webui_content /var/www/cobbler_webui_content</span><br><span class="line"></span><br><span class="line">WSGIScriptAliasMatch ^/cblr/svc/([^/]*) /var/www/cobbler/svc/services.py</span><br></pre></td></tr></table></figure><p>我们能看到, Cobbler已经构建了一个YUM源, 并且在httpd的配置文件中定制了别名, 我们现在已经可以访问到看看了.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ks_mirror.png" alt="ks_mirror.png"></p><p>接着再次执行一次同步:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># cobbler sync</span></span><br><span class="line">task started: 2017-12-11_203756_sync</span><br><span class="line">task started (<span class="built_in">id</span>=Sync, time=Mon Dec 11 20:37:56 2017)</span><br><span class="line">running pre-sync triggers</span><br><span class="line">cleaning trees</span><br><span class="line">removing: /var/www/cobbler/images/CentOS7-x86_64</span><br><span class="line">removing: /var/lib/tftpboot/pxelinux.cfg/default</span><br><span class="line">removing: /var/lib/tftpboot/grub/images</span><br><span class="line">removing: /var/lib/tftpboot/grub/efidefault</span><br><span class="line">removing: /var/lib/tftpboot/images/CentOS7-x86_64</span><br><span class="line">removing: /var/lib/tftpboot/s390x/profile_list</span><br><span class="line">copying bootloaders</span><br><span class="line">copying distros to tftpboot</span><br><span class="line">copying files <span class="keyword">for</span> distro: CentOS7-x86_64</span><br><span class="line">trying hardlink /var/www/cobbler/ks_mirror/CentOS7_x86_64/images/pxeboot/vmlinuz -&gt; /var/lib/tftpboot/images/CentOS7-x86_64/vmlinuz</span><br><span class="line">trying hardlink /var/www/cobbler/ks_mirror/CentOS7_x86_64/images/pxeboot/initrd.img -&gt; /var/lib/tftpboot/images/CentOS7-x86_64/initrd.img</span><br><span class="line">copying images</span><br><span class="line">generating PXE configuration files</span><br><span class="line">generating PXE menu structure</span><br><span class="line">copying files <span class="keyword">for</span> distro: CentOS7-x86_64</span><br><span class="line">trying hardlink /var/www/cobbler/ks_mirror/CentOS7_x86_64/images/pxeboot/vmlinuz -&gt; /var/www/cobbler/images/CentOS7-x86_64/vmlinuz</span><br><span class="line">trying hardlink /var/www/cobbler/ks_mirror/CentOS7_x86_64/images/pxeboot/initrd.img -&gt; /var/www/cobbler/images/CentOS7-x86_64/initrd.img</span><br><span class="line">Writing template files <span class="keyword">for</span> CentOS7-x86_64</span><br><span class="line">rendering TFTPD files</span><br><span class="line">generating /etc/xinetd.d/tftp</span><br><span class="line">processing boot_files <span class="keyword">for</span> distro: CentOS7-x86_64</span><br><span class="line">cleaning <span class="built_in">link</span> caches</span><br><span class="line">running post-sync triggers</span><br><span class="line">running python triggers from /var/lib/cobbler/triggers/sync/post/*</span><br><span class="line">running python trigger cobbler.modules.sync_post_restart_services</span><br><span class="line">running shell triggers from /var/lib/cobbler/triggers/sync/post/*</span><br><span class="line">running python triggers from /var/lib/cobbler/triggers/change/*</span><br><span class="line">running python trigger cobbler.modules.scm_track</span><br><span class="line">running shell triggers from /var/lib/cobbler/triggers/change/*</span><br><span class="line">*** TASK COMPLETE ***</span><br></pre></td></tr></table></figure><p>接着我们重新打开另外一台主机. 就可以看到下面的画面:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/cobbler_first_run.png" alt="cobbler_first_run.png"></p><p>但是这显然不够, 我们想要达成无人值守的自动化安装, 就需要kickstart文件的帮助.</p><blockquote><p>脱坑指南, 如果说你在这个时候尝试进入安装的时候出现了故障:</p><p>dracut-initqueue: curl: (23) Failed writing body (11904 !&#x3D; 16384)<br>loop: module loaded<br>dracut-initqueue[579]: mount: wrong fs type, bad option, bad superblock on &#x2F;dev&#x2F;loop0<br>dracut-initqueue[579]: missing codepage or helper program, or other error<br>dracut-initqueue[579]: In some cases useful info is found in syslog - try<br>dracut-initqueue[579]: dmesg | tail or so.<br>dracut-initqueue[579]:Mumount: &#x2F;run&#x2F;initramfs&#x2F;squashfs: not mounted<br>dracut-initqueue[579]: &#x2F;sbin&#x2F;dmsquash-lice-root: line 273: printf: write error: No space left on device</p><p><img src="https://www.zhangfangzhou.cn/wp-content/uploads/2017/11/centos7-bad-superblock-.png" alt="img"></p><p>那么这个时候考虑<strong>升级内存, 起码要2G.</strong></p></blockquote><p>关于Kickstart文件的内容以及语法, 就参考红帽官方的文档就好: <a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/installation_guide/sect-kickstart-syntax#sect-kickstart-commands">KICKSTART 语法参考</a></p><p>我给出的一个小样例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#version=DEVEL</span></span><br><span class="line">firewall --disabled</span><br><span class="line"><span class="comment"># System authorization information</span></span><br><span class="line">auth --enableshadow --passalgo=sha512</span><br><span class="line">text</span><br><span class="line"><span class="comment"># Network installation</span></span><br><span class="line">url --url=<span class="string">&quot;http://192.168.224.128/cobbler/ks_mirror/CentOS7_x86_64/&quot;</span></span><br><span class="line"><span class="comment"># Keyboard layouts</span></span><br><span class="line">keyboard --vckeymap=us --xlayouts=<span class="string">&#x27;us&#x27;</span></span><br><span class="line"><span class="comment"># System language</span></span><br><span class="line">lang en_US.UTF-8</span><br><span class="line"><span class="comment"># Root password</span></span><br><span class="line">rootpw --iscrypted $6$VyQYHVcM4r7uDUwN<span class="variable">$e1wqoecztBT05bXGiHE5p5rR4siqHstjlz6Hbpuav</span>/xUG0NqzC8Hrn478skCplkCtL0KJhQgue4G0CgKDBSkW0</span><br><span class="line"></span><br><span class="line">firstboot --<span class="built_in">disable</span></span><br><span class="line">selinux --<span class="built_in">disable</span></span><br><span class="line">zerombr</span><br><span class="line"><span class="comment"># System timezone</span></span><br><span class="line">timezone Asia/Shanghai</span><br><span class="line"><span class="comment"># System bootloader configuration</span></span><br><span class="line">bootloader --append=<span class="string">&quot; crashkernel=auto&quot;</span> --location=mbr --boot-drive=sda</span><br><span class="line"></span><br><span class="line">clearpart --all</span><br><span class="line"><span class="comment"># Partition</span></span><br><span class="line">part /boot --fstype=<span class="string">&quot;ext4&quot;</span> --size=200</span><br><span class="line">part / --fstype=<span class="string">&quot;xfs&quot;</span> --size=19456</span><br><span class="line">logging --level=info</span><br><span class="line"></span><br><span class="line">%packages</span><br><span class="line">@^minimal</span><br><span class="line">@core</span><br><span class="line">net-tools</span><br><span class="line">chrony</span><br><span class="line">kexec-tools</span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line">%post --interpreter=/bin/bash</span><br><span class="line"></span><br><span class="line">/bin/hostname agent</span><br><span class="line">/usr/bin/cat <span class="string">&quot;HOSTNAME agent&quot;</span> &gt;&gt; /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>但是好像有问题…hostname的修改没有生效..</p><p>总之生成了这个文件之后我们就可以去改变profile的行为了, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cobbler profile edit --name=CentOS7-x86_64 --kickstart=%你的kickstart文件路径%</span><br><span class="line">cobbler <span class="built_in">sync</span></span><br></pre></td></tr></table></figure><p>接着我们重启机器就可以享受无人值守的PXE自动安装了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> DHCP </tag>
            
            <tag> PXE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来做个mini-Linux吧!</title>
      <link href="/2017/10/01/%E6%9D%A5%E5%81%9A%E4%B8%AAmini-Linux%E5%90%A7/"/>
      <url>/2017/10/01/%E6%9D%A5%E5%81%9A%E4%B8%AAmini-Linux%E5%90%A7/</url>
      
        <content type="html"><![CDATA[<p>制作一只超 mini 的 Tux !!</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/tux.png" alt="tux"></p><span id="more"></span><p>在制作之前, 我们一定要熟悉Linux的启动路程啊, 这个部分我已经在不同的文章中重复了三次之多了, 在这里回顾一下Linux内核编译的一些步骤:</p><p>首先我们拿到Linux kernel的源代码之后进行解压, 执行<code>make menuconfig</code> 除此之外, 我们还可以直接使用当前系统的.config模板 当然手写也是可以的, 只要确保语法没有什么错误. 接着就可以进行make了, 这里可以使用-j参数加快速度. 编译结束之后, 执行模块安装, 最后才执行整个系统的安装.</p><p>但是, 今天不是这样的方式了, 我们要先编译一个非模块的方式, 这样就不需要initrd和ramdisk&#x2F;ramfs了 这就是内核空间了, 那么文件系统方面呢? 我们移植一个bash其实就可以, 但是这样并不能使用, 他只能用来测试. 所以我们使用<strong>busybox</strong>. 这是一个很神奇的程序, 他可以模拟你想要实现的基础二进制程序, 这个我们后面再说.</p><p>这样就可以得到一个完整的OS了. 但为了能够引导系统, 我们还需要一个bootloader. OK, 现在就开始吧!</p><p>我们使用CentOS6来做这个实验, 可以考虑做之前做个快照~</p><h2 id="制作开始"><a href="#制作开始" class="headerlink" title="制作开始"></a>制作开始</h2><p>首先我们需要安装两个yum包组 – Development tools 和 Server Platform Development.  接着获取源代码.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall <span class="string">&quot;Server Platform Development&quot;</span> <span class="string">&quot;Development Tools&quot;</span> -y</span><br><span class="line">wget https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.10.67.tar.xz --no-check-certificate</span><br></pre></td></tr></table></figure><p>接着我们解压内核:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf linux-3.10.67.tar.xz -C /usr/src</span><br></pre></td></tr></table></figure><p>进入目录里, 当时在编译内核的时候我们是使用了一个系统既有的配置模板, 但是现在我们不一样了, 我们要重头制作一个最精简的内核啦, 所以查看一下make的选项: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost linux-3.10.67]<span class="comment"># make help</span></span><br><span class="line">...(omitted)</span><br><span class="line">Configuration targets:</span><br><span class="line">...(omitted)</span><br><span class="line">  allnoconfig  - New config <span class="built_in">where</span> all options are answered with no</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>这个<code>allnoconfig</code>就是我们要使用的选项.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost linux-3.10.67]<span class="comment"># make allnoconfig</span></span><br><span class="line">  HOSTCC  scripts/basic/fixdep</span><br><span class="line">  HOSTCC  scripts/kconfig/conf.o</span><br><span class="line">  SHIPPED scripts/kconfig/zconf.tab.c</span><br><span class="line">  SHIPPED scripts/kconfig/zconf.lex.c</span><br><span class="line">  SHIPPED scripts/kconfig/zconf.hash.c</span><br><span class="line">  HOSTCC  scripts/kconfig/zconf.tab.o</span><br><span class="line">  HOSTLD  scripts/kconfig/conf</span><br><span class="line">scripts/kconfig/conf --allnoconfig Kconfig</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># configuration written to .config</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>这样就得到了我们的.config模板文件. 但是这样只是得到了一份比较干净的模板, 我们接下来要做的就是根据自己的硬件状态按需启用功能. 打开配置菜单:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost linux-3.10.67]<span class="comment"># make menuconfig</span></span><br><span class="line">  HOSTCC  scripts/kconfig/lxdialog/checklist.o</span><br><span class="line">  HOSTCC  scripts/kconfig/lxdialog/inputbox.o</span><br><span class="line">  HOSTCC  scripts/kconfig/lxdialog/menubox.o</span><br><span class="line">  HOSTCC  scripts/kconfig/lxdialog/textbox.o</span><br><span class="line">  HOSTCC  scripts/kconfig/lxdialog/util.o</span><br><span class="line">  HOSTCC  scripts/kconfig/lxdialog/yesno.o</span><br><span class="line">  HOSTCC  scripts/kconfig/mconf.o</span><br><span class="line">  HOSTLD  scripts/kconfig/mconf</span><br><span class="line">scripts/kconfig/mconf Kconfig</span><br></pre></td></tr></table></figure><p>在接下来的几个步骤中, 请注意<strong>一定要确保开启的选项是和你的实际硬件情况相符合的.</strong>  如果你是VMware虚拟机的话, 应该和我的硬件情况差不多, 但还是要注意看啊</p><p>其实重点就在于位数, CPU和<strong>磁盘驱动</strong>, 最重要的就是磁盘驱动了, 接下来的选项如下:</p><blockquote><p>先贴一下我的硬件情况:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># lspci</span></span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440BX/ZX/DX - 82443BX/ZX/DX Host bridge (rev 01)</span><br><span class="line">00:01.0 PCI bridge: Intel Corporation 440BX/ZX/DX - 82443BX/ZX/DX AGP bridge (rev 01)</span><br><span class="line">00:07.0 ISA bridge: Intel Corporation 82371AB/EB/MB PIIX4 ISA (rev 08)</span><br><span class="line">00:07.1 IDE interface: Intel Corporation 82371AB/EB/MB PIIX4 IDE (rev 01)</span><br><span class="line">00:07.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 08)</span><br><span class="line">00:07.7 System peripheral: VMware Virtual Machine Communication Interface (rev 10)</span><br><span class="line">00:0f.0 VGA compatible controller: VMware SVGA II Adapter</span><br><span class="line">00:10.0 SCSI storage controller: LSI Logic / Symbios Logic 53c1030 PCI-X Fusion-MPT Dual Ultra320 SCSI (rev 01)</span><br><span class="line">00:11.0 PCI bridge: VMware PCI bridge (rev 02)</span><br><span class="line">00:15.0 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:15.1 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:15.2 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:15.3 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:15.4 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:15.5 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:15.6 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:15.7 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:16.0 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:16.1 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:16.2 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:16.3 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:16.4 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:16.5 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:16.6 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:16.7 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:17.0 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:17.1 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:17.2 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:17.3 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:17.4 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:17.5 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:17.6 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:17.7 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:18.0 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:18.1 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:18.2 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:18.3 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:18.4 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:18.5 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:18.6 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">00:18.7 PCI bridge: VMware PCI Express Root Port (rev 01)</span><br><span class="line">02:00.0 USB controller: VMware USB1.1 UHCI Controller</span><br><span class="line">02:01.0 Ethernet controller: Advanced Micro Devices [AMD] 79c970 [PCnet32 LANCE] (rev 10)</span><br><span class="line">02:02.0 Multimedia audio controller: Ensoniq ES1371 [AudioPCI-97] (rev 02)</span><br><span class="line">02:03.0 USB controller: VMware USB2 EHCI Controller</span><br><span class="line">02:05.0 Ethernet controller: Advanced Micro Devices [AMD] 79c970 [PCnet32 LANCE] (rev 10)</span><br></pre></td></tr></table></figure></blockquote><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/64bit.png" alt="64bit"></p><p>打开64位支持. 接着进入处理器配置: ( Processor type and features )</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/multi-processing.png" alt="multi-processing"></p><p>接着进入PCI总线的配置:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/pci.png" alt="pci"></p><p>打开支持. 其他都不用做.</p><p>接着进入Device Drivers &gt; SCSI device support  (  这里是因为我的设备是SCSI啊  )</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/scsi0.png" alt="scsi0"></p><p>打开SCSI的底层协议支持, 接着回到上级, 由于我是MPT协议所以打开支持:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/mpt.png" alt="mpt"></p><p>进去之后就会看到SPI的驱动支持和MPT驱动以及日志, 编译进内核:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/mpt2.png" alt="mpt2"></p><p>接着保存退出就可以了.</p><p>接着就到了编译的时候了, 由于没有模块的参与, 所以直接编译一个内核就可以了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost linux-3.10.67]<span class="comment"># make -j 2 bzImage</span></span><br></pre></td></tr></table></figure><p><strong>其实我们可以新建一个硬盘加入进来, 安装引导, 将内核放进去.</strong></p><p>如果这个时候你已经编译完了, 可以看一下报告:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Setup is 13628 bytes (padded to 13824 bytes).</span><br><span class="line">System is 1448 kB</span><br><span class="line">CRC 1c46d854</span><br><span class="line">Kernel: <span class="built_in">arch</span>/x86/boot/bzImage is ready  (<span class="comment">#1)</span></span><br></pre></td></tr></table></figure><p>内核的大小是1448 kB 怎么样? 够小了吧. </p><p>我添加了一块新的SCSI硬盘, 大小为10G, 其实2G都足够了.</p><p>OK, 开始分区划分文件系统:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># fdisk /dev/sdb</span></span><br><span class="line">Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel</span><br><span class="line">Building a new DOS disklabel with disk identifier 0xc4f29f1a.</span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, <span class="keyword">until</span> you decide to write them.</span><br><span class="line">After that, of course, the previous content won<span class="string">&#x27;t be recoverable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">WARNING: DOS-compatible mode is deprecated. It&#x27;</span>s strongly recommended to</span><br><span class="line">         switch off the mode (<span class="built_in">command</span> <span class="string">&#x27;c&#x27;</span>) and change display units to</span><br><span class="line">         sectors (<span class="built_in">command</span> <span class="string">&#x27;u&#x27;</span>).</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n      </span><br><span class="line">Command action</span><br><span class="line">   e   extended</span><br><span class="line">   p   primary partition (1-4)</span><br><span class="line">p</span><br><span class="line">Partition number (1-4): 1</span><br><span class="line">First cylinder (1-1305, default 1): 1</span><br><span class="line">Last cylinder, +cylinders or +size&#123;K,M,G&#125; (1-1305, default 1305): +100M</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Command action</span><br><span class="line">   e   extended</span><br><span class="line">   p   primary partition (1-4)</span><br><span class="line">p</span><br><span class="line">Partition number (1-4): 2</span><br><span class="line">First cylinder (15-1305, default 15): </span><br><span class="line">Using default value 15</span><br><span class="line">Last cylinder, +cylinders or +size&#123;K,M,G&#125; (15-1305, default 1305): +2G</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure><p>100M用于内核, 2G用于根文件系统.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkfs.ext4 /dev/sdb1</span></span><br><span class="line">mke2fs 1.41.12 (17-May-2010)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=1024 (<span class="built_in">log</span>=0)</span><br><span class="line">Fragment size=1024 (<span class="built_in">log</span>=0)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">28112 inodes, 112420 blocks</span><br><span class="line">5621 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=1</span><br><span class="line">Maximum filesystem blocks=67371008</span><br><span class="line">14 block <span class="built_in">groups</span></span><br><span class="line">8192 blocks per group, 8192 fragments per group</span><br><span class="line">2008 inodes per group</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">8193, 24577, 40961, 57345, 73729</span><br><span class="line"></span><br><span class="line">Writing inode tables: <span class="keyword">done</span>                            </span><br><span class="line">Creating journal (4096 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">This filesystem will be automatically checked every 35 mounts or</span><br><span class="line">180 days, whichever comes first.  Use tune2fs -c or -i to override.</span><br><span class="line">[root@localhost ~]<span class="comment"># mkfs.ext4 /dev/sdb2</span></span><br><span class="line">mke2fs 1.41.12 (17-May-2010)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Fragment size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">131648 inodes, 526128 blocks</span><br><span class="line">26306 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=541065216</span><br><span class="line">17 block <span class="built_in">groups</span></span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">7744 inodes per group</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">32768, 98304, 163840, 229376, 294912</span><br><span class="line"></span><br><span class="line">Writing inode tables: <span class="keyword">done</span>                            </span><br><span class="line">Creating journal (16384 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">This filesystem will be automatically checked every 35 mounts or</span><br><span class="line">180 days, whichever comes first.  Use tune2fs -c or -i to override.</span><br></pre></td></tr></table></figure><p>文件系统也OK了, 这样就可以开始挂载了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir /mnt/&#123;boot,sysroot&#125;</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mount /dev/sdb1 /mnt/boot/</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grub-install --root-directory=/mnt /dev/sdb</span></span><br><span class="line">Probing devices to guess BIOS drives. This may take a long time.</span><br><span class="line">Installation finished. No error reported.</span><br><span class="line">This is the contents of the device map /mnt/boot/grub/device.map.</span><br><span class="line">Check <span class="keyword">if</span> this is correct or not. If any of the lines is incorrect,</span><br><span class="line">fix it and re-run the script `grub-install<span class="string">&#x27;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(fd0)/dev/fd0</span></span><br><span class="line"><span class="string">(hd0)/dev/sda</span></span><br><span class="line"><span class="string">(hd1)/dev/sdb</span></span><br><span class="line"><span class="string">[root@localhost ~]# ls /mnt/boot/</span></span><br><span class="line"><span class="string">grub  lost+found</span></span><br><span class="line"><span class="string">[root@localhost ~]# mount /dev/sdb2 /mnt/sysroot/</span></span><br></pre></td></tr></table></figure><p>建立引导完成. 我们现在把刚刚编译结束的内核拷贝过来:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cp -av /usr/src/linux-3.10.67/arch/x86/boot/bzImage /mnt/boot/bzImage</span></span><br><span class="line">`/usr/src/linux-3.10.67/arch/x86/boot/bzImage<span class="string">&#x27; -&gt; `/mnt/boot/bzImage&#x27;</span></span><br><span class="line">[root@localhost ~]<span class="comment"># file /mnt/boot/bzImage </span></span><br><span class="line">/mnt/boot/bzImage: Linux kernel x86 boot executable bzImage, version 3.10.67 (root@localhost.localdo, RO-rootFS, swap_dev 0x1, Normal VGA</span><br></pre></td></tr></table></figure><p>我们的这个mini内核能够驱动SCSI硬盘,所以我们不需要ramdisk了, 接下来编辑grub.conf配置使得引导内核就行了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">default=0</span><br><span class="line"><span class="built_in">timeout</span>=3</span><br><span class="line">title Mini Linux(3.10.67)</span><br><span class="line">        root (hd0,0)</span><br><span class="line">        kernel /bzImage ro root=/dev/sda2</span><br></pre></td></tr></table></figure><p>上面就是我们的grub.conf. 好了, 使用<code>sync</code>写入到磁盘. <strong>挂起虚拟机!</strong></p><p>接着, 新建虚拟机 –&gt; 不选择系统, 选择之前创建的那个虚拟SCSI硬盘, 配置完成. </p><p>激动人心的时刻到来~ 开机~</p><p>接着, 内核炸啦 ! ! !</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/panic.png" alt="panic"></p><p>看一下panic信息: 没有文件系统可以挂载根. 原因很简单, 我们没法驱动文件系统….所以只能重新编译内核, 加入文件系统.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/fs.png" alt="fs"></p><p>进入文件系统设置, 直接把ext家族都选进内核. 除此之外, 我们还要进入上级目录中的可执行文件格式, 打开ELF支持和#!支持.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/elf.png" alt="elf"></p><p>退出并保存.</p><p>好了, 编译吧.</p><p>编译结束之后, 我们把新的覆盖掉. 还是要先同步数据接着挂起.</p><p>重新启动小企鹅 ! ! !</p><p>……</p><p>啊 ! 内核又被我们吓死了!</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/noinit.png" alt="noinit"></p><p>但是查看一些信息, 我们发现, 文件系统已经挂载上去了. 内核被吓死的原因其实是因为没有init程序. </p><p>所以接下来, 就到了busybox登场的时候了!</p><h2 id="移植bash-shell"><a href="#移植bash-shell" class="headerlink" title="移植bash shell"></a>移植bash shell</h2><p>首先我们先来了解一下主程序是什么玩意, 在源码的init目录下, 有个main.c文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /usr/src/linux-3.10.67/init/main.c</span></span><br></pre></td></tr></table></figure><p>840行左右有个:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/exec.png" alt="exec"></p><p>这就是尝试加载的顺序. 可以看出来, 即使你只有个sh程序, 也是可以跑的.</p><p>在使用busybox模拟之前, 我们先尝试移植一个bash shell过去好了</p><p>先来手动模拟个根, 进入sysroot</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sysroot]<span class="comment"># mkdir -pv bin dev etc home lib lib64 media mnt proc root sbin sys tmp usr/&#123;bin,sbin,lib,lib64&#125; var/&#123;log,run,lock&#125;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `bin<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `dev&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `etc<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `home&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `lib<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `lib64&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `media<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `mnt&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `proc<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `root&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `sbin<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `sys&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `tmp<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `usr&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `usr/bin<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `usr/sbin&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `usr/lib<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `usr/lib64&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `var<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `var/log&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `var/run<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `var/lock&#x27;</span></span><br></pre></td></tr></table></figure><p>为了方便移植, 我们写一个脚本, 贴在下面:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">target=/mnt/sysroot</span><br><span class="line">[ -d <span class="variable">$target</span> ] || <span class="built_in">mkdir</span> <span class="variable">$target</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&#x27;A command: &#x27;</span> <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">libcp</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> lib <span class="keyword">in</span> $(ldd <span class="variable">$1</span> | grep -o <span class="string">&quot;[^[:space:]]*/lib[^[:space:]]*&quot;</span>); <span class="keyword">do</span></span><br><span class="line">        libdir=$(<span class="built_in">dirname</span> <span class="variable">$lib</span>)</span><br><span class="line">        [ -d $target<span class="variable">$libdir</span> ] || <span class="built_in">mkdir</span> -p $target<span class="variable">$libdir</span></span><br><span class="line">        [ -f $target<span class="variable">$lib</span> ] || <span class="built_in">cp</span> <span class="variable">$lib</span> $target<span class="variable">$lib</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$command</span>&quot;</span> != <span class="string">&#x27;quit&#x27;</span> ]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> ! <span class="built_in">which</span> <span class="variable">$command</span> &amp;&gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">read</span> -p <span class="string">&quot;No such command.enter again: &quot;</span> <span class="built_in">command</span></span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">command</span>=$(<span class="built_in">which</span> --skip-alias <span class="variable">$command</span>)</span><br><span class="line">    cmddir=$(<span class="built_in">dirname</span> <span class="variable">$command</span>)</span><br><span class="line">    [ -d <span class="variable">$cmddir</span> ] || <span class="built_in">mkdir</span> -p $target<span class="variable">$cmddir</span></span><br><span class="line">    [ -d $target<span class="variable">$command</span> ] || <span class="built_in">cp</span> <span class="variable">$command</span> $target<span class="variable">$command</span></span><br><span class="line">    libcp <span class="variable">$command</span></span><br><span class="line">    <span class="built_in">read</span> -p <span class="string">&quot;Another command? (enter quit to exit) &quot;</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>使用这个脚本我们把bash和ls程序复制到了新的根里.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># tree /mnt/sysroot/</span></span><br><span class="line">/mnt/sysroot/</span><br><span class="line">├── bin</span><br><span class="line">│   ├── bash</span><br><span class="line">│   └── <span class="built_in">ls</span></span><br><span class="line">├── dev</span><br><span class="line">├── etc</span><br><span class="line">├── home</span><br><span class="line">├── lib</span><br><span class="line">├── lib64</span><br><span class="line">│   ├── ld-linux-x86-64.so.2</span><br><span class="line">│   ├── libacl.so.1</span><br><span class="line">│   ├── libattr.so.1</span><br><span class="line">│   ├── libcap.so.2</span><br><span class="line">│   ├── libc.so.6</span><br><span class="line">│   ├── libdl.so.2</span><br><span class="line">│   ├── libpthread.so.0</span><br><span class="line">│   ├── librt.so.1</span><br><span class="line">│   ├── libselinux.so.1</span><br><span class="line">│   └── libtinfo.so.5</span><br><span class="line">....(omitted)</span><br></pre></td></tr></table></figure><p>好了, 我们在 grub.conf 中加入 init&#x3D;&#x2F;bin&#x2F;bash 明确告诉内核如何启动. </p><p>还是一样的步骤: 写入磁盘, 挂起, 重启小企鹅.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/bash%21.png" alt="bash!"></p><p>终于! 内核没有恐慌啦. 但是你又发现, 怎么敲, 小企鹅也没反应. </p><p>原因很简单, 没有键盘驱动. 那么再来一次吧…这次要把输入设备的驱动支持加入到内核中.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/keyboard.png" alt="keyboard"></p><p>加入鼠标和键盘支持, 注意这里的鼠标是PS2的, 而VMware模拟的鼠标是USB驱动的, 所以还要开启USB驱动支持:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/usb.png" alt="usb"></p><p>这里我把USB1.1, 2.0, 3.0的驱动都打开了.</p><p>编译内核,拷贝,重复磁盘写入,挂起步骤.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/bashNew.png" alt="bashNew"></p><p>小企鹅站起来啦!</p><p>那么接下来, 我们使用脚本来模拟一下init程序, 在&#x2F;mnt&#x2F;sysroot&#x2F;sbin&#x2F;init中写上:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\tWelcome to \033[32mMini Linux\033[0m&quot;</span></span><br><span class="line">mount -n -t proc proc /proc</span><br><span class="line">mount -n -t sysfs sysfs /sys</span><br><span class="line">mount -n -o remount,rw /dev/sda2 /</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><p>再给他加几个程序:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sysroot]<span class="comment"># bash ~/cp.sh </span></span><br><span class="line">A <span class="built_in">command</span>:<span class="built_in">touch</span></span><br><span class="line">Another <span class="built_in">command</span>? (enter quit to <span class="built_in">exit</span>)  mount</span><br><span class="line">Another <span class="built_in">command</span>? (enter quit to <span class="built_in">exit</span>)  blkid</span><br><span class="line">Another <span class="built_in">command</span>? (enter quit to <span class="built_in">exit</span>)  top</span><br><span class="line">Another <span class="built_in">command</span>? (enter quit to <span class="built_in">exit</span>)  ps</span><br><span class="line">Another <span class="built_in">command</span>? (enter quit to <span class="built_in">exit</span>)  quit</span><br></pre></td></tr></table></figure><p>再来!</p><p>进去之后发现还是没有&#x2F;proc和&#x2F;sys…没关系, 手动再挂载一次. 这样就可以看到当前的挂载情况了:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/mountOK.png" alt="mountOK"></p><p> 但是你会发现, 我们不能把磁盘挂载过来, 原因是&#x2F;dev下是空的. 这个我们之前也说过dev下的设备文件是由udev创建的 那怎么办? 没关系, 我们的内核提供了这个功能, 可以不依靠udev, 我们 回到宿主机重新打开menuconfig:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/maindevNew.png" alt="maindevNew"></p><p>再来吧.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/new.png" alt="new"></p><p> 这样我们的dev下就可以看到设备文件了. 这就是那个选项的功用.</p><p>接着我们把sda2挂载到根目录下就好了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash-4.1<span class="comment"># mount -n -t ext4 -o remount,rw /dev/sda2 /</span></span><br></pre></td></tr></table></figure><p>完成! 但是现在离我们的目标还差一个重要的部分, 还记得原本我们计划使用busybox来模拟用户空间的吗. 所以现在就要编译一个busybox给我们的小Tux使用啦</p><h2 id="busybox"><a href="#busybox" class="headerlink" title="busybox"></a>busybox</h2><p>这里使用的busybox版本是1.22.1(Stable).</p><p>首先获取 <a href="http://busybox.net/downloads/busybox-1.22.1.tar.bz2">源代码</a> , 将其解压之后可以通过INSTALL文档来获得帮助.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># tar xf busybox-1.22.1.tar.bz2 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># cd busybox-1.22.1</span></span><br><span class="line">[root@localhost busybox-1.22.1]<span class="comment"># less INSTALL </span></span><br></pre></td></tr></table></figure><p>你会发现,busybox的构建方式和内核特别像.</p><p>在编译之前, 显然我们的busybox应该编译成为一个单独的应用程序. 这就需要进行<strong>静态编译</strong> 也就是不使用共享的链接库, 我们的glibc提供了一个专门用于进行静态编译的包:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Installed Packages</span><br><span class="line">glibc.x86_64                                </span><br><span class="line">glibc-common.x86_64                         </span><br><span class="line">glibc-devel.x86_64                          </span><br><span class="line">glibc-headers.x86_64                        </span><br><span class="line">Available Packages</span><br><span class="line">glibc.i686                                  </span><br><span class="line">glibc-devel.i686                            </span><br><span class="line">glibc-static.i686                           </span><br><span class="line">glibc-static.x86_64                         </span><br><span class="line">glibc-utils.x86_64                          </span><br></pre></td></tr></table></figure><p>就是那个static了, 如果没有安装devel的话还是要先安装这个的( 不过一般机器都是装过的吧</p><p>接着就可以开始进行配置和编译了.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/build0.png" alt="build0"></p><p>进去之后你会发现, 这个界面和我们编译内核的配置界面很相似, 这个就是tui嘛. 我们要注意的选项是Build Options,</p><p>进去之后看到的第一项就是我们要勾选的:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/static0.png" alt="static0"></p><p>接着回到上级, 我们进入make Install行为设置:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/makeInstall.png" alt="makeInstall"></p><p>我们可以直接把安装的位置放到&#x2F;mnt&#x2F;sysroot目录下, 也可以不修改直接编译, 反正复制过去就可以了.</p><p>那么接下来保存退出就好, 执行<code>make &amp;&amp; make install</code> </p><p>既然使用了busybox, 我们就不需要原先手动创建的那些目录了, 将他们删除:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /mnt/sysroot/</span></span><br><span class="line">[root@localhost sysroot]<span class="comment"># ls</span></span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  proc  root  sbin  sys  tmp  usr  var</span><br><span class="line">[root@localhost sysroot]<span class="comment"># rm -rf ./*</span></span><br><span class="line">[root@localhost sysroot]<span class="comment"># ls</span></span><br><span class="line">[root@localhost sysroot]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>编译完成了之后, 我们把所有的_install下的文件复制到&#x2F;mnt&#x2F;sysroot上去.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost busybox-1.22.1]<span class="comment"># cp -a ./_install/* /mnt/sysroot/</span></span><br></pre></td></tr></table></figure><p>来确认一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sysroot]<span class="comment"># ll</span></span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Oct  2 11:51 bin</span><br><span class="line">lrwxrwxrwx. 1 root root   11 Oct  2 11:51 linuxrc -&gt; bin/busybox</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Oct  2 11:51 sbin</span><br><span class="line">drwxr-xr-x. 4 root root 4096 Oct  2 11:51 usr</span><br></pre></td></tr></table></figure><p>其中有个软链, 这个是在模拟init程序, 我们并不需要这个, 所以也把他删除吧. 因为我们有个init程序在sbin目录下: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sysroot]<span class="comment"># ls sbin/ | grep init</span></span><br><span class="line">init</span><br></pre></td></tr></table></figure><p>这样就可以改写grub.conf文件, 将启动参数指向这个程序就行了. 不过为了保险起见, 我们还是把一些目录创建一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sysroot]<span class="comment"># mkdir -pv tmp proc sys etc home root mnt media var lib lib64 dev boot</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `tmp<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `proc&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `sys<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `etc&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `home<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `root&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `mnt<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `media&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `var<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `lib&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `lib64<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir: created directory `dev&#x27;</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `boot<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>没完, 这个sbin&#x2F;init程序是需要读取etc&#x2F;inittab来工作的, 所以我们需要提供这样一个文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/rc.d/rc.sysinit</span><br><span class="line">console::respawn:-/bin/sh</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/bin/mount -a -r</span><br></pre></td></tr></table></figure><p>但是现在也没有这个rc.sysinit脚本啊, 只好手写一个了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\tWelcome to \033[32mMini Linux\033[0m !&quot;</span></span><br><span class="line">mount -n -t proc proc /proc</span><br><span class="line">mount -n -t sysfs sysfs /sys</span><br><span class="line">mount -o remount,rw /dev/sda2 /</span><br></pre></td></tr></table></figure><p>由于inittab已经开启了一个console了, 所以不需要再启动shell了. 赋予执行权限之后再来一次就好了.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/welcom.png" alt="welcom"></p><p>看到那个提示语了么! 这就说明init成功了!</p><p><strong>踩坑提示: sh不支持-n参数, 所以这个地方应该把脚本中的-n参数弄掉</strong></p><p>我们来完善这个小企鹅, 加上fstab:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /mnt/sysroot/etc/fstab</span></span><br><span class="line"></span><br><span class="line">proc            /proc   proc    defaults        0 0</span><br><span class="line">sysfs           /sys    sysfs   defaults        0 0</span><br><span class="line">/dev/sda1       /boot   ext4    defaults        0 0</span><br><span class="line">/dev/sda2       /       ext4    defaults        0 0</span><br></pre></td></tr></table></figure><p>并且完善我们的启动脚本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\tWelcome to \033[32mMini Linux\033[0m !&quot;</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;scan /sys and populate /dev...&quot;</span></span><br><span class="line">mdev -s</span><br><span class="line"></span><br><span class="line">mount -o remount,rw /dev/sda2 /</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mounting all file systems...&quot;</span></span><br><span class="line">mount -a</span><br></pre></td></tr></table></figure><p>其中有个mdev, 这个就是充当udev功能的.</p><p>接着, 完善我们的启动终端:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/rc.d/rc.sysinit</span><br><span class="line">tty1::askfirst:/bin/sh</span><br><span class="line">tty2::askfirst:/bin/sh</span><br><span class="line">tty3::askfirst:/bin/sh</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/bin/mount -a -r</span><br></pre></td></tr></table></figure><p>重启进入系统, 这个时候你如果使用Alt+f2来切换的话, 就会看到:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/active.png" alt="active"></p><p>这就是askfirst的效果. 但是mount还是有问题. 考虑到busybox的Bug, 我们把系统上的mount复制过去.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sysroot]<span class="comment"># cd bin/</span></span><br><span class="line">[root@localhost bin]<span class="comment"># ls</span></span><br><span class="line">ash      <span class="built_in">chgrp</span>   cttyhack       dumpkmap  fgrep   hostname  <span class="built_in">kill</span>     lsattr    more        netstat        <span class="built_in">printenv</span>   <span class="built_in">rmdir</span>         setserial  <span class="built_in">sync</span>    usleep</span><br><span class="line"><span class="built_in">base64</span>   <span class="built_in">chmod</span>   <span class="built_in">date</span>           <span class="built_in">echo</span>      fsync   hush      linux32  lzop      mount       <span class="built_in">nice</span>           ps         rpm           sh         tar     vi</span><br><span class="line">busybox  <span class="built_in">chown</span>   <span class="built_in">dd</span>             ed        getopt  ionice    linux64  makemime  mountpoint  pidof          <span class="built_in">pwd</span>        run-parts     <span class="built_in">sleep</span>      <span class="built_in">touch</span>   watch</span><br><span class="line"><span class="built_in">cat</span>      conspy  <span class="built_in">df</span>             egrep     grep    iostat    <span class="built_in">ln</span>       <span class="built_in">mkdir</span>     mpstat      ping           reformime  scriptreplay  <span class="built_in">stat</span>       <span class="literal">true</span>    zcat</span><br><span class="line">catv     <span class="built_in">cp</span>      dmesg          <span class="literal">false</span>     gunzip  ipcalc    login    <span class="built_in">mknod</span>     mt          ping6          rev        sed           <span class="built_in">stty</span>       umount</span><br><span class="line">chattr   cpio    dnsdomainname  fdflush   gzip    kbd_mode  <span class="built_in">ls</span>       <span class="built_in">mktemp</span>    <span class="built_in">mv</span>          pipe_progress  <span class="built_in">rm</span>         setarch       su         <span class="built_in">uname</span></span><br><span class="line">[root@localhost bin]<span class="comment"># mv mount mount.orig</span></span><br><span class="line">[root@localhost bin]<span class="comment"># bash ~/cp.sh </span></span><br><span class="line">A <span class="built_in">command</span>:mount</span><br><span class="line">Another <span class="built_in">command</span>? (enter quit to <span class="built_in">exit</span>)  bash</span><br><span class="line">Another <span class="built_in">command</span>? (enter quit to <span class="built_in">exit</span>)  quit</span><br><span class="line">[root@localhost bin]<span class="comment"># ls</span></span><br><span class="line">ash      chattr  cpio      dnsdomainname  fdflush  gzip      kbd_mode  <span class="built_in">ls</span>        <span class="built_in">mktemp</span>      mt       ping6          rev           sed        <span class="built_in">stty</span>   umount</span><br><span class="line"><span class="built_in">base64</span>   <span class="built_in">chgrp</span>   cttyhack  dumpkmap       fgrep    hostname  <span class="built_in">kill</span>      lsattr    more        <span class="built_in">mv</span>       pipe_progress  <span class="built_in">rm</span>            setarch    su     <span class="built_in">uname</span></span><br><span class="line">bash     <span class="built_in">chmod</span>   <span class="built_in">date</span>      <span class="built_in">echo</span>           fsync    hush      linux32   lzop      mount       netstat  <span class="built_in">printenv</span>       <span class="built_in">rmdir</span>         setserial  <span class="built_in">sync</span>   usleep</span><br><span class="line">busybox  <span class="built_in">chown</span>   <span class="built_in">dd</span>        ed             getopt   ionice    linux64   makemime  mount.orig  <span class="built_in">nice</span>     ps             rpm           sh         tar    vi</span><br><span class="line"><span class="built_in">cat</span>      conspy  <span class="built_in">df</span>        egrep          grep     iostat    <span class="built_in">ln</span>        <span class="built_in">mkdir</span>     mountpoint  pidof    <span class="built_in">pwd</span>            run-parts     <span class="built_in">sleep</span>      <span class="built_in">touch</span>  watch</span><br><span class="line">catv     <span class="built_in">cp</span>      dmesg     <span class="literal">false</span>          gunzip   ipcalc    login     <span class="built_in">mknod</span>   </span><br></pre></td></tr></table></figure><p>行了, 再试一次吧.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/suc1.png" alt="suc1"></p><p>这一次成功挂载! 一个较完整的小企鹅站起来啦! 但是作为Linux内核, 没有网络功能岂不是很讽刺 所以我们要给他加上网络功能</p><p>( 其实这样折腾还蛮累的…. )</p><p>首先打开网络支持:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/networkingsupport.png" alt="networkingsupport"></p><p>接着进入选项打开TCP&#x2F;IP网络支持, 如果你有兴致也可以把多播和高级路由打开.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/tcpip.png" alt="tcpip"></p><p>接着就是网卡驱动的支持:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/networkdriver.png" alt="networkdriver"></p><p>具体到Ethernet网卡的驱动:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ethernet0.png" alt="ethernet0"></p><p>这里面有很多无用的驱动, 都把他们关掉. 只要打开你自己网卡的支持就行了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># lspci</span></span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440BX/ZX/DX - 82443BX/ZX/DX Host bridge (rev 01)</span><br><span class="line">00:01.0 PCI bridge: Intel Corporation 440BX/ZX/DX - 82443BX/ZX/DX AGP bridge (rev 01)</span><br><span class="line">00:07.0 ISA bridge: Intel Corporation 82371AB/EB/MB PIIX4 ISA (rev 08)</span><br><span class="line">00:07.1 IDE interface: Intel Corporation 82371AB/EB/MB PIIX4 IDE (rev 01)</span><br><span class="line">00:07.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 08)</span><br><span class="line">00:07.7 System peripheral: VMware Virtual Machine Communication Interface (rev 10)</span><br><span class="line">00:0f.0 VGA compatible controller: VMware SVGA II Adapter</span><br><span class="line">00:10.0 SCSI storage controller: LSI Logic / Symbios Logic 53c1030 PCI-X Fusion-MPT Dual Ultra320 SCSI (rev 01)</span><br><span class="line">00:11.0 PCI bridge: VMware PCI bridge (rev 02)</span><br><span class="line">...(omitted)</span><br><span class="line">02:00.0 USB controller: VMware USB1.1 UHCI Controller</span><br><span class="line">02:01.0 Ethernet controller: Advanced Micro Devices [AMD] 79c970 [PCnet32 LANCE] (rev 10)</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/amd1.png" alt="amd1"></p><p>这样就行了, 保存编译吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost linux-3.10.67]<span class="comment"># cp -av arch/x86/boot/bzImage /mnt/boot/</span></span><br><span class="line"><span class="built_in">cp</span>: overwrite `/mnt/boot/bzImage<span class="string">&#x27;? y</span></span><br><span class="line"><span class="string">`arch/x86/boot/bzImage&#x27;</span> -&gt; `/mnt/boot/bzImage<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>我被坑了. 我就纳闷明明物理机的网卡是Intel e1000怎么模拟了个AMD, 其实我是Intel的NIC啊,,,所以后来又重新编译了一次, 就不上图了…心累</p></blockquote><p>接着就会看到:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ifconfig0.png" alt="ifconfig0"></p><p>配置上IP启用就可以正常的Ping了.</p><p>再来折腾点新的玩意, 这一次我们把网络驱动编译成模块.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ntel.png" alt="ntel"></p><p>接着正常编译, 但这次不同的是, 我们需要额外的编译一个单独的模块.</p><p>这样来:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost linux-3.10.67]<span class="comment"># make M=drivers/net/ethernet/intel/e1000/</span></span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  LD [M]  drivers/net/ethernet/intel/e1000/e1000.ko</span><br><span class="line">[root@localhost linux-3.10.67]<span class="comment"># mkdir /mnt/sysroot/lib/modules -pv</span></span><br><span class="line"><span class="built_in">mkdir</span>: created directory `/mnt/sysroot/lib/modules<span class="string">&#x27;</span></span><br><span class="line"><span class="string">[root@localhost linux-3.10.67]# cp drivers/net/ethernet/intel/e1000/e1000.ko /mnt/sysroot/lib/modules/</span></span><br><span class="line"><span class="string">[root@localhost linux-3.10.67]# </span></span><br></pre></td></tr></table></figure><p>重新开机:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ins0.png" alt="ins0"></p><p>果然, 没有了驱动, mini Tux无法认识他的新朋友Intel e1000网卡. 但是我们可以插一下模块, Tux就会认识了:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ins1.png" alt="ins1"></p><p>现在就可以再次验证:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ins2.png" alt="ins2"></p><p>大功告成. 这样我们就继续补充配置我们小企鹅了.</p><p>在rc.sysinit中加入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;loading Intel e1000...&quot;</span></span><br><span class="line">insmod lib/modules/e1000.ko</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Initializing NIC...&quot;</span></span><br><span class="line">ifconfig eth1 192.168.206.133 up</span><br><span class="line">ifconfig lo 127.0.0.1 up</span><br><span class="line"></span><br><span class="line">[ -f /etc/sysconfig/network ] &amp;&amp; . /etc/sysconfig/network</span><br><span class="line">[ -z <span class="string">&quot;<span class="variable">$HOSTNAME</span>&quot;</span> -o <span class="variable">$HOSTNAME</span> == <span class="string">&#x27;(none)&#x27;</span> ] &amp;&amp; HOSTNAME=<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">hostname <span class="variable">$HOSTNAME</span></span><br></pre></td></tr></table></figure><p>接着创建&#x2F;etc&#x2F;sysconfig&#x2F;network, 向里面echo一句:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sysroot]<span class="comment"># mkdir etc/sysconfig</span></span><br><span class="line">[root@localhost sysroot]<span class="comment"># echo &quot;HOSTNAME=miniTux.yaoxuannn.com&quot; &gt; etc/sysconfig/network </span></span><br></pre></td></tr></table></figure><p>除了网络的初始化, 我们还想让这只小企鹅增加用户用户认证的功能, 怎么办?</p><p>步骤如下:</p><ul><li>创建用户, 以及所需要的文件(passwd, group, shadow)</li><li>修改inittab, 运行getty.</li><li>最好使用简单的加密算法</li></ul><p>动手!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># chroot /mnt/sysroot/ /bin/sh</span></span><br><span class="line">/ <span class="comment"># adduser root</span></span><br><span class="line">adduser: /etc/passwd: No such file or directory</span><br><span class="line">/ <span class="comment"># touch /etc/passwd /etc/shadow /etc/group</span></span><br><span class="line">/ <span class="comment"># adduser root</span></span><br><span class="line">passwd: unknown uid 0</span><br><span class="line">/ <span class="comment"># vim /etc/passwd</span></span><br><span class="line">/bin/sh: vim: not found</span><br><span class="line">/ <span class="comment"># vi /etc/passwd</span></span><br><span class="line">/ <span class="comment"># vi /etc/group</span></span><br><span class="line">/ <span class="comment"># # file shadow is a little difficult to handle...I choose to copy one line from the real root...</span></span><br><span class="line">/ <span class="comment"># </span></span><br></pre></td></tr></table></figure><p>( 真的心累…..</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># head -1 /etc/shadow &gt; /mnt/sysroot/etc/shadow</span></span><br><span class="line">[root@localhost ~]<span class="comment"># openssl passwd -1 -salt $(openssl rand -hex 4)</span></span><br><span class="line">Password: </span><br><span class="line">$1$e1f8a47b<span class="variable">$sdg4zhqqBfNE</span>..EMno.q60</span><br><span class="line">[root@localhost ~]<span class="comment"># vim /mnt/sysroot/etc/shadow</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chmod 400 /mnt/sysroot/etc/shadow</span></span><br></pre></td></tr></table></figure><p>接下来就可以去搞我们的初始化脚本了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/rc.d/rc.sysinit</span><br><span class="line">::respawn:/sbin/getty 9600 tty1</span><br><span class="line">::respawn:/sbin/getty 9600 tty2</span><br><span class="line">::respawn:/sbin/getty 9600 tty3</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/bin/mount -a -r</span><br></pre></td></tr></table></figure><p>挂起, 打开小企鹅!</p><p>It works! 我们的脚本工作了, 但是一敲回车就进入sh了..所以还是不行, 看样子是哪里有问题. ( 难道是busybox的Bug?</p><h2 id="折腾不动了-后面有空再填坑-拜拜"><a href="#折腾不动了-后面有空再填坑-拜拜" class="headerlink" title="折腾不动了, 后面有空再填坑, 拜拜"></a>折腾不动了, 后面有空再填坑, 拜拜</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NFS和Samba</title>
      <link href="/2017/09/30/NFS%E5%92%8CSamba/"/>
      <url>/2017/09/30/NFS%E5%92%8CSamba/</url>
      
        <content type="html"><![CDATA[<p>Linux和Windows的文件共享, NFS和Samba (SMB)</p><span id="more"></span><h2 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h2><p>前面在说ftp文件共享的时候我们提到了NFS是Linux&#x2F;Unix上一个常用的文件共享服务中的一种. NFS的全称是Network File System. 一般情况下, 文件系统在内核中实现, 但并不是说文件系统不能在用户空间实现, 例如分布式的一些文件系统, 特别是一些网络文件系统和虚拟文件系统, 在内核中由一个叫FUSE的模块专门用来实现这个, 当然这不是这篇文章的重点. NFS是在内核中实现的, 在编译内核的时候就有这个选项的配置.</p><p>NFS中最大的问题就是在对本地文件系统的接口调用要被映射到网络上的另外一台主机上. 这是如何实现的? </p><p>在很久很久之前我们曾经提到过RPC, 远程过程调用的概念. 我们在内核上实现了很多系统调用, 当用户空间的程序需要进行特权操作的时候, 会发起系统调用, 这是<strong>本地系统调用</strong> 例如 ( read(), write(), open(), close() ) 而所谓远程过程调用其实就是把这个原本的过程调用发给远端主机. 当然这个也是需要监听在某个套接字的. 接受到了传过来的函数和参数的时候, 就会通过这个服务进程来托付给远端的OS 其实就相当于是对于远端机器的本地系统调用.当执行结束了之后, 这个执行结果就会<strong>返回给这个监听服务进程</strong>, 接着该进程再将结果构造成响应报文发送给发起调用的主机. 这就是RPC. 从本质讲他还是系统调用, 一部分的功能交给了本地程序, 一部分交给了远程主机的函数.</p><p>这个基本上就是NFS的工作模式, 当你对文件系统发起操作的时候, 内核中的NFS模块会得到响应, 尽管要操作的目录的本地并不存在, 但是NFS模块会帮助你从远端拿到结果并返回给你. 那么我们知道, 只要涉及到跨主机的情况, 为了能够使得双方得到兼容, 或者说双方都可以明确意思, 就需要<strong>协议</strong>的帮助, 或者使用<strong>半结构化的数据</strong>, 例如xml, json, http(RESTful)等.</p><p>在早期的NFS版本中, 有个非常棘手的问题, 就是文件权限的问题. 想象在本地主机test(uid&#x3D;1002)用户存储了一个文件到远端主机上, 但是问题是远端主机上没有test这个用户啊? 这怎么办? 好办! 我们说过用户和组的本质只是一个ID号, 那么只要在远端主机上直接看到的就是1002这个ID号就行了, 但是, 巧合的是远端主机上正好有一个叫centos的用户的ID号也是1002, 这样子就乱套了. 除此之外, 我们知道root用户的ID号是0, 而在每一台主机上都是如此, 所以root用户就还是拥有可以操作远端一切文件的权限了.</p><p>因此, NFS的解决方法是进行权限的集中管理, 并且进行root的权限挤压, 也就是说, 当收到root用户存储的文件时, 会自动将这个root用户挤压成一个权限最小的用户, 来避免权限问题. 而用户不同的问题使用了一个新的机制, 叫做NIS. </p><p>NIS的全称是Network Information System, 如他的名字一样, 这个系统就像是一个信息库, 单独存放用户的账号信息. 我们知道进行登录是需要一个login程序的. 当我们输入了账号之后, login程序就会去找NIS去询问有没有这个账号啊? 如果有的话就显示password, 接着再将用户输入的密码发送给NIS询问密码是否正确 这样的一套工作流程. 问题终于解决了? 有意思的是, NIS协议是明文的. emmmmm, 所以NIS不建议在互联网上使用, 除此之外, NIS成为了这个网络的重要节点. 所以这样的缺点, 使得NIS的使用率并不高, 甚至说几乎没有在使用这个. 而现在使用的更多的是LDAP.</p><p>好吧, 我不使用NIS了. 现在怎么解决问题呢? 于是就想到了类似vsftpd的那种用户映射的模式, 在新版本的NFS中, 由一个叫做idmapd的服务端服务来完成这个事情, 实现用户账号的映射.</p><p>对于NFS来说, 另一个棘手的问题是用户认证这件事, 因为他只负责文件系统, 不能像其他的远程调用一样进行用户账号和密码的验证. 所以, NFS仅支持对于IP的认证. 但这又不安全而且很不灵活. 而且即使是这种认证也需要另外一个服务来跑, 这个认证服务叫做mountd, 他的主要作用就是<strong>令牌分发</strong> 当来访者请求发送到NFS服务器的时候, 这个请求会先交给mound服务, mountd判断这个用户是合法或者说有权限访问, 就发给他一个令牌, 这样每一对文件的操作只要令牌验证就可以了.</p><p>至此, 服务端已经运行三个daemon了: idmapd, mountd, nfsd. 客户端呢? 假设给你这样的场景, 如果有个疯子在你传输大文件的时候把你网线拔了, 你的文件传到一半怎么办? 这个时候就要求客户端进行文件跟踪以及文件锁的相关服务.</p><p>NFS监听在2049&#x2F;udp, 2049&#x2F;tcp端口上, 而mountd监听的端口就要由本地的公共服务rpc来决定了, 是一个随机端口. 但是这个随机端口是服务决定的, 所以是个半随机端口, 其实这个服务的名字叫做portmapper:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># rpcinfo </span></span><br><span class="line">   program version netid     address                service    owner</span><br><span class="line">    100000    4    tcp6      ::.0.111               portmapper superuser</span><br><span class="line">    100000    3    tcp6      ::.0.111               portmapper superuser</span><br><span class="line">    100000    4    udp6      ::.0.111               portmapper superuser</span><br><span class="line">    100000    3    udp6      ::.0.111               portmapper superuser</span><br><span class="line">    100000    4    tcp       0.0.0.0.0.111          portmapper superuser</span><br><span class="line">    100000    3    tcp       0.0.0.0.0.111          portmapper superuser</span><br><span class="line">    100000    2    tcp       0.0.0.0.0.111          portmapper superuser</span><br><span class="line">    100000    4    udp       0.0.0.0.0.111          portmapper superuser</span><br><span class="line">    100000    3    udp       0.0.0.0.0.111          portmapper superuser</span><br><span class="line">    100000    2    udp       0.0.0.0.0.111          portmapper superuser</span><br><span class="line">    100000    4    <span class="built_in">local</span>     /var/run/rpcbind.sock  portmapper superuser</span><br><span class="line">    100000    3    <span class="built_in">local</span>     /var/run/rpcbind.sock  portmapper superuser</span><br></pre></td></tr></table></figure><p>可以看到它监听在111端口上, 如果你无法看到或者无法使用, 应该先安装.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># rpm -qf /sbin/rpcinfo </span></span><br><span class="line">rpcbind-0.2.0-42.el7.x86_64</span><br></pre></td></tr></table></figure><p>接下来我们就来说说怎么使用nfs吧.</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># rpm -q nfs-utils</span></span><br><span class="line">package nfs-utils is not installed</span><br><span class="line">[root@WWW ~]<span class="comment"># yum install nfs-utils</span></span><br></pre></td></tr></table></figure><p>接下来看看装了那些内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># rpm -ql nfs-utils</span></span><br><span class="line">/etc/exports.d</span><br><span class="line">/etc/gssproxy/24-nfs-server.conf</span><br><span class="line">/etc/modprobe.d/lockd.conf</span><br><span class="line">/etc/nfs.conf</span><br><span class="line">/etc/nfsmount.conf</span><br><span class="line">/etc/request-key.d/id_resolver.conf</span><br><span class="line">/etc/sysconfig/nfs</span><br><span class="line">/sbin/mount.nfs</span><br><span class="line">/sbin/mount.nfs4</span><br><span class="line">/sbin/osd_login</span><br><span class="line">/sbin/rpc.statd</span><br><span class="line">/sbin/umount.nfs</span><br><span class="line">/sbin/umount.nfs4</span><br><span class="line">/usr/lib/systemd/scripts/nfs-utils_env.sh</span><br><span class="line">/usr/lib/systemd/system-generators/nfs-server-generator</span><br><span class="line">/usr/lib/systemd/system/auth-rpcgss-module.service</span><br><span class="line">/usr/lib/systemd/system/nfs-blkmap.service</span><br><span class="line">/usr/lib/systemd/system/nfs-client.target</span><br><span class="line">/usr/lib/systemd/system/nfs-config.service</span><br><span class="line">/usr/lib/systemd/system/nfs-idmap.service</span><br><span class="line">/usr/lib/systemd/system/nfs-idmapd.service</span><br><span class="line">/usr/lib/systemd/system/nfs-lock.service</span><br><span class="line">/usr/lib/systemd/system/nfs-mountd.service</span><br><span class="line">/usr/lib/systemd/system/nfs-secure.service</span><br><span class="line">/usr/lib/systemd/system/nfs-server.service</span><br><span class="line">/usr/lib/systemd/system/nfs-utils.service</span><br><span class="line">/usr/lib/systemd/system/nfs.service</span><br><span class="line">/usr/lib/systemd/system/nfslock.service</span><br><span class="line">/usr/lib/systemd/system/proc-fs-nfsd.mount</span><br><span class="line">/usr/lib/systemd/system/rpc-gssd.service</span><br><span class="line">/usr/lib/systemd/system/rpc-statd-notify.service</span><br><span class="line">/usr/lib/systemd/system/rpc-statd.service</span><br><span class="line">/usr/lib/systemd/system/rpcgssd.service</span><br><span class="line">/usr/lib/systemd/system/rpcidmapd.service</span><br><span class="line">/usr/lib/systemd/system/var-lib-nfs-rpc_pipefs.mount</span><br><span class="line">/usr/sbin/blkmapd</span><br><span class="line">/usr/sbin/exportfs</span><br><span class="line">/usr/sbin/mountstats</span><br><span class="line">/usr/sbin/nfsdcltrack</span><br><span class="line">/usr/sbin/nfsidmap</span><br><span class="line">/usr/sbin/nfsiostat</span><br><span class="line">/usr/sbin/nfsstat</span><br><span class="line">/usr/sbin/rpc.gssd</span><br><span class="line">/usr/sbin/rpc.idmapd</span><br><span class="line">/usr/sbin/rpc.mountd</span><br><span class="line">/usr/sbin/rpc.nfsd</span><br><span class="line">/usr/sbin/rpcdebug</span><br><span class="line">/usr/sbin/showmount</span><br><span class="line">/usr/sbin/sm-notify</span><br><span class="line">/usr/sbin/start-statd</span><br><span class="line">...(omitted)</span><br><span class="line">/var/lib/nfs</span><br><span class="line">/var/lib/nfs/etab</span><br><span class="line">/var/lib/nfs/rmtab</span><br><span class="line">/var/lib/nfs/rpc_pipefs</span><br><span class="line">/var/lib/nfs/statd</span><br><span class="line">/var/lib/nfs/statd/sm</span><br><span class="line">/var/lib/nfs/statd/sm.bak</span><br><span class="line">/var/lib/nfs/state</span><br><span class="line">/var/lib/nfs/v4recovery</span><br><span class="line">/var/lib/nfs/xtab</span><br></pre></td></tr></table></figure><p>很显眼就能看到</p><ul><li>&#x2F;usr&#x2F;sbin&#x2F;rpc.idmapd</li><li>&#x2F;usr&#x2F;sbin&#x2F;rpc.mountd</li><li>&#x2F;usr&#x2F;sbin&#x2F;rpc.nfsd</li></ul><p>这三个重要的服务端程序.</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>现在就直接来启动, 要注意的是 这个时候的服务名字不是nfsd而是nfs:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># systemctl start nfs</span></span><br><span class="line">[root@WWW ~]<span class="comment"># systemctl status nfs</span></span><br><span class="line">● nfs-server.service - NFS server and services</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/nfs-server.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (exited) since Sat 2017-09-30 02:51:15 EDT; 6s ago</span><br><span class="line">  Process: 9826 ExecStart=/usr/sbin/rpc.nfsd <span class="variable">$RPCNFSDARGS</span> (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 9821 ExecStartPre=/bin/sh -c /bin/kill -HUP `<span class="built_in">cat</span> /run/gssproxy.pid` (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 9820 ExecStartPre=/usr/sbin/exportfs -r (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 9826 (code=exited, status=0/SUCCESS)</span><br><span class="line">   CGroup: /system.slice/nfs-server.service</span><br><span class="line"></span><br><span class="line">Sep 30 02:51:15 WWW systemd[1]: Starting NFS server and services...</span><br><span class="line">Sep 30 02:51:15 WWW systemd[1]: Started NFS server and services.</span><br></pre></td></tr></table></figure><p>这个时候该启动的程序都已经在自己监听的套接字上了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># netstat -antp</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:49287           0.0.0.0:*               LISTEN      9806/rpc.statd      </span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd           </span><br><span class="line">tcp        0      0 0.0.0.0:20048           0.0.0.0:*               LISTEN      9819/rpc.mountd     </span><br></pre></td></tr></table></figure><p>而且这个时候再调用rpcinfo, 就可以看到一大堆端口了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># rpcinfo </span></span><br><span class="line">   program version netid     address                service    owner</span><br><span class="line">    100000    4    tcp6      ::.0.111               portmapper superuser</span><br><span class="line">    100000    3    tcp6      ::.0.111               portmapper superuser</span><br><span class="line">    100000    4    udp6      ::.0.111               portmapper superuser</span><br><span class="line">    100000    3    udp6      ::.0.111               portmapper superuser</span><br><span class="line">    100000    4    tcp       0.0.0.0.0.111          portmapper superuser</span><br><span class="line">    100000    3    tcp       0.0.0.0.0.111          portmapper superuser</span><br><span class="line">    100000    2    tcp       0.0.0.0.0.111          portmapper superuser</span><br><span class="line">    100000    4    udp       0.0.0.0.0.111          portmapper superuser</span><br><span class="line">    100000    3    udp       0.0.0.0.0.111          portmapper superuser</span><br><span class="line">    100000    2    udp       0.0.0.0.0.111          portmapper superuser</span><br><span class="line">    100000    4    <span class="built_in">local</span>     /var/run/rpcbind.sock  portmapper superuser</span><br><span class="line">    100000    3    <span class="built_in">local</span>     /var/run/rpcbind.sock  portmapper superuser</span><br><span class="line">    100024    1    udp       0.0.0.0.232.28         status     29</span><br><span class="line">    100024    1    tcp       0.0.0.0.192.135        status     29</span><br><span class="line">    100024    1    udp6      ::.164.187             status     29</span><br><span class="line">    100024    1    tcp6      ::.233.229             status     29</span><br><span class="line">    100005    1    udp       0.0.0.0.78.80          mountd     superuser</span><br><span class="line">    100005    1    tcp       0.0.0.0.78.80          mountd     superuser</span><br><span class="line">    100005    1    udp6      ::.78.80               mountd     superuser</span><br><span class="line">    100005    1    tcp6      ::.78.80               mountd     superuser</span><br><span class="line">    100005    2    udp       0.0.0.0.78.80          mountd     superuser</span><br><span class="line">    100005    2    tcp       0.0.0.0.78.80          mountd     superuser</span><br><span class="line">    100005    2    udp6      ::.78.80               mountd     superuser</span><br><span class="line">    100005    2    tcp6      ::.78.80               mountd     superuser</span><br><span class="line">    100005    3    udp       0.0.0.0.78.80          mountd     superuser</span><br><span class="line">    100005    3    tcp       0.0.0.0.78.80          mountd     superuser</span><br><span class="line">    100005    3    udp6      ::.78.80               mountd     superuser</span><br><span class="line">    100005    3    tcp6      ::.78.80               mountd     superuser</span><br><span class="line">    100003    3    tcp       0.0.0.0.8.1            nfs        superuser</span><br><span class="line">    100003    4    tcp       0.0.0.0.8.1            nfs        superuser</span><br><span class="line">    100227    3    tcp       0.0.0.0.8.1            nfs_acl    superuser</span><br><span class="line">    100003    3    udp       0.0.0.0.8.1            nfs        superuser</span><br><span class="line">    100003    4    udp       0.0.0.0.8.1            nfs        superuser</span><br><span class="line">    100227    3    udp       0.0.0.0.8.1            nfs_acl    superuser</span><br><span class="line">    100003    3    tcp6      ::.8.1                 nfs        superuser</span><br><span class="line">    100003    4    tcp6      ::.8.1                 nfs        superuser</span><br><span class="line">    100227    3    tcp6      ::.8.1                 nfs_acl    superuser</span><br><span class="line">    100003    3    udp6      ::.8.1                 nfs        superuser</span><br><span class="line">    100003    4    udp6      ::.8.1                 nfs        superuser</span><br><span class="line">    100227    3    udp6      ::.8.1                 nfs_acl    superuser</span><br><span class="line">    100021    1    udp       0.0.0.0.220.82         nlockmgr   superuser</span><br><span class="line">    100021    3    udp       0.0.0.0.220.82         nlockmgr   superuser</span><br><span class="line">    100021    4    udp       0.0.0.0.220.82         nlockmgr   superuser</span><br><span class="line">    100021    1    tcp       0.0.0.0.182.24         nlockmgr   superuser</span><br><span class="line">    100021    3    tcp       0.0.0.0.182.24         nlockmgr   superuser</span><br><span class="line">    100021    4    tcp       0.0.0.0.182.24         nlockmgr   superuser</span><br><span class="line">    100021    1    udp6      ::.217.178             nlockmgr   superuser</span><br><span class="line">    100021    3    udp6      ::.217.178             nlockmgr   superuser</span><br><span class="line">    100021    4    udp6      ::.217.178             nlockmgr   superuser</span><br><span class="line">    100021    1    tcp6      ::.142.205             nlockmgr   superuser</span><br><span class="line">    100021    3    tcp6      ::.142.205             nlockmgr   superuser</span><br><span class="line">    100021    4    tcp6      ::.142.205             nlockmgr   superuser</span><br></pre></td></tr></table></figure><p>如果此时重启, 端口就会发生改变. 因为这是半随机的.</p><h3 id="配置NFS"><a href="#配置NFS" class="headerlink" title="配置NFS"></a>配置NFS</h3><p>说了这么多, 其实配置才是最简单的, 只需要编辑&#x2F;etc&#x2F;exports文件, 来说明要导出的文件目录是哪一个就行了. 这个文件的具体格式是这样的:</p><blockquote><p>dir(filesystem)  client1(option1, option2)  client2(option1, option2)</p></blockquote><p>以及就是暴露出去哪个目录(或者文件系统, 但是文件系统就是挂载到目录上才可以使用的, 所以指定目录就行了), 接着允许访问的客户是谁, 以及他们的权限设定和选项.</p><p>所有支持的选项可以在exports的man手册上查看. 一个最简单的例子就像这样:</p><p><code>/tmp192.168.56.103(rw)</code> </p><p>接着我们重启服务 ( 这里先进行重启, 但是这是一种极其不推荐的做法, 后面再细说 ) 接着就可以查看了, 使用命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW etc]<span class="comment"># showmount -e 192.168.56.101</span></span><br><span class="line">Export list <span class="keyword">for</span> 192.168.56.101:</span><br><span class="line">/tmp 192.168.56.103</span><br></pre></td></tr></table></figure><p>在另外一台主机上也是可以查看到的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># ip addr show enp0s3 </span></span><br><span class="line">2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 08:00:27:a0:b9:10 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.56.103/24 brd 192.168.56.255 scope global dynamic enp0s3</span><br><span class="line">       valid_lft 1161sec preferred_lft 1161sec</span><br><span class="line">[root@WWW ~]<span class="comment"># showmount -e 192.168.56.101</span></span><br><span class="line">Export list <span class="keyword">for</span> 192.168.56.101:</span><br><span class="line">/tmp 192.168.56.103</span><br></pre></td></tr></table></figure><p>当然前提是安装了nfs-utils这个包.</p><p>现在其实已经配置完成了, 登录到103主机挂载即可使用了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># mount -t nfs 192.168.56.101:/tmp /mnt/</span></span><br><span class="line">[root@WWW ~]<span class="comment"># cd /mnt/</span></span><br><span class="line">[root@WWW mnt]<span class="comment"># ls</span></span><br><span class="line">fstab                                                                  yum_save_tx.2017-09-23.17-39.rZFKGX.yumtx  yum_save_tx.2017-09-26.11-33.JDsQeW.yumtx</span><br><span class="line"><span class="built_in">functions</span>                                                              yum_save_tx.2017-09-24.02-10.SFv1gg.yumtx  yum_save_tx.2017-09-28.02-22.TmlpEK.yumtx</span><br><span class="line">grub.cfg                                                               yum_save_tx.2017-09-24.02-14.hLrGaJ.yumtx  yum_save_tx.2017-09-28.02-24.nw6FJ3.yumtx</span><br><span class="line">systemd-private-76aa5be0b609474b906e0041c7287281-named.service-YvkHEW  yum_save_tx.2017-09-24.02-17.jrTroG.yumtx  yum_save_tx.2017-09-28.02-26.eetkNP.yumtx</span><br><span class="line">systemd-private-84ee57e9e1d94742bc1ef6e525e7c6f9-named.service-bGtSvY  yum_save_tx.2017-09-24.02-25.z2khA_.yumtx</span><br><span class="line">yum_save_tx.2017-09-23.17-39.CI1ETc.yumtx                              yum_save_tx.2017-09-26.11-32.zTDVHS.yumtx</span><br></pre></td></tr></table></figure><p>怎么样是不是很帅气 ! </p><p>那么就来说说几个常用的参数吧. 除了简单的读写权限, 还有很多有趣的属性呢</p><ul><li>async: 异步读写, 可以提高性能.</li><li>secure: 使用1024以下的端口</li><li>root_squash: root权限挤压</li><li>all_squash: 所有用户都积压权限</li><li>anonuid&#x3D;?, anongid&#x3D;?: 所有的文件所属用户和组都是匿名</li></ul><p>现在就来说一下, 如何正常的进行文件系统导出, 不是进行重启服务, 而是使用一个特定的工具: <code>exportfs</code> </p><p>我们先加上一个新的文件系统导出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW tmp]<span class="comment"># mkdir -p /share/nfs</span></span><br><span class="line">[root@WWW tmp]<span class="comment"># vim /etc/exports</span></span><br><span class="line">[root@WWW tmp]<span class="comment"># showmount -e 192.168.56.101</span></span><br><span class="line">Export list <span class="keyword">for</span> 192.168.56.101:</span><br><span class="line">/tmp 192.168.56.103</span><br><span class="line">[root@WWW tmp]<span class="comment"># exportfs -ar</span></span><br><span class="line">[root@WWW tmp]<span class="comment"># showmount -e 192.168.56.101</span></span><br><span class="line">Export list <span class="keyword">for</span> 192.168.56.101:</span><br><span class="line">/share/nfs 192.168.56.103</span><br><span class="line">/tmp       192.168.56.103</span><br></pre></td></tr></table></figure><p>-ar就是说all re-export, 另外还支持其他的参数例如 -u 关闭导出的文件系统, 可以和-a参数连在一起使用, 表示关闭所有的文件系统.</p><p>当然我们也可以进行开机自动挂载nfs文件系统, 只要在fstab中写上就行了. 直接mount也可以看到当前的参数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...(omitted)</span><br><span class="line">192.168.56.101:/tmp on /mnt <span class="built_in">type</span> nfs4 (rw,relatime,vers=4.1,rsize=262144,wsize=262144,namlen=255,hard,proto=tcp,port=0,timeo=600,retrans=2,sec=sys,clientaddr=192.168.56.103,local_lock=none,addr=192.168.56.101)</span><br></pre></td></tr></table></figure><h2 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h2><p>前面说的NFS, 如果想要使用, 最好是Unix&#x2F;Linux系统, Windows对于NFS的支持还是很有限的. 更早之前, 我们还说过FTP这个协议, 但是FTP位于应用层, 从协议本身来看, 把一个FTP共享<strong>挂载</strong>在客户机上, 这是不可能的.</p><p>这两者就催生了samba的诞生, 为了使得能够在Linux&#x2F;Unix上实现一个能够提供Windows支持的协议, 于是这就是Windows上的smb, 即Service Message Block. 这个就是Windows上网络邻居之间共享文件所使用到的, 它的协议通称CIFS, 即Common Internet File System.  一段时间之后smb协议逐渐演化成一个开源项目, 这个项目的命名就是samba.</p><p>samba可以安装在Win和Unix&#x2F;Linux主机上. 在Windows上, 这个服务监听137&#x2F;udp, 138&#x2F;tcp, 139&#x2F;tcp, 445&#x2F;tcp.</p><p>具体说来, 在137,138是用来实现NetBIOS的, 这个是Windows用来基于主机名进行互相访问的, 对于主机名的解析, 依靠Windows的Wins服务解析服务, 除此之外, Windows的网络共享模型有基于工作组和基于域的, 这些都需要特定的服务来支持. 对于Linux&#x2F;Unix主机, 如果想要加入Windows, 就必须也实现这些服务. </p><p>samba就做了这些事情, 它主要实现了三种服务: nmdb: 提供NetBIOS服务, smbd: 提供CIFS协议支持, winbindd: 提供对Windows用户组的支持.</p><p>接下来我们使用一个CentOS6和和一台Windows XP做实验:</p><p>先来看看CentOS6上的软件包:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum list all samba*</span></span><br><span class="line">Loaded plugins: fastestmirror, refresh-packagekit, security</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">base                                                                                                                                                | 3.7 kB     00:00     </span><br><span class="line">extras                                                                                                                                              | 3.4 kB     00:00     </span><br><span class="line">updates                                                                                                                                             | 3.4 kB     00:00     </span><br><span class="line">Installed Packages</span><br><span class="line">samba-client.x86_64                                                                   3.5.10-114.el6                                                      @base/<span class="variable">$releasever</span></span><br><span class="line">samba-common.x86_64                                                                   3.5.10-114.el6                                                      @base/<span class="variable">$releasever</span></span><br><span class="line">samba-winbind-clients.x86_64                                                          3.5.10-114.el6                                                      @base/<span class="variable">$releasever</span></span><br><span class="line">Available Packages</span><br><span class="line">samba.x86_64                                                                          3.6.23-45.el6_9                                                     updates          </span><br><span class="line">samba-client.x86_64                                                                   3.6.23-45.el6_9                                                     updates          </span><br><span class="line">samba-common.i686                                                                     3.6.23-45.el6_9                                                     updates          </span><br><span class="line">samba-common.x86_64                                                                   3.6.23-45.el6_9                                                     updates          </span><br><span class="line">samba-doc.x86_64                                                                      3.6.23-45.el6_9                                                     updates          </span><br><span class="line">samba-domainjoin-gui.x86_64                                                           3.6.23-45.el6_9                                                     updates          </span><br><span class="line">samba-glusterfs.x86_64                                                                3.6.23-45.el6_9                                                     updates          </span><br><span class="line">samba-swat.x86_64                                                                     3.6.23-45.el6_9                                                     updates          </span><br><span class="line">samba-winbind.x86_64                                                                  3.6.23-45.el6_9                                                     updates          </span><br><span class="line">samba-winbind-clients.i686                                                            3.6.23-45.el6_9                                                     updates          </span><br><span class="line">samba-winbind-clients.x86_64                                                          3.6.23-45.el6_9                                                     updates          </span><br><span class="line">samba-winbind-devel.i686                                                              3.6.23-45.el6_9                                                     updates          </span><br><span class="line">samba-winbind-devel.x86_64                                                            3.6.23-45.el6_9                                                     updates          </span><br><span class="line">samba-winbind-krb5-locator.x86_64                                                     3.6.23-45.el6_9                                                     updates          </span><br><span class="line">samba4.x86_64                                                                         4.2.10-11.el6_9                                                     updates          </span><br><span class="line">samba4-client.x86_64                                                                  4.2.10-11.el6_9                                                     updates          </span><br><span class="line">samba4-common.x86_64                                                                  4.2.10-11.el6_9                                                     updates          </span><br><span class="line">samba4-dc.x86_64                                                                      4.2.10-11.el6_9                                                     updates          </span><br><span class="line">samba4-dc-libs.x86_64                                                                 4.2.10-11.el6_9                                                     updates          </span><br><span class="line">samba4-devel.x86_64                                                                   4.2.10-11.el6_9                                                     updates          </span><br><span class="line">samba4-libs.x86_64                                                                    4.2.10-11.el6_9                                                     updates          </span><br><span class="line">samba4-pidl.x86_64                                                                    4.2.10-11.el6_9                                                     updates          </span><br><span class="line">samba4-python.x86_64                                                                  4.2.10-11.el6_9                                                     updates          </span><br><span class="line">samba4-test.x86_64                                                                    4.2.10-11.el6_9                                                     updates          </span><br><span class="line">samba4-winbind.x86_64                                                                 4.2.10-11.el6_9                                                     updates          </span><br><span class="line">samba4-winbind-clients.x86_64                                                         4.2.10-11.el6_9                                                     updates          </span><br><span class="line">samba4-winbind-krb5-locator.x86_64                                                    4.2.10-11.el6_9                                                     updates          </span><br></pre></td></tr></table></figure><p>有两个版本的samba, 系统已经预先安装了samba客户端, 3.6版本. 那么我们就使用这个版本的吧.</p><p>在Windows上, 共享文件路径是这样写的: \SEREVR\shared_name.</p><p>下面说说我们当前的环境:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/cmd1.png" alt="cmd1"></p><p>而另外一台CentOS6主机就是那个192.168.56.101. 现在在Windows上建立一个共享文件夹, 步骤如下:</p><ul><li>关闭简单文件共享</li></ul><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/easy.png" alt="easy"></p><ul><li>设置共享文件夹</li></ul><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/shared.png" alt="shared"></p><ul><li>配置权限, 创建一个新用户</li></ul><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/confshared.png" alt="confshared"></p><p>完成之后就会看到图标发生改变.</p><p>现在就来试试连接到Windows上的共享文件夹, 首先我们来看看samba-client安装了什么二进制程序吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpm -ql samba-client</span></span><br><span class="line">/usr/bin/findsmb</span><br><span class="line">/usr/bin/nmblookup</span><br><span class="line">/usr/bin/rpcclient</span><br><span class="line">/usr/bin/sharesec</span><br><span class="line">/usr/bin/smbcacls</span><br><span class="line">/usr/bin/smbclient</span><br><span class="line">/usr/bin/smbget</span><br><span class="line">/usr/bin/smbprint</span><br><span class="line">/usr/bin/smbspool</span><br><span class="line">/usr/bin/smbtar</span><br><span class="line">/usr/bin/smbtree</span><br></pre></td></tr></table></figure><p>其中我们最关心的就是那个smbclient了. 使用这个程序可以列出目标主机的共享目录, 以及进行连接, 接着就像是使用ftp客户端一样了.</p><p>来试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@localhost ~]<span class="comment"># smbclient -L 192.168.56.102 -U test</span></span><br><span class="line">Enter <span class="built_in">test</span><span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string">session request to 192.168.56.102 failed (Called name not present)</span></span><br><span class="line"><span class="string">Domain=[NETCOOL-TEST] OS=[Windows 5.1] Server=[Windows 2000 LAN Manager]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Sharename       Type      Comment</span></span><br><span class="line"><span class="string">---------       ----      -------</span></span><br><span class="line"><span class="string">IPC$            IPC       远程 IPC</span></span><br><span class="line"><span class="string">Shard           Disk      This is a teest</span></span><br><span class="line"><span class="string">ADMIN$          Disk      远程管理</span></span><br><span class="line"><span class="string">C$              Disk      默认共享</span></span><br><span class="line"><span class="string">Shared          Disk      This is a test.</span></span><br><span class="line"><span class="string">session request to 192.168.56.102 failed (Called name not present)</span></span><br><span class="line"><span class="string">session request to 192 failed (Called name not present)</span></span><br><span class="line"><span class="string">Domain=[NETCOOL-TEST] OS=[Windows 5.1] Server=[Windows 2000 LAN Manager]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Server               Comment</span></span><br><span class="line"><span class="string">---------            -------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Workgroup            Master</span></span><br><span class="line"><span class="string">---------            -------</span></span><br></pre></td></tr></table></figure><p>默认就有很多共享服务, 在最后一行的那个就是我们的新建的Shared文件夹, 可以往里面扔东西, 因为刚刚我给了test用户写入的权限, 使用上面说的路径来连接: [ 为了防止各种各样的辣鸡NT权限报错,建议把测试文件夹放在别的分区或者共享文档目录下 ]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># smbclient //192.168.56.102/Shared -U test</span></span><br><span class="line">Enter <span class="built_in">test</span><span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string">session request to 192.168.56.102 failed (Called name not present)</span></span><br><span class="line"><span class="string">Domain=[NETCOOL-TEST] OS=[Windows 5.1] Server=[Windows 2000 LAN Manager]</span></span><br><span class="line"><span class="string">smb: \&gt; ls</span></span><br><span class="line"><span class="string">  .                                   D        0  Mon Oct  2 19:55:36 2017</span></span><br><span class="line"><span class="string">  ..                                  D        0  Mon Oct  2 19:55:36 2017</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">40915 blocks of size 262144. 26933 blocks available</span></span><br><span class="line"><span class="string">smb: \&gt; ?</span></span><br><span class="line"><span class="string">?              allinfo        altname        archive        blocksize      </span></span><br><span class="line"><span class="string">cancel         case_sensitive cd             chmod          chown          </span></span><br><span class="line"><span class="string">close          del            dir            du             echo           </span></span><br><span class="line"><span class="string">exit           get            getfacl        hardlink       help           </span></span><br><span class="line"><span class="string">history        iosize         lcd            link           lock           </span></span><br><span class="line"><span class="string">lowercase      ls             l              mask           md             </span></span><br><span class="line"><span class="string">mget           mkdir          more           mput           newer          </span></span><br><span class="line"><span class="string">open           posix          posix_encrypt  posix_open     posix_mkdir    </span></span><br><span class="line"><span class="string">posix_rmdir    posix_unlink   print          prompt         put            </span></span><br><span class="line"><span class="string">pwd            q              queue          quit           readlink       </span></span><br><span class="line"><span class="string">rd             recurse        reget          rename         reput          </span></span><br><span class="line"><span class="string">rm             rmdir          showacls       setmode        stat           </span></span><br><span class="line"><span class="string">symlink        tar            tarmode        translate      unlock         </span></span><br><span class="line"><span class="string">volume         vuid           wdel           logon          listconnect    </span></span><br><span class="line"><span class="string">showconnect    ..             !     </span></span><br></pre></td></tr></table></figure><p>是不是和ftp使用起来很像啊</p><p>向里面扔个文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">smb: \&gt; lcd /etc/</span><br><span class="line">smb: \&gt; put fstab </span><br><span class="line">putting file fstab as \fstab (84.7 kb/s) (average 84.7 kb/s)</span><br></pre></td></tr></table></figure><p>此时Windows中已经看到了:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/sucshared.png" alt="sucshared"></p><p>就这么简单. 这是一种基于交互式访问的方式,也可以进行挂载使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mount -t cifs //192.168.56.102/Shared /NTshared/ -o username=test</span></span><br><span class="line">Password:</span><br><span class="line">[root@localhost NTshared]<span class="comment"># cd /NTshared/</span></span><br><span class="line">[root@localhost NTshared]<span class="comment"># ls</span></span><br><span class="line">fstab</span><br></pre></td></tr></table></figure><p>这很简单, 但是重点在于, 我们如何使Linux成为Samba服务器端, Windows成为客户端呢.</p><ul><li>首先安装服务器端程序</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install samba -y</span><br></pre></td></tr></table></figure><p>安装完成之后, 我们按照惯例查看安装了哪些, 其中最重要的就是下面的两守护进程了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...(omitted)</span><br><span class="line">/usr/sbin/nmbd</span><br><span class="line">/usr/sbin/smbd</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>启动samba服务的时候, 其实就是启动的这个. 他的主配置文件是<code>/etc/samba/smb.conf</code> </p><ul><li>接着我们需要进行认证的设置</li></ul><p>与ftp相似的是, samba直接启动之后就可以使用. 但是不同的是, samba需要指定那些目录共享, 这其中有点像NFS. 我们在说ftp的时候说过, vsftpd维护三种用户: 系统用户匿名用户虚拟用户. 对于samba来说, 他只使用系统用户, 但是有意思的是, 他不是用shadow文件进行的密码认证, 而是使用自己的密码文件. 这就是说 账号使用passwd中的系统用户, 但是认证是自己来( 所以我可以理解成samba不使用Linux的统一认证pam(?) )</p><p>由一个工具专门做这个事情<code>smbpasswd</code>. </p><p>不多说了, 直接启动服务看看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># service nmb start &amp;&amp; service smb start</span></span><br><span class="line">Starting NMB services:                                     [  OK  ]</span><br><span class="line">Starting SMB services:                                     [  OK  ]</span><br></pre></td></tr></table></figure><p>接着就能看到监听的137,139,445端口已经开始监听起来了. </p><blockquote><p><strong>脱坑指南: 如果你的nmb进程启动有问题( 比如没法创建套接字 ), 那么就手动的<code>nmbd -D</code>启动.</strong></p></blockquote><p>这个时候按理说已经可以在Windows主机中看到Linux主机了, 但是问题在于他们的工作组不一样( 上面说过使用工作组来划分 ), 因为Windows上的默认工作组是<code>WORKGROUP</code>, 而samba默认的工作组是<code>MYGROUP</code>. 这个设定可以在samba的配置文件中进行更改:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#======================= Global Settings =====================================</span></span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------- Network Related Options -------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># workgroup = NT-Domain-Name or Workgroup-Name, eg: MIDEARTH</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># server string is the equivalent of the NT Description field</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># netbios name can be used to specify a server name not tied to the hostname</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Interfaces lets you configure Samba to use multiple interfaces</span></span><br><span class="line"><span class="comment"># If you have multiple network interfaces then you can list the ones</span></span><br><span class="line"><span class="comment"># you want to listen on (never omit localhost)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Hosts Allow/Hosts Deny lets you restrict who can connect, and you can</span></span><br><span class="line"><span class="comment"># specifiy it as a per share option as well</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">        workgroup = MYGROUP</span><br><span class="line">        server string = Samba Server Version %v</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>把他改成WORKGROUP之后, 重新启动服务, 在windows中的网上邻居中查看工作组的计算机就可以看到:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/sambaserver.png" alt="sambaserver"></p><blockquote><p><strong>脱坑指南: 如果你看不到主机先尝试清空iptables.</strong></p></blockquote><p>但是这个时候还是连接不了的哦 因为这个时候我们还没有设置Samba的用户账户. 所以没法进行连接.</p><p>这个账号的设置就需要我们之前说过的smbpasswd了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># useradd smbuser1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># smbpasswd -a smbuser1</span></span><br><span class="line">New SMB password:</span><br><span class="line">Retype new SMB password:</span><br><span class="line">Added user smbuser1.</span><br></pre></td></tr></table></figure><p>除了-a参数增加用户以外, 还有一些常用的选项:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># smbpasswd</span></span><br><span class="line">  -a                   add user</span><br><span class="line">  -d                   <span class="built_in">disable</span> user</span><br><span class="line">  -e                   <span class="built_in">enable</span> user</span><br><span class="line">  -x                   delete user</span><br></pre></td></tr></table></figure><p>输入密码登陆之后就可以看到了:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/smbuser1.png" alt="smbuser1"></p><p>接着你就可以在里面创建文件了, 因为这就是smbuser1的家目录, 所以是有权限的.</p><p>另外如果是使用另外一台Linux来访问这个smbuser1是什么样子的呢?我们启动另外一台CentOS7来看看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># smbclient -L 192.168.56.101 -U smbuser1</span></span><br><span class="line">Enter SAMBA\smbuser1<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string">Domain=[LOCALHOST] OS=[Unix] Server=[Samba 3.6.23-45.el6_9]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Sharename       Type      Comment</span></span><br><span class="line"><span class="string">---------       ----      -------</span></span><br><span class="line"><span class="string">IPC$            IPC       IPC Service (Samba Server Version 3.6.23-45.el6_9)</span></span><br><span class="line"><span class="string">smbuser1        Disk      Home Directories</span></span><br><span class="line"><span class="string">Domain=[LOCALHOST] OS=[Unix] Server=[Samba 3.6.23-45.el6_9]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Server               Comment</span></span><br><span class="line"><span class="string">---------            -------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Workgroup            Master</span></span><br><span class="line"><span class="string">---------            -------</span></span><br><span class="line"><span class="string">WORKGROUP            LOCALHOST</span></span><br></pre></td></tr></table></figure><p>可以看出来咯, 默认的备注还是家目录.</p><p>还是回过头来看看配置文件吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        workgroup = WORKGROUP <span class="comment"># 工作组</span></span><br><span class="line">        server string = Samba Server Version %v <span class="comment"># 服务器描述</span></span><br><span class="line">;       netbios name = MYSERVER <span class="comment"># 主机名</span></span><br><span class="line">;       interfaces = lo eth0 192.168.12.2/24 192.168.13.2/24 <span class="comment"># 启用接口</span></span><br><span class="line">;       hosts allow = 127. 192.168.12. 192.168.13. <span class="comment"># 访问控制白名单</span></span><br><span class="line">        <span class="built_in">log</span> file = /var/log/samba/log.%m <span class="comment"># 每一个进程都会有一个日志</span></span><br><span class="line">        max <span class="built_in">log</span> size = 50 <span class="comment"># 滚动限制</span></span><br></pre></td></tr></table></figure><p>跳过后面的关于域的设定, 我们直接来看后面的共享设定:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[homes]</span><br><span class="line">        comment = Home Directories</span><br><span class="line">        browseable = no <span class="comment"># 除了属主外是否可以浏览, 应该打开的</span></span><br><span class="line">        writable = <span class="built_in">yes</span> <span class="comment"># 是否可写</span></span><br><span class="line">;       valid <span class="built_in">users</span> = %S</span><br><span class="line">;       valid <span class="built_in">users</span> = MYDOMAIN\%S</span><br></pre></td></tr></table></figure><p>第一行就是我们的注释设定, 在这里进行更改. </p><p>如果先要自定义一个共享, 首先就要确保由一个Path参数. 后面有示例.</p><p>不管怎么说, 我们现在就来手动创建一个分享吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">test</span>]</span><br><span class="line">        comment = Shared <span class="built_in">test</span></span><br><span class="line">        path = /tmp/shared</span><br><span class="line">        public = <span class="built_in">yes</span></span><br><span class="line">        writable = <span class="built_in">yes</span></span><br><span class="line">        guest ok = <span class="built_in">yes</span></span><br><span class="line">        <span class="built_in">readonly</span> = no</span><br></pre></td></tr></table></figure><p>接着我们创建那个文件夹:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir /tmp/shared</span></span><br></pre></td></tr></table></figure><p>我们可以执行检查, 来确保配置文件不会出错:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># testparm </span></span><br><span class="line">Load smb config files from /etc/samba/smb.conf</span><br><span class="line">rlimit_max: increasing rlimit_max (1024) to minimum Windows <span class="built_in">limit</span> (16384)</span><br><span class="line">Processing section <span class="string">&quot;[homes]&quot;</span></span><br><span class="line">Processing section <span class="string">&quot;[printers]&quot;</span></span><br><span class="line">Processing section <span class="string">&quot;[test]&quot;</span></span><br><span class="line">Loaded services file OK.</span><br><span class="line">Server role: ROLE_STANDALONE</span><br><span class="line">Press enter to see a dump of your service definitions</span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">server string = Samba Server Version %v</span><br><span class="line"><span class="built_in">log</span> file = /var/log/samba/log.%m</span><br><span class="line">max <span class="built_in">log</span> size = 50</span><br><span class="line">client signing = required</span><br><span class="line">idmap config * : backend = tdb</span><br><span class="line">cups options = raw</span><br><span class="line"></span><br><span class="line">[homes]</span><br><span class="line">comment = Home Directories</span><br><span class="line"><span class="built_in">read</span> only = No</span><br><span class="line"></span><br><span class="line">[printers]</span><br><span class="line">comment = All Printers</span><br><span class="line">path = /var/spool/samba</span><br><span class="line">printable = Yes</span><br><span class="line"><span class="built_in">print</span> ok = Yes</span><br><span class="line">browseable = No</span><br><span class="line"></span><br><span class="line">[<span class="built_in">test</span>]</span><br><span class="line">comment = Shared <span class="built_in">test</span></span><br><span class="line">path = /tmp/shared</span><br><span class="line"><span class="built_in">read</span> only = No</span><br><span class="line">guest ok = Yes</span><br></pre></td></tr></table></figure><p>接着重启服务, 来进入另外一台CentOS7 试试看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># smbclient //192.168.56.101/test -U smbuser1</span></span><br><span class="line">Enter SAMBA\smbuser1<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string">Domain=[LOCALHOST] OS=[Unix] Server=[Samba 3.6.23-45.el6_9]</span></span><br><span class="line"><span class="string">smb: \&gt; ls</span></span><br><span class="line"><span class="string">  .                                   D        0  Mon Oct  2 15:16:31 2017</span></span><br><span class="line"><span class="string">  ..                                  D        0  Mon Oct  2 15:19:02 2017</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">5715544 blocks of size 1024. 3492768 blocks available</span></span><br></pre></td></tr></table></figure><p>没毛病.</p><blockquote><p>温馨提示: 如果你看到的是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">smb: \&gt; <span class="built_in">ls</span></span><br><span class="line">NT_STATUS_ACCESS_DENIED listing \*</span><br></pre></td></tr></table></figure><p>并且在上面的Windows实验中看到的是:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/deny.png" alt="deny"></p><p>而且你确定是有权限的话, 那么很大一部分原因可能是SELINUX.</p></blockquote><h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><p>另外, samba是有一个图形化管理工具的, 叫做swat. 处于extra源中.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> NFS </tag>
            
            <tag> Samba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FTP协议和vsftpd</title>
      <link href="/2017/09/27/FTP%E5%8D%8F%E8%AE%AE%E5%92%8Cvsftpd/"/>
      <url>/2017/09/27/FTP%E5%8D%8F%E8%AE%AE%E5%92%8Cvsftpd/</url>
      
        <content type="html"><![CDATA[<p>文件共享服务 – 应用层的FTP, 工作在内核的nfs(难以跨平台), 跨平台的文件服务samba(在Linux上实现SMB).</p><span id="more"></span><p>先来说说我们的存储模型有哪些呢? DAS, NAS, SAN. 我们所使用的磁盘其实就是DAS模型, 而NAS其实就是专门用作存储的设备, 其内核对SAMBA, NFS等有特别的优化. 至于SAN, 他和NAS的区别就在于他是基于块的存储, 而NAS是基于文件共享的.</p><h2 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h2><p>FTP的全称是(File Transfer Protocol), 也就是文件传输协议. 基于应用层协议来实现. 是一个C&#x2F;S架构的协议. FTP是使用Socket进行的通信, 所以那也就会有端口的绑定. 但是FTP的连接却不像其他的服务一样(只监听一个端口), 它首先监听了21号端口. 但是FTP是很复杂的协议, 起码和HTTP协议比起来是复杂了很多. 因为它涉及到很多文件的管理功能. 例如创建, 改变权限, 复制, 移动等等. 所以他需要很多很多命令. 这样FTP就需要传输两类命令, 或者说两种数据:</p><ul><li>命令连接: 用来进行命令的传输</li><li>数据连接: 用来传输用户所请求的上传和下载文件, 按需创建和关闭连接</li></ul><p>当客户端想要进行访问FTP服务端的时候, 它先将请求发送到服务器端的21号端口. 鉴于之前说过的FTP需要传输两种数据. 所以他需要在接收到客户端命令之后(例如, 下载一个文件)从磁盘上获取, 接着<strong>另起一个连接</strong>. 这个连接和之前的session已经不是一样的了. 所以他需要再次通过一个套接字将数据发送. 发送结束之后, 结束这个新的Session.</p><p>同HTTP协议一样, FTP在传输非文本数据的时候也有问题, 例如图片, 如果启用字符传输机制, 对方可能看到的是一堆乱码. 而如果使用的是二进制的传输形式, 对方可能无法理解得到的结果. 所以FTP既支持文本传输也支持二进制传输格式, 这个是依靠传输数据的格式来判断的.</p><p>另外, FTP有个麻烦的模式: 主动和被动. 之所有会有这个, 是因为客户端请求下载一个文件的时候, 我们说需要一个新的数据连接, 这个连接谁来创建? 如果是服务器端, 这就是主动模式. 但是这个是存在一个问题的, 服务器端主动发送请求, 但是我们都知道一次连接是需要知道对方打开的端口是多少的. 这个时候客户端是随机的端口, 服务端怎么发送请求? </p><p>所以, 其实在<strong>主动模式</strong>下, 客户端选择一个随机端口. 连接服务器端的21号端口. 接着服务器端会将自己的20号端口去和客户端的随机端口+1的那个端口建立连接, 如果被占用就继续加一. 后者的这个连接上就是数据传输通道, 而前者就是命令传输端口. 其实在一开始命令连接的时候 客户端也会告诉服务器端, 自己打开的端口是哪一个. </p><p>然而, 这样是有很大的安全隐患的. 因为我们知道客户端主动打开了一个端口等着我, 如果加以构造, 服务端是可以随意向客户端发送数据的. 所以客户端是需要防火墙的, 但是这又出现了问题, 我们怎么知道开启那个端口使得服务端连接过来呢?</p><p>这么麻烦, 所以催生了后来的被动模式, 不管是命令还是数据传输都有客户端来负责建立连接. 这样客户端使用一个随机端口连接到服务器端的21端口, 接着再有客户端连接到20端口发起数据传输请求. 接着就可以将服务器端的随机端口托付过来传输数据就行了. 服务端发送过来端口形式是XXX,XX这样的形式 这个是需要进行计算的: XXX * 256 + XX.</p><p>可是, 服务器端也有防火墙啊? 他怎么知道服务器端的那个随机端口是哪一个呢? 关于这个, 在随后的iptables中在看. ( 连接追踪 )</p><p>简单的说说FTP协议, 接下来看看有那些典型的FTP软件:</p><ul><li>wu-ftpd</li><li>proftpd</li><li>pureftpd</li><li>vsftpd</li><li>ServU ( Windows )</li></ul><p>以上是服务器端, 而客户端也有很多, 例如:</p><ul><li>wget</li><li>lftp</li><li>ftp</li><li>curl</li><li>filezilla</li><li>gftp ( GUI )</li></ul><h2 id="FTP协议的响应码"><a href="#FTP协议的响应码" class="headerlink" title="FTP协议的响应码"></a>FTP协议的响应码</h2><p><strong>1XX</strong>: 信息类的响应码</p><p><strong>2XX</strong>: 成功类的响应码</p><p><strong>3XX:</strong> 需要补充信息的状态码</p><p><strong>4XX:</strong> 客户端错误</p><p>**5XX: ** 服务端错误</p><p>这个和HTTP的响应码几乎是一样的.</p><h2 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h2><p>现在想想我们之前说过的MySQL, 和FTP有一点像么? 当然他们组织数据的方式是不一样的, MySQl提供的是结构化的数据.  对于用户认证, MySQL提供的验证机制和系统是不一样的, 用户需要提供账号和密码, 这些信息是保存在一个数据表中的. 这种认证方式 我们把这个叫做<strong>虚拟用户</strong> . 这个是为了和操作系统其他的资源隔离起来, 更加安全. 此用户仅仅是为了一个特定服务而存在.</p><p>与MySQL应用层服务不同的是, FTP协议存在的非常早, 在互联网混沌初开的时候就已经存在了. 早期, FTP使用的是系统用户进行认证. 其实也是因为FTP提供的是系统文件服务, 所以才选择这样的策略 – 关联系统账号.</p><p>现在的FTP已经完全支持虚拟用户了. 尽管默认使用的是系统用户, 但是可以非常方便的进行用户认证管理, 另外, 结合之前说过的MySQL, 我们还可以将用户账号信息丢到数据库中( 当然这里说的和mysql.user表是没有什么关系的 ). 这样更方便管理和组织.</p><p>Linux上平台独有的一些验证技术, 比如说之前说过的PAM模块, 如果我们的FTP程序使用这个做为用户认证的依赖, 那么移植到Win平台就比较困难. 所以为了通用和跨平台, 就需要FTP程序自我实现验证. </p><p>除了我们上面说的系统用户和虚拟用户, 还有一种匿名用户. 其实, 说到底虚拟用户和匿名用户还是系统用户的一个包装, 最终操作都需要系统用户去进行 这是由Linux系统决定的机制. </p><h2 id="vsftpd"><a href="#vsftpd" class="headerlink" title="vsftpd"></a>vsftpd</h2><p>现在就来说说这个典型的FTP程序, 按照惯例, 安装完了之后我们先看看安装了哪些文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># rpm -ql vsftpd</span></span><br><span class="line">/etc/logrotate.d/vsftpd</span><br><span class="line">/etc/pam.d/vsftpd</span><br><span class="line">/etc/vsftpd</span><br><span class="line">/etc/vsftpd/ftpusers</span><br><span class="line">/etc/vsftpd/user_list</span><br><span class="line">/etc/vsftpd/vsftpd.conf</span><br><span class="line">/etc/vsftpd/vsftpd_conf_migrate.sh</span><br><span class="line">/usr/lib/systemd/system-generators/vsftpd-generator</span><br><span class="line">/usr/lib/systemd/system/vsftpd.service</span><br><span class="line">/usr/lib/systemd/system/vsftpd.target</span><br><span class="line">/usr/lib/systemd/system/vsftpd@.service</span><br><span class="line">/usr/sbin/vsftpd</span><br><span class="line">...(omitted)</span><br><span class="line">/var/ftp</span><br><span class="line">/var/ftp/pub</span><br></pre></td></tr></table></figure><p>首先就看到了我们的日志滚动配置和PAM用户认证配置文件.</p><p>接着就是systemd的服务Unit. 主配置文件: &#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf</p><p>接着还有用户控制配置文件, 以及主程序. 最后的两个路径, 就像是HTTP服务的共享资源目录一样, 匿名用户的资源位置就是这个目录. 其实这个匿名用户就是ftp用户的映射:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># finger ftp</span></span><br><span class="line">Login: ftp            Name: FTP User</span><br><span class="line">Directory: /var/ftp                 Shell: /sbin/nologin</span><br><span class="line">Never logged <span class="keyword">in</span>.</span><br><span class="line">No mail.</span><br><span class="line">No Plan.</span><br></pre></td></tr></table></figure><p>其实就是家目录.</p><p>而虚拟用户就需要我们进行制定映射系统目录了 ( 系统用户的家目录 )</p><p>直接启动试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># systemctl start vsftpd.service</span></span><br><span class="line">[root@WWW ~]<span class="comment"># ss -antp</span></span><br><span class="line">State       Recv-Q Send-Q                                        Local Address:Port                                                       Peer Address:Port              </span><br><span class="line">LISTEN      0      10                                           192.168.56.101:53                                                                    *:*                   <span class="built_in">users</span>:((&quot;named&quot;,pid=<span class="number">1035</span>,fd=<span class="number">22</span>))</span><br><span class="line">LISTEN      0      10                                                127.0.0.1:53                                                                    *:*                   <span class="built_in">users</span>:((&quot;named&quot;,pid=<span class="number">1035</span>,fd=<span class="number">21</span>))</span><br><span class="line">LISTEN      0      128                                          192.168.56.101:22                                                                    *:*                   <span class="built_in">users</span>:((&quot;sshd&quot;,pid=<span class="number">1004</span>,fd=<span class="number">3</span>))</span><br><span class="line">LISTEN      0      128                                               127.0.0.1:953                                                                   *:*                   <span class="built_in">users</span>:((&quot;named&quot;,pid=<span class="number">1035</span>,fd=<span class="number">23</span>))</span><br><span class="line">ESTAB       0      52                                           192.168.56.101:22                                                         192.168.56.1:6533                <span class="built_in">users</span>:((&quot;sshd&quot;,pid=<span class="number">12137</span>,fd=<span class="number">3</span>))</span><br><span class="line">LISTEN      0      32                                                       :::21                                                                   :::*                   <span class="built_in">users</span>:((&quot;vsftpd&quot;,pid=<span class="number">12421</span>,fd=<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>现在服务已经起来了, 我们进入另外一台主机试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># ftp 192.168.56.101</span></span><br><span class="line">Connected to 192.168.56.101 (192.168.56.101).</span><br><span class="line">220 (vsFTPd 3.0.2)</span><br><span class="line">Name (192.168.56.101:root): anonymous </span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; </span><br></pre></td></tr></table></figure><p>我们使用匿名用户账号登录.(也可以使用ftp用户本身) 接着看到了2XX的成功信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ftp&gt; <span class="built_in">ls</span></span><br><span class="line">227 Entering Passive Mode (192,168,56,101,159,15).</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">drwxr-xr-x    2 0        0               6 Aug 03 06:10 pub</span><br><span class="line">226 Directory send OK.</span><br></pre></td></tr></table></figure><p>看到了pub目录, 还有进入了被动模式. 接下来快速的执行两次命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ftp&gt; ls</span><br><span class="line">227 Entering Passive Mode (192,168,56,101,25,251).</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">drwxr-xr-x    2 0        0               6 Aug 03 06:10 pub</span><br><span class="line">226 Directory send OK.</span><br><span class="line">ftp&gt; ls</span><br><span class="line">227 Entering Passive Mode (192,168,56,101,243,212).</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">drwxr-xr-x    2 0        0               6 Aug 03 06:10 pub</span><br><span class="line">226 Directory send OK.</span><br></pre></td></tr></table></figure><p>端口是一次传输换一个, 另外这个时候快速的回到服务器端查看一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TIME-WAIT   0      0                                     ::ffff:192.168.56.101:62420                                             ::ffff:192.168.56.103:41501              </span><br><span class="line">TIME-WAIT   0      0                                     ::ffff:192.168.56.101:6651                                              ::ffff:192.168.56.103:34982  </span><br></pre></td></tr></table></figure><p>计算一下, 25 * 256 + 251 &#x3D; 6651, 果然是吧.</p><p>可以使用help来查看所有支持的命令.</p><p>接下来我们要看看vsftpd的配置文件了.</p><h2 id="vsftpd配置"><a href="#vsftpd配置" class="headerlink" title="vsftpd配置"></a>vsftpd配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable=YES</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">local_umask=022</span><br></pre></td></tr></table></figure><p>这几项都很好理解吧 </p><p>我们在FTP服务器上进行一个用户的创建接下来看看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW vsftpd]<span class="comment"># useradd test</span></span><br><span class="line">[root@WWW vsftpd]<span class="comment"># echo &quot;test&quot; | passwd test --stdin</span></span><br><span class="line">Changing password <span class="keyword">for</span> user <span class="built_in">test</span>.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure><p>接着我们在客户端尝试使用test用户进行连接:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># ftp 192.168.56.101</span></span><br><span class="line">Connected to 192.168.56.101 (192.168.56.101).</span><br><span class="line">220 (vsFTPd 3.0.2)</span><br><span class="line">Name (192.168.56.101:root): <span class="built_in">test</span></span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; <span class="built_in">pwd</span></span><br><span class="line">257 <span class="string">&quot;/home/test&quot;</span></span><br><span class="line">ftp&gt; <span class="built_in">cd</span> /etc/</span><br><span class="line">250 Directory successfully changed.</span><br><span class="line">ftp&gt; <span class="built_in">ls</span></span><br><span class="line">227 Entering Passive Mode (192,168,56,101,170,58).</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">-rw-r--r--    1 0        0            1240 Sep 28 08:40 passwd</span><br><span class="line">drwxr-xr-x    3 0        0             219 Jun 25 12:39 ppp</span><br><span class="line">lrwxrwxrwx    1 0        0              14 Jun 25 02:20 redhat-release -&gt; centos-release</span><br><span class="line">-rw-r--r--    1 0        0              30 Sep 28 07:47 resolv.conf</span><br><span class="line">----------    1 0        0             844 Sep 28 08:41 shadow</span><br><span class="line">drwxr-xr-x    3 0        0              54 Jun 25 12:39 udev</span><br><span class="line">drwxr-xr-x    2 0        0             111 Sep 28 08:38 vsftpd</span><br><span class="line">drwxr-xr-x    3 0        0              38 Jun 26 08:13 yum.repos.d</span><br><span class="line">226 Directory send OK.</span><br><span class="line">ftp&gt; </span><br></pre></td></tr></table></figure><p>默认的目录会是自己的家目录, 这个我们之前就说过了, 但是, 在这情况下, 客户端可以随意的移动倒其他的目录, FTP是明文传输, 这样实在是太危险了. 所以我们必须把系统用户像匿名用户那样锁在一个目录中, 或者说根切换.</p><p>接下来我们按照用户类型看一下配置项:</p><h3 id="匿名用户"><a href="#匿名用户" class="headerlink" title="匿名用户"></a>匿名用户</h3><p>anonymous_enable&#x3D;YES<br>anon_upload_enable&#x3D;YES 匿名用户能不能进行文件上传<br>anon_mkdir_write_enable&#x3D;YES 匿名用户能否创建新目录<br>anon_other_write_enable&#x3D;YES 匿名用户能否进行其他写操作</p><p>我们打开文件上传选项, 做个试验:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ftp&gt; put anaconda-ks.cfg </span><br><span class="line"><span class="built_in">local</span>: anaconda-ks.cfg remote: anaconda-ks.cfg</span><br><span class="line">227 Entering Passive Mode (192,168,56,101,30,146).</span><br><span class="line">553 Could not create file.</span><br></pre></td></tr></table></figure><p>尽管开启了选项但是似乎没有起到作用?? 其实不是, 如果这个选项没有开启, 收到的信息应该是Permission Denied. 但现在的这个消息说明了什么信息呢?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x   3 root root    17 Sep 28 02:27 ftp</span><br></pre></td></tr></table></figure><p>没错, 是目录权限问题, 那怎么办? 直接修改权限? 肯定不行, 这样的话安全机制就荡然无存了呀, 所以这个时候我们可以这样做:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ftp]<span class="comment"># ls</span></span><br><span class="line">pub</span><br><span class="line">[root@WWW ftp]<span class="comment"># mkdir upload</span></span><br><span class="line">[root@WWW ftp]<span class="comment"># setfacl -m u:ftp:rwx upload/</span></span><br><span class="line">[root@WWW ftp]<span class="comment"># getfacl upload/</span></span><br><span class="line"><span class="comment"># file: upload/</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rwx</span><br><span class="line">user:ftp:rwx</span><br><span class="line">group::r-x</span><br><span class="line">mask::rwx</span><br><span class="line">other::r-x</span><br></pre></td></tr></table></figure><p>现在就可以了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># ftp 192.168.56.101</span></span><br><span class="line">Connected to 192.168.56.101 (192.168.56.101).</span><br><span class="line">220 (vsFTPd 3.0.2)</span><br><span class="line">Name (192.168.56.101:root): ftp</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; <span class="built_in">ls</span></span><br><span class="line">227 Entering Passive Mode (192,168,56,101,189,51).</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">drwxr-xr-x    2 0        0               6 Aug 03 06:10 pub</span><br><span class="line">drwxrwxr-x    2 0        0               6 Sep 28 08:54 upload</span><br><span class="line">226 Directory send OK.</span><br><span class="line">ftp&gt; <span class="built_in">cd</span> upload</span><br><span class="line">250 Directory successfully changed.</span><br><span class="line">ftp&gt; put anaconda-ks.cfg </span><br><span class="line"><span class="built_in">local</span>: anaconda-ks.cfg remote: anaconda-ks.cfg</span><br><span class="line">227 Entering Passive Mode (192,168,56,101,91,5).</span><br><span class="line">150 Ok to send data.</span><br><span class="line">226 Transfer complete.</span><br><span class="line">1249 bytes sent <span class="keyword">in</span> 0.00625 secs (199.87 Kbytes/sec)</span><br></pre></td></tr></table></figure><p>但是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp&gt; <span class="built_in">mkdir</span> <span class="built_in">test</span></span><br><span class="line">550 Permission denied.</span><br></pre></td></tr></table></figure><p>无法创建目录, 这个时候就需要第三个选项了, 允许新建目录.</p><p>可是刚把目录创建好, 又遇到了新的问题. 这个上传的文件和目录怎么删除不掉啊!!</p><p>这就是第四个选项的功能, 启动之后再试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ftp&gt; <span class="built_in">rmdir</span> <span class="built_in">test</span></span><br><span class="line">250 Remove directory operation successful.</span><br><span class="line">ftp&gt; delete anaconda-ks.cfg </span><br><span class="line">250 Delete operation successful.</span><br></pre></td></tr></table></figure><p>就可以了.</p><p>以上的这些属性都是比较危险的选项, 开启时候要注意的.</p><h3 id="本地用户的配置"><a href="#本地用户的配置" class="headerlink" title="本地用户的配置"></a>本地用户的配置</h3><p>local_enable&#x3D;YES<br>write_enable&#x3D;YES<br>local_umask&#x3D;022<br>chroot_local_user&#x3D;YES<br>allow_writeable_chroot&#x3D;YES<br>chroot_list_enable&#x3D;YES<br>chroot_list_file&#x3D;&#x2F;etc&#x2F;vsftpd&#x2F;chroot_list</p><p>关于这些属性的意味我们在实验中展示: [ 前三个就省略了, 看看都明白了 ]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># ftp 192.168.56.101</span></span><br><span class="line">Connected to 192.168.56.101 (192.168.56.101).</span><br><span class="line">220 (vsFTPd 3.0.2)</span><br><span class="line">Name (192.168.56.101:root): <span class="built_in">test</span></span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; <span class="built_in">pwd</span></span><br><span class="line">257 <span class="string">&quot;/&quot;</span></span><br></pre></td></tr></table></figure><p>原先我们使用系统用户进行登录的时候, 会显示对方的家目录, 但是开启了第四个选项之后就可以看到被禁锢到根下了. <strong>注意: 要和第五个选项同时开启,否则服务器会直接报错 拒绝连接</strong></p><p>复原第四个选项, 我们开启第六和第七个选项, 先来创建一个新用户: ( 同样需要第五个选项 )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ftp]<span class="comment"># useradd test2</span></span><br><span class="line">[root@WWW ftp]<span class="comment"># echo &quot;test&quot; | passwd test2 --stdin</span></span><br><span class="line">Changing password <span class="keyword">for</span> user test2.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure><p>接着创建需要的那个列表文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW vsftpd]<span class="comment"># echo &quot;test2&quot; &gt; chroot_list</span></span><br></pre></td></tr></table></figure><p>好了, 现在进行验证:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># ftp 192.168.56.101</span></span><br><span class="line">Connected to 192.168.56.101 (192.168.56.101).</span><br><span class="line">220 (vsFTPd 3.0.2)</span><br><span class="line">Name (192.168.56.101:root): <span class="built_in">test</span></span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; <span class="built_in">pwd</span></span><br><span class="line">257 <span class="string">&quot;/home/test&quot;</span></span><br><span class="line">ftp&gt; <span class="built_in">bye</span></span><br><span class="line">221 Goodbye.</span><br><span class="line">[root@WWW ~]<span class="comment"># ftp 192.168.56.101</span></span><br><span class="line">Connected to 192.168.56.101 (192.168.56.101).</span><br><span class="line">220 (vsFTPd 3.0.2)</span><br><span class="line">Name (192.168.56.101:root): test2</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; <span class="built_in">pwd</span></span><br><span class="line">257 <span class="string">&quot;/&quot;</span></span><br><span class="line">ftp&gt; </span><br></pre></td></tr></table></figure><p>这就是指定chroot的用户.</p><p>接下来我们继续看几个配置:</p><p>dirmessage_enable&#x3D;YES</p><p>这个选项允许你改变进入目录的提示信息, 在目录下新建一个.message文件就可以了, 有点像motd的感觉. 也有类似banner的选项就是: ftpd_banner&#x3D;Welcome to blah FTP service.</p><p>xferlog_enable&#x3D;YES 这个看名字也知道是什么了吧, 即使开启记录日志, 和这个配置相互配合的还有几个选项:</p><p>xferlog_file&#x3D;&#x2F;var&#x2F;log&#x2F;xferlog</p><p>xferlog_std_format&#x3D;YES</p><p>其实就是日志保存位置和是否使用标准格式. </p><p>chown_uploads&#x3D;YES<br>chown_username&#x3D;whoever</p><p>是否修改上传文件的属主, 如果启用, 指定系统上存在的一个用户就行. 下面两个和连接相关: </p><p>idle_session_timeout&#x3D;600<br>data_connection_timeout&#x3D;120</p><p>都是关于超时的设定.</p><p>最后还有关于pam的设定, 我们看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># ls /etc/pam.d/vsftpd  -l</span></span><br><span class="line">-rw-r--r-- 1 root root 335 Aug  3 02:10 /etc/pam.d/vsftpd</span><br></pre></td></tr></table></figure><p>后面还有一个userlist和一个tcp_wrapper. 先来说说这个userlist, 这个其实可以和pam归在一起. 可以使用这些选项来建立访问用户控制(白名单, 黑名单)</p><p>例如:<br>在userlist文件中加上test:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Users that are not allowed to login via ftp</span></span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line">adm</span><br><span class="line">lp</span><br><span class="line"><span class="built_in">sync</span></span><br><span class="line">shutdown</span><br><span class="line">halt</span><br><span class="line">mail</span><br><span class="line">news</span><br><span class="line">uucp</span><br><span class="line">operator</span><br><span class="line">games</span><br><span class="line">nobody</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>接着在另一台主机测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># ftp 192.168.56.101</span></span><br><span class="line">Connected to 192.168.56.101 (192.168.56.101).</span><br><span class="line">220 Welcome to blah FTP service.</span><br><span class="line">Name (192.168.56.101:root): <span class="built_in">test</span></span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">530 Login incorrect.</span><br><span class="line">Login failed.</span><br></pre></td></tr></table></figure><p>我确定我的密码输入的是正确的, 但是会被deny.</p><p>这是一份黑名单, vsftpd借助pam模块实现. 但是其实他自己也有用户控制, 就是另外一个user_list文件. 这个更加灵活, 可以作为黑名单, 也可以作为白名单. 通过选项: userlist_deny&#x3D;YES|NO</p><p>接着还有连接参数, 一些限制参数:</p><p>max_clients: 最大并发连接数<br>max_per_ip: 每个IP可同时发起的并发请求.</p><p>还有速率上的限制:</p><p>anno_max_rate: 匿名用户的最大传输限制, 字节&#x2F;s<br>local_max_rate: 本地用户的最大传输限制, 字节&#x2F;s</p><h3 id="虚拟用户的配置"><a href="#虚拟用户的配置" class="headerlink" title="虚拟用户的配置"></a>虚拟用户的配置</h3><p>虚拟用户需要映射到一个指定的系统账号. 所以每一个虚拟用户访问到的就是这个系统账号的家目录. 但是我们却可以赋予这些虚拟用户不同的权限, 这是依靠匿名用户进行的设定. </p><p>关于账号的存储, 我们说过可以存储在文件中, 奇数偶数分别为用户名&#x2F;密码. 这个文件为了安全会被Hash, 但是我的每一次修改都要进行Hash计算, 所以很不方便.</p><p>因此更好的方法是存储在数据库中. 而且这样还是即时的. 但是我们知道vsftpd是依靠于PAM的验证机制的, 如果想要访问数据库, 就需要PAM能够访问数据库. 这样就需要一个模块: pam-mysql, 这个模块是第三方的, 默认不会有, 所以就需要安装.</p><p>这个模块在epel源中, 如果搜索不到需要建立yum源, 如果实在搜索不到就使用二进制的rpm包吧.</p><p>安装完成之后会看到:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># yum list pam_mysql</span></span><br><span class="line">Installed Packages</span><br><span class="line">pam_mysql.x86_64                                                               1:0.8.1-0.22.el7.lux                                                               installed</span><br><span class="line">[root@WWW ~]<span class="comment"># rpm -ql pam_mysql</span></span><br><span class="line">/lib64/security/pam_mysql.so</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>只要出现了so对象就可以了. 接着就可以继续了.</p><p>在pam_mysql的文档中, 我们可以看到官方给的一个示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">An example of the configuration file:</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">auth       optional     pam_mysql.so user=root passwd=password</span><br><span class="line">account    required     pam_mysql.so user=root passwd=password</span><br><span class="line">---------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>后面还有更多的配置项. 接下来就直接来实现:</p><p>准备2台主机, 一台作为ftp服务器, 另外一台mysql服务器.</p><p>mysql准备好了之后进行用户添加和权限管理:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [mysql]&gt; create database vsftpd;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">MariaDB [mysql]&gt; use vsftpd;</span><br><span class="line">Database changed</span><br><span class="line">MariaDB [vsftpd]&gt; grant <span class="keyword">select</span> on vsftpd.* to vsftpd@192.168.56.101 identified by <span class="string">&#x27;???&#x27;</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">MariaDB [vsftpd]&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>接着在vsftpd的主机上进行连接测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># mysql -u vsftpd -p -h 192.168.56.103</span></span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection <span class="built_in">id</span> is 14</span><br><span class="line">Server version: 5.5.56-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; </span><br></pre></td></tr></table></figure><p>成功 ! 那我们继续. 接下来创建表和插入用户信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [vsftpd]&gt; desc <span class="built_in">users</span>;</span><br><span class="line">+----------+----------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type     | Null | Key | Default | Extra          |</span><br><span class="line">+----------+----------+------+-----+---------+----------------+</span><br><span class="line">| <span class="built_in">id</span>       | int(11)  | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name     | char(20) | NO   |     | NULL    |                |</span><br><span class="line">| password | char(48) | NO   |     | NULL    |                |</span><br><span class="line">+----------+----------+------+-----+---------+----------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [vsftpd]&gt; insert <span class="built_in">users</span> values(default, <span class="string">&#x27;justin&#x27;</span>, password(<span class="string">&quot;????&quot;</span>));</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>这一步也完成之后, 我们就可以建立pam认证所需的文件了.</p><p>关于文件的写法, 可以参考pam_mysql的说明文件.</p><p>完成后的pam文件应该是这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth required /lib64/security/pam_mysql.so user=vsftpd passwd=???? host=192.168.56.103 db=vsftpd table=<span class="built_in">users</span> usercolumn=name passwdcolumn=password crypt=mysql</span><br><span class="line">account required /lib64/security/pam_mysql.so user=vsftpd passwd=???? host=192.168.56.103 db=vsftpd table=<span class="built_in">users</span> usercolumn=name passwdcolumn=password crypt=mysql</span><br></pre></td></tr></table></figure><p>接着在vsftpd的配置文件中指定:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pam_service_name=vsftpd.mysql</span><br><span class="line">guest_enable=YES</span><br><span class="line">guest_username=vuser</span><br></pre></td></tr></table></figure><p>接着重启服务就完成了, 如果中间存在报错, 检查vsftpd的配置文件, 如果还不行, 查看secure日志吧.</p><p>以上就是连接mysql虚拟用户的配置.  接下来我继续谈这个, 我们在数据库中插入一个新的用户:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+--------+-------------------------------------------+</span><br><span class="line">| <span class="built_in">id</span> | name   | password                                  |</span><br><span class="line">+----+--------+-------------------------------------------+</span><br><span class="line">|  1 | justin | *29B43F519A224212716DDB7493DBE966B405D061 |</span><br><span class="line">|  2 | bieber | *29B43F519A224212716DDB7493DBE966B405D061 |</span><br><span class="line">+----+--------+-------------------------------------------+</span><br></pre></td></tr></table></figure><p>现在的问题是, 我希望这些用户拥有不同的权限, 这怎么办呢?</p><p>对于这个问题, vsftpd的解决方法是在一个单独的user_config目录下, 一个用户一个配置文件来实现管理, 我们实际操作一下就行了:<br>比方说我们把这个单独的目录放在和主配置文件一样的位置, 就在配置文件中加上这个:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user_config_dir=/etc/vsftpd/vusers</span><br></pre></td></tr></table></figure><p>接着创建之, 并且在里面写上对应的用户控制:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW vusers]<span class="comment"># ls</span></span><br><span class="line">bieber  justin</span><br></pre></td></tr></table></figure><p>我是这样写的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW vusers]<span class="comment"># cat justin </span></span><br><span class="line">anon_upload_enable=YES</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line">anon_other_write_enable=YES</span><br><span class="line">[root@WWW vusers]<span class="comment"># cat bieber </span></span><br><span class="line">anon_upload_enable=NO</span><br><span class="line">anon_mkdir_write_enable=NO</span><br><span class="line">anon_other_write_enable=NO</span><br></pre></td></tr></table></figure><p>这样, justin用户可以进行写操作, 而bieber用户 不可以进行任何上传和写操作了.</p><p>实验效果略.</p><p>再插一句, 我们之前说过ftps是明文的,  而另外一个现在更加常用的文件传输 – sftp. 它是基于SSH协议的, 所以是加密传输的, 更加安全.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> FTP </tag>
            
            <tag> vsftpd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHELL脚本编程及字符操作</title>
      <link href="/2017/09/25/SHELL%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/09/25/SHELL%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>自动化运维第一步, shell编程以及熟练的字符串操作是十分重要的技能点! 开始修炼!</p><span id="more"></span><h2 id="shell编程认知"><a href="#shell编程认知" class="headerlink" title="shell编程认知"></a>shell编程认知</h2><p>首先要明确的是, shell编程语言是一个解释型语言. 也就是说, 我们所写的脚本其实就是文本文件而已. 这些文本文件CPU无法运行, 因此需要一个二进制的程序来解释他们. 这个程序就是解释器. </p><p>与其他的解释型语言(例如: Python)不同, shell近乎没有函数, 他不需要依赖于函数库. 这是为什么? 因为我们的shell很特殊. 他并不需要这些函数来支持, 因为已经有很多别人实现好的程序可以实现各种各样的功能了. 比如Python打开一个文件需要调用open函数, 而shell想要打开一个文件就直接调用例如cat这样的工具就可以了. 在解释器解释执行的时候, 会从环境变量中扫描到cat这个程序的所在, 接着执行它.</p><p>除了这些, 在脚本的开头我们经常会写上这样一句:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure><p>这里的<code>#!</code> 是一种叫做魔数的机制, 通过这个机制了可以来判断文件该有什么解释器来进行解释, 如果一旦出现了空格或者没有写在第一行, 这个机制就会失效. 同样的, 还有每个图片文件的开头的一串特殊的数据会用来表示其格式很多很多. 都是通过这一种机制来表示自己的数据组织结构.</p><p>接下来简单说说SHELL的变量吧.</p><p>有一种变量叫做全局变量. 在shell中的表现就是环境变量. 声明一个环境变量的方法很简单:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -x name=justin</span><br><span class="line"><span class="built_in">export</span> name=justin</span><br></pre></td></tr></table></figure><p>以bash为例, bash内置了很多环境变量. 例如<code>HOSTNAME USER SHELL LANG PATH </code>等等. </p><p>除了环境变量, 在进行shell编程中还有一种重要的变量, 就是<strong>位置变量</strong> </p><p>常用到的位置变量有:</p><ul><li>${0,1,2,3,….} 其中0表示命令本身, 后面的数字就表示参数</li><li>$# 传递给脚本的参数个数</li><li>$* 传递给脚本的所有参数, 视为一个字符串</li><li>$@ 传递给脚本的所有参数, 单个形式</li></ul><h2 id="数组与流程控制"><a href="#数组与流程控制" class="headerlink" title="数组与流程控制"></a>数组与流程控制</h2><p>首先来看看数组, 在Shell中声明一个数组使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -a ARRAY_NAME -- 数组</span><br><span class="line"><span class="built_in">declare</span> -A ARRAY_NAME -- 关联数组 字典</span><br></pre></td></tr></table></figure><p>在赋值的时候也有多种方法, 可以单个赋值也可以统一赋值:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW mage_shell_edu]<span class="comment"># weekday=(&#x27;Sun&#x27; &#x27;Mon&#x27; &#x27;Tus&#x27; &#x27;Wed&#x27;)</span></span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># weekday[0]=&#x27;Sun&#x27;</span></span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># weekday[1]=&#x27;Mon&#x27;</span></span><br></pre></td></tr></table></figure><p>在集合赋值的时候使用空格分开每一个值.</p><p>在引用时, 我们是用<code>$&#123;ARRAY&#125;[INDEX]</code> 当省略<code>[INDEX]</code>的时候, 不是整个数组, 而是第一个元素, 如果想要获得全部数组的话, 使用@或者*就可以了, 例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $&#123;weekday[*]&#125;</span></span><br><span class="line">Sun Mon Tus Wed</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $&#123;weekday[@]&#125;</span></span><br><span class="line">Sun Mon Tus Wed</span><br></pre></td></tr></table></figure><h3 id="while的特殊用法"><a href="#while的特殊用法" class="headerlink" title="while的特殊用法"></a>while的特殊用法</h3><p>读取文件的每一行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ $[`<span class="built_in">echo</span> <span class="variable">$line</span> | <span class="built_in">cut</span> -d: -f3` % 2] -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> -e -n <span class="string">&quot;username: `echo <span class="variable">$line</span> | cut -d: -f1`\t&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;uid: `echo <span class="variable">$line</span> | cut -d: -f3`&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span> &lt; /etc/passwd</span><br></pre></td></tr></table></figure><p>这段脚本就是读取passwd文件的每一行. 接着输出uid为偶数的行. 每一行都会被存在line这个变量中.</p><h3 id="if循环和elif和else"><a href="#if循环和elif和else" class="headerlink" title="if循环和elif和else"></a>if循环和elif和else</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">What information would you like to see:</span></span><br><span class="line"><span class="string">(cpu) show cpu information;</span></span><br><span class="line"><span class="string">(disk) show disk information;</span></span><br><span class="line"><span class="string">(mem) show memory information;</span></span><br><span class="line"><span class="string">(quit) quit</span></span><br><span class="line"><span class="string">===================================</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter a option: &quot;</span> option</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$option</span> != <span class="string">&#x27;cpu&#x27;</span> -a <span class="variable">$option</span> != <span class="string">&#x27;disk&#x27;</span> -a <span class="variable">$option</span> != <span class="string">&#x27;mem&#x27;</span> -a <span class="variable">$option</span> != <span class="string">&#x27;quit&#x27;</span> ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">read</span> -p <span class="string">&quot;Wrong option. Enter again: &quot;</span> option</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ -n <span class="variable">$option</span> ]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$option</span> == <span class="string">&quot;cpu&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        lscpu</span><br><span class="line">    <span class="keyword">elif</span> [ <span class="variable">$option</span> == <span class="string">&quot;mem&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">cat</span> /proc/meminfo</span><br><span class="line">    <span class="keyword">elif</span> [ <span class="variable">$option</span> == <span class="string">&#x27;disk&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">        fdisk -l</span><br><span class="line">    <span class="keyword">elif</span> [ <span class="variable">$option</span> == <span class="string">&#x27;quit&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Quit&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">read</span> -p <span class="string">&quot;See anything? [cpu,disk,mem,quit] &quot;</span> option</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这里面还有一个有趣的地方就是cat的hereDOC输出.</p><h3 id="case和函数"><a href="#case和函数" class="headerlink" title="case和函数"></a>case和函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">LOCK=/var/lock/subsys/service</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;USAGE: service &#123;start|stop|restart|status&#125;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$LOCK</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;service has already run...exit&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Attempting to start the service...&quot;</span></span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$LOCK</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Service started.&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Something goes wrong..&quot;</span></span><br><span class="line"><span class="built_in">rm</span> -f <span class="variable">$LOCK</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">stop</span></span>() &#123;</span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$LOCK</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Stopping service...&quot;</span></span><br><span class="line"><span class="built_in">rm</span> -f <span class="variable">$LOCK</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Service stopped.&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 0;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Service is not running...&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="variable">$1</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$1</span> == <span class="string">&#x27;start&#x27;</span> -o <span class="variable">$1</span> == <span class="string">&#x27;stop&#x27;</span> -o <span class="variable">$1</span> == <span class="string">&#x27;restart&#x27;</span> -o <span class="variable">$1</span> == <span class="string">&#x27;status&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">    start</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">    stop</span><br><span class="line">            ;;</span><br><span class="line">    status)</span><br><span class="line">    <span class="keyword">if</span> [ -e <span class="variable">$LOCK</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Service is running.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Service is not running&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">    stop</span><br><span class="line">start</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    usage</span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> -n -e <span class="string">&quot;Invalid option: <span class="variable">$1</span>\n&quot;</span></span><br><span class="line">usage</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="生成一个列表"><a href="#生成一个列表" class="headerlink" title="生成一个列表"></a>生成一个列表</h3><p>Shell生成一个列表的方式有很多, 由于默认都是字符串, 所以直接给出列表就是可以的, 接下来再说几个:</p><ul><li>生成整数列表的两种方式<ul><li>{start..end}</li><li>$(seq [start [step]] end)</li></ul></li><li>返回列表的命令(e.g: ls)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># for n in &#123;1..9&#125;; do echo $n; done</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">[root@WWW ~]<span class="comment"># seq 1 2 10</span></span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>接下是一个ls返回列表的示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> $(<span class="built_in">ls</span> /var/); <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -f /var/<span class="variable">$file</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Regular File&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> [ -L /var/<span class="variable">$file</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Symbolic File&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> [ -r /var/<span class="variable">$file</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Directory&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>接下来看看, Shell对<strong>字符串</strong>的操作:</p><p>首先先来看下字符串的<strong>切片</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW mage_shell_edu]<span class="comment"># name=&quot;Justin&quot;</span></span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $&#123;name:1:3&#125;</span></span><br><span class="line">ust</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $&#123;name:3&#125;</span></span><br><span class="line">tin</span><br></pre></td></tr></table></figure><p>很好理解. 倒序也是支持的, 但是..诡异的是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $&#123;name: -3&#125;</span></span><br><span class="line">tin</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $&#123;name: -3: -1&#125;</span></span><br><span class="line">ti</span><br></pre></td></tr></table></figure><p><strong>一定要加空格.</strong></p><p>除了切片, Shell还支持模式取字串和查找替换. 不过说实话, 我觉得这些功能…似乎大家都选择使用sed和awk来实现了…就简单的记录一下吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW mage_shell_edu]<span class="comment"># name=$(head -1 /etc/passwd)</span></span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $name</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $&#123;name/root/ROOT&#125;</span></span><br><span class="line">ROOT:x:0:0:root:/root:/bin/bash</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $&#123;name//root/ROOT&#125;</span></span><br><span class="line">ROOT:x:0:0:ROOT:/ROOT:/bin/bash</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $&#123;name/#root/ROOT&#125;</span></span><br><span class="line">ROOT:x:0:0:root:/root:/bin/bash</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># name=&quot;admin:$name:root&quot;</span></span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $name</span></span><br><span class="line">admin:root:x:0:0:root:/root:/bin/bash:root</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $&#123;name/#root/ROOT&#125;</span></span><br><span class="line">admin:root:x:0:0:root:/root:/bin/bash:root</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $&#123;name/%root/ROOT&#125;</span></span><br><span class="line">admin:root:x:0:0:root:/root:/bin/bash:ROOT</span><br></pre></td></tr></table></figure><p>上面是关于查找替换的示例, 其中<code>//</code>表示全文检索替换, 而<code>%</code> 是行尾锚定, <code>#</code> 行首锚定.</p><p><strong>大小写转换</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $name</span></span><br><span class="line">admin:root:x:0:0:root:/root:/bin/bash:root</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $&#123;name^^&#125;</span></span><br><span class="line">ADMIN:ROOT:X:0:0:ROOT:/ROOT:/BIN/BASH:ROOT</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># newname=$&#123;name^^&#125;</span></span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $newname</span></span><br><span class="line">ADMIN:ROOT:X:0:0:ROOT:/ROOT:/BIN/BASH:ROOT</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># echo $&#123;newname,,&#125;</span></span><br><span class="line">admin:root:x:0:0:root:/root:/bin/bash:root</span><br></pre></td></tr></table></figure><p>最后附赠一个有意思的小命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW mage_shell_edu]<span class="comment"># mktemp /tmp/test.XXX</span></span><br><span class="line">/tmp/test.Vmd</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># mktemp /tmp/test.XXX</span></span><br><span class="line">/tmp/test.LQW</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># mktemp /tmp/test.XXXXXX</span></span><br><span class="line">/tmp/test.SuR3Bk</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># mktemp -d /tmp/test.XXXXXX</span></span><br><span class="line">/tmp/test.N9FxlV</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># ls /tmp/test*</span></span><br><span class="line">/tmp/test  /tmp/test.LQW  /tmp/test.SuR3Bk  /tmp/test.Vmd</span><br><span class="line"></span><br><span class="line">/tmp/test.N9FxlV:</span><br></pre></td></tr></table></figure><p>这个命令是有返回值的, 也就是说你可以赋给变量从而使用它. 最少要使用三个X才可以. 另外, 使用<code>-d</code>参数可以创建目录.</p><h2 id="管道和字符操作"><a href="#管道和字符操作" class="headerlink" title="管道和字符操作"></a>管道和字符操作</h2><p>(略)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识数据库(mariadb初步)</title>
      <link href="/2017/09/24/%E8%AE%A4%E8%AF%86%E6%95%B0%E6%8D%AE%E5%BA%93-mariadb%E5%88%9D%E6%AD%A5/"/>
      <url>/2017/09/24/%E8%AE%A4%E8%AF%86%E6%95%B0%E6%8D%AE%E5%BA%93-mariadb%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>mariadb, mysql的基础认识和应用.</p><span id="more"></span><h2 id="认识数据库"><a href="#认识数据库" class="headerlink" title="认识数据库"></a>认识数据库</h2><p>我们现在已经知道数据库有很多种类型的, 比如关系型数据库, NoSQL数据库, 分布式关系型数据库.  而mysql,mariadb只是数量众多的数据库中关系型数据库的一种开源实现. 数据存储在文本文件中在数据量很大中是很麻烦的, 所以数据库就是为了<strong>组织数据</strong>.  所以采用何种组织数据的方式, 我们就把他成为数据组织模型. 像文件系统组织文件的模型就是树状的. 对于单个文件就是一行行的流.</p><p>数据结构模型一开始有: <strong>层次模型</strong>. 这种模型使用时就发现了问题, 因为他很难表示两个节点之间的关系, 多个节点就更加困难了. 于是后来就有了<strong>网状结构</strong> .</p><p>而网状结构却发现, 这个模型和应用程序的耦合度过大. 一旦应用程序的发生改变, 这个结构也要发生变化.</p><p>因此最后提出了<strong>关系结构模型</strong>, 每一个数据被组成行和列, 一个二维交叉的平面结构上. 那么当进行一个大的数据集的设计的时候, 为了达到降低数据冗余, 达到更改方便的时候, 提出设计数据库的几个范式, 有关数据库的设计在之前我曾经简单的在慕课网上学习了一些: <a href="https://yaoxuannn.com/2017/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/">数据库设计</a> </p><p>之前说过, 为了满足范式我们经常要进行表的拆分, 这个时候如果要进行查询就要先进行表的连接(join), 而这个连接就是关系性数据库要解决的一个大问题, 表的连接是十分消耗资源的. 这个合并操作对于内存是一个大的消耗. 因此就精心设计算法来避免产生过多中间数据.</p><p>那么列举一些典型的RDBMS:<br>首当其冲的就是MySQL了, 其下有三个重要的分支: MySQL, MariaDB, Percona-Server(反正我是没听说过)</p><p>还有很著名的开源数据库: PostgreSQL: pgSQL.  再来一个Oracle的oracle, 还有MS的MSSQL. </p><p>接下来就要来看看一个关系型数据库的组成结构了.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/sql.png" alt="sql"></p><p>不管怎么说, 最终都是要存储在磁盘上的, 所以也可以简单的说MySQL只是一个文件系统上的能够理解数据库源数据的一个软件管理程序罢了.  所有的数据都是现在内存中进行的缓冲 接着在PUSH到磁盘上的. 如一个文件正在被一个进程进行写操作, 那么就会上锁, 这就是为了在资源竞争保护资源. 对于一个关系型数据库来说, 事务是一个必不可少的组件. 多个写操作被认定成一个整体操作. 如何认定一个关系型数据库满足事务功能? 只要满足ACID测试就行, ACID是事务的一个标准, 也就是(原子性, 一致性, 隔离性, 持久性)</p><p>回复管理器就是为了保证事务的运行, 他会把事物产生的数据连续存储两次, 一次存储在事务日志中, 一次存储在事务文件中, 这样就可以进行一致性检测.</p><p>上面的那一大块东西就是SQL引擎, 或者SQL解释器.  以上就是一个标准的RDBMS的组成结构.</p><p>那么我怎么和数据库进行交互呢 ?  </p><p>一般数据库都会把自己作为一个服务器通过监听套接字来监听客户端发送来的请求, 基于一个而应用层的协议, 基于C&#x2F;S架构, 每一个软件设计都会设计自己的协议. 那么我们怎么去对接这样的协议, 合成满足对方协议的报文呢? 这就需要数据库的开发者提供客户端的接口, 其中有两种: 程序接口, 以及应用程序接口.</p><p>一个通用的接口就是ODBC, 但是过于底层, 所以在此基础上再封装得到对应的程序编程语言的数据库编程接口, 再度封装和抽象, 甚至得到一个编程语言通用的数据库抽象层.</p><h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><p><strong>约束(constraint)</strong>  我们来举个例子吧, 比如现在想表里填一个学生的年龄, 但是填写了200, 如果数据库对于这个数值的大小有限制, 它可以检测数据的合法性, 这就是约束.</p><blockquote><p>约束有这些常见的类型: <strong>主键</strong> 一个或者多个字段的组合, 简单的说就是在本表中唯一标识一个行, 而且必须提供数据, 即NOT NULL.</p><p><strong>唯一键</strong> 一个或者多个字段的组合, 填入的数据必须能在本表唯一标识本行, 允许为空. 一个表只能有一个主键, 但是唯一键可以出现多次.</p><p><strong>外键</strong> 一个表中可以填入的数据取决于另一个表的主键已有的数据.</p><p><strong>检查性</strong> check约束. 就是上面的那个例子</p></blockquote><p><strong>索引</strong> 将表中的一个或者多个字段中的数据复制一份另存并且这些数据需要按需排序存储. 分稀疏索引, 稠密索引</p><p><strong>关系计算</strong>:</p><blockquote><p>选择: 挑选出符合需要的行</p><p>投影: 挑选出需要的字段, 和选择可以同时进行.</p><p>连接: 笛卡尔积, 内外连接…</p></blockquote><p>而在组织数据之前, 我们现需要将数据进行抽象. 站在不同的角度来看, 数据是不一样的表现形式. 在物理层上, 决定这数据的存储格式即如何在磁盘上进行文件组织. 而逻辑层上, 描述DB中如何存储, 以及数据间的关系如何处理. 最后在视图层上, 描述DB的部分数据.</p><p>( 过于学术化, 不管了</p><h2 id="MariaDB"><a href="#MariaDB" class="headerlink" title="MariaDB"></a>MariaDB</h2><p>先来说说MariaDB的特性吧:</p><p>首先和MySQL一样的, 他们都支持插件式的存储引擎, 这个组件就是既能够和磁盘打交道, 还可以为逻辑层提供保证的这么一个组件. 我们就把他成为存储引擎. 对于Oracle等, 他们的存储引擎都是不可变的, 但是MySQL和MariaDB是可以进行插件式的接口设计的, 只要整合到core上就可以使用. 存储引擎有多重实现版本, 功能和性能都有差异, 用户可以根据需要进行选择.</p><p>存储引擎也被成为”表类型” 相比MySQL, MariaDB提供更多的存储引擎.</p><p>原先是MyISAM这个引擎, 后来出现了InnoDB, 也是InnoDB得到了广泛使用, 而MyISAM后来推出了针对MariaDB的Aria引擎, 能够进行数据恢复. 其实InnoDB在mariaDB上也不叫做这个名字, 而是<strong>XtraDB</strong> .都是升级版.</p><p>MariaDB提供了诸多扩展和测试组件, 而且他是真正开源的.</p><p>在CentOS7上这个mariaDB是默认安装的. 我们来说说他的配置文件吧.</p><p>MySQL的配置文件查找方式很有趣, 他是基于ini格式, 为各个程序提供配置信息:  [prog_name]</p><p>配置文件存在查找次序:</p><blockquote><p>&#x2F;etc&#x2F;my.cnf –&gt; &#x2F;etc&#x2F;mysql&#x2F;my.cnf –&gt; –default-extra-file&#x3D;&#x2F;PATH&#x2F;TO&#x2F;CONF_FILE –&gt; ~&#x2F;.my.cnf</p><p>会匹配最后一个查找到的配置文件</p></blockquote><p>MySQL默认提供了几个配置文件, 这些文件分别对应不同等级的内存或者服务器所使用的配置, small, medium, large, huge, heavy-4G. </p><p>MariaDB有两种程序组成一种就是客户端, 一种就是服务端, 服务器端监听两种套接字: ip socket 和 unix socket</p><p>监听在TCP的3306端口, 支持远程通信. 而unix socket监听在一个socket文件, 仅支持本地通信. 我们的命令行交互式客户端程序就叫做: mysql</p><p>常用的属性是: -u 用户名 -h 主机地址 -p 密码</p><p>要注意的是, MySQL的用户账号有两个部分组成, ‘USERNAME‘@’HOST’ 这里的host四为了限制用户可通过哪些主机来进行远程连接MySQL服务, 支持使用通配符: % 匹配任意长度的任意字符, _ 匹配任意单个字符.</p><p>在我们刚刚安装完成之后, mysql会预置几个用户, 这是十分危险的, 我们来看一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection <span class="built_in">id</span> is 4</span><br><span class="line">Server version: 5.5.56-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; use mysql</span><br><span class="line">Reading table information <span class="keyword">for</span> completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">MariaDB [mysql]&gt; <span class="keyword">select</span> User,Host,Password from user;</span><br><span class="line">+------+-----------+----------+</span><br><span class="line">| User | Host      | Password |</span><br><span class="line">+------+-----------+----------+</span><br><span class="line">| root | localhost |          |</span><br><span class="line">| root | www       |          |</span><br><span class="line">| root | 127.0.0.1 |          |</span><br><span class="line">| root | ::1       |          |</span><br><span class="line">|      | localhost |          |</span><br><span class="line">|      | www       |          |</span><br><span class="line">+------+-----------+----------+</span><br><span class="line">6 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [mysql]&gt; </span><br></pre></td></tr></table></figure><p>有两个匿名用户, 而且都是没有密码的. 这可不行 所以我们要先进行安全的初始化. 由一个程序可以帮助我们(你的路径可能和我不一样)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># /usr/bin/mysql_secure_installation </span></span><br><span class="line"></span><br><span class="line">NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB</span><br><span class="line">      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!</span><br><span class="line"></span><br><span class="line">In order to <span class="built_in">log</span> into MariaDB to secure it, we<span class="string">&#x27;ll need the current</span></span><br><span class="line"><span class="string">password for the root user.  If you&#x27;</span>ve just installed MariaDB, and</span><br><span class="line">you haven<span class="string">&#x27;t set the root password yet, the password will be blank,</span></span><br><span class="line"><span class="string">so you should just press enter here.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Enter current password for root (enter for none): </span></span><br></pre></td></tr></table></figure><p>在回车之后会有一大堆的安全初始化流程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">OK, successfully used password, moving on...</span><br><span class="line"></span><br><span class="line">Setting the root password ensures that nobody can <span class="built_in">log</span> into the MariaDB</span><br><span class="line">root user without the proper authorisation.</span><br><span class="line"></span><br><span class="line">Set root password? [Y/n] Y        </span><br><span class="line">New password: </span><br><span class="line">Re-enter new password: </span><br><span class="line">Password updated successfully!</span><br><span class="line">Reloading privilege tables..</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">By default, a MariaDB installation has an anonymous user, allowing anyone</span><br><span class="line">to <span class="built_in">log</span> into MariaDB without having to have a user account created <span class="keyword">for</span></span><br><span class="line">them.  This is intended only <span class="keyword">for</span> testing, and to make the installation</span><br><span class="line">go a bit smoother.  You should remove them before moving into a</span><br><span class="line">production environment.</span><br><span class="line"></span><br><span class="line">Remove anonymous <span class="built_in">users</span>? [Y/n] y</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Normally, root should only be allowed to connect from <span class="string">&#x27;localhost&#x27;</span>.  This</span><br><span class="line">ensures that someone cannot guess at the root password from the network.</span><br><span class="line"></span><br><span class="line">Disallow root login remotely? [Y/n] n</span><br><span class="line"> ... skipping.</span><br><span class="line"></span><br><span class="line">By default, MariaDB comes with a database named <span class="string">&#x27;test&#x27;</span> that anyone can</span><br><span class="line">access.  This is also intended only <span class="keyword">for</span> testing, and should be removed</span><br><span class="line">before moving into a production environment.</span><br><span class="line"></span><br><span class="line">Remove <span class="built_in">test</span> database and access to it? [Y/n] n</span><br><span class="line"> ... skipping.</span><br><span class="line"></span><br><span class="line">Reloading the privilege tables will ensure that all changes made so far</span><br><span class="line">will take effect immediately.</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? [Y/n] y</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br><span class="line"></span><br><span class="line">All <span class="keyword">done</span>!  If you<span class="string">&#x27;ve completed all of the above steps, your MariaDB</span></span><br><span class="line"><span class="string">installation should now be secure.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Thanks for using MariaDB!</span></span><br></pre></td></tr></table></figure><p>这里我故意没有禁用管理员远程登录, 其实这个应该是禁用掉的.</p><p>现在登陆进去再看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; use mysql</span><br><span class="line">Reading table information <span class="keyword">for</span> completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">MariaDB [mysql]&gt; <span class="keyword">select</span> User,Host,Password from user;</span><br><span class="line">+------+-----------+-------------------------------------------+</span><br><span class="line">| User | Host      | Password                                  |</span><br><span class="line">+------+-----------+-------------------------------------------+</span><br><span class="line">| root | localhost | *D79FA10BB5A035FC32C7106AE068E4772D8FF081 |</span><br><span class="line">| root | www       | *D79FA10BB5A035FC32C7106AE068E4772D8FF081 |</span><br><span class="line">| root | 127.0.0.1 | *D79FA10BB5A035FC32C7106AE068E4772D8FF081 |</span><br><span class="line">| root | ::1       | *D79FA10BB5A035FC32C7106AE068E4772D8FF081 |</span><br><span class="line">+------+-----------+-------------------------------------------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>就已经加密了, 而且匿名用户已经删除了.</p><p>mysql的命令有两种, 一种是客户端命令, 一种是客户端命令.</p><p>客户端命令是在本地执行的, 例如status这个命令, 每一个客户端命令都有其缩写形式, 以&#x2F;开头.使用help可以查看所有的客户端命令, 而服务器端命令是需要通过MySQL协议发往服务器端执行之后才获得结果, 每一个命令都需要使用;(默认)来标记结束.</p><p>使用<code>show character set</code>;来查看所有支持的字符集, 使用<code>show collation;</code>查看所有的排序规则 , 使用<code>show engines;</code> 查看所有存储引擎支持.</p><p>最后再说一下, 如何进行MariaDB的权限管理吧:</p><p>先来说怎么进行用户的创建:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [mysql]&gt; create user <span class="string">&#x27;justin&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [mysql]&gt; <span class="keyword">select</span> User,Host,Password from user;</span><br><span class="line">+--------+-----------+-------------------------------------------+</span><br><span class="line">| User   | Host      | Password                                  |</span><br><span class="line">+--------+-----------+-------------------------------------------+</span><br><span class="line">| root   | localhost | *D79FA10BB5A035FC32C7106AE068E4772D8FF081 |</span><br><span class="line">| root   | www       | *D79FA10BB5A035FC32C7106AE068E4772D8FF081 |</span><br><span class="line">| root   | 127.0.0.1 | *D79FA10BB5A035FC32C7106AE068E4772D8FF081 |</span><br><span class="line">| root   | ::1       | *D79FA10BB5A035FC32C7106AE068E4772D8FF081 |</span><br><span class="line">| justin | %         | *2470C0C06DEE42FD1618BB99005ADCA2EC9D1E19 |</span><br><span class="line">+--------+-----------+-------------------------------------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>删除用户就变得简单了, 直接drop user就行了.</p><p>如果这个时候进行登录 会发现justin用户无法看到mysql数据库, 这是因为我们呢还没有给justin用户进行授权.</p><p>授权的命令是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Name: <span class="string">&#x27;GRANT&#x27;</span></span><br><span class="line">Description:</span><br><span class="line">Syntax:</span><br><span class="line">GRANT</span><br><span class="line">    priv_type [(column_list)]</span><br><span class="line">      [, priv_type [(column_list)]] ...</span><br><span class="line">    ON [object_type] priv_level</span><br><span class="line">    TO user_specification [, user_specification] ...</span><br><span class="line">    [REQUIRE &#123;NONE | ssl_option [[AND] ssl_option] ...&#125;]</span><br><span class="line">    [WITH with_option ...]</span><br></pre></td></tr></table></figure><p>这个命令也可以进行用户的创建. 后面的省略号甚至可以进行查询的数量进行限制, 把这个help稍微整理一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT priv_type,... ON [TABLE|...] db_name.tb_name TO <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;host&#x27;</span> [IDENTIFIED BY <span class="string">&#x27;password&#x27;</span>]</span><br></pre></td></tr></table></figure><p>可以查看指定用户的权限设定:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show grants <span class="keyword">for</span> root@localhost;</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Grants <span class="keyword">for</span> root@localhost                                                                                                              |</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY PASSWORD <span class="string">&#x27;*D79FA10BB5A035FC32C7106AE068E4772D8FF081&#x27;</span> WITH GRANT OPTION |</span><br><span class="line">| GRANT PROXY ON <span class="string">&#x27;&#x27;</span>@<span class="string">&#x27;&#x27;</span> TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> WITH GRANT OPTION                                                                           |</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>另外, 如果是想知道当前登录用户的权限设定的话, 可以使用内置的函数来:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show grants <span class="keyword">for</span> current_user();</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Grants <span class="keyword">for</span> root@localhost                                                                                                              |</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY PASSWORD <span class="string">&#x27;*D79FA10BB5A035FC32C7106AE068E4772D8FF081&#x27;</span> WITH GRANT OPTION |</span><br><span class="line">| GRANT PROXY ON <span class="string">&#x27;&#x27;</span>@<span class="string">&#x27;&#x27;</span> TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> WITH GRANT OPTION                                                                           |</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>而如果想要撤销授权, 就使用revoke指令就行. 格式是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE priv_type,... ON db_name.tb_name FROM <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;host&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在我们启动MariaDB服务进程的时候,会读取mysql库中的所有授权表到内存中, 所以每当有用户进行登录的时候都会到内存中进行检查. 而当我们进行权限改变, 或者用户更改的时候, 这些操作机会保存在表中, MariaDB会自动进行重读授权表. 而对于不能或者不能及时重读授权表的时候, 我们就使用<code>FLUSH PRIVILEGES</code> 来强制重读.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http协议和httpd</title>
      <link href="/2017/09/23/http%E5%8D%8F%E8%AE%AE%E5%92%8Chttpd/"/>
      <url>/2017/09/23/http%E5%8D%8F%E8%AE%AE%E5%92%8Chttpd/</url>
      
        <content type="html"><![CDATA[<p>再来看http协议 &amp; Web服务器httpd的初次会面</p><span id="more"></span><h2 id="HTTP协议补充"><a href="#HTTP协议补充" class="headerlink" title="HTTP协议补充"></a>HTTP协议补充</h2><p>虽然之前说过一大堆关于Http的东西了, 就是那一堆图解http阅读笔记, 虽然写了三个部分吧, 但是毕竟是很早的时候搞得, 那个时候的认知显然和现在不太一样, 所以这里就再来说一下, 但是不说原理, 补充一些当时没有写的.</p><p><strong>来自未来: 之前写的http阅读笔记太垃圾了所以我删掉了 哈哈哈, 推荐直接去看书吧</strong></p><p>早期我们的HTTP协议仅仅可以传输html文本, 也就是所谓超文本标记语言. 但是现在可不一样, 我们可以传输音乐, 图片, 视频等等. 这是怎么做的?</p><p>其实就是引入了MIME, 这个玩意是来自于邮件的, 为了能够发送不同类型的文件附件, 叫做多用途互联网邮件扩展. 基于这个HTTP就能够发送非文本的数据了. </p><p>至于HTTP的工作原理, 之前也说得差不多了. 其实也很简单, 就是HTTP请求和HTTP响应. 报文也主要就是这两种. </p><p>最简单的Web资源就是静态的文件, 而还有一些就是动态的资源, 这些资源会先在服务器主机上执行一遍.</p><p>那么在这里来提一个问题, 浏览器是怎么显示图片的? 有些浏览器根本就没有图片显示功能啊. 这里其实他是调用外部系统接口(比如Windows内置的图片查看器), 或者一些插件. 根据获得的资源的后缀名或, 编码, MIME 来判断使用什么来打开并且显示他们.</p><p>MIME也可以叫做媒体类型: 分为主类型&#x2F;次类型, 比如:</p><ul><li>text&#x2F;html</li><li>text&#x2F;plain</li><li>image&#x2F;jpeg</li><li>image&#x2F;gif</li></ul><p>然后我们补充一下HTTP的几个版本更迭吧:</p><ul><li>HTTP&#x2F;0.9 原型版本 很多设计缺陷 不支持多媒体</li><li>HTTP&#x2F;1.0 支持多媒体, 缓存机制设计存在问题</li><li>HTTP&#x2F;1.1 增强了Cache功能</li><li>HTTP&#x2F;2.0</li></ul><h2 id="Web服务器基础"><a href="#Web服务器基础" class="headerlink" title="Web服务器基础"></a>Web服务器基础</h2><p>说到服务器应用, 感觉还是要说一下http的完整请求啊…那就再来一遍吧, 这次我们站在服务器的角度来说.</p><p>( * ) 建立或处理连接 : 接受请求或者拒绝请求</p><p>( * ) 接受请求 : 就是接受来自网络的请求报文中的对某资源的一次请求的过程.</p><p>这里我们稍微多扯扯, 如果一个Web服务器的进程和一个主机的进程正在进行通信, 这个时候又来了一台主机, 他该怎么办呢, 这个处理模型, 也就是并发访问响应模型 (Web I&#x2F;O结构): 常见的有数种:</p><p><strong>单进程I&#x2F;O结构</strong> , 在没有处理完上一个的请求, 不会处理下一个, 被串行响应, 不能算作并行的结构.</p><p><strong>多进程IO结构</strong> , 启动多个进程, 是每个进程响应一个请求. 会造成大量的CPU进程切换, 以及大量的内存消耗.</p><p><strong>I&#x2F;O复用结构</strong>, 一个进程响应多个请求.(多线程模型, 生成N个线程(在Linux上几乎和多进程没什么区别). 事件驱动模型)</p><p><strong>复用的多进程I&#x2F;O结构</strong>, 启动多个进程, 每个进程响应多个请求.</p><p>( * ) 处理请求 : 对请求报文进行解析, 并获取请求的资源以及请求方法等信息</p><p>( * ) 访问资源 : 获取请求报文中请求的资源</p><p>这些资源通常放置于本地文件系统的某路径下, 此路径也被称为DocRoot, 也就是做根的映射.</p><p>web服务器的路径映射方式有多种:<br>​(a) docroot</p><pre><code>(b) alias别名(c) 虚拟主机docroot映射(d) 用户家目录映射</code></pre><p>( * ) 构建响应报文 : 显式分类, 魔法分类, 协商分类来标记MIME类型. 或者重定向等</p><p>( * ) 发送响应报文</p><p>( * ) 记录日志</p><h2 id="http服务器程序"><a href="#http服务器程序" class="headerlink" title="http服务器程序"></a>http服务器程序</h2><p>先来数数常见的Web服务器程序吧, 最常见的http服务器程序就是: <strong>httpd(apache), Nginx, Lighttpd</strong> 第三个你可能没有听说过, 其实这也是我第一次听说, 这个玩意是德国开发的, 据说和Nginx的性能不相上下, 但是社区的活跃程度远远比不上Nginx.</p><p>上面的这三个服务器都是静态资源服务器, 在不借助组件的情况下, 只能处理静态资源. 除他们之外, 还有一些应用程序服务器, 这些服务器本身就有作为静态资源服务器的能力, 还可以进行动态资源的处理, 比如:IIS; tomcat, jetty, jboss, resin, webshpere, weblogic, oc4j. 最火的应该就是tomcat和jetty了.</p><p>httpd, 关于其Apache这个名字是有个历史的. 据说这个应用程序是美国的一个信息部为了开发一个完整的Web服务器软件而召集了很多技术优秀的工程师, 这些工程师在做完项目之后就都散到了各个互联网公司中, 但是由于对自己过去的这一个项目怀有感情, 所以就自发的在网上建立起了这个httpd项目, 大家一起维护, 做优化, 打补丁,打补丁, 一直打补丁. 所以就有人说这个httpd服务器是个: <code>a patchy server</code> &#x3D;&#x3D; <code>apache</code>. 这也就是apache的名字由来.</p><p>后来Apache占用的市场份额越来越大, 于是成立了Apache软件基金会, 也就是ASF.</p><p>现在就把目光聚集到今天的主角: httpd身上吧. 先来说说他的几个特性.</p><h2 id="httpd"><a href="#httpd" class="headerlink" title="httpd"></a>httpd</h2><p>httpd的几个特性:</p><ul><li>高度模块化, core + modules</li><li>支持DSO(动态共享对象)</li><li>MPM: 多路处理模块, 实现不同的结构模型<ul><li>prefork: 多进程模型, 每个进程响应一个请求. 一个主进程生成多个子进程, 子进程也被称为工作进程, 每个子进程处理一个用户请求, 即使没有用户请求, 也会预先生成几个空闲线程, 随时等待请求到达, 最大不能超过1024个. 但是这种模型主要是早期所采用的. 现在在高并发场景中几乎不再使用, 因为消耗的时间过长, 效率不高.</li><li>worker: 多线程模型 ( 多进程生成, 一个进程生成多个线程 ) 一个线程响应一个请求, 对于Linux而言, 这个模型的性能提升倒没有prefork多.</li><li>event: 事件驱动模型, 一个线程响应多个请求</li></ul></li></ul><p>现在就来看看如何进行httpd的安装和配置吧.</p><p>对于CentOS6和CentOS7来说, rpm包安装的httpd版本是不一样的, 在CentOS6上安装的是2.2版本, 而CentOS7上安装得是2.4版本. 一般我们有两种安装方式对嘛, rpm和编译安装. httpd相比其他的程序, 编译安装较为常见, 这是因为rpm安装的可能会缺少我们所希望的功能.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># rpm -qc httpd</span></span><br><span class="line">/etc/httpd/conf.d/autoindex.conf</span><br><span class="line">/etc/httpd/conf.d/userdir.conf</span><br><span class="line">/etc/httpd/conf.d/welcome.conf</span><br><span class="line">/etc/httpd/conf.modules.d/00-base.conf</span><br><span class="line">/etc/httpd/conf.modules.d/00-dav.conf</span><br><span class="line">/etc/httpd/conf.modules.d/00-lua.conf</span><br><span class="line">/etc/httpd/conf.modules.d/00-mpm.conf</span><br><span class="line">/etc/httpd/conf.modules.d/00-proxy.conf</span><br><span class="line">/etc/httpd/conf.modules.d/00-systemd.conf</span><br><span class="line">/etc/httpd/conf.modules.d/01-cgi.conf</span><br><span class="line">/etc/httpd/conf/httpd.conf</span><br><span class="line">/etc/httpd/conf/magic</span><br><span class="line">/etc/logrotate.d/httpd</span><br><span class="line">/etc/sysconfig/htcacheclean</span><br><span class="line">/etc/sysconfig/httpd</span><br></pre></td></tr></table></figure><p>他的主配置文件是<code>/etc/httpd/conf/httpd.conf</code> 以及在<code>/etc/httpd/conf.d/*.conf</code> 的种种子配置文件.</p><p>上面的结果是CentOS7上实现的 ,想到版本不一致, 我们还是分版本来说这个吧.</p><h3 id="CentOS6上的httpd-2-2"><a href="#CentOS6上的httpd-2-2" class="headerlink" title="CentOS6上的httpd 2.2"></a>CentOS6上的httpd 2.2</h3><p>我们再使用rpm来查看一下他的httpd启动程序:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpm -ql httpd | grep bin</span></span><br><span class="line">/usr/sbin/apachectl</span><br><span class="line">/usr/sbin/htcacheclean</span><br><span class="line">/usr/sbin/httpd</span><br><span class="line">/usr/sbin/httpd.event</span><br><span class="line">/usr/sbin/httpd.worker</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>注意到这里的后缀名, 这就是可以根据具体的业务情况来选择不同模型的 如果是编译的时候只能选择其中一个, 默认选择的是prefork.</p><p>而服务脚本所在:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -l /etc/rc.d/init.d/httpd</span></span><br><span class="line">-rwxr-xr-x. 1 root root 3371 Dec  9  2011 /etc/rc.d/init.d/httpd</span><br><span class="line"><span class="comment"># 该脚本的配置文件是</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -l /etc/sysconfig/httpd </span></span><br><span class="line">-rw-r--r--. 1 root root 947 Feb  9  2010 /etc/sysconfig/httpd</span><br></pre></td></tr></table></figure><p>日志文件在:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -l /var/log/httpd/</span></span><br><span class="line">total 0</span><br></pre></td></tr></table></figure><p>httpd的日志记录有两种: <code>access_log</code> 访问日志 以及 <code>error_log</code> 错误日志</p><p>最重要的一个目录当属站点文档目录了: <code>/var/www/html</code> </p><p>来看一下他的配置文件的组成:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost html]<span class="comment"># grep &quot;Section&quot; /etc/httpd/conf/httpd.conf</span></span><br><span class="line"><span class="comment">### Section 1: Global Environment</span></span><br><span class="line"><span class="comment">### Section 2: &#x27;Main&#x27; server configuration</span></span><br><span class="line"><span class="comment">### Section 3: Virtual Hosts</span></span><br></pre></td></tr></table></figure><p>一共有三段, 第一段就是全局的配置, 也就是类似日志记录位置, 程序配置等等, 后面两个一般不会一起使用, 一个是定义主服务器的文档根位置等一些设定, 而如果想要一台主机提供多个站点的话, 就需要配置第三个虚拟主机的配置.</p><p>默认的配置格式就是: <code>directive value</code> 前者不区分字母大小写, 后者作为路径时, 取决于文件系统.</p><p>接下来我们走进配置文件里面看看, 先备份一个:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]<span class="comment"># cp httpd.conf&#123;,.bak&#125;</span></span><br><span class="line"><span class="comment"># 有没有感受到bash的神奇力量hhh</span></span><br></pre></td></tr></table></figure><p>接下来就可以放心的进去了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Listen: Allows you to bind Apache to specific IP addresses and/or</span></span><br><span class="line"><span class="comment"># ports, in addition to the default. See also the &lt;VirtualHost&gt;</span></span><br><span class="line"><span class="comment"># directive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Change this to Listen on specific IP addresses as shown below to </span></span><br><span class="line"><span class="comment"># prevent Apache from glomming onto all bound IP addresses (0.0.0.0)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#Listen 12.34.56.78:80</span></span><br><span class="line">Listen 80</span><br></pre></td></tr></table></figure><p>这应该是最基本的配置了把, 这个listen指令可以出现多次, 不指定ip就表示所有IP.</p><p>另一个常用的配置就是持久连接(Persistent Connection), 建立连接, 每个资源获取完成之后不会断开连接, 而是等待其他的请求完成. 那么如何才断开呢? 首先就是数量的限制: 默认是100个资源, 还有时间限制: 这个可配置(建议不配置的太大, 2s-15s都有的, 对于并发访问较大的网站来说, 这个应该设置的小一点甚至关闭[因为可能会有用户得不到服务]) httpd2.4已经支持毫秒级的配置了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># KeepAlive: Whether or not to allow persistent connections (more than</span></span><br><span class="line"><span class="comment"># one request per connection). Set to &quot;Off&quot; to deactivate.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">KeepAlive Off</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># MaxKeepAliveRequests: The maximum number of requests to allow</span></span><br><span class="line"><span class="comment"># during a persistent connection. Set to 0 to allow an unlimited amount.</span></span><br><span class="line"><span class="comment"># We recommend you leave this number high, for maximum performance.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">MaxKeepAliveRequests 100</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># KeepAliveTimeout: Number of seconds to wait for the next request from the</span></span><br><span class="line"><span class="comment"># same client on the same connection.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">KeepAliveTimeout 15</span><br></pre></td></tr></table></figure><p>这些就是持久连接的设置, 如果上面没有启动, 下面的两个参数就不会起到作用.</p><p>接下来我们可以做个试验, 使用telnet进行请求:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]<span class="comment"># telnet 192.168.206.132 80</span></span><br><span class="line">Trying 192.168.206.132...</span><br><span class="line">Connected to 192.168.206.132.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 192.168.206.132</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着你就会收到一大堆的文本信息, 这个就是HTTP响应报文:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 403 Forbidden</span><br><span class="line">Date: Sat, 19 Aug 2017 00:54:48 GMT</span><br><span class="line">Server: Apache/2.2.15 (CentOS)</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 5039</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD XHTML 1.1//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;</span>&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;title&gt;Apache HTTP Server Test Page powered by CentOS&lt;/title&gt;</span><br><span class="line">...(omitted)</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure><p>一个请求对应着一个连接, 请求处理完了. 链接就会close掉. 如果这个时候我们把上面的持久连接打开, 就可以持续发送请求, 直到你不动他到超时时间到.</p><p>接下来我们说之前说过的MPM, 多路处理模块. 这个其实有十几种, 这是为了满足不同的操作系统, 每个操作系统对于这个的支持是不一样的. 一次编译只能编译一个模块, 而rpm为了不同模式的支持, 就提供了三个二进制的. 默认就是prefork模型. 我们说过httpd的模块是动态的, 所以我们可以查看当前编译进核心的模块有哪些:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]<span class="comment"># httpd -l</span></span><br><span class="line">Compiled <span class="keyword">in</span> modules:</span><br><span class="line">  core.c</span><br><span class="line">  prefork.c</span><br><span class="line">  http_core.c</span><br><span class="line">  mod_so.c</span><br></pre></td></tr></table></figure><p>剩余的功能可以动态的加载进去, 我们来查看所有加载的模块:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]<span class="comment"># httpd -M</span></span><br><span class="line">Loaded Modules:</span><br><span class="line"> core_module (static)</span><br><span class="line"> mpm_prefork_module (static)</span><br><span class="line"> http_module (static)</span><br><span class="line"> so_module (static)</span><br><span class="line"> auth_basic_module (shared)</span><br><span class="line">...(omitted)</span><br><span class="line"> proxy_http_module (shared)</span><br><span class="line"> proxy_ajp_module (shared)</span><br><span class="line"> proxy_connect_module (shared)</span><br><span class="line"> cache_module (shared)</span><br><span class="line"> suexec_module (shared)</span><br><span class="line"> disk_cache_module (shared)</span><br><span class="line"> cgi_module (shared)</span><br><span class="line"> version_module (shared)</span><br><span class="line"> dnssd_module (shared)</span><br><span class="line">Syntax OK</span><br></pre></td></tr></table></figure><p>如果想要更换使用的httpd模式, 就在脚本文件里进行编辑就好:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]<span class="comment"># cat /etc/sysconfig/httpd </span></span><br><span class="line"><span class="comment"># Configuration file for the httpd service.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default processing model (MPM) is the process-based</span></span><br><span class="line"><span class="comment"># &#x27;prefork&#x27; model.  A thread-based model, &#x27;worker&#x27;, is also</span></span><br><span class="line"><span class="comment"># available, but does not work with some modules (such as PHP).</span></span><br><span class="line"><span class="comment"># The service must be stopped before changing this variable.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#HTTPD=/usr/sbin/httpd.worker</span></span><br><span class="line">HTTPD=/usr/sbin/httpd.XXXX</span><br></pre></td></tr></table></figure><p>这样就行了. 重新restart之后就会起效果了.</p><p>配置文件里还提供了条件方式装载不同的MPM:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prefork MPM</span></span><br><span class="line"><span class="comment"># StartServers: number of server processes to start</span></span><br><span class="line"><span class="comment"># MinSpareServers: minimum number of server processes which are kept spare</span></span><br><span class="line"><span class="comment"># MaxSpareServers: maximum number of server processes which are kept spare</span></span><br><span class="line"><span class="comment"># ServerLimit: maximum value for MaxClients for the lifetime of the server</span></span><br><span class="line"><span class="comment"># MaxClients: maximum number of server processes allowed to start</span></span><br><span class="line"><span class="comment"># MaxRequestsPerChild: maximum number of requests a server process serves</span></span><br><span class="line">&lt;IfModule prefork.c&gt;</span><br><span class="line">StartServers       8 <span class="comment"># 子进程数量</span></span><br><span class="line">MinSpareServers    5 <span class="comment"># 最小空闲进程数</span></span><br><span class="line">MaxSpareServers   20 <span class="comment"># 最大空闲进程数</span></span><br><span class="line">ServerLimit      256 <span class="comment"># 为MaxClient提供的最大服务器数量 &gt;= MaxClient</span></span><br><span class="line">MaxClients       256 <span class="comment"># 最大客户端请求</span></span><br><span class="line">MaxRequestsPerChild  4000 <span class="comment"># 子进程的最大处理量</span></span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># worker MPM</span></span><br><span class="line"><span class="comment"># StartServers: initial number of server processes to start</span></span><br><span class="line"><span class="comment"># MaxClients: maximum number of simultaneous client connections</span></span><br><span class="line"><span class="comment"># MinSpareThreads: minimum number of worker threads which are kept spare</span></span><br><span class="line"><span class="comment"># MaxSpareThreads: maximum number of worker threads which are kept spare</span></span><br><span class="line"><span class="comment"># ThreadsPerChild: constant number of worker threads in each server process</span></span><br><span class="line"><span class="comment"># MaxRequestsPerChild: maximum number of requests a server process serves</span></span><br><span class="line">&lt;IfModule worker.c&gt;</span><br><span class="line">StartServers         4 <span class="comment"># 请注意这里 服务器启动时启动的进程数量</span></span><br><span class="line">MaxClients         300</span><br><span class="line">MinSpareThreads     25 </span><br><span class="line">MaxSpareThreads     75 <span class="comment"># 请注意这里 最大空闲线程</span></span><br><span class="line">ThreadsPerChild     25 <span class="comment"># 请注意这里 每个子进程的线程数 4 * 25 = 100, 但是75 &lt; 100, so kill one child. ( 脑残一般的设定</span></span><br><span class="line">MaxRequestsPerChild  0</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><p>当然, httpd的命令要随着httpd的启动方式来决定.</p><p>httpd还有DSO的支持, 也就是动态的共享对象. 在<code>/usr/lib64/httpd/modules</code>这个目录下 大多数模块都在这里, 这些模块都是可以使用指令模块加载的:</p><p><code>LoadModule  &lt;mod_name&gt; &lt;mod_path&gt;</code> 这里的路径是相对于ServerRoot而言的.</p><p>可以进配置文件进行查看.</p><p>ServerRoot下的模块目录其实就是刚刚说的软件连接:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]<span class="comment"># ls  -l /etc/httpd/modules</span></span><br><span class="line">lrwxrwxrwx. 1 root root 29 Dec 16  2011 /etc/httpd/modules -&gt; ../../usr/lib64/httpd/modules</span><br></pre></td></tr></table></figure><p>那么简单看完了配置, 我们来定义server文档页面的路径吧.</p><p><code>DocumentRoot &quot;/var/www/html&quot;</code> 这个就是文档的根, 所以我们在url中的<code>/</code> 就是这个目录了.</p><p>注意一点, 这里的目录的权限是直接影响到用户的访问的.</p><p>httpd的访问控制有两种模式 , 一种就是基于文件系统目录结构的, 一种就是基于URL的 .而访问控制机制其实无非就是来源地址, 账号啥的.</p><p>我们来试试这个访问控制功能吧</p><ul><li><p>Options 定义用户访问此目录下的资源的选项 </p><ul><li><pre><code class="bash"># Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;,# or any combination of:#   Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews## Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot;# doesn&#39;t give it to you.## The Options directive is both complicated and important.  Please see# http://httpd.apache.org/docs/2.2/mod/core.html#options# for more information.#    Options Indexes FollowSymLinks<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * 设置的这两项就是最常见的两项, 一种就是访问根的时候(/), 默认返回的资源(Index). 其实这个选项十分危险, 但是如果是用作下载站之类的话, 这个倒是一个不错的选项. 而FollowSymLinks的意义就是跟踪符号链接, 如果你的目录下有一个符号链接,这个选项会进行跟踪并将其视作连接后的文件.</span><br><span class="line"></span><br><span class="line">* 接着还有一个选项是`AllowOverride` 此选项是说, 是否覆盖当前目录下的.htaccess文件的访问控制. .htaccess可以实现对单个目录的访问控制(一个目录一个隐藏文件.htaccess, 但是这种方式极度消耗资源)</span><br><span class="line"></span><br><span class="line">* 基于来源地址的访问控制机制:</span><br><span class="line"></span><br><span class="line">  * Order: 检查次序, 可以理解黑名单和白名单的转换</span><br><span class="line">    * Allow from + IP地址|网络地址&#123;172.16|172.16.0.0|172.16.0.0/16|172.16.0.0/255.255.0.0&#125;|FQDN</span><br><span class="line">    * Deny from </span><br><span class="line"></span><br><span class="line">这些说完了, 我们再来看一下重要的日志,  httpd的日志配置选项还是很标准的:</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"># ErrorLog: The location of the error log file.</span><br><span class="line"># If you do not specify an ErrorLog directive within a &lt;VirtualHost&gt;</span><br><span class="line"># container, error messages relating to that virtual host will be</span><br><span class="line"># logged here.  If you *do* define an error logfile for a &lt;VirtualHost&gt;</span><br><span class="line"># container, that host&#x27;s errors will be logged there and not here.</span><br><span class="line">#</span><br><span class="line">ErrorLog logs/error_log</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># LogLevel: Control the number of messages logged to the error_log.</span><br><span class="line"># Possible values include: debug, info, notice, warn, error, crit,</span><br><span class="line"># alert, emerg.</span><br><span class="line">#</span><br><span class="line">LogLevel warn</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>接着注意到有很多<code>CustomLog</code>但是有很多都被注释了, 只开启了一个:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#CustomLog logs/access_log common</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you would like to have separate agent and referer logfiles, uncomment</span></span><br><span class="line"><span class="comment"># the following directives.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#CustomLog logs/referer_log referer</span></span><br><span class="line"><span class="comment">#CustomLog logs/agent_log agent</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For a single logfile with access, agent, and referer information</span></span><br><span class="line"><span class="comment"># (Combined Logfile Format), use the following directive:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">CustomLog logs/access_log combined</span><br></pre></td></tr></table></figure><p>后面的combined是在定义日志格式的, 你会在上面看到:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LogFormat <span class="string">&quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot;&quot;</span> combined</span><br><span class="line">LogFormat <span class="string">&quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b&quot;</span> common</span><br><span class="line">LogFormat <span class="string">&quot;%&#123;Referer&#125;i -&gt; %U&quot;</span> referer</span><br><span class="line">LogFormat <span class="string">&quot;%&#123;User-agent&#125;i&quot;</span> agent</span><br></pre></td></tr></table></figure><p>有多种格式, 你也可以来自定义. 日志对于服务器来说非常重要, 因此来看看常见的日志format string:</p><ul><li>%h remote host 远程主机的IP地址</li><li>%l 远程的登录名, 一般是空(-)</li><li>%u 远程登录的用户账号</li><li>%t 服务端收到请求的时间</li><li>%r 请求报文的首行信息(method url version)</li><li>%&gt;s 响应状态码</li><li>%b 响应报文的大小(不包含首部, 只有主体)</li><li>%{Referer}i: 请求报文中的”Referer”首部的值</li></ul><p>httpd还可以进行别名的设置, 就是说, 当你访问对应的位置的时候, 能够进行别的目录映射 就是这个意思:</p><p>DocumentRoot “&#x2F;www&#x2F;htdocs”</p><p>那么访问: <a href="http://yaoxuannn.com/index.html">http://yaoxuannn.com/index.html</a> –&gt; &#x2F;www&#x2F;htdocs&#x2F;index.html</p><p>如果设置了别名(Alias), 比如:</p><p>Alias &#x2F;bbs&#x2F; “&#x2F;forum&#x2F;bbs&#x2F;“</p><p>那么访问: <a href="http://yaoxuannn.com/bbs/index.php">http://yaoxuannn.com/bbs/index.php</a> –&gt; &#x2F;forum&#x2F;bbs&#x2F;index.php 了</p><p>上面说过了基于来源地址的访问控制, 现在我们来补充一下基于用户的访问控制, 其实这个访问控制方式就是进行我们熟悉的401质询, 请求用户输入账号和密码 关于这个认证的过程就省略了, 因为太简单了. 关于认证类型有两种: 明文(basic)和消息摘要(digest-MD5)  一般还是会选择basic方式, 虽然这么说…现在也没有谁会使用这种认证了.所以不细说了, 直接过一遍过程就行了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost htdocs]<span class="comment"># htpasswd -cm /etc/httpd/conf.d/.htpasswd justin</span></span><br><span class="line">New password: </span><br><span class="line">Re-<span class="built_in">type</span> new password: </span><br><span class="line">Adding password <span class="keyword">for</span> user justin</span><br><span class="line">[root@localhost htdocs]<span class="comment"># tail /etc/httpd/conf.d/.htpasswd </span></span><br><span class="line">justin:$apr1$ce77yxIr<span class="variable">$GLPzKPK8BOdCpBKAwA0VY0</span></span><br><span class="line">---------</span><br><span class="line">    AuthType Basic</span><br><span class="line">    AuthName <span class="string">&quot;Admin&quot;</span></span><br><span class="line">    AuthUserFile <span class="string">&quot;/etc/httpd/conf.d/.htpasswd&quot;</span></span><br><span class="line">    Require valid-user</span><br><span class="line"></span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line">----------</span><br></pre></td></tr></table></figure><p>接下来就剩一个虚拟主机的配置了. </p><p>对于httpd来说有三种实现方案:</p><ul><li>基于IP实现, (不太常用)</li><li>基于端口实现, (不常用)</li><li>基于主机实现, (使用较多)</li></ul><p>其实也可以混合使用. 一般情况下, 我们都会禁用掉中心主机才使用虚拟主机. 一个虚拟主机都有专门的配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost <span class="string">&quot;IP:PORT&quot;</span>&gt;</span><br><span class="line">ServerName</span><br><span class="line">DocumentRoot <span class="string">&quot;&quot;</span></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>大多数用于中心主机的配置都可以使用, 配置起来也很简单, 就不说了</p><blockquote><p>curl工具简明使用说明</p><p>这个curl可是很有名的, 功能很强大, 支持多种协议, 支持各种HTTP方法, 支持各种认证, 支持管道, 支持代理, 支持断点续传, 甚至支持IPv6. </p><p><code>curl [options][URL...]</code> </p><p>他的常用选项有这些:</p><p>-A 指定user-agent 设置用户代理</p><p>-e 指定referer信息</p><p>-H 自定义头部</p><p>-I 仅显示响应报文首部信息</p></blockquote><p>最后再说怎么实现httpd的https:</p><p>我们在之前的文章中扯过了怎么签发证书, 那么现在实现一个https的服务器就很简单了.</p><p>对于rpm安装的httpd, 默认是携带ssl模块的, 所以我们还要先进行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ssl]# yum install mod_ssl</span><br></pre></td></tr></table></figure><p>接着就在&#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;ssl.conf中进行配置就行了.</p><h3 id="CentOS7上的httpd-2-4"><a href="#CentOS7上的httpd-2-4" class="headerlink" title="CentOS7上的httpd 2.4"></a>CentOS7上的httpd 2.4</h3><p>新特性有哪些呢? 新版本的httpd使MPM支持DSO机制, 这样就不需要进行多次编译以得到不同的模式了, 而是按需加载.</p><p>另外支持event MPM, 支持异步读写, 日志级别可以每个目录自定, 表达式分析器得到增强, 支持毫秒级别的keepalive timeout还支持用户自定义变量.</p><p>还有增加了一些新模块: 例如proxy_fcgi, ratelimit, remoteip. </p><p>另外在配置机制上也有更改, 不再支持Order, Allow, Deny.</p><p>在配置文件的分布上, 一共有三个部分:</p><ul><li>主配置&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</li><li>模块配置  &#x2F;etc&#x2F;httpd&#x2F;conf.modules.d&#x2F;*.conf</li><li>辅助配置  &#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;*.conf</li></ul><p>通过修改模块配置文件来动态改变使用的MPM</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoadModule mpm_event_module modules/mod_mpm_event.so</span><br></pre></td></tr></table></figure><p>通过注释和解注释来使用不同的模块.</p><p>对于控制IP和特定主机的访问控制, 可以使用Require关键字来进行:</p><blockquote><p>Require ip ADDR</p><p>Require no ip ADDR</p><p>Require host HOSTNAME</p><p>Require no host HOSTNAME</p></blockquote><p>但是需要注意的是, 这个访问控制需要放在一个单独的容器中执行. 例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;RequireAll&gt;</span><br><span class="line">  Require not ip 192.168.56.1</span><br><span class="line">  Require all granted</span><br><span class="line">&lt;/RequireAll&gt;</span><br></pre></td></tr></table></figure><h2 id="补充-2018-09-07"><a href="#补充-2018-09-07" class="headerlink" title="补充 (2018-09-07)"></a>补充 (2018-09-07)</h2><h3 id="随便扯一下"><a href="#随便扯一下" class="headerlink" title="随便扯一下"></a>随便扯一下</h3><p>在看PHP的相关配置之前, 我们还是先来回忆一下关于LAMP中AMP的概念和一些相关的东西.</p><p>首先是我们的客户端通过HTTP协议的请求发送到我们的HTTP服务器, 然后我们的服务器通过CGI协议访问到和后台的应用服务器, 也就&#x2F;是我们的PHP应用程序. 接着根据我们的应用代码, 通过应用程序的mysql协议或者说是驱动连接到我们后方的mysqld守护进程. </p><p>另外我们说httpd支持多种运行模式: prefork, event, worker. 而第一个prefork, 我们所使用的PHP模块叫做<code>libphp5.so</code>. 后面的两个所使用的叫做: <code>libphp5-zts.so</code>.</p><p>一般我们都可以通过使用PHP加速器来加速我们的执行过程, 常见的几种PHP加速器有: APC, eAccelerator, Xcache.</p><p>就这样随便说一下吧, 接下来就来看看PHP的一些配置吧.</p><h3 id="PHP的配置"><a href="#PHP的配置" class="headerlink" title="PHP的配置"></a>PHP的配置</h3><p>php的配置文件, 位置在<code>/etc/php.ini</code>和<code>/etc/php.d/*.ini</code>. </p><p>官方关于配置文件的写法在<a href="http://www.php.net/manual/zh/configuration.file.php">这里</a>. </p><p>需要说明的一个: <strong>配置文件（php.ini）在 PHP 启动时被读取。对于服务器模块版本的 PHP，仅在 web 服务器启动时读取一次。对于 CGI 和 CLI 版本，每次调用都会读取</strong>.</p><p>在配置文件中, 我们可以进行关于是否启用解释器的设定, 是否使用短标签等等很多配置, 这里我们其实没有必要去了解,  大部分的配置其实都和开发人员所写的程序相关联的, 在这个文件中, 你可以直接指定MySQL链接的相关参数, 例如主机 端口, 用户名, 密码等等, 不过这并不是一个好的idea. 因为任何一个有PHP访问权限的用户, 都可以直接通过<code>get_cfg_var()</code>来获得.</p><p>更多比较长的一些配置属性都被丢在了<code>/etc/php.d</code>中, 例如<code>mysql.ini</code>. 里面其实就是配置了一个加载的模块.</p><p>对于PHP的配置, 和具体的业务应用程序关联度比较高, 所以还是到需要用的时候再进行查阅吧.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> http </tag>
            
            <tag> httpd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>套接字基础</title>
      <link href="/2017/09/23/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/09/23/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>套接字基础.</p><span id="more"></span><h2 id="什么是套接字"><a href="#什么是套接字" class="headerlink" title="什么是套接字"></a>什么是套接字</h2><p>我们之前已经知道, 应用程序运行在用户空间, 也可以说称之为是用户进程. 而为了网络通信, 我们的应用程序需要经过TCP&#x2F;IP协议栈的封装和解封装. 这个时候, 应用程序就需要向内核进行申请, 申请什么呢? 就是申请这<strong>套接字</strong>(socket).</p><p>所谓套接字, 其实就是一种IPC的实现机制. IPC的实现机制很多, 什么信号啊, 共享内存啊, 等等. 而socket就是一种实现.主要是允许不同主机(甚至是同一主机)不同进程之间的通信, 从而完成数据交换. </p><p> 一般我们在这里通常进行的都是System Call, 系统调用, 但是这里我们实际上调用的是Socket库的API, 这个API出现在1983年左右, 早期出现在BSD上后来就被广泛是实现在了Linux上的版本上.</p><p>但是我们知道, TCP和UDP的端口是独立的.(都是0-65535)</p><blockquote><p><strong>0号端口是个啥?</strong></p><p>这个问题有趣吧, 一般我们可是接触不到这个端口的.  但它依然是一个合法的端口号.</p><p>这个端口原本是系统保留的, 但是后来在Unix&#x2F;Linux网络编程中, 它成为了一个向系统请求下一个可以使用的端口号的端口号. </p><p>我们来使用Python来做个实验就知道了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]# python3</span><br><span class="line">Python 3.6.1 (default, Jul  9 2017, 05:20:23) </span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-11)] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import socket</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; soc = socket.socket()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; soc.bind((&quot;<span class="number">127.0</span>.<span class="number">0.1</span>&quot;, <span class="number">0</span>))</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; soc.getsockname()</span></span><br><span class="line">(&#x27;127.0.0.1&#x27;, 51043)</span><br></pre></td></tr></table></figure></blockquote><p>套接字也有很多种类的, 有TCP的套接字, UDP的套接字, 也有什么TCP&#x2F;UDP都不走的裸套接字. 而这些就分别叫做<code>SOCK_STREAM, SOCK_DGRAM, SOCK_RAW</code> </p><p>除了这些分类, 我们还将Socket分为了很多Socket Domain: (Socket域) 这是另外一种分类方式, 主要根据其所使用的地址:</p><ul><li><strong>AF_INET</strong>:  Address Family: IPv4</li><li><strong>AF_INET6</strong>: IPv6</li><li><strong>AF_UNIX</strong>: 同一主机上的不同的进程进行通信的时候使用, 效率更佳, 而且不占用协议栈</li></ul><p>每一类套接字都提供两种socket, 也就是我们上面说的TCP和UDP的套接字, 即<strong>流</strong>和<strong>数据报</strong></p><p>接下来我们扯扯一些套接字相关的系统调用吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">socket() 创建一个套接字</span><br><span class="line"><span class="built_in">bind</span>()</span><br><span class="line">listen()</span><br><span class="line">accept()</span><br><span class="line">connect()</span><br><span class="line">write()</span><br><span class="line"><span class="built_in">read</span>()</span><br><span class="line">send()</span><br><span class="line">recv()</span><br><span class="line">sendto()</span><br><span class="line">recvform()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCNA学习&amp;实验-[完结]</title>
      <link href="/2017/09/22/CCNA%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E9%AA%8C-updating/"/>
      <url>/2017/09/22/CCNA%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E9%AA%8C-updating/</url>
      
        <content type="html"><![CDATA[<p>在学习完CCNA前都一直更新, 这份文档的创建时间是17-09-15, 每次更新都将会直接更新文档时间以用于置顶. 另外,这篇文档主要用来记录一些CCNA相关的思科IOS的操作和命令. ( 毕竟我不是学网工的,所以里面的一些看法可能不是很准确 ). 实验的主要参考资料:  CCNA学习指南(7th), 以及乾颐堂CCNA3.0的视频.</p><span id="more"></span><h2 id="大实验环境介绍"><a href="#大实验环境介绍" class="headerlink" title="大实验环境介绍"></a>大实验环境介绍</h2><p>啊, 提到这个实验环境我真的快要疯掉了. 首先先说昨天晚上我一个人在实验室瞎JB搞了几个小时, 终于把GNS3搞好了 ( 你们这个不行啊, 难道就不能配一个一体化的环境?? ) 接着又因为那个蠢CiscoIOU的license搞得焦头烂额. 为什么这个许可文件不能跟着GNS3一起打包啊, 混蛋. 所以又在GayHub上面找到了一个使用Python写的生成器. 最后才解决了这个问题.</p><p><strong>来自未来的补充: 不知道当时的我怎么这么憨…这东西一点也不麻烦啊…</strong></p><p>接着终于配置好了. 你们这个也太吃CPU和内存了吧. 我只是放了三台设备, 连拓扑都没, 光开个机虚拟机的CPU就已经飙到100了, 学习体验极差 (&#x2F;滑稽)  — [虽然如此,不过本人最后还是使用的GNS3…不折腾了]</p><h2 id="初次进入IOS"><a href="#初次进入IOS" class="headerlink" title="初次进入IOS."></a>初次进入IOS.</h2><p>IOS好像都是使用telnet进行的远程连接, 不明白为啥我每次进去都已经是特权模式了, 所谓特权模式其实就有点像sudo的感觉, 命令提示符是井字号**#** 而一般的模式是右尖号**&gt;**. 进入和退出特权模式的指令是<code>enable</code>和<code>disable</code>. 接着先来进行时间和时区的修改吧.</p><h3 id="时间和时区"><a href="#时间和时区" class="headerlink" title="时间和时区"></a>时间和时区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Branch&gt;</span><br><span class="line">Branch&gt;<span class="built_in">enable</span></span><br><span class="line">Password:</span><br><span class="line">Branch<span class="comment">#show clock</span></span><br><span class="line">16:00:51.683 UTC Fri Nov 21 1997</span><br></pre></td></tr></table></figure><p>时间完全不对啊, 我们<strong>先来进行时区的修改</strong>, 因为即使你把时间调整正确了, 但是时区不对那当你进行时区调整的时候时间就又发生变化了.</p><p>首先我们进入配置终端的模式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#configure terminal</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">Branch(config)<span class="comment">#clock timezone BJS +8</span></span><br><span class="line">Nov 21 16:03:33.660: %SYS-6-CLOCKUPDATE: System clock has been updated from 16:03:33 UTC Fri Nov 21 1997 to 00:03:33 BJS Sat Nov 22 1997, configured from console by console.</span><br><span class="line">Branch(config)<span class="comment">#end</span></span><br><span class="line">Nov 21 16:03:57.150: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">Branch<span class="comment">#show clock</span></span><br><span class="line">00:04:03.333 BJS Sat Nov 22 1997</span><br></pre></td></tr></table></figure><p>OK, 接下来来进行时间的调整吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#clock set 13:28:00 15 Sep 2017</span></span><br><span class="line">Sep 15 05:28:00.000: %SYS-6-CLOCKUPDATE: System clock has been updated from 00:04:52 BJS Sat Nov 22 1997 to 13:28:00 BJS Fri Sep 15 2017, configured from console by console.</span><br><span class="line">Branch<span class="comment">#show clock</span></span><br><span class="line">13:28:06.507 BJS Fri Sep 15 2017</span><br></pre></td></tr></table></figure><p>这样就完成了时区的调整.</p><h3 id="第一次的Ping"><a href="#第一次的Ping" class="headerlink" title="第一次的Ping"></a>第一次的Ping</h3><p>实验拓扑: (两台三层路由, 都通过Ethernet0&#x2F;1接口进行连接)</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ping1.png" alt="ping1"></p><p>要做的事情很简单, 打开接口, 设置IP, Ping!</p><p>首先打开HQ的终端:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#configure terminal</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">HQ(config)<span class="comment">#interface e0/1</span></span><br><span class="line">HQ(config-if)<span class="comment">#no shutdown</span></span><br><span class="line">*Sep 15 05:39:15.873: %LINK-3-UPDOWN: Interface Ethernet0/1, changed state to up</span><br><span class="line">*Sep 15 05:39:16.877: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/1, changed state to up</span><br><span class="line">HQ(config-if)<span class="comment">#ip address 192.168.1.2 255.255.255.0</span></span><br><span class="line">HQ(config-if)<span class="comment">#end</span></span><br><span class="line">*Sep 15 05:39:32.875: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><blockquote><p>关于这里的end, 和exit是有区别的, 其中exit可以理解成是返回上级, 而end则是直接退出config菜单.</p></blockquote><p>接着进入Branch的终端, 执行一样的命令但是将IP设置成192.168.1.1:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Branch(config-if)<span class="comment">#ip address 192.168.1.1 255.255.255.0</span></span><br></pre></td></tr></table></figure><p>这样就行了, 开始Ping吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#ping 192.168.1.2</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.1.2, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">.!!!!</span><br><span class="line">Success rate is 80 percent (4/5), round-trip min/avg/max = 5/5/6 ms</span><br></pre></td></tr></table></figure><p>HQ这边:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#ping 192.168.1.1</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.1.1, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 4/5/6 ms</span><br></pre></td></tr></table></figure><p>其中 <strong>!</strong> 表示通, 而 <strong>.</strong> 表示不通.</p><p>这里补充一个<strong>更改主机名</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#configure terminal</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">HQ(config)<span class="comment">#hostname HQ</span></span><br><span class="line">HQ(config)<span class="comment">#hostname Test</span></span><br><span class="line">Test(config)<span class="comment">#hostname HQ</span></span><br><span class="line">HQ(config)<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>另外<strong>设立密码</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#configure terminal</span></span><br><span class="line">HQ(config)<span class="comment">#enable password justin</span></span><br><span class="line">HQ(config)<span class="comment">#end</span></span><br><span class="line">*Sep 15 09:42:58.855: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">HQ<span class="comment">#disable</span></span><br><span class="line">HQ&gt;<span class="built_in">enable</span></span><br><span class="line">Password: <span class="comment"># 输错</span></span><br><span class="line">Password: <span class="comment"># 输错again</span></span><br><span class="line">Password:</span><br><span class="line">HQ<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><strong>设置加密密码</strong>:</p><p>在较旧的机器上, 这个选项可能不会起作用, password是指明文密码, 而加密的密码是secret, 设置方法如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">HQ(config)<span class="comment">#enable password justin</span></span><br><span class="line">HQ(config)<span class="comment">#enable secret justin</span></span><br><span class="line">The <span class="built_in">enable</span> secret you have chosen is the same as your <span class="built_in">enable</span> password.</span><br><span class="line">This is not recommended.  Re-enter the <span class="built_in">enable</span> secret.</span><br><span class="line"></span><br><span class="line">HQ(config)<span class="comment">#enable secret bieber</span></span><br><span class="line">HQ(config)<span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="配置远程管理虚拟线缆"><a href="#配置远程管理虚拟线缆" class="headerlink" title="配置远程管理虚拟线缆"></a>配置远程管理虚拟线缆</h3><p>我们在Branch端进行设置, 接着通过HQ端进行连接 (他们已经是能够Ping通的了)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#configure terminal</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">Branch(config)<span class="comment">#line vty 4</span></span><br><span class="line">Branch(config-line)<span class="comment">#password justin</span></span><br><span class="line">Branch(config-line)<span class="comment">#transport input all</span></span><br><span class="line">Branch(config-line)<span class="comment">#end</span></span><br><span class="line">Branch<span class="comment">#</span></span><br><span class="line">Sep 15 10:28:11.083: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><p>接着转到HQ端:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#telnet 192.168.1.1</span></span><br><span class="line">Trying 192.168.1.1 ... Open</span><br><span class="line"></span><br><span class="line">User Access Verification</span><br><span class="line"></span><br><span class="line">Password:</span><br><span class="line">Branch&gt;</span><br><span class="line">Branch&gt;show tcp brief</span><br><span class="line">TCB       Local Address               Foreign Address             (state)</span><br><span class="line">F5D0FE10  192.168.1.1.23             192.168.1.2.50223           ESTAB</span><br></pre></td></tr></table></figure><h3 id="结束实验前的保存"><a href="#结束实验前的保存" class="headerlink" title="结束实验前的保存"></a>结束实验前的保存</h3><p>正常情况下, 我们正在运行的配置是保存在RAM中的, 所以为了在下一次的时候仍然保留现在运行的配置就是要进行保存, 那么, 保存到哪里呢? 也就是非易失性存储器(NVRAM).  </p><p>可以使用<code>show XX-config</code>来查看各个配置的情况.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#show running-config</span></span><br><span class="line">HQ<span class="comment">#show startup-config</span></span><br></pre></td></tr></table></figure><p>如果先要进行保存, 可以直接进行<code>write</code>操作, 或者使用<code>copy</code>将<code>running-config</code>拷贝到<code>startup-config</code>. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#show clock</span></span><br><span class="line">*18:38:16.862 BJS Fri Sep 15 2017</span><br><span class="line">HQ<span class="comment">#configure terminal</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">HQ(config)<span class="comment">#end</span></span><br><span class="line">HQ<span class="comment">#</span></span><br><span class="line">*Sep 15 10:38:36.749: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">HQ<span class="comment">#show running-config</span></span><br><span class="line">Building configuration...</span><br><span class="line"></span><br><span class="line">Current configuration : 1991 bytes</span><br><span class="line">!</span><br><span class="line">! Last configuration change at 18:38:36 BJS Fri Sep 15 2017</span><br><span class="line">!</span><br><span class="line">HQ<span class="comment">#show startup-config</span></span><br><span class="line">Using 1991 out of 32768 bytes</span><br><span class="line">!</span><br><span class="line">! Last configuration change at 18:37:44 BJS Fri Sep 15 2017</span><br><span class="line">!</span><br><span class="line">HQ<span class="comment">#write</span></span><br><span class="line">Building configuration...</span><br><span class="line">[OK]</span><br><span class="line">HQ<span class="comment">#show startup-config</span></span><br><span class="line">Using 1991 out of 32768 bytes</span><br><span class="line">!</span><br><span class="line">! Last configuration change at 18:38:36 BJS Fri Sep 15 2017</span><br><span class="line">!</span><br></pre></td></tr></table></figure><p>实验时间是18:38, 我们强制写入running-config, 查看时间18:38没问题 ,但是这个时候我们的startup-config就过时了(18:37).执行写入命令, 查看startup-confiig时间, 已被更新.</p><p>事实上, 我们也可以使用<code>copy</code>来进行有方向的拷贝.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#copy running-config startup-config</span></span><br></pre></td></tr></table></figure><p>如果要擦除所有的配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#write erase</span></span><br><span class="line">Erasing the nvram filesystem will remove all configuration files! Continue? [confirm]</span><br><span class="line">[OK]</span><br><span class="line">Erase of nvram: complete</span><br><span class="line">*Sep 15 10:52:17.132: %SYS-7-NV_BLOCK_INIT: Initialized the geometry of nvram</span><br><span class="line">HQ<span class="comment">#show startup-config</span></span><br><span class="line">startup-config is not present</span><br></pre></td></tr></table></figure><p>接着重启设备的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#reload</span></span><br><span class="line">Proceed with reload? [confirm]</span><br><span class="line"></span><br><span class="line">*Sep 15 10:53:59.786: %SYS-5-RELOAD: Reload requested by console. Reload Reason: Reload Command.</span><br><span class="line">unix_reload()</span><br></pre></td></tr></table></figure><p>如果这个时候你没有进行保存:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#reload</span></span><br><span class="line"></span><br><span class="line">System configuration has been modified. Save? [<span class="built_in">yes</span>/no]:</span><br></pre></td></tr></table></figure><p>这个问题的其实就是问你是否进行保存. 看自己了吧.</p><blockquote><p>IOS的中断测试很奇怪, 是<code>CTRL+SHIFT+6</code> 而<code>CTRL+C</code>是指退出到特权模式. </p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>设置旗标</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#config terminal</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">HQ(config)<span class="comment">#banner motd X This is my HQ router! X # 第一种方法</span></span><br><span class="line">HQ(config)<span class="comment">#banner motd X # 第二种方法</span></span><br><span class="line">Enter TEXT message.  End with the character <span class="string">&#x27;X&#x27;</span>.</span><br><span class="line">This is my HQ router!</span><br><span class="line">X</span><br><span class="line">HQ(config)<span class="comment">#end</span></span><br><span class="line">HQ<span class="comment">#</span></span><br><span class="line">*Sep 17 02:22:51.397: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">HQ<span class="comment">#logout</span></span><br><span class="line"><span class="comment"># 当再次建立连接的时候:</span></span><br><span class="line">HQ con0 is now available</span><br><span class="line"></span><br><span class="line">Press RETURN to get started.</span><br><span class="line"></span><br><span class="line">This is my HQ router!</span><br><span class="line"></span><br><span class="line">HQ<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><strong>历史</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#show history</span></span><br><span class="line">  ping 192.168.1.1</span><br><span class="line">  ping 192.168.1.2</span><br><span class="line">  ping 192.168.1.3</span><br><span class="line">  show <span class="built_in">history</span></span><br><span class="line">HQ<span class="comment">#terminal history size 100</span></span><br></pre></td></tr></table></figure><p><strong>终端长度</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#terminal length ?</span></span><br><span class="line">  &lt;0-512&gt;  Number of lines on screen (0 <span class="keyword">for</span> no pausing)</span><br></pre></td></tr></table></figure><p><strong>管道</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#show history | include show # 包含show的</span></span><br><span class="line">  show <span class="built_in">history</span></span><br><span class="line">  show <span class="built_in">history</span></span><br><span class="line">  show <span class="built_in">history</span></span><br><span class="line">  show <span class="built_in">history</span> | include show</span><br><span class="line">HQ<span class="comment">#show history | section conf # 显示所有和conf有关的</span></span><br><span class="line">  configure</span><br><span class="line">  configure</span><br><span class="line">  configure terminal</span><br><span class="line">  configure ter</span><br><span class="line">  show <span class="built_in">history</span> | section conf</span><br></pre></td></tr></table></figure><p><strong>密码加密</strong></p><p>什么意思? 我们刚刚不是使用了secret吗? 请看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#show run</span></span><br><span class="line">...(omitted)</span><br><span class="line"><span class="built_in">enable</span> secret 5 $1$l86G<span class="variable">$JudkPOGyI5PrPlv0</span>/3zeI1</span><br><span class="line"><span class="built_in">enable</span> password justin</span><br><span class="line">...(omitted)</span><br><span class="line">line vty 0</span><br><span class="line"> password justin</span><br><span class="line"> login </span><br></pre></td></tr></table></figure><p>除了我们设置的secret是加了密的, 其他都是明文, 这太危险了 其实只需要一条命令就能解决这种现象:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">HQ(config)<span class="comment">#service password-encryption </span></span><br><span class="line">HQ(config)<span class="comment">#end</span></span><br><span class="line">HQ<span class="comment">#show run</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">enable</span> secret 5 $1$l86G<span class="variable">$JudkPOGyI5PrPlv0</span>/3zeI1</span><br><span class="line"><span class="built_in">enable</span> password 7 0501131C354540</span><br><span class="line">...</span><br><span class="line">line vty 0</span><br><span class="line"> password 7 0705345F5A0017</span><br><span class="line"> login</span><br></pre></td></tr></table></figure><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>查看MAC表: (仅用于交换机[或者说二层设备, 并且这个MAC表是只有二层设备才具有的.])</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Switch<span class="comment">#show mac address-table</span></span><br><span class="line">          Mac Address Table</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">Vlan    Mac Address       Type        Ports</span><br><span class="line">----    -----------       --------    -----</span><br></pre></td></tr></table></figure><p>那么MAC地址表是怎么形成的呢? 默认情况下是通过自动学习(dynamic, 当交换机转发或泛洪以太网帧的时候从源字段提取MAC地址和接口的关联), 另外还有静态的方式.</p><h3 id="路由和主机远程管理交换机"><a href="#路由和主机远程管理交换机" class="headerlink" title="路由和主机远程管理交换机"></a>路由和主机远程管理交换机</h3><p>实验拓扑: </p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/mac2.png" alt="拓扑"></p><p>说明: 这个实验中PC1和Branch其实是同一个设备(但这并不影响我们进行实验, 因为他们都属于数据终端设备, 而交换机属于数据通信设备), 但是PC1我们关闭了路由功能, 而Branch是开启了路由的.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PC1(config)<span class="comment">#no ip routing</span></span><br><span class="line">PC1(config)<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>另外, 我们打开交换机的路由转发:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SW1(config)<span class="comment">#ip routing </span></span><br></pre></td></tr></table></figure><p>下面开始进行环境设置: </p><p>路由器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#conf terminal </span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">Branch(config)<span class="comment">#interface e0/0</span></span><br><span class="line">Branch(config-if)<span class="comment">#no shu</span></span><br><span class="line">*Sep 16 07:50:30.459: %LINK-3-UPDOWN: Interface Ethernet0/0, changed state to up</span><br><span class="line">*Sep 16 07:50:31.468: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/0, changed state to up</span><br><span class="line">Branch(config-if)<span class="comment">#ip address 10.1.10.254 255.255.255.0</span></span><br><span class="line">Branch(config-if)<span class="comment">#end</span></span><br><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 16 07:50:55.772: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><p>主机:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">PC1(config)<span class="comment">#interface e0/1 </span></span><br><span class="line">PC1(config-if)<span class="comment">#no shu </span></span><br><span class="line">*Sep 16 07:51:38.765: %LINK-3-UPDOWN: Interface Ethernet0/1, changed state to up</span><br><span class="line">*Sep 16 07:51:39.774: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/1, changed state to up</span><br><span class="line">PC1(config-if)<span class="comment">#ip address 10.1.10.100 255.255.255.0</span></span><br><span class="line">PC1(config-if)<span class="comment">#exi</span></span><br><span class="line">PC1(config)<span class="comment">#ip default-gateway 10.1.10.254</span></span><br></pre></td></tr></table></figure><p>交换机:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先我们查看一下MAC地址表, 后面的小彩蛋会用到</span></span><br><span class="line">SW1<span class="comment">#show mac address-table </span></span><br><span class="line">          Mac Address Table</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">Vlan    Mac Address       Type        Ports</span><br><span class="line">----    -----------       --------    -----</span><br><span class="line">SW1<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">SW1(config)<span class="comment">#interface vlan 1</span></span><br><span class="line">SW1(config-if)<span class="comment">#no shut</span></span><br><span class="line">SW1(config-if)<span class="comment">#ip address </span></span><br><span class="line">*Sep 16 07:57:12.448: %LINK-3-UPDOWN: Interface Vlan1, changed state to up</span><br><span class="line">*Sep 16 07:57:13.450: %LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan1, changed state to up</span><br><span class="line">SW1(config-if)<span class="comment">#ip address 10.1.10.99 255.255.255.0</span></span><br><span class="line">SW1(config-if)<span class="comment">#exi</span></span><br><span class="line">SW1(config)<span class="comment">#ip default-gateway 10.1.10.254</span></span><br><span class="line">SW1(config)<span class="comment">#end</span></span><br><span class="line">SW1<span class="comment">#</span></span><br><span class="line">*Sep 16 07:57:50.319: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><p>Ping测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#ping 10.1.10.254</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.1.10.254, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">.!!!!</span><br><span class="line">Success rate is 80 percent (4/5), round-trip min/avg/max = 5/5/6 ms</span><br><span class="line">SW1<span class="comment">#ping 10.1.10.100</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.1.10.100, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">.!!!!</span><br><span class="line">Success rate is 80 percent (4/5), round-trip min/avg/max = 2/4/5 ms</span><br></pre></td></tr></table></figure><p>成功, 接下来进行远程telnet:</p><p>主机:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#telnet 10.1.10.99</span></span><br><span class="line">Trying 10.1.10.99 ... Open</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Password required, but none <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">[Connection to 10.1.10.99 closed by foreign host]</span><br></pre></td></tr></table></figure><p>出现了问题. 原来是虚拟线缆的密码没有设置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">SW1(config)<span class="comment">#line vty 0 4</span></span><br><span class="line">SW1(config-line)<span class="comment">#password justin</span></span><br><span class="line">SW1(config-line)<span class="comment">#end</span></span><br><span class="line">SW1<span class="comment">#</span></span><br><span class="line">*Sep 16 08:04:17.977: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><p>再次尝试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#telnet 10.1.10.99</span></span><br><span class="line">Trying 10.1.10.99 ... Open</span><br><span class="line"></span><br><span class="line">User Access Verification</span><br><span class="line"></span><br><span class="line">Password: </span><br><span class="line">SW1&gt;</span><br></pre></td></tr></table></figure><p>使用路由器也能够进行远程管理. 实验结束.</p><p>小彩蛋:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#show mac address-table </span></span><br><span class="line">          Mac Address Table</span><br><span class="line">-------------------------------------------</span><br><span class="line"></span><br><span class="line">Vlan    Mac Address       Type        Ports</span><br><span class="line">----    -----------       --------    -----</span><br><span class="line">   1    aabb.cc00.0100    DYNAMIC     Et0/0</span><br><span class="line">   1    aabb.cc00.0410    DYNAMIC     Et0/1</span><br><span class="line">Total Mac Addresses <span class="keyword">for</span> this criterion: 2</span><br></pre></td></tr></table></figure><p>这个路由表就是在我们进行Ping测试的时候学习到的.</p><p>另外当你远程进入到了设备进行管理的时候, 你可能会发现设置时远端设备没有日志输出, 但是真正被操作的那台会有显示. 这一点也不好, 因为日志可以为我们提供大量有用的信息, 怎么开启呢?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">SW1(config)<span class="comment">#end</span></span><br></pre></td></tr></table></figure><p>另外一边:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*Sep 17 03:58:42.057: %SYS-5-CONFIG_I: Configured from console by vty0 (10.1.10.254)</span><br></pre></td></tr></table></figure><p>现在我们开启:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#terminal monitor </span></span><br><span class="line">SW1<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">SW1(config)<span class="comment">#end</span></span><br><span class="line">SW1<span class="comment">#</span></span><br><span class="line">*Sep 17 03:59:31.949: %SYS-5-CONFIG_I: Configured from console by vty0 (10.1.10.254)</span><br></pre></td></tr></table></figure><h2 id="子网与简单静态路由"><a href="#子网与简单静态路由" class="headerlink" title="子网与简单静态路由"></a>子网与简单静态路由</h2><p>实验拓扑:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/subnet2.png" alt="subnet2"></p><p>和上面一样, 还是先进行IP地址和接口的配置:</p><p>HQ:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">HQ(config)<span class="comment">#inte e0/1</span></span><br><span class="line">HQ(config-if)<span class="comment">#no shut</span></span><br><span class="line">*Sep 17 03:17:47.514: %LINK-3-UPDOWN: Interface Ethernet0/1, changed state to up</span><br><span class="line">*Sep 17 03:17:48.519: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/1, changed state to up</span><br><span class="line">HQ(config-if)<span class="comment">#ip address 192.168.1.1 255.255.255.0 </span></span><br><span class="line">HQ(config-if)<span class="comment">#exi</span></span><br><span class="line">HQ(config)<span class="comment">#inter e0/0</span></span><br><span class="line">HQ(config-if)<span class="comment">#no shut </span></span><br><span class="line">*Sep 17 03:18:13.821: %LINK-3-UPDOWN: Interface Ethernet0/0, changed state to up</span><br><span class="line">*Sep 17 03:18:14.827: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/0, changed state to up</span><br><span class="line">HQ(config-if)<span class="comment">#ip address 10.1.10.23 255.255.255.240 </span></span><br><span class="line">HQ(config-if)<span class="comment">#end                </span></span><br><span class="line">HQ<span class="comment">#</span></span><br><span class="line">*Sep 17 03:19:13.905: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><p>Branch:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">Branch(config)<span class="comment">#inter e0/1</span></span><br><span class="line">Branch(config-if)<span class="comment">#no shut</span></span><br><span class="line">Branch(config-if)<span class="comment">#ip address 192.1</span></span><br><span class="line">*Sep 17 03:20:51.347: %LINK-3-UPDOWN: Interface Ethernet0/1, changed state to up</span><br><span class="line">*Sep 17 03:20:52.349: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/1, changed state to up</span><br><span class="line">Branch(config-if)<span class="comment">#ip address 192.168.1.2 255.255.255.252</span></span><br><span class="line">Branch(config-if)<span class="comment">#exi</span></span><br><span class="line">Branch(config)<span class="comment">#inter e0/0</span></span><br><span class="line">Branch(config-if)<span class="comment">#ip address 172.16.1.100 255.255.255.248</span></span><br><span class="line">Branch(config-if)<span class="comment">#end</span></span><br><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 17 03:22:30.740: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><p>在进行ping测试之前, 先来观察一下双方的路由表:</p><p>HQ:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#show ip rou</span></span><br><span class="line">...(omitted)</span><br><span class="line">      10.0.0.0/8 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        10.1.10.16/28 is directly connected, Ethernet0/0</span><br><span class="line">L        10.1.10.23/32 is directly connected, Ethernet0/0</span><br><span class="line">      192.168.1.0/24 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        192.168.1.0/24 is directly connected, Ethernet0/1</span><br><span class="line">L        192.168.1.1/32 is directly connected, Ethernet0/1</span><br></pre></td></tr></table></figure><p>Branch:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#show ip rou</span></span><br><span class="line">...(omitted)</span><br><span class="line">      172.16.0.0/16 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        172.16.1.96/29 is directly connected, Ethernet0/0</span><br><span class="line">L        172.16.1.100/32 is directly connected, Ethernet0/0</span><br><span class="line">      192.168.1.0/24 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        192.168.1.0/30 is directly connected, Ethernet0/1</span><br><span class="line">L        192.168.1.2/32 is directly connected, Ethernet0/1</span><br></pre></td></tr></table></figure><p>那么, 问题来了, 两台路由器现在可以直接进行通信吗?</p><p>我们来测试一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#ping 192.168.1.2 source e0/1</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.1.2, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">Packet sent with a <span class="built_in">source</span> address of 192.168.1.1 </span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 5/5/5 m</span><br></pre></td></tr></table></figure><p>另外一边:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#ping 192.168.1.1 source e0/1</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.1.1, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">Packet sent with a <span class="built_in">source</span> address of 192.168.1.2 </span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 5/5/5 ms</span><br></pre></td></tr></table></figure><p>尽管他们的子网掩码不同仍然没有问题, 但是双方的e0&#x2F;0(这才是我们所需要的)不能够进行通信, 为了能够使他们通信, 我们可以考虑进行手动增加一条静态路由:</p><p>HQ:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HQ(config)<span class="comment">#ip route 172.16.1.96 255.255.255.248 e0/1 </span></span><br><span class="line">HQ(config)<span class="comment">#end</span></span><br><span class="line">HQ<span class="comment">#</span></span><br><span class="line">*Sep 17 03:33:43.157: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">HQ<span class="comment">#ping 172.16.1.100</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 172.16.1.100, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">.!!!!</span><br><span class="line">Success rate is 80 percent (4/5), round-trip min/avg/max = 6/6/6 ms</span><br></pre></td></tr></table></figure><p>Branch:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#ip route 10.1.10.16 255.255.255.240 e0/1</span></span><br><span class="line">Branch(config)<span class="comment">#end</span></span><br><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 17 03:36:40.131: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">Branch<span class="comment">#ping 10.1.10.23            </span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.1.10.23, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">.!!!!</span><br><span class="line">Success rate is 80 percent (4/5), round-trip min/avg/max = 5/6/8 ms</span><br></pre></td></tr></table></figure><p>现在我们再来观察一下他们的路由:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#show ip route </span></span><br><span class="line">...(omitted)</span><br><span class="line">      10.0.0.0/8 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        10.1.10.16/28 is directly connected, Ethernet0/0</span><br><span class="line">L        10.1.10.23/32 is directly connected, Ethernet0/0</span><br><span class="line">      172.16.0.0/29 is subnetted, 1 subnets</span><br><span class="line">S        172.16.1.96 is directly connected, Ethernet0/1</span><br><span class="line">      192.168.1.0/24 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        192.168.1.0/24 is directly connected, Ethernet0/1</span><br><span class="line">L        192.168.1.1/32 is directly connected, Ethernet0/1</span><br></pre></td></tr></table></figure><p>其中S就是指该路由为静态路由:</p><p>也可以直接指明:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#show ip route static </span></span><br><span class="line">...(omitted)</span><br><span class="line">      10.0.0.0/28 is subnetted, 1 subnets</span><br><span class="line">S        10.1.10.16 is directly connected, Ethernet0/1</span><br></pre></td></tr></table></figure><p>实验结束.</p><p>附赠大礼包:</p><p><strong>报文与分片</strong></p><p>默认的MTU是1500, 我们可以通过查看接口来获得值:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#show inter e0/1</span></span><br><span class="line">Ethernet0/1 is up, line protocol is up </span><br><span class="line">  Hardware is AmdP2, address is aabb.cc00.0110 (bia aabb.cc00.0110)</span><br><span class="line">  Internet address is 192.168.1.1/24</span><br><span class="line">  MTU 1500 bytes, BW 10000 Kbit/sec, DLY 1000 usec, </span><br><span class="line">  ...(omitted)</span><br></pre></td></tr></table></figure><p>另外我们的Branch也是这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#show inter e0/1</span></span><br><span class="line">Ethernet0/1 is up, line protocol is up </span><br><span class="line">  Hardware is AmdP2, address is aabb.cc00.0310 (bia aabb.cc00.0310)</span><br><span class="line">  Internet address is 192.168.1.2/24</span><br><span class="line">  MTU 1500 bytes, BW 10000 Kbit/sec, DLY 1000 usec,</span><br><span class="line">  ...(omitted)</span><br></pre></td></tr></table></figure><p>接下来还是进行熟悉的Ping操作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#ping 192.168.1.1 df-bit </span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.1.1, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">Packet sent with the DF bit <span class="built_in">set</span></span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 5/5/6 ms</span><br></pre></td></tr></table></figure><p>这里添加了一个限定参数, df-bit在命令执行的输出中我们也可以看到有DF的字样, 什么玩意呢这是, DF就是Don’t fragment的意思啦, 也就是不要进行分片. 从上述的结果看不出来什么, 因为发送的报文大小是100bytes, 现在我们发送&gt;1500的报文:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#ping 192.168.1.1 df-bit size 1501</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 1501-byte ICMP Echos to 192.168.1.1, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">Packet sent with the DF bit <span class="built_in">set</span></span><br><span class="line">.....</span><br><span class="line">Success rate is 0 percent (0/5)</span><br></pre></td></tr></table></figure><p>发不过去了.  移除DF标志位:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#ping 192.168.1.1 size 1501       </span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 1501-byte ICMP Echos to 192.168.1.1, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 5/5/6 ms</span><br></pre></td></tr></table></figure><p>顺利发送.</p><p>玩上瘾了, 再来一个子网广播小实验:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#ping 192.168.1.255</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.1.255, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line"></span><br><span class="line">Reply to request 0 from 192.168.1.2, 6 ms</span><br><span class="line">Reply to request 1 from 192.168.1.2, 5 ms</span><br><span class="line">Reply to request 2 from 192.168.1.2, 5 ms</span><br><span class="line">Reply to request 3 from 192.168.1.2, 5 ms</span><br></pre></td></tr></table></figure><p>嘿嘿, 收到了Branch的回信, 接着在试试Branch的那一端:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#ping 192.168.1.155</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.1.155, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">.....</span><br><span class="line">Success rate is 0 percent (0/5)</span><br></pre></td></tr></table></figure><p>咦? 没有人回应? 还记得上面我们特意把他们的子网掩码设置的不同吗, 所以这里的Branch的广播地址应该是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#ping 192.168.1.3</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.1.3, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line"></span><br><span class="line">Reply to request 0 from 192.168.1.1, 4 ms</span><br><span class="line">Reply to request 1 from 192.168.1.1, 5 ms</span><br><span class="line">Reply to request 2 from 192.168.1.1, 4 ms</span><br></pre></td></tr></table></figure><p>这就可以了.</p><h2 id="ARP实验"><a href="#ARP实验" class="headerlink" title="ARP实验"></a>ARP实验</h2><p>实验拓扑和上面一样:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/subnet2.png" alt="subnet2"></p><p>路由的配置保持不变, 现在我们再来实验. 首先我在HQ上做了一点手脚, 现在 先不说 我们再次来进行Ping测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#ping 172.16.1.100</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 172.16.1.100, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">.!!!!</span><br><span class="line">Success rate is 80 percent (4/5), round-trip min/avg/max = 1/4/5 ms</span><br></pre></td></tr></table></figure><p>是通的, 接着我们进行Branch的Ping测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#ping 10.1.10.16</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.1.10.16, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">.....</span><br><span class="line">Success rate is 0 percent (0/5)</span><br></pre></td></tr></table></figure><p>不同了, 但是HQ-&gt;Branch是通的啊. 现在我们查看一下Branch的ARP表:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#sh arp</span></span><br><span class="line">Protocol  Address          Age (min)  Hardware Addr   Type   Interface</span><br><span class="line">Internet  10.1.10.16              0   Incomplete      ARPA   </span><br><span class="line">Internet  172.16.1.100            -   aabb.cc00.0300  ARPA   Ethernet0/0</span><br><span class="line">Internet  192.168.1.1             1   aabb.cc00.0110  ARPA   Ethernet0/1</span><br><span class="line">Internet  192.168.1.2             -   aabb.cc00.0310  ARPA   Ethernet0/1</span><br></pre></td></tr></table></figure><p>我们都知道ARP的作用是做MAC和IPADDR的转换, 尤其是当在这个试验中的直连路由中. 我们明明配置了静态路由, 但是依然没法Ping到10.1.10.16. 原因就出自HQ那一端: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#sh ip interface e0/1</span></span><br><span class="line">Ethernet0/1 is up, line protocol is up</span><br><span class="line">  Internet address is 192.168.1.1/24</span><br><span class="line">  ...(omitted)</span><br><span class="line">  Proxy ARP is disabled</span><br></pre></td></tr></table></figure><p>Proxy ARP被关闭了!这就是为什么Branch无法获得MAC地址, 我们的HQ不告诉他了. 这就是说 事实上路由包括两个部分: <strong>决策</strong>和<strong>执行</strong>. 光有路线还不行, 还需要有行动.</p><p>重新开启e0&#x2F;1接口的代理ARP, Branch就可以通信了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">HQ(config)<span class="comment">#inter e0/1</span></span><br><span class="line">HQ(config-if)<span class="comment">#ip proxy-arp </span></span><br><span class="line">HQ(config-if)<span class="comment">#end</span></span><br></pre></td></tr></table></figure><p>Branch:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#ping 10.1.10.16</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.1.10.16, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">.!!!!</span><br><span class="line">Success rate is 80 percent (4/5), round-trip min/avg/max = 5/5/5 ms</span><br></pre></td></tr></table></figure><p>注意: 第一个包绝对不会通. 另外, 如果你想要实现MAC INCOMLETE的效果, 首先要记得清空Branch的ARP缓存才行.</p><p>同样, 如果现在再次将HQ的代理ARP关闭, Ping测试的结果还是通的. 这就是因为Branch上有ARP的缓存 ( 这个缓存的老化时间特别长 ).</p><p>从这个实验也可以看出, 直接设置出接口的静态路由是有弊端的, 那么更好的方式其实是设置下一跳路由, 这样玩的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#no ip route 10.1.10.16 255.255.255.240</span></span><br></pre></td></tr></table></figure><p>先关闭路由, Ping不通现在. </p><p>接着重写路由, 但这次写成下一跳的形式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#ip route 10.1.10.16 255.255.255.240 192.168.1.1</span></span><br></pre></td></tr></table></figure><p>关闭HQ的代理ARP功能, 清空本地ARP缓存:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HQ<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">HQ(config)<span class="comment">#inter e0/1</span></span><br><span class="line">HQ(config-if)<span class="comment">#no ip proxy-arp </span></span><br><span class="line">HQ(config-if)<span class="comment">#end</span></span><br><span class="line">HQ<span class="comment">#</span></span><br><span class="line">*Sep 17 08:38:08.122: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><p>Branch:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#clear ip arp 10.1.10.16</span></span><br><span class="line">Branch<span class="comment">#sh arp</span></span><br><span class="line">Protocol  Address          Age (min)  Hardware Addr   Type   Interface</span><br><span class="line">Internet  172.16.1.100            -   aabb.cc00.0300  ARPA   Ethernet0/0</span><br><span class="line">Internet  192.168.1.1            23   aabb.cc00.0110  ARPA   Ethernet0/1</span><br><span class="line">Internet  192.168.1.2             -   aabb.cc00.0310  ARPA   Ethernet0/1</span><br></pre></td></tr></table></figure><p>激动人心的时候到了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#ping 10.1.10.16</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.1.10.16, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/4/5 ms</span><br></pre></td></tr></table></figure><p>超级顺畅.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#sh arp</span></span><br><span class="line">Protocol  Address          Age (min)  Hardware Addr   Type   Interface</span><br><span class="line">Internet  172.16.1.100            -   aabb.cc00.0300  ARPA   Ethernet0/0</span><br><span class="line">Internet  192.168.1.1             0   aabb.cc00.0110  ARPA   Ethernet0/1</span><br><span class="line">Internet  192.168.1.2             -   aabb.cc00.0310  ARPA   Ethernet0/1</span><br></pre></td></tr></table></figure><p>ARP解析项也没了, 所以这样的好处还有节约性能. </p><p>另外,为了保险, 其实可以接口和下一跳一起写的. 最后配置的结果就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#ip route 10.1.10.16 255.255.255.240 e0/1 192.168.1.1</span></span><br><span class="line">Branch(config)<span class="comment">#do sh ip rou </span></span><br><span class="line">...(omitted)</span><br><span class="line">      10.0.0.0/28 is subnetted, 1 subnets</span><br><span class="line">S        10.1.10.16 [1/0] via 192.168.1.1, Ethernet0/1</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p><strong>别忘了先把之前的路由删除了啊.</strong> </p><h2 id="静态路由-amp-浮动路由"><a href="#静态路由-amp-浮动路由" class="headerlink" title="静态路由&amp;浮动路由"></a>静态路由&amp;浮动路由</h2><p><strong>默认路由实验</strong>:</p><p>实验拓扑:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/route2.png" alt="route1"></p><p>路由器配置就忽略了, 基本和上面的几个实验的配置没有什么区别.</p><p>现在我们在HQ写一个明细路由(也就是非默认路由).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HQ(config)<span class="comment">#ip route 10.1.10.0 255.255.255.0 e0/1 192.168.1.1</span></span><br></pre></td></tr></table></figure><p>Check一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#sh ip rou</span></span><br><span class="line">...(omitted)</span><br><span class="line">      10.0.0.0/24 is subnetted, 1 subnets</span><br><span class="line">S        10.1.10.0 [1/0] via 192.168.1.1, Ethernet0/1</span><br></pre></td></tr></table></figure><p>接着给Branch配一个默认路由, 默认路由其实就是0.0.0.0&#x2F;0了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">Branch(config)<span class="comment">#ip route 0.0.0.0 0.0.0.0 e0/1</span></span><br><span class="line">%Default route without gateway, <span class="keyword">if</span> not a point-to-point interface, may impact performance</span><br><span class="line">Branch(config)<span class="comment">#no ip route 0.0.0.0 0.0.0.0 e0/1</span></span><br><span class="line">Branch(config)<span class="comment">#ip route 0.0.0.0 0.0.0.0 e0/1 192.168.1.2</span></span><br></pre></td></tr></table></figure><p>上面第一次的设置有警告了, 如果你不在一个点对点网络中, 这样做会影响性能.</p><p>当然了, 总不能所有的包都从一个出口出去了, 这样岂不是会把我们的Branch累死.</p><p>所以最好的方法就是综合设置下一跳和出接口.</p><p>配置完成了, 那么现在我们就来看一下路由表吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#sh ip ro</span></span><br><span class="line">S*    0.0.0.0/0 [1/0] via 192.168.1.2, Ethernet0/1</span><br><span class="line">      10.0.0.0/8 is variably subnetted, 2 subnets, 2 masks</span><br></pre></td></tr></table></figure><p>这个S*是什么呢? 这被称为候选默认路由.</p><p>从这个实验我们引出浮动路由的实验:</p><p><strong>静态默认路由和路由负载均衡的实验</strong></p><p>实验拓扑:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/route4.png" alt="route4"></p><p>( 妈呀, 画图累死了.</p><p>先按照实验拓扑中的状态进行配置.</p><p>我现在配置的越来越熟练了哈哈哈.</p><p>你可以参考下面的配置, 当然是建议自己动手啦~</p><p>PC1 [路由模拟]:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">PC1(config)<span class="comment">#inter e0/1</span></span><br><span class="line">PC1(config-if)<span class="comment">#no sh</span></span><br><span class="line">PC1(config-if)<span class="comment">#ip addr 10.1.</span></span><br><span class="line">*Sep 17 13:33:43.877: %LINK-3-UPDOWN: Interface Ethernet0/1, changed state to up</span><br><span class="line">*Sep 17 13:33:44.882: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/1, changed state to up</span><br><span class="line">PC1(config-if)<span class="comment">#ip addr 10.1.10.100 255.255.255.0</span></span><br><span class="line">PC1(config-if)<span class="comment">#exi</span></span><br><span class="line">PC1(config)<span class="comment">#ip default-gateway 10.1.10.254              </span></span><br><span class="line">PC1(config)<span class="comment">#no ip routing</span></span><br><span class="line">PC1(config)<span class="comment">#end</span></span><br><span class="line">PC1<span class="comment">#</span></span><br><span class="line">*Sep 17 13:34:18.742: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><p>Branch:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">Branch(config)<span class="comment">#inter e0/0</span></span><br><span class="line">Branch(config-if)<span class="comment">#no sh</span></span><br><span class="line">Branch(config-if)<span class="comment">#ip address </span></span><br><span class="line">*Sep 17 13:36:02.132: %LINK-3-UPDOWN: Interface Ethernet0/0, changed state to up</span><br><span class="line">*Sep 17 13:36:03.139: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/0, changed state to up</span><br><span class="line">Branch(config-if)<span class="comment">#ip address 10.1.10.254 255.255.255.0</span></span><br><span class="line">Branch(config-if)<span class="comment">#exi</span></span><br><span class="line">Branch(config)<span class="comment">#inte e0/1</span></span><br><span class="line">Branch(config-if)<span class="comment">#no sh</span></span><br><span class="line">Branch(config-if)<span class="comment">#ip addre 1</span></span><br><span class="line">*Sep 17 13:36:24.959: %LINK-3-UPDOWN: Interface Ethernet0/1, changed state to up</span><br><span class="line">*Sep 17 13:36:25.965: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/1, changed state to up</span><br><span class="line">Branch(config-if)<span class="comment">#ip addre 192.168.1.1 255.255.255.0</span></span><br><span class="line">Branch(config-if)<span class="comment">#exi</span></span><br><span class="line">Branch(config)<span class="comment">#ip route 0.0.0.0 0.0.0.0 e0/1 192.168.1.2</span></span><br><span class="line">Branch(config)<span class="comment">#end</span></span><br><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 17 13:36:36.208: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><p>HQ:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">HQ(config)<span class="comment">#inte e0/1</span></span><br><span class="line">HQ(config-if)<span class="comment">#no sh</span></span><br><span class="line">HQ(config-if)<span class="comment">#ip addr 192.168.1</span></span><br><span class="line">*Sep 17 13:37:21.008: %LINK-3-UPDOWN: Interface Ethernet0/1, changed state to up</span><br><span class="line">*Sep 17 13:37:22.013: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/1, changed state to up</span><br><span class="line">HQ(config-if)<span class="comment">#ip addr 192.168.1.2 255.255.255.0</span></span><br><span class="line">HQ(config-if)<span class="comment">#exi</span></span><br><span class="line">HQ(config)<span class="comment">#inte e0/0</span></span><br><span class="line">HQ(config-if)<span class="comment">#no sh</span></span><br><span class="line">HQ(config-if)<span class="comment">#ip addr </span></span><br><span class="line">*Sep 17 13:37:33.536: %LINK-3-UPDOWN: Interface Ethernet0/0, changed state to up</span><br><span class="line">*Sep 17 13:37:34.537: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/0, changed state to up</span><br><span class="line">HQ(config-if)<span class="comment">#ip addr 172.16.1.1 255.255.255.0</span></span><br><span class="line">HQ(config-if)<span class="comment">#exi</span></span><br><span class="line">HQ(config)<span class="comment">#ip route 0.0.0.0 0.0.0.0 e0/1 192.168.1.1</span></span><br><span class="line">HQ(config)<span class="comment">#end</span></span><br><span class="line">*Sep 17 13:37:53.594: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><p>Server [路由模拟]:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Server<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">Server(config)<span class="comment">#inte e0/0</span></span><br><span class="line">Server(config-if)<span class="comment">#no sh</span></span><br><span class="line">Server(config-if)<span class="comment">#ip address 172.1</span></span><br><span class="line">*Sep 17 13:38:18.541: %LINK-3-UPDOWN: Interface Ethernet0/0, changed state to up</span><br><span class="line">*Sep 17 13:38:19.547: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/0, changed state to up</span><br><span class="line">Server(config-if)<span class="comment">#ip address 172.16.1.2 255.255.255.0</span></span><br><span class="line">Server(config-if)<span class="comment">#exi</span></span><br><span class="line">Server(config)<span class="comment">#no ip routing</span></span><br><span class="line">Server(config)<span class="comment">#ip default-gateway 172.16.1.1</span></span><br><span class="line">Server(config)<span class="comment">#end</span></span><br><span class="line">Server<span class="comment">#</span></span><br><span class="line">*Sep 17 13:38:54.270: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><p>进行Ping测试:</p><p>PC1 –&gt; Server:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 172.16.1.2</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 172.16.1.2, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/2 ms</span><br></pre></td></tr></table></figure><p>Server –&gt; PC1:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Server<span class="comment">#ping 10.1.10.100</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.1.10.100, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 ms</span><br></pre></td></tr></table></figure><p>OK, 他们可以通信了.</p><p>接着上面的来, 我们来实现路由表的负载均衡. 现在我们在Branch和HQ之间加上一根串行线:也就变成了这样</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/route6.png" alt="route6"></p><p>开始配置Branch和HQ之间的serial接口:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">HQ(config)<span class="comment">#inter s2/0</span></span><br><span class="line">HQ(config-if)<span class="comment">#no sh</span></span><br><span class="line">HQ(config-if)<span class="comment">#ip address 200.</span></span><br><span class="line">*Sep 17 14:14:05.632: %LINK-3-UPDOWN: Interface Serial2/0, changed state to up</span><br><span class="line">*Sep 17 14:14:06.633: %LINEPROTO-5-UPDOWN: Line protocol on Interface Serial2/0, changed state to up</span><br><span class="line">HQ(config-if)<span class="comment">#ip address 200.202.100.2 255.255.255.0</span></span><br><span class="line">HQ(config-if)<span class="comment">#end</span></span><br><span class="line">HQ<span class="comment">#ping </span></span><br><span class="line">*Sep 17 14:14:15.225: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">HQ<span class="comment">#ping 200.202.100.1</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 200.202.100.1, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 8/9/10 ms</span><br></pre></td></tr></table></figure><p>Branch同理.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#conf ter </span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">Branch(config)<span class="comment">#ip route 0.0.0.0 0.0.0.0 s2/0</span></span><br><span class="line">Branch(config)<span class="comment">#end</span></span><br><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 17 14:15:14.748: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><p>这一次就没有警告了, 看到没. 查看路由表, 就会看到有两个下一跳. 这就是<strong>路由表的负载均衡</strong> </p><p>并且, 检查arp表, 我们发现, 串行线路是不会有ARP记录的.</p><p><strong>浮动静态路由的实验</strong></p><p>所谓浮动路由, 其实就是管理距离(或者我们说叫优先级吧) , 如果我们吧刚刚设置的serial口的路由距离调的高一些, 就可以实现浮动路由, 也就是使这一条成为备份.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">Branch(config)<span class="comment">#ip route 0.0.0.0 0.0.0.0 s2/0 10</span></span><br><span class="line">Branch(config)<span class="comment">#end</span></span><br><span class="line">Branch<span class="comment">#sh i</span></span><br><span class="line">*Sep 17 14:23:15.496: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">Branch<span class="comment">#sh ip rou</span></span><br><span class="line">S*    0.0.0.0/0 [1/0] via 192.168.1.2, Ethernet0/1</span><br><span class="line">      10.0.0.0/8 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        10.1.10.0/24 is directly connected, Ethernet0/0</span><br><span class="line">L        10.1.10.254/32 is directly connected, Ethernet0/0</span><br><span class="line">      192.168.1.0/24 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        192.168.1.0/24 is directly connected, Ethernet0/1</span><br><span class="line">L        192.168.1.1/32 is directly connected, Ethernet0/1</span><br><span class="line">      200.202.100.0/24 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        200.202.100.0/24 is directly connected, Serial2/0</span><br><span class="line">L        200.202.100.1/32 is directly connected, Serial2/0</span><br><span class="line">Branch<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>看到没, 原本的哪一个默认路由已经看不到了. 测试一下吧:</p><p>首先先给HQ加上路由:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">HQ(config)<span class="comment">#ip route 10.1.10.0 255.255.255.0 s2/0</span></span><br><span class="line">HQ(config)<span class="comment">#end</span></span><br><span class="line">HQ<span class="comment">#</span></span><br><span class="line">*Sep 17 14:25:26.060: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><p>接着, 关闭接口:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">Branch(config)<span class="comment">#inte e0/1 </span></span><br><span class="line">Branch(config-if)<span class="comment">#sh</span></span><br><span class="line">Branch(config-if)<span class="comment">#end</span></span><br><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 17 14:26:19.050: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 17 14:26:20.541: %LINK-5-CHANGED: Interface Ethernet0/1, changed state to administratively down</span><br><span class="line">*Sep 17 14:26:21.545: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/1, changed state to down</span><br></pre></td></tr></table></figure><p>HQ同理: (这说一下, 在我看的视频中讲的是如果你关闭一端的接口, 那么另一端的接口会自动的断掉, 但是模拟器好像并不会做到这一点)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#conf te</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">HQ(config)<span class="comment">#inte e0/1 </span></span><br><span class="line">HQ(config-if)<span class="comment">#sh</span></span><br><span class="line">HQ(config-if)<span class="comment">#end</span></span><br><span class="line">HQ<span class="comment">#</span></span><br><span class="line">*Sep 17 14:26:45.056: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">HQ<span class="comment">#</span></span><br><span class="line">HQ<span class="comment">#</span></span><br><span class="line">*Sep 17 14:26:46.287: %LINK-5-CHANGED: Interface Ethernet0/1, changed state to administratively down</span><br><span class="line">*Sep 17 14:26:47.292: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/1, changed state to down</span><br></pre></td></tr></table></figure><p>现在再使用PC1去Ping Server:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 172.16.1.2</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 172.16.1.2, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 9/9/10 ms</span><br></pre></td></tr></table></figure><p>Server也可和PC1正常通信.</p><p>这个时候查看路由表就可以看到s2&#x2F;0这一条了.</p><p>浮动路由实验结束.</p><p>小彩蛋:</p><p>这个时候如果你进行大量的Ping测试, 会明显看出速率的降低.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 172.16.1.2 repeat 100</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 100, 100-byte ICMP Echos to 172.16.1.2, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">Success rate is 100 percent (100/100), round-trip min/avg/max = 1/1/6 ms</span><br><span class="line">-------关闭接口前后的分割线-----------</span><br><span class="line">PC1<span class="comment">#ping 172.16.1.2 repeat 100</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 100, 100-byte ICMP Echos to 172.16.1.2, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">Success rate is 100 percent (100/100), round-trip min/avg/max = 6/9/12 ms</span><br></pre></td></tr></table></figure><h2 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h2><p><strong>最长匹配原则</strong></p><p>什么是最长匹配原则呢? 其实就是更精确的路由更优先走的意思了, 我们沿用上一次实验的拓扑来进行:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/route6.png" alt="route6"></p><p>在进行实验前, 我将之前关闭的接口重新打开, 接着将HQ的serial路由改成管理距离为10的备用路由. 也就是说现在的Branch和HQ的路由情况如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#sh run | s rou</span></span><br><span class="line">ip route 0.0.0.0 0.0.0.0 Ethernet0/1 192.168.1.2</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 Serial2/0 10</span><br></pre></td></tr></table></figure><p>HQ:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#sh run | s rou</span></span><br><span class="line">ip route 0.0.0.0 0.0.0.0 Ethernet0/1 192.168.1.1</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 Serial2/0 10</span><br></pre></td></tr></table></figure><p>那么现在我们调整Branch端的路由, 增加一条更精确的, 通往黑洞的路由:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#ip route 172.16.1.0 255.255.255.0 null0</span></span><br></pre></td></tr></table></figure><p>接着使用PC1尝试和服务器通信:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 172.16.1.1</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 172.16.1.1, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">UUUUU</span><br><span class="line">Success rate is 0 percent (0/5)</span><br></pre></td></tr></table></figure><p>目标不可达.</p><p>接着我们再给Branch增加一条更更精确的正确路由:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#ip route 172.16.1.1 255.255.255.255 e0/1 192.168.1.2</span></span><br><span class="line">Branch<span class="comment">#sh ip rou sta  </span></span><br><span class="line">S*    0.0.0.0/0 is directly connected, Ethernet0/1</span><br><span class="line">      172.16.0.0/16 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">S        172.16.1.0/24 is directly connected, Null0</span><br><span class="line">S        172.16.1.1/32 [1/0] via 192.168.1.2, Ethernet0/1</span><br></pre></td></tr></table></figure><p>再试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 172.16.1.1</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 172.16.1.1, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/2 ms</span><br></pre></td></tr></table></figure><p>通了, 这就是最长匹配原则.</p><h2 id="VLAN技术"><a href="#VLAN技术" class="headerlink" title="VLAN技术"></a>VLAN技术</h2><p>实验一: 简单vlan的配置, 初次尝试简单vlan划分</p><p>实验拓扑:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vlan1.png" alt="vlan1"></p><p>配置完成之后, 我们查看一下SW1当前的VLAN信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#sh vlan </span></span><br><span class="line"></span><br><span class="line">VLAN Name                             Status    Ports</span><br><span class="line">---- -------------------------------- --------- -------------------------------</span><br><span class="line">1    default                          active    Et0/0, Et0/1, Et0/2, Et0/3</span><br><span class="line">                                                Et1/0, Et1/1, Et1/2, Et1/3</span><br><span class="line">                                                Et2/0, Et2/1, Et2/2, Et2/3</span><br><span class="line">                                                Et3/0, Et3/1, Et3/2, Et3/3</span><br></pre></td></tr></table></figure><p>就是默认的配置, 所有的接口都从VLAN1走, 现在我们尝试创建两个VLAN:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SW1(config)<span class="comment">#vlan 10</span></span><br><span class="line">SW1(config-vlan)<span class="comment">#name 507a</span></span><br><span class="line">SW1(config-vlan)<span class="comment">#vlan 20</span></span><br><span class="line">SW1(config-vlan)<span class="comment">#name 507b</span></span><br></pre></td></tr></table></figure><p>接着划分VLAN(其实把接口划分到VLAN上):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">SW1(config)<span class="comment">#interface range e0/0 -1 </span></span><br><span class="line">SW1(config-if-range)<span class="comment">#switchport mode access</span></span><br><span class="line">SW1(config-if-range)<span class="comment">#switchport access vlan 10</span></span><br></pre></td></tr></table></figure><p>查看一下vlan10的信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#sh vlan id 10</span></span><br><span class="line"></span><br><span class="line">VLAN Name                             Status    Ports</span><br><span class="line">---- -------------------------------- --------- -------------------------------</span><br><span class="line">10   507a                             active    Et0/0, Et0/1</span><br><span class="line">....(omitted)</span><br></pre></td></tr></table></figure><p>测试一下数据包是否是通的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 10.1.10.254</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.1.10.254, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 5/5/6 ms</span><br></pre></td></tr></table></figure><p>实验二: access模式vlan, 交换机之间的vlan划分</p><p>这里使用的交换机都是三层交换机. 继续沿用我们上面的拓扑, 但是稍微升级一下:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vlan2.png" alt="vlan2"></p><p>这里省略PC2的配置, 因为和PC1几乎一样.</p><p>首先我们配置一下SW1的vlan20的模式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">SW1(config)<span class="comment">#int e0/2</span></span><br><span class="line">SW1(config-if)<span class="comment">#switchport mo acc</span></span><br><span class="line">SW1(config-if)<span class="comment">#switchport acc vlan 20 </span></span><br><span class="line">SW1(config-if)<span class="comment">#end</span></span><br><span class="line">SW1<span class="comment">#</span></span><br><span class="line">*Sep 18 12:45:36.057: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><p>接着进入SW2进行相对应的配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SW2(config)<span class="comment">#vlan 10</span></span><br><span class="line">SW2(config-vlan)<span class="comment">#name 507a</span></span><br><span class="line">SW2(config-vlan)<span class="comment">#</span></span><br><span class="line">*Sep 18 12:52:06.159: %CDP-4-NATIVE_VLAN_MISMATCH: Native VLAN mismatch discovered on Ethernet0/2 (1), with SW1 Ethernet0/2 (20).</span><br><span class="line">SW2(config-vlan)<span class="comment">#vlan 20</span></span><br><span class="line">SW2(config-vlan)<span class="comment">#name 507b</span></span><br></pre></td></tr></table></figure><p>这个时候你的SW2开始报错, 其实你的SW1也有报错, 这是说你的本征VLAN不匹配, 就是说你的SW1配置了access, 但是SW2没有.</p><p>那么现在就赶紧配置上吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SW2<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">SW2(config)<span class="comment">#int e0/2</span></span><br><span class="line">SW2(config-if)<span class="comment">#switchport mo acc</span></span><br><span class="line">SW2(config-if)<span class="comment">#switchport acc vlan 20</span></span><br><span class="line">SW2(config-if)<span class="comment">#end</span></span><br></pre></td></tr></table></figure><p>以及别忘了, 我们要把PC2也加入vlan20: [ 这里犯蠢了, 可以直接用range的. ]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SW2(config)<span class="comment">#int e0/1</span></span><br><span class="line">SW2(config-if)<span class="comment">#swi</span></span><br><span class="line">SW2(config-if)<span class="comment">#switchport mode acc</span></span><br><span class="line">SW2(config-if)<span class="comment">#switchport acc vlan 20</span></span><br><span class="line">SW2(config-if)<span class="comment">#end</span></span><br></pre></td></tr></table></figure><p>接着, 我们把SW1的vlan20打开端口, 配置充当网关的IP:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SW1(config)<span class="comment">#int vlan 20</span></span><br><span class="line">SW1(config-if)<span class="comment">#no sh</span></span><br><span class="line">SW1(config-if)<span class="comment">#</span></span><br><span class="line">*Sep 18 13:02:23.072: %LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan20, changed state to down</span><br><span class="line">SW1(config-if)<span class="comment">#ip add</span></span><br><span class="line">*Sep 18 13:02:25.643: %LINK-3-UPDOWN: Interface Vlan20, changed state to up</span><br><span class="line">*Sep 18 13:02:26.650: %LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan20, changed state to up</span><br><span class="line">SW1(config-if)<span class="comment">#ip addr 10.1.20.254 255.255.255.0</span></span><br></pre></td></tr></table></figure><p>接着我们测试连通性:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC2<span class="comment">#ping 10.1.20.254</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.1.20.254, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 5/5/6 ms</span><br></pre></td></tr></table></figure><p><strong>我觉得OK</strong>.</p><p>第三个实验: trunk vlan的实现, 首先要加一个e0&#x2F;3的网线:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vlan3.png" alt="vlan3"></p><p>现在开始配置SW1的trunk:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">SW1(config)<span class="comment">#int range e0/2 -3</span></span><br><span class="line">SW1(config-if-range)<span class="comment">#switch</span></span><br><span class="line">SW1(config-if-range)<span class="comment">#switchport mode trunk</span></span><br><span class="line">Command rejected: An interface whose trunk encapsulation is <span class="string">&quot;Auto&quot;</span> can not be configured to <span class="string">&quot;trunk&quot;</span> mode.</span><br><span class="line">% Range <span class="built_in">command</span> terminated because it failed on Ethernet0/2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>出现了报错, 这个原因是因为我们的e0&#x2F;2端口配置的是access结果进行了自动协商, 所以我们现需要进行手工指定一下封装格式, 接着就不会报错了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SW1(config-if-range)<span class="comment">#switchport trunk encapsulation dot1q </span></span><br><span class="line">SW1(config-if-range)<span class="comment">#switchport mode tru</span></span><br></pre></td></tr></table></figure><p>SW2同理. 配置完成之后 我们查看一下trunk情况:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SW2<span class="comment">#sh int tru</span></span><br><span class="line"></span><br><span class="line">Port        Mode             Encapsulation  Status        Native vlan</span><br><span class="line">Et0/2       on               802.1q         trunking      1</span><br><span class="line">Et0/3       on               802.1q         trunking      1</span><br></pre></td></tr></table></figure><p>两端一样的配置才可以.</p><p>现在, PC2还可以Ping通网关吗?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC2<span class="comment">#ping 10.1.20.254</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.1.20.254, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 ms</span><br></pre></td></tr></table></figure><p>没问题, 经过了trunk的解包, 最后变成和一般的ETH II包相同的头部了. ( 这里感觉说的不对, 现在只是做做实验配置啥的, 下次进行抓包实验就知道了. )</p><p>之所以没有打上VLAN ID, 是因为报文经过了本征VLAN, 其实就是native vlan.</p><p>收到不打tag的包默认只能转给本征VLAN.</p><h2 id="中途休息"><a href="#中途休息" class="headerlink" title="中途休息"></a>中途休息</h2><p>下面一些简单的命令使用记录就是根据CCNA学习指南中第6,7章节所讲述的内容. 其中有一些在一开始的初入IOS中已经记录过了, 所以这里不再赘述.</p><p>实验拓扑没有, 只有一台单独的路由器&#x2F;交换机.</p><p><strong>显示版本, 主机名, 旗标, 密码, 接口描述, 密码</strong>这些都已经说过了, 所以略过.</p><p><strong>SSH的设定</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Router<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">Router(config)<span class="comment">#hostname router </span></span><br><span class="line">router(config)<span class="comment">#ip domain-name yaoxuannn.com</span></span><br><span class="line">router(config)<span class="comment">#username router password justin13wyx</span></span><br><span class="line">router(config)<span class="comment">#crypto key generate rsa general-keys modulus 2048</span></span><br><span class="line">The name <span class="keyword">for</span> the keys will be: router.yaoxuannn.com</span><br><span class="line"></span><br><span class="line">% The key modulus size is 2048 bits</span><br><span class="line">% Generating 2048 bit RSA keys, keys will be non-exportable...</span><br><span class="line">[OK] (elapsed time was 2 seconds)</span><br><span class="line"></span><br><span class="line">router(config)<span class="comment">#</span></span><br><span class="line">*Sep 19 05:01:11.887: %SSH-5-ENABLED: SSH 1.99 has been enabled</span><br><span class="line">router(config)<span class="comment">#line vty 0 4</span></span><br><span class="line">router(config-line)<span class="comment">#transport input ssh telnet</span></span><br></pre></td></tr></table></figure><p>于是, 我一直都没有成功登录. 虽然是连接到了主机, 但是总是密码错误被拒绝. ( 好气</p><p><strong>do</strong>:</p><p>这个其实就像有点像vim等里面的<code>!</code>命令啦. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">IOU1<span class="comment">#sh ip int b   </span></span><br><span class="line">Interface                  IP-Address      OK? Method Status                Protocol</span><br><span class="line">Ethernet0/0                unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Ethernet0/1                192.168.1.2     YES manual up                    up      </span><br><span class="line">Ethernet0/2                unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Ethernet0/3                unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Ethernet1/0                unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Ethernet1/1                unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Ethernet1/2                unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Ethernet1/3                unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Serial2/0                  unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Serial2/1                  unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Serial2/2                  unassigned      YES NVRAM  administratively down down    </span><br><span class="line">          </span><br><span class="line">IOU1<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">IOU1(config)<span class="comment">#sh ip int b</span></span><br><span class="line">                 ^</span><br><span class="line">% Invalid input detected at <span class="string">&#x27;^&#x27;</span> marker.</span><br><span class="line"></span><br><span class="line">IOU1(config)<span class="comment">#do sh ip int b</span></span><br><span class="line">Interface                  IP-Address      OK? Method Status                Protocol</span><br><span class="line">Ethernet0/0                unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Ethernet0/1                192.168.1.2     YES manual up                    up      </span><br><span class="line">Ethernet0/2                unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Ethernet0/3                unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Ethernet1/0                unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Ethernet1/1                unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Ethernet1/2                unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Ethernet1/3                unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Serial2/0                  unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Serial2/1                  unassigned      YES NVRAM  administratively down down    </span><br><span class="line">Serial2/2                  unassigned      YES NVRAM  administratively down down </span><br></pre></td></tr></table></figure><p>查看当前的会话:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Router<span class="comment">#sh users</span></span><br><span class="line">    Line       User       Host(s)              Idle       Location</span><br><span class="line">*  0 con 0                idle                 00:00:00   </span><br><span class="line">   2 vty 0                idle                 00:00:10 192.168.1.2</span><br><span class="line"></span><br><span class="line">  Interface    User               Mode         Idle     Peer Address</span><br></pre></td></tr></table></figure><p>奇怪的是, 我明明使用telnet连接到了远端设备, 但是使用下面的命令似乎一点用都没, 奇怪, 难道是模拟器的缘故, 还是我哪里操作不对?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IOU1<span class="comment">#telnet 192.168.1.1</span></span><br><span class="line">Trying 192.168.1.1 ... Open</span><br><span class="line"></span><br><span class="line">User Access Verification</span><br><span class="line"></span><br><span class="line">Password: </span><br><span class="line">Router&gt;sh sess</span><br><span class="line">% No connections open</span><br></pre></td></tr></table></figure><p>神奇.</p><p><strong>没有想到, 这么快就结束了. 早知道就不设置这个标题了. ( 果然这种实践性的东西看书就是麻烦 )</strong></p><h2 id="VLAN-self"><a href="#VLAN-self" class="headerlink" title="VLAN-self"></a>VLAN-self</h2><p>话说之前一直都没怎么搞定trunk, 本征vlan, access到底是个什么玩意. 于是….我自己设计了一个实验来彻底搞懂他们! ( 所以现在了解了很多, 差不多明白了hhh ) </p><p>实验拓扑如下:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vlan5.png" alt="vlan5"></p><p>现在我们进行一下配置, 主要有: PC{1,2,3,4}的初始化设置, 开启端口, 关闭路由, 设置IP; SW{1,2}对主机的access设置, vlan设置和划分, SW之间的配置(*).</p><p>省略主机的设置, 下面是SW1的配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">SW1(config)<span class="comment">#vlan 10</span></span><br><span class="line">SW1(config-vlan)<span class="comment">#name 507a</span></span><br><span class="line">SW1(config-vlan)<span class="comment">#vlan 20</span></span><br><span class="line">SW1(config-vlan)<span class="comment">#name 507b</span></span><br><span class="line">SW1(config-vlan)<span class="comment">#int e0/1</span></span><br><span class="line">SW1(config-if)<span class="comment">#sw mo acc</span></span><br><span class="line">SW1(config-if)<span class="comment">#sw acc vlan 10</span></span><br><span class="line">SW1(config-if)<span class="comment">#int e0/2</span></span><br><span class="line">SW1(config-if)<span class="comment">#sw mo acc </span></span><br><span class="line">SW1(config-if)<span class="comment">#sw acc vlan 20</span></span><br><span class="line">SW1(config-if)<span class="comment">#end</span></span><br><span class="line">SW1<span class="comment">#</span></span><br><span class="line">*Sep 19 15:08:02.531: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">SW1<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>SW2几乎和SW1一样的配置, 所以也省略了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">SW1(config)<span class="comment">#int e0/0</span></span><br><span class="line">SW1(config-if)<span class="comment">#sw tr en do</span></span><br><span class="line">SW1(config-if)<span class="comment">#sw mo tru</span></span><br><span class="line">SW1(config-if)<span class="comment">#end</span></span><br></pre></td></tr></table></figure><p>同上, SW2也是这样. 现在进行Ping测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 192.168.1.3</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.1.3, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 ms</span><br></pre></td></tr></table></figure><p>现在的状态是, PC1仅仅可以Ping通PC3. PC2仅仅可以Ping通PC4. 原因很简单了, 就是VLAN ID匹配嘛~.</p><p>那么有趣的是, 怎么使得PC2和PC3进行通信, PC1和PC4进行通信呢?</p><p>首先我们如果采用一般的方法肯定是行不通的. 其实这种跨ID的通信, 可以认定为vlan跳跃攻击. 做法其实很简单 , 只要把SW1的本征VLAN配置成SW1一方你想要通信的那个, SW2的本征VLAN配置成你想要SW2那一边通信的一方就行了.</p><p>先不考虑后果, 我们来配一配再试试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 192.168.1.4</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.1.4, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">.....</span><br><span class="line">Success rate is 0 percent (0/5)</span><br></pre></td></tr></table></figure><p>肯定是不通的嘛~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SW1(config)<span class="comment">#int e0/0</span></span><br><span class="line">SW1(config-if)<span class="comment">#sw tr na</span></span><br><span class="line">SW1(config-if)<span class="comment">#sw tr native vlan 10</span></span><br><span class="line">SW1(config-if)<span class="comment">#end</span></span><br></pre></td></tr></table></figure><p>另外一边:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SW2(config)<span class="comment">#int e0/0</span></span><br><span class="line">SW2(config-if)<span class="comment">#sw tr </span></span><br><span class="line">*Sep 19 15:21:23.782: %CDP-4-NATIVE_VLAN_MISMATCH: Native VLAN mismatch discovered on Ethernet0/0 (1), with SW1 Ethernet0/0 (10).</span><br><span class="line">SW2(config-if)<span class="comment">#sw tr na vlan 20</span></span><br><span class="line">SW2(config-if)<span class="comment">#end</span></span><br></pre></td></tr></table></figure><p>刚刚配好SW1的时候你会发现有报错, 也就是本征VLAN不匹配的报错, 不用管它.</p><p>这个报错会一直跟随着你,但是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 192.168.1.4</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.1.4, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">.!!!!</span><br><span class="line">Success rate is 80 percent (4/5), round-trip min/avg/max = 1/1/1 ms</span><br></pre></td></tr></table></figure><p>啊哈哈哈, 竟然通了! 真神奇!</p><p>但是遗憾的是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 192.168.1.3</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.1.3, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">.....</span><br><span class="line">Success rate is 0 percent (0/5)</span><br></pre></td></tr></table></figure><p>咦咦咦? 自己家的东西怎么Ping不通? 其实啊, PC1是可以访问到PC3的, Ping不同的缘故只是因为PC3返回的reply报文携带的vlan10ID被SW1进行了帧过滤到了PC2身上, 接着PC2就把他丢弃了. 这个可以通过进行抓包进行分析. – (注: 这个情况发生的前提条件式PC1有PC3的arp缓存.)</p><p>附: 抓包截图:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vlan5_1.png" alt="vlan5_1"></p><p>而返回的报文中:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vlan5_2.png" alt="vlan5_2"></p><p>根本没有插入携带vlanID帧.</p><p><strong>补充: 本征VLAN其实也是可以打上tag的, 使用下面的命令就可以:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SW1(config)<span class="comment">#vlan dot1q tag native </span></span><br></pre></td></tr></table></figure><h2 id="STP生成树"><a href="#STP生成树" class="headerlink" title="STP生成树"></a>STP生成树</h2><p>  简单的说, 生成树协议是为了避免出现二层设备环路所造成的: 广播风暴, 单点帧拷贝, MAC表不稳定而开发的802.1D协议组. </p><p>( 生成树好烦啊…</p><p>好像我也做不出什么实验, 烦死了 ,随便丢个拓扑图给你:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/stp1.png" alt="stp1"></p><p>这里的SW1和SW2构成了环路. </p><p>你猜一猜, 如果这个时候我用PC1去PingPC2, 是否能通呢?</p><p>实践出真知, 我们来试试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 192.168.1.200            </span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.1.200, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 5/5/6 ms</span><br></pre></td></tr></table></figure><p>没问题!和你想的是否一样呢?</p><p>哈哈哈你是不是觉得就算通了, 其实效率很低呢? 我们再来试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 192.168.1.200 repeat 1000</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 1000, 100-byte ICMP Echos to 192.168.1.200, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">Success rate is 100 percent (1000/1000), round-trip min/avg/max = 1/2/21 ms</span><br></pre></td></tr></table></figure><p>平均2ms, 并没有被拉慢速度. 很神奇吧, 这就是生成树的力量, 我们来看看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#sh spanning-tree vlan 10</span></span><br><span class="line"></span><br><span class="line">VLAN0010</span><br><span class="line">  Spanning tree enabled protocol rstp</span><br><span class="line">  Root ID    Priority    10</span><br><span class="line">             Address     aabb.cc00.0200</span><br><span class="line">             Cost        100</span><br><span class="line">             Port        2 (Ethernet0/1)</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    32778  (priority 32768 sys-id-ext 10)</span><br><span class="line">             Address     aabb.cc00.0100</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time  300 sec</span><br><span class="line"></span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/0               Desg FWD 100       128.1    Shr </span><br><span class="line">Et0/1               Root FWD 100       128.2    Shr </span><br><span class="line">Et0/2               Altn BLK 100       128.3    Shr </span><br></pre></td></tr></table></figure><p>看到没, 生成树机制使得e0&#x2F;2接口处于block状态. 所以才没造成环路! 那么这个接口就不能用了吗? 当然不是, 我们查看一下接口就明白了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#sh ip int b</span></span><br><span class="line">Interface              IP-Address      OK? Method Status                Protocol</span><br><span class="line">Ethernet0/0            unassigned      YES <span class="built_in">unset</span>  up                    up      </span><br><span class="line">Ethernet0/1            unassigned      YES <span class="built_in">unset</span>  up                    up      </span><br><span class="line">Ethernet0/2            unassigned      YES <span class="built_in">unset</span>  up                    up     </span><br></pre></td></tr></table></figure><p>是up的状态.</p><p>所以说这是个逻辑上的block, 而且仅仅适用于vlan10这个环境.</p><p>现在我们强制打开这个端口看看会出现什么现象:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SW1(config-if)<span class="comment">#spanning-tree bpdufilter enable</span></span><br></pre></td></tr></table></figure><p>过一小会而查看一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#sh spanning-tree vlan 10</span></span><br><span class="line"></span><br><span class="line">VLAN0010</span><br><span class="line">  Spanning tree enabled protocol rstp</span><br><span class="line">  Root ID    Priority    10</span><br><span class="line">             Address     aabb.cc00.0200</span><br><span class="line">             Cost        100</span><br><span class="line">             Port        2 (Ethernet0/1)</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    32778  (priority 32768 sys-id-ext 10)</span><br><span class="line">             Address     aabb.cc00.0100</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time  300 sec</span><br><span class="line"></span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/0               Desg FWD 100       128.1    Shr </span><br><span class="line">Et0/1               Root FWD 100       128.2    Shr </span><br><span class="line">Et0/2               Desg LRN 100       128.3    Shr </span><br></pre></td></tr></table></figure><p>接口变成来了LRN状态, 说明正在学习. ( 其实在LRN之前还有一个LIS的状态, 如果你点的快的话或许能看到</p><p>接着三口均为转发状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#sh spanning-tree vlan 10</span></span><br><span class="line"></span><br><span class="line">VLAN0010</span><br><span class="line">  Spanning tree enabled protocol rstp</span><br><span class="line">  Root ID    Priority    10</span><br><span class="line">             Address     aabb.cc00.0200</span><br><span class="line">             Cost        100</span><br><span class="line">             Port        2 (Ethernet0/1)</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    32778  (priority 32768 sys-id-ext 10)</span><br><span class="line">             Address     aabb.cc00.0100</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time  300 sec</span><br><span class="line"></span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/0               Desg FWD 100       128.1    Shr </span><br><span class="line">Et0/1               Root FWD 100       128.2    Shr </span><br><span class="line">Et0/2               Desg FWD 100       128.3    Shr </span><br></pre></td></tr></table></figure><p>再Ping试试: ( 为了实验效果, 请清除arp缓存 )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 192.168.1.200 repeat 100</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 1000, 100-byte ICMP Echos to 192.168.1.200, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">..............!.......................................................</span><br><span class="line">...................</span><br><span class="line">Success rate is 1 percent (1/89), round-trip min/avg/max = 99/99/99 ms</span><br></pre></td></tr></table></figure><p>这个时候查看交换机的CPU, 你会发现会被疯狂占用. 而且其实这个时候, 你的命令敲的已经不是那么顺畅了.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/stp2.png" alt="stp2"></p><p>如果这是真机后果可能会比你想象的严重.</p><p>赶紧变回来吧.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SW1(config-if)<span class="comment">#spanning-tree bpdufilter disable</span></span><br></pre></td></tr></table></figure><h2 id="生成树的调整和实施"><a href="#生成树的调整和实施" class="headerlink" title="生成树的调整和实施"></a>生成树的调整和实施</h2><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/stp1.png" alt="stp1"></p><p>还是这样的拓扑图, 首先我们来切换根桥, 也就是通过调整优先级来实施.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#sh spanning-tree vlan 10</span></span><br><span class="line"></span><br><span class="line">VLAN0010</span><br><span class="line">  Spanning tree enabled protocol rstp</span><br><span class="line">  Root ID    Priority    32778</span><br><span class="line">             Address     aabb.cc00.0100</span><br><span class="line">             This bridge is the root</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    32778  (priority 32768 sys-id-ext 10)</span><br><span class="line">             Address     aabb.cc00.0100</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time  300 sec</span><br><span class="line"></span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/0               Desg FWD 100       128.1    Shr </span><br><span class="line">Et0/1               Desg FWD 100       128.2    Shr </span><br><span class="line">Et0/2               Desg FWD 100       128.3    Shr </span><br></pre></td></tr></table></figure><p>显然现在的根网桥就是SW1这只, 现在我们把它切换到SW2上:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SW2(config)<span class="comment">#spanning-tree vlan 10 priority 0</span></span><br><span class="line">SW2<span class="comment">#sh spanning-tree vlan 10</span></span><br><span class="line"></span><br><span class="line">VLAN0010</span><br><span class="line">  Spanning tree enabled protocol rstp</span><br><span class="line">  Root ID    Priority    10</span><br><span class="line">             Address     aabb.cc00.0200</span><br><span class="line">             This bridge is the root</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    10   (priority 4096 sys-id-ext 10)</span><br><span class="line">             Address     aabb.cc00.0200</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time  300 sec</span><br><span class="line"></span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/0               Desg FWD 100       128.1    Shr </span><br><span class="line">Et0/1               Desg FWD 100       128.2    Shr </span><br><span class="line">Et0/2               Desg FWD 100       128.3    Shr </span><br></pre></td></tr></table></figure><p>很简单吧, 合理的修改优先级来优化根位置. 在原本BLK的接口变得FWD的时候, 他也是经历了LIS, LRN的过程的.</p><p>接着我们再看看, trunk对于vlan的控制, 老实说我觉得这个实验应该在之前说VLAN的时候做的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#sh spanning-tree vlan 10</span></span><br><span class="line"></span><br><span class="line">VLAN0010</span><br><span class="line">  Spanning tree enabled protocol rstp</span><br><span class="line">  Root ID    Priority    10</span><br><span class="line">             Address     aabb.cc00.0200</span><br><span class="line">             Cost        100</span><br><span class="line">             Port        2 (Ethernet0/1)</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    32778  (priority 32768 sys-id-ext 10)</span><br><span class="line">             Address     aabb.cc00.0100</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time  300 sec</span><br><span class="line"></span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/0               Desg FWD 100       128.1    Shr </span><br><span class="line">Et0/1               Root FWD 100       128.2    Shr </span><br><span class="line">Et0/2               Altn BLK 100       128.3    Shr </span><br></pre></td></tr></table></figure><p>显然我们当前的SW1的0&#x2F;2端口是被堵住的, 现在我们不允许VLAN ID为10的帧通过e0&#x2F;2会怎么样呢?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SW1(config-if)<span class="comment">#sw tr allowed vlan remove 10</span></span><br><span class="line">SW1<span class="comment">#sh spanning-tree vlan 10</span></span><br><span class="line"></span><br><span class="line">VLAN0010</span><br><span class="line">  Spanning tree enabled protocol rstp</span><br><span class="line">  Root ID    Priority    10</span><br><span class="line">             Address     aabb.cc00.0200</span><br><span class="line">             Cost        100</span><br><span class="line">             Port        2 (Ethernet0/1)</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    32778  (priority 32768 sys-id-ext 10)</span><br><span class="line">             Address     aabb.cc00.0100</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time  300 sec</span><br><span class="line"></span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/0               Desg FWD 100       128.1    Shr </span><br><span class="line">Et0/1               Root FWD 100       128.2    Shr </span><br></pre></td></tr></table></figure><p>没有了, 同时之前的潜在环路也消失了, 也就是说逻辑上已经不需要vlan10的生成树来封堵它了.通过这样的配置就可以实现链路的负载了.</p><p>接下来再说一个超级有用的二层交换的命令, 这个小实验建议手要快一点(建议使用分开的Tab, 这方便观察结果, 首先展示实验结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 192.168.1.200 r 1000000</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 1000000, 100-byte ICMP Echos to 192.168.1.200, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...................!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!.....!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br></pre></td></tr></table></figure><p>这个是想表达什么呢? 首先我们开始进行批量的ping, 接着将SW1的e0&#x2F;1接口关闭, 于是出现了第一次的中断, 但是我在关闭接口之后立即又打开了它, 但是显然, 差不多经历了30s数据包才继续通信, 接着我再次将SW1的e0&#x2F;1接口关闭, 于是出现了第二次的中断, 接着, 和第一次不同的是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SW1(config-if)<span class="comment">#spanning-tree portfast </span></span><br><span class="line">%Warning: portfast should only be enabled on ports connected to a single</span><br><span class="line"> host. Connecting hubs, concentrators, switches, bridges, etc... to this</span><br><span class="line"> interface  when portfast is enabled, can cause temporary bridging loops.</span><br><span class="line"> Use with CAUTION</span><br><span class="line"></span><br><span class="line">%Portfast has been configured on Ethernet0/0 but will only</span><br><span class="line"> have effect when the interface is <span class="keyword">in</span> a non-trunking mode.</span><br></pre></td></tr></table></figure><p>接着再次打开了端口, 与第一次不同的是, 通信状态立即回复.</p><p>这个就是fastport, 这个选项使得生成树直接跳过LIS-LRN-FWD的30s时间, 而直接进入FWD状态.</p><p>如果说一个接口一个接口的配置太麻烦了, 也可以直接配个全局的, 就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SW1(config)<span class="comment">#spanning-tree portfast normal default </span></span><br></pre></td></tr></table></figure><p>如此即可.</p><p>那么这个fastport是不是有点不安全呢? 想象这么一种情况:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/stp3.png" alt="stp3"></p><p>(当然也不一定就是黑客啥的, 如果有一些网络管理员不小心把交换机啥的配置在了这个地方也会有造成网络崩溃的危险)这个时候, 我们需要SW能够拥有识别和保护的能力, 这就是现在要说的<strong>BPDUGUARD</strong> 也就是受到BPDU包, 那么就会将接口关闭. ( 实验不好做, 不想做了</p><p>(结果还是做了) 我们把SW1的e0&#x2F;1端口上加上这个选项:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SW1(config)<span class="comment">#int e0/1</span></span><br><span class="line">SW1(config-if)<span class="comment">#span bpdug enab</span></span><br><span class="line">SW1(config-if)<span class="comment">#end</span></span><br><span class="line">SW1<span class="comment">#</span></span><br><span class="line">*Sep 20 12:29:53.672: %SPANTREE-2-BLOCK_BPDUGUARD: Received BPDU on port Et0/1 with BPDU Guard enabled. Disabling port.</span><br><span class="line">*Sep 20 12:29:53.672: %PM-4-ERR_DISABLE: bpduguard error detected on Et0/1, putting Et0/1 <span class="keyword">in</span> err-disable state</span><br><span class="line">SW1<span class="comment">#</span></span><br><span class="line">*Sep 20 12:29:54.248: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">*Sep 20 12:29:54.683: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/1, changed state to down</span><br><span class="line">SW1<span class="comment">#</span></span><br><span class="line">*Sep 20 12:29:55.684: %LINK-3-UPDOWN: Interface Ethernet0/1, changed state to down</span><br></pre></td></tr></table></figure><p>直接就被关闭了. 现在查看端口显示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#sh int e0/1</span></span><br><span class="line">Ethernet0/1 is down, line protocol is down (err-disabled) </span><br></pre></td></tr></table></figure><p>这里的err-disable可以进行自动回复, 还可以一定间隔自动回复:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SW1(config)<span class="comment">#errdisable recovery cause bpduguard </span></span><br><span class="line">SW1(config)<span class="comment">#errdisable recovery interval 30</span></span><br></pre></td></tr></table></figure><p>这里就是说, 回复因为bpduguard造成的err-disabled, 第二个是说, 每个30s进行回复 (不过我自己实验的时候, 发现连个卵用都没有. 1分钟之后的更新, 当你把这个接口上的guard关掉之后才会看到自动回复的日志)</p><p>这个命令也可以进行全局设置, 但是必须结合fastport才可以.</p><h2 id="以太通道的建立"><a href="#以太通道的建立" class="headerlink" title="以太通道的建立"></a>以太通道的建立</h2><p>实验拓扑:<br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/channel1.png" alt="channel1"></p><p>和上面的拓扑没什么区别, 但这一次总结配置了很多说过的东西. 接下来注意到e0&#x2F;1和e0&#x2F;2中间的那个小圈. 之前说过e0&#x2F;1和e0&#x2F;2由于会形成环路, 所以生成树会堵塞其中一个接口. 但是如果我们能够把这两条路当成是生成树的一个接口, 那么不仅能够提升带宽, 还可以增加冗余. 这个技术就是<strong>以太通道</strong></p><p>先来查看一下当前接口和生成树的状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">SW2<span class="comment">#sh run int e0/0</span></span><br><span class="line">Building configuration...</span><br><span class="line"></span><br><span class="line">Current configuration : 109 bytes</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> switchport access vlan 10</span><br><span class="line"> switchport mode access</span><br><span class="line"> spanning-tree portfast edge</span><br><span class="line"> spanning-tree bpduguard <span class="built_in">enable</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">SW2<span class="comment">#sh run int e0/1</span></span><br><span class="line">Building configuration...</span><br><span class="line"></span><br><span class="line">Current configuration : 90 bytes</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> switchport trunk encapsulation dot1q</span><br><span class="line"> switchport mode trunk</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">SW2<span class="comment">#sh run int e0/2</span></span><br><span class="line">Building configuration...</span><br><span class="line"></span><br><span class="line">Current configuration : 90 bytes</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> switchport trunk encapsulation dot1q</span><br><span class="line"> switchport mode trunk</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>SW1这边:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#sh run int e0/0         </span></span><br><span class="line">Building configuration...</span><br><span class="line"></span><br><span class="line">Current configuration : 109 bytes</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> switchport access vlan 10</span><br><span class="line"> switchport mode access</span><br><span class="line"> spanning-tree portfast edge</span><br><span class="line"> spanning-tree bpduguard <span class="built_in">enable</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">SW1<span class="comment">#sh run int e0/1</span></span><br><span class="line">Building configuration...</span><br><span class="line"></span><br><span class="line">Current configuration : 90 bytes</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> switchport trunk encapsulation dot1q</span><br><span class="line"> switchport mode trunk</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">SW1<span class="comment">#sh run int e0/2</span></span><br><span class="line">Building configuration...</span><br><span class="line"></span><br><span class="line">Current configuration : 90 bytes</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> switchport trunk encapsulation dot1q</span><br><span class="line"> switchport mode trunk</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>而目前的生成树:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#sh span vlan 10</span></span><br><span class="line"></span><br><span class="line">VLAN0010</span><br><span class="line">  Spanning tree enabled protocol rstp</span><br><span class="line">  Root ID    Priority    32778</span><br><span class="line">             Address     aabb.cc00.0300</span><br><span class="line">             Cost        100</span><br><span class="line">             Port        2 (Ethernet0/1)</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    32778  (priority 32768 sys-id-ext 10)</span><br><span class="line">             Address     aabb.cc00.0500</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time  300 sec</span><br><span class="line"></span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/0               Desg FWD 100       128.1    Shr Edge </span><br><span class="line">Et0/1               Root FWD 100       128.2    Shr </span><br><span class="line">Et0/2               Altn BLK 100       128.3    Shr </span><br></pre></td></tr></table></figure><p>作为根桥的SW2:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SW2<span class="comment">#sh span vlan 10</span></span><br><span class="line"></span><br><span class="line">VLAN0010</span><br><span class="line">  Spanning tree enabled protocol rstp</span><br><span class="line">  Root ID    Priority    32778</span><br><span class="line">             Address     aabb.cc00.0300</span><br><span class="line">             This bridge is the root</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    32778  (priority 32768 sys-id-ext 10)</span><br><span class="line">             Address     aabb.cc00.0300</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time  300 sec</span><br><span class="line"></span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/0               Desg FWD 100       128.1    Shr Edge </span><br><span class="line">Et0/1               Desg FWD 100       128.2    Shr </span><br><span class="line">Et0/2               Desg FWD 100       128.3    Shr </span><br></pre></td></tr></table></figure><p><strong>现在我们把e0&#x2F;1和e0&#x2F;2捆绑起来:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SW1(config-if-range)<span class="comment">#channel-group 1 mode active </span></span><br><span class="line">Creating a port-channel interface Port-channel 1</span><br><span class="line"></span><br><span class="line">SW1(config-if-range)<span class="comment">#</span></span><br><span class="line">*Sep 21 04:00:19.927: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/1, changed state to down</span><br><span class="line">*Sep 21 04:00:19.927: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/2, changed state to down</span><br><span class="line">SW1(config-if-range)<span class="comment">#</span></span><br><span class="line">*Sep 21 04:00:21.192: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/2, changed state to up</span><br><span class="line">*Sep 21 04:00:21.192: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/1, changed state to up</span><br><span class="line">SW1(config-if-range)<span class="comment">#</span></span><br><span class="line">*Sep 21 04:00:27.353: %EC-5-L3DONTBNDL2: Et0/1 suspended: LACP currently not enabled on the remote port.</span><br><span class="line">*Sep 21 04:00:27.374: %EC-5-L3DONTBNDL2: Et0/2 suspended: LACP currently not enabled on the remote port.</span><br><span class="line">SW1(config-if-range)<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>端口先进行了关闭, 接着又Up起来, 接着收到了消息, LACP没有在远端端口上开启. 在SW2上进行完全相同的操作( 这个地方SW2可以有多个方案选择, active或者passive )  </p><p>完成了之后来看一下效果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#sh etherchannel summary </span></span><br><span class="line">Flags:  D - down        P - bundled <span class="keyword">in</span> port-channel</span><br><span class="line">        I - stand-alone s - suspended</span><br><span class="line">        H - Hot-standby (LACP only)</span><br><span class="line">        R - Layer3      S - Layer2</span><br><span class="line">        U - <span class="keyword">in</span> use      N - not <span class="keyword">in</span> use, no aggregation</span><br><span class="line">        f - failed to allocate aggregator</span><br><span class="line"></span><br><span class="line">        M - not <span class="keyword">in</span> use, minimum links not met</span><br><span class="line">        m - not <span class="keyword">in</span> use, port not aggregated due to minimum links not met</span><br><span class="line">        u - unsuitable <span class="keyword">for</span> bundling</span><br><span class="line">        w - waiting to be aggregated</span><br><span class="line">        d - default port</span><br><span class="line"></span><br><span class="line">        A - formed by Auto LAG</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Number of channel-groups <span class="keyword">in</span> use: 1</span><br><span class="line">Number of aggregators:           1</span><br><span class="line"></span><br><span class="line">Group  Port-channel  Protocol    Ports</span><br><span class="line">------+-------------+-----------+-----------------------------------------------</span><br><span class="line">1      Po1(SU)         LACP      Et0/1(P)    Et0/2(P)    </span><br></pre></td></tr></table></figure><p><strong>U</strong>即表示已经在使用.</p><p>那么这个时候我们的生成树会变成什么样的呢? 很好奇吧, 我们来看一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SW2<span class="comment">#sh span vlan 10</span></span><br><span class="line"></span><br><span class="line">VLAN0010</span><br><span class="line">  Spanning tree enabled protocol rstp</span><br><span class="line">  Root ID    Priority    32778</span><br><span class="line">             Address     aabb.cc00.0300</span><br><span class="line">             This bridge is the root</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    32778  (priority 32768 sys-id-ext 10)</span><br><span class="line">             Address     aabb.cc00.0300</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time  300 sec</span><br><span class="line"></span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/0               Desg FWD 100       128.1    Shr Edge </span><br><span class="line">Po1                 Desg FWD 56        128.65   Shr </span><br></pre></td></tr></table></figure><p>原先FWD的e0&#x2F;1和BLK的e0&#x2F;2端口现在合成成了一个FWD的Po1, 注意到Nbr也发生了变化.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SW2<span class="comment">#sh int Po1</span></span><br><span class="line">Port-channel1 is up, line protocol is up (connected) </span><br><span class="line">  Hardware is EtherChannel, address is aabb.cc00.0310 (bia aabb.cc00.0310)</span><br><span class="line">  MTU 1500 bytes, BW 20000 Kbit/sec, DLY 1000 usec, </span><br><span class="line">  ...(omitted)</span><br></pre></td></tr></table></figure><p>带宽是原来的两倍!</p><h2 id="VTP协议-VLAN中继协议"><a href="#VTP协议-VLAN中继协议" class="headerlink" title="VTP协议-VLAN中继协议"></a>VTP协议-VLAN中继协议</h2><p>在做实验之前, 我们先说说这个VTP协议, 简单的说就是为了VLAN配置信息的同步, 也可以理解成是一台交换机进行统一部署. VTP共有3个版本, 各个版本之间不兼容, 所以说, 如果要进行VTP, 就要保证交换机之间的版本号一致.</p><p>除此之外, 还需要满足: 交换机之间的VTP管理域名相同, 至少有一台VTP服务器, VTP的密码相同, 以及只在trunk上工作. 这很好理解</p><p>值得注意的是, VTP不是基于C&#x2F;S架构的, 这就是说, 一个VTP域中可以存在多个服务器.</p><p>实验拓扑:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vtp2.png" alt="vtp2"></p><p>SW3和SW4暂时没有开机.</p><p>现在我们在SW上查看一下当前vtp的状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SW<span class="comment">#sh vtp status</span></span><br><span class="line">VTP Version capable             : 1 to 3</span><br><span class="line">VTP version running             : 1</span><br><span class="line">VTP Domain Name                 : </span><br><span class="line">VTP Pruning Mode                : Disabled</span><br><span class="line">VTP Traps Generation            : Disabled</span><br><span class="line">Device ID                       : aabb.cc80.0200</span><br><span class="line">Configuration last modified by 0.0.0.0 at 0-0-00 00:00:00</span><br><span class="line">Local updater ID is 0.0.0.0 (no valid interface found)</span><br><span class="line"></span><br><span class="line">Feature VLAN:</span><br><span class="line">--------------</span><br><span class="line">VTP Operating Mode                : Server</span><br><span class="line">Maximum VLANs supported locally   : 1005</span><br><span class="line">Number of existing VLANs          : 5</span><br><span class="line">Configuration Revision            : 0</span><br><span class="line">MD5 digest                        : 0x57 0xCD 0x40 0x65 0x63 0x59 0x47 0xBD </span><br><span class="line">                                    0x56 0x9D 0x4A 0x3E 0xA5 0x69 0x35 0xBC </span><br></pre></td></tr></table></figure><p>要关注的地方是version版本号(1), Mode模式(Server, 这是默认值), 已存在的vlan和配置版本(这个配置版本就有一点像程序的版本号, 每次进行vlan的修改,删除,新增都会使得这个值加一)</p><p>SW1也是一台vtp server,略过.</p><p>现在我们在SW上进行下面的操作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SW(config)<span class="comment">#vtp domain jky   </span></span><br><span class="line">Changing VTP domain name from NULL to jky</span><br><span class="line">SW(config)<span class="comment">#vtp version 2</span></span><br></pre></td></tr></table></figure><p>提示说VTP域名从没有到变成了jky, 现在查看SW1或者SW2的vtp status, 你就会发现:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#sh vtp status</span></span><br><span class="line">VTP Version capable             : 1 to 3</span><br><span class="line">VTP version running             : 2</span><br><span class="line">VTP Domain Name                 : jky</span><br><span class="line">VTP Pruning Mode                : Disabled</span><br><span class="line">VTP Traps Generation            : Disabled</span><br><span class="line">Device ID                       : aabb.cc80.0100</span><br><span class="line">Configuration last modified by 0.0.0.0 at 9-21-17 05:23:53</span><br><span class="line">Local updater ID is 0.0.0.0 (no valid interface found)</span><br><span class="line"></span><br><span class="line">Feature VLAN:</span><br><span class="line">--------------</span><br><span class="line">VTP Operating Mode                : Server</span><br><span class="line">Maximum VLANs supported locally   : 1005</span><br><span class="line">Number of existing VLANs          : 5</span><br><span class="line">Configuration Revision            : 1</span><br><span class="line">MD5 digest                        : 0x7C 0x50 0x18 0xD1 0xBF 0x8C 0xF3 0x39 </span><br><span class="line">                                    0x58 0xC0 0x7B 0x6E 0xDD 0x66 0xFF 0x90 </span><br></pre></td></tr></table></figure><p>版本号变成了2, 而且域的名字也变成了jky, 另外我之前说过的Conf Revision也自动加了一.</p><p>现在我们尝试为SW和SW1添加相同的vtp密码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SW(config)<span class="comment">#vtp password jky507</span></span><br><span class="line">Setting device VTP password to jky507</span><br></pre></td></tr></table></figure><p>开始为SW配置VLAN:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SW(config)<span class="comment">#vlan 10</span></span><br><span class="line">SW(config-vlan)<span class="comment">#name 507a</span></span><br><span class="line">SW(config-vlan)<span class="comment">#vlan 20</span></span><br><span class="line">SW(config-vlan)<span class="comment">#name 507b</span></span><br><span class="line">SW(config-vlan)<span class="comment">#vlan 30,40,50</span></span><br><span class="line">SW(config-vlan)<span class="comment">#end</span></span><br></pre></td></tr></table></figure><p>来看看SW1是否得到了更新和同步:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SW1<span class="comment">#sh vlan b</span></span><br><span class="line"></span><br><span class="line">VLAN Name                             Status    Ports</span><br><span class="line">---- -------------------------------- --------- -------------------------------</span><br><span class="line">1    default                          active    Et0/1, Et0/2, Et0/3, Et1/0</span><br><span class="line">                                                Et1/1, Et1/2, Et1/3, Et2/0</span><br><span class="line">                                                Et2/1, Et2/2, Et2/3, Et3/0</span><br><span class="line">                                                Et3/1, Et3/2, Et3/3</span><br><span class="line">10   507a                             active    </span><br><span class="line">20   507b                             active    </span><br><span class="line">30   VLAN0030                         active    </span><br><span class="line">40   VLAN0040                         active    </span><br><span class="line">50   VLAN0050                         active    </span><br><span class="line">1002 fddi-default                     act/unsup </span><br><span class="line">1003 trcrf-default                    act/unsup </span><br><span class="line">1004 fddinet-default                  act/unsup </span><br><span class="line">1005 trbrf-default                    act/unsup </span><br></pre></td></tr></table></figure><p>看吧, SW1和SW的vlan保持了一致! 那, 没有设置密码的SW2显然就没有得到同步了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SW2<span class="comment">#sh vlan b </span></span><br><span class="line"></span><br><span class="line">VLAN Name                             Status    Ports</span><br><span class="line">---- -------------------------------- --------- -------------------------------</span><br><span class="line">1    default                          active    Et0/0, Et0/2, Et0/3, Et1/0</span><br><span class="line">                                                Et1/1, Et1/2, Et1/3, Et2/0</span><br><span class="line">                                                Et2/1, Et2/2, Et2/3, Et3/0</span><br><span class="line">                                                Et3/1, Et3/2, Et3/3</span><br><span class="line">1002 fddi-default                     act/unsup </span><br><span class="line">1003 trcrf-default                    act/unsup </span><br><span class="line">1004 fddinet-default                  act/unsup </span><br><span class="line">1005 trbrf-default                    act/unsup </span><br></pre></td></tr></table></figure><p>接下来, 你来猜一猜, 如果我现在把SW2的vtp密码设置上, 他会得到同步吗?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">SW2(config)<span class="comment">#vtp pas jky507</span></span><br><span class="line">Setting device VTP password to jky507</span><br><span class="line">SW2(config)<span class="comment">#end</span></span><br><span class="line">SW2<span class="comment">#sh vlan</span></span><br><span class="line">*Sep 21 05:31:32.763: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">SW2<span class="comment">#sh vlan b</span></span><br><span class="line"></span><br><span class="line">VLAN Name                             Status    Ports</span><br><span class="line">---- -------------------------------- --------- -------------------------------</span><br><span class="line">1    default                          active    Et0/0, Et0/2, Et0/3, Et1/0</span><br><span class="line">                                                Et1/1, Et1/2, Et1/3, Et2/0</span><br><span class="line">                                                Et2/1, Et2/2, Et2/3, Et3/0</span><br><span class="line">                                                Et3/1, Et3/2, Et3/3</span><br><span class="line">1002 fddi-default                     act/unsup </span><br><span class="line">1003 trcrf-default                    act/unsup </span><br><span class="line">1004 fddinet-default                  act/unsup </span><br><span class="line">1005 trbrf-default                    act/unsup </span><br><span class="line">SW2<span class="comment">#sh vtp status</span></span><br><span class="line">VTP Version capable             : 1 to 3</span><br><span class="line">VTP version running             : 2</span><br><span class="line">VTP Domain Name                 : jky</span><br><span class="line">VTP Pruning Mode                : Disabled</span><br><span class="line">VTP Traps Generation            : Disabled</span><br><span class="line">Device ID                       : aabb.cc80.0500</span><br><span class="line">Configuration last modified by 0.0.0.0 at 9-21-17 05:23:53</span><br><span class="line">Local updater ID is 0.0.0.0 (no valid interface found)</span><br><span class="line"></span><br><span class="line">Feature VLAN:</span><br><span class="line">--------------</span><br><span class="line">VTP Operating Mode                : Server</span><br><span class="line">Maximum VLANs supported locally   : 1005</span><br><span class="line">Number of existing VLANs          : 5</span><br><span class="line">Configuration Revision            : 1</span><br><span class="line">MD5 digest                        : 0xF4 0xD1 0xC8 0xA8 0xAB 0xFF 0x33 0x7E </span><br><span class="line">                                    0x84 0xCC 0xD5 0x91 0xA7 0x16 0x8D 0xBC </span><br></pre></td></tr></table></figure><p>挨 ? 按理说现在SW2和SW1的环境应该是一样的呀, 为什么没有用呢? 这里就要说IOS的一个大大大大的坑了, 这个VTP的触发条件就是对VLAN的操作, 如果没有, 不好意思. 他不会进行同步. 这样的话我们可以尝试对VLAN进行一些操作来触发它, 比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SW(config)<span class="comment">#vlan 99</span></span><br><span class="line">SW(config-vlan)<span class="comment">#no vlan 99</span></span><br><span class="line">SW(config)<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>这个时候查看SW2的vlan配置, 就已经和SW, SW1保持一致了.</p><p>好了, 到了把SW3和SW4开机的时候了.</p><p>别忘了把trunk先开开:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SW3(config)<span class="comment">#int e0/0</span></span><br><span class="line">SW3(config-if)<span class="comment">#sw tr en do</span></span><br><span class="line">SW3(config-if)<span class="comment">#sw mo tr</span></span><br><span class="line">SW3(config-if)<span class="comment">#end</span></span><br></pre></td></tr></table></figure><p>接着我们尝试一下client模式.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SW3(config)<span class="comment">#vtp mode client</span></span><br><span class="line">Setting device to VTP Client mode <span class="keyword">for</span> VLANS.</span><br><span class="line">SW3(config)<span class="comment">#do sh vtp status</span></span><br><span class="line">VTP Version capable             : 1 to 3</span><br><span class="line">VTP version running             : 1</span><br><span class="line">VTP Domain Name                 : </span><br><span class="line">VTP Pruning Mode                : Disabled</span><br><span class="line">VTP Traps Generation            : Disabled</span><br><span class="line">Device ID                       : aabb.cc80.0300</span><br><span class="line">Configuration last modified by 0.0.0.0 at 0-0-00 00:00:00</span><br><span class="line"></span><br><span class="line">Feature VLAN:</span><br><span class="line">--------------</span><br><span class="line">VTP Operating Mode                : Client</span><br><span class="line">Maximum VLANs supported locally   : 1005</span><br><span class="line">Number of existing VLANs          : 5</span><br><span class="line">Configuration Revision            : 0</span><br><span class="line">MD5 digest                        : 0x57 0xCD 0x40 0x65 0x63 0x59 0x47 0xBD </span><br><span class="line">                                    0x56 0x9D 0x4A 0x3E 0xA5 0x69 0x35 0xBC </span><br></pre></td></tr></table></figure><p>这个时候先别急着试, 我们说过vtp的同步是要很多条件的.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SW3(config)<span class="comment">#vtp password jky507</span></span><br><span class="line">Setting device VTP password to jky507</span><br><span class="line">SW3(config)<span class="comment">#vtp version 2</span></span><br><span class="line">Cannot modify version <span class="keyword">in</span> VTP client mode unless the system is <span class="keyword">in</span> VTP version 3</span><br><span class="line">SW3(config)<span class="comment">#vtp domain jky</span></span><br><span class="line">Changing VTP domain name from NULL to jky</span><br></pre></td></tr></table></figure><p>如果是Client模式, 你是不能进行version的变更的, 同时, 如果你想要进行vlan配置的改变:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SW3(config)<span class="comment">#vlan 10</span></span><br><span class="line">VTP VLAN configuration not allowed when device is <span class="keyword">in</span> CLIENT mode.</span><br></pre></td></tr></table></figure><p>是不被允许的.</p><p>接着我们把SW4和SW的接口down掉.</p><p>最后一定不要忘记:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SW4(config)<span class="comment">#vtp password jky507</span></span><br><span class="line">Setting device VTP password to jky507</span><br><span class="line">SW4(config)<span class="comment">#vtp domain jky</span></span><br><span class="line">Changing VTP domain name from NULL to jky</span><br><span class="line">SW4(config)<span class="comment">#vtp mode client</span></span><br><span class="line">Setting device to VTP Client mode <span class="keyword">for</span> VLANS.</span><br><span class="line">SW4(config)<span class="comment">#^Z</span></span><br></pre></td></tr></table></figure><p>OK, 我们来测试一下Client的转发和续传:</p><p>这次我们特地在SW1上进行更改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SW1(config)<span class="comment">#vlan 50</span></span><br><span class="line">SW1(config-vlan)<span class="comment">#name 508</span></span><br><span class="line">SW1(config-vlan)<span class="comment">#^Z</span></span><br></pre></td></tr></table></figure><p>看看SW4怎么样了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SW4<span class="comment">#sh vlan b</span></span><br><span class="line"></span><br><span class="line">VLAN Name                             Status    Ports</span><br><span class="line">---- -------------------------------- --------- -------------------------------</span><br><span class="line">1    default                          active    Et0/1, Et0/2, Et0/3, Et1/0</span><br><span class="line">                                                Et1/1, Et1/2, Et1/3, Et2/0</span><br><span class="line">                                                Et2/1, Et2/2, Et2/3, Et3/0</span><br><span class="line">                                                Et3/1, Et3/2, Et3/3</span><br><span class="line">10   507a                             active    </span><br><span class="line">20   507b                             active    </span><br><span class="line">30   506                              active    </span><br><span class="line">40   505                              active    </span><br><span class="line">50   508                              active    </span><br><span class="line">1002 fddi-default                     act/unsup </span><br><span class="line">1003 trcrf-default                    act/unsup </span><br><span class="line">1004 fddinet-default                  act/unsup </span><br><span class="line">1005 trbrf-default                    act/unsup </span><br></pre></td></tr></table></figure><p>更新了, 这次更新显然是SW3转发给SW4得到的, 其实不仅Client可以进行转发, 由于这一次我们是在SW1上做的改变, 所以这同时也证明Server端也是可以进行转发的, 同时也可以进行同步.</p><p>除了这两种模式, 还有一种透明模式, 这种模式就像是自治一般, 允许更改但是不能进行发布. 这种模式相较于Server和Client更加可靠其实, 至于为什么, 你自己想吧. 所以一般我们推荐使用transport模式.</p><h2 id="HCRP小实验"><a href="#HCRP小实验" class="headerlink" title="HCRP小实验"></a>HCRP小实验</h2><p>这个实验很简单, 拓扑也很simple, 就是感受一下虚拟IP而已.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/hcrp.png" alt="hcrp"></p><p>最简单的连接了 不说直接配.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HQ(config)<span class="comment">#int e0/0</span></span><br><span class="line">HQ(config-if)<span class="comment">#standby 1 ip 192.168.1.254</span></span><br><span class="line">HQ(config-if)<span class="comment">#^Z</span></span><br><span class="line">...(omitted)</span><br><span class="line">*Sep 21 06:53:11.122: %HSRP-5-STATECHANGE: Ethernet0/0 Grp 1 state Standby -&gt; Active</span><br></pre></td></tr></table></figure><p>看到输出, e0&#x2F;0的第一组状态变成了Active.</p><p>我们把Branch也设置成同样的.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#int e0/0</span></span><br><span class="line">Branch(config-if)<span class="comment">#standby 1 ip 192.168.1.254</span></span><br><span class="line">Branch(config-if)<span class="comment">#^Z</span></span><br><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 21 06:54:43.377: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 21 06:55:06.347: %HSRP-5-STATECHANGE: Ethernet0/0 Grp 1 state Speak -&gt; Standby</span><br></pre></td></tr></table></figure><p>此时的Branch就相当是一台热备路由了. 我们来观察一下standby的状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#sh standby b</span></span><br><span class="line">                     P indicates configured to preempt.</span><br><span class="line">                     |</span><br><span class="line">Interface   Grp  Pri P State   Active          Standby         Virtual IP</span><br><span class="line">Et0/0       1    100   Standby 192.168.1.20    <span class="built_in">local</span>           192.168.1.254</span><br></pre></td></tr></table></figure><p>显示本地设备是standby的状态, 这个时候使用HQ查看是相反的两个. 那么如果我想使得Branch成为Active的状态, 有什么办法么?</p><p>这里的Active其实参考的是上面的Pri值, 也就是优先级, 越大越优先.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Branch(config-if)<span class="comment">#standby 1 priority 125</span></span><br><span class="line">Branch(config-if)<span class="comment">#^Z</span></span><br></pre></td></tr></table></figure><p>过了很久, 你本以为会有什么消息输出, 结果没有.</p><p>查看一下状态吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#sh standby b</span></span><br><span class="line">                     P indicates configured to preempt.</span><br><span class="line">                     |</span><br><span class="line">Interface   Grp  Pri P State   Active          Standby         Virtual IP</span><br><span class="line">Et0/0       1    125   Standby 192.168.1.20    <span class="built_in">local</span>           192.168.1.254</span><br></pre></td></tr></table></figure><p>改是改过来了, 但是就没有切换状态呀.</p><p>这个时候, 就需要Branch主动发出请求了, 也就是需要进行一个属性的调用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Branch(config-if)<span class="comment">#standby 1 preempt </span></span><br><span class="line">Branch(config-if)<span class="comment">#^Z</span></span><br><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 21 07:01:11.706: %HSRP-5-STATECHANGE: Ethernet0/0 Grp 1 state Standby -&gt; Active</span><br></pre></td></tr></table></figure><p>同时, HQ那边也还会有提示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#</span></span><br><span class="line">*Sep 21 07:01:11.707: %HSRP-5-STATECHANGE: Ethernet0/0 Grp 1 state Active -&gt; Speak</span><br><span class="line">HQ<span class="comment">#</span></span><br><span class="line">*Sep 21 07:01:22.034: %HSRP-5-STATECHANGE: Ethernet0/0 Grp 1 state Speak -&gt; Standby</span><br></pre></td></tr></table></figure><p>最后我们来Ping这虚拟IP试试吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#ping 192.168.1.254</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.1.254, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">.!!!!</span><br><span class="line">Success rate is 80 percent (4/5), round-trip min/avg/max = 1/3/6 ms</span><br></pre></td></tr></table></figure><p>第一个包是在进行ARP请求 虚拟IP的实验完成.</p><h2 id="VLAN间路由"><a href="#VLAN间路由" class="headerlink" title="VLAN间路由"></a>VLAN间路由</h2><p>实验拓扑:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vlan6_new.png" alt="vlan6_new"></p><p>似曾相识?emmmm..就是这样.</p><p>我们还是先把基本的属性配置好. 现在的问题是, 我们想要使得PC1和PC2进行通信, 之前我们说过可以使用修改本征VLAN使得帧不携带VLANID的方法, 但是这显然不好, 现在我们通过单臂路由的实现使PC1和PC2进行通信.</p><p>首先确认除Branch以外的设备都已经配置完成. 现在我们进入Branch的配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">Branch(config)<span class="comment">#int e0/0.10</span></span><br><span class="line">Branch(config-subif)<span class="comment">#en</span></span><br><span class="line">Branch(config-subif)<span class="comment">#encapsulation do</span></span><br><span class="line">Branch(config-subif)<span class="comment">#encapsulation dot1Q 10</span></span><br><span class="line">Branch(config-subif)<span class="comment">#ip addr 10.1.10.254 255.255.255.0</span></span><br><span class="line">Branch(config-subif)<span class="comment">#exi</span></span><br><span class="line">Branch(config)<span class="comment">#int e0/0.20</span></span><br><span class="line">Branch(config-subif)<span class="comment">#en do 20</span></span><br><span class="line">Branch(config-subif)<span class="comment">#ip addr 10.1.20.254 255.255.255.0</span></span><br><span class="line">Branch(config-subif)<span class="comment">#exi</span></span><br><span class="line">Branch(config)<span class="comment">#int e0/0</span></span><br><span class="line">Branch(config-if)<span class="comment">#no sh</span></span><br><span class="line">Branch(config-if)<span class="comment">#^Z</span></span><br><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 21 08:47:44.945: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 21 08:47:46.257: %LINK-3-UPDOWN: Interface Ethernet0/0, changed state to up</span><br><span class="line">*Sep 21 08:47:47.266: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/0, changed state to up</span><br></pre></td></tr></table></figure><p>好, 进行测试. 激动人心的时刻到了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC2<span class="comment">#ping 10.1.10.100</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.1.10.100, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 ms</span><br></pre></td></tr></table></figure><p>太好了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 10.1.20.100</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.1.20.100, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/2/4 ms</span><br></pre></td></tr></table></figure><p>如果你的PC1和PC2无法通信, 请检查一下:</p><ul><li>SW1和SW2对应VLAN的生成树, 其中SW1有10和20的两个生成树实例</li><li>trunk的配置是否完成(一共有两个交换机trunk, 路由器的子接口两个dot1q封装)</li><li>vlan的划分是否完成.</li></ul><h2 id="SVI交换虚拟接口"><a href="#SVI交换虚拟接口" class="headerlink" title="SVI交换虚拟接口"></a>SVI交换虚拟接口</h2><p>实验拓扑:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/svi.png" alt="svi"></p><p>这个实验的关键点在于SW的三层交换.</p><p>我们配置三个VLAN10, 20, 30分别使用access模式划分给PC1, PC2, 路由器Branch. 接着为SW配置路由表, 将默认路由指向VLAN30.  最好手动开启交换功能.</p><p>To tell you from the heart, 这个实验我没有做成功. 虽然我排查了很久确定没有出错, 但是就是无法使得PC1和Branch通信.</p><blockquote><p>这个实验中SW配置了默认路由, 确定了SW到每一个节点的连通, 我也确定<strong>我敲了SW的 ip routing 命令, 但是就是不转发!</strong> 到底是为什么呢? 在这里贴下SW的配置, 如果你能发现问题 请告知 : )</p><p>SW2:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">SW<span class="comment">#sh ip rout</span></span><br><span class="line">S*    0.0.0.0/0 [1/0] via 192.168.3.254, Vlan30</span><br><span class="line">      192.168.1.0/24 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        192.168.1.0/24 is directly connected, Vlan10</span><br><span class="line">L        192.168.1.100/32 is directly connected, Vlan10</span><br><span class="line">      192.168.2.0/24 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        192.168.2.0/24 is directly connected, Vlan20</span><br><span class="line">L        192.168.2.100/32 is directly connected, Vlan20</span><br><span class="line">      192.168.3.0/24 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        192.168.3.0/24 is directly connected, Vlan30</span><br><span class="line">L        192.168.3.100/32 is directly connected, Vlan30</span><br><span class="line"></span><br><span class="line">SW<span class="comment">#sh run int e0/1</span></span><br><span class="line">Building configuration...</span><br><span class="line"></span><br><span class="line">Current configuration : 80 bytes</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> switchport access vlan 10</span><br><span class="line"> switchport mode access</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">SW<span class="comment">#sh spanning-tree vlan 10</span></span><br><span class="line"></span><br><span class="line">VLAN0010</span><br><span class="line">  Spanning tree enabled protocol rstp</span><br><span class="line">  Root ID    Priority    32778</span><br><span class="line">             Address     aabb.cc00.0100</span><br><span class="line">             This bridge is the root</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    32778  (priority 32768 sys-id-ext 10)</span><br><span class="line">             Address     aabb.cc00.0100</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time  300 sec</span><br><span class="line"></span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/1               Desg FWD 100       128.2    Shr Edge </span><br><span class="line"></span><br><span class="line">interface Vlan1</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown </span><br><span class="line">!         </span><br><span class="line">interface Vlan10</span><br><span class="line"> ip address 192.168.1.100 255.255.255.0</span><br><span class="line">!         </span><br><span class="line">interface Vlan20</span><br><span class="line"> ip address 192.168.2.100 255.255.255.0</span><br><span class="line">!         </span><br><span class="line">interface Vlan30</span><br><span class="line"> ip address 192.168.3.100 255.255.255.0</span><br><span class="line">!         </span><br><span class="line">ip forward-protocol nd</span><br></pre></td></tr></table></figure></blockquote><h2 id="DHCP实现"><a href="#DHCP实现" class="headerlink" title="DHCP实现"></a>DHCP实现</h2><p>首先我们的实验拓扑:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/dhcp4.png" alt="dhcp4"></p><p>和我们设置单臂路由的时候几乎一样. 现在我们先关闭PC1和PC2的IP地址. 接着重新设置IP获取方式为DHCP.下述配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PC1(config)<span class="comment">#int e0/1</span></span><br><span class="line">PC1(config-if)<span class="comment">#no ip addr # 关闭IP地址</span></span><br><span class="line">PC1(config-if)<span class="comment">#ip addr dhcp # 设置成DHCP动态获取</span></span><br></pre></td></tr></table></figure><p>接着我们要把路由器设置成为一台DHCP服务器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#ip dhcp pool VLAN10</span></span><br><span class="line">Branch(dhcp-config)<span class="comment">#network 10.1.10.0 255.255.255.0</span></span><br><span class="line">Branch(dhcp-config)<span class="comment">#default-router 10.1.10.254</span></span><br><span class="line">Branch(dhcp-config)<span class="comment">#dns-server 114.114.114.114 223.5.5.5</span></span><br><span class="line">Branch(dhcp-config)<span class="comment">#domain-name yaoxuannn.com</span></span><br><span class="line">Branch(dhcp-config)<span class="comment">#exi</span></span><br><span class="line">Branch(config)<span class="comment">#ip dhcp pool VLAN20</span></span><br><span class="line">Branch(dhcp-config)<span class="comment">#network 10.1.20.0 255.255.255.0</span></span><br><span class="line">Branch(dhcp-config)<span class="comment">#default-router 10.1.20.254</span></span><br><span class="line">Branch(dhcp-config)<span class="comment">#dns-server 223.5.5.5 114.114.114.114</span></span><br><span class="line">Branch(dhcp-config)<span class="comment">#domain-name yaoxuannn.com</span></span><br><span class="line">Branch(dhcp-config)<span class="comment">#exi</span></span><br><span class="line">Branch(config)<span class="comment">#ip dhcp excluded-address ?</span></span><br><span class="line">  A.B.C.D  Low IP address</span><br><span class="line">  vrf      VRF name <span class="keyword">for</span> excluded address range</span><br><span class="line"></span><br><span class="line">Branch(config)<span class="comment">#ip dhcp excluded-address 10.1.10.250 10.1.10.254</span></span><br><span class="line">Branch(config)<span class="comment">#ip dhcp excluded-address 10.1.20.250 10.1.20.254</span></span><br></pre></td></tr></table></figure><p>这个时候, PC1和PC2会收到消息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PC2<span class="comment">#</span></span><br><span class="line">*Sep 21 11:31:17.361: %DHCP-6-ADDRESS_ASSIGN: Interface Ethernet0/1 assigned DHCP address 10.1.20.1, mask 255.255.255.0, hostname PC2</span><br></pre></td></tr></table></figure><p>很简单吧~</p><p>有趣的是, 我们的DHCP事实上很有趣. 我们来抓个包看看.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/dhcp2.png" alt="dhcp2"></p><p>这是释放IP的时候所发的包.</p><p>有意思的是:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/dhcp3.png" alt="dhcp3"></p><p>有没有发现, 所有的包都是广播啊!哈哈哈这个是不是和你想象的不太一样啊.</p><p>另外, 如果出现了IP地址冲突, 是需要网络管理员进行手动的修改的.命令就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#sh ip dhcp conflict </span></span><br><span class="line">IP address        Detection method   Detection time          VRF</span><br><span class="line">Branch<span class="comment">#clear ip dhcp conflict ?</span></span><br><span class="line">  *        Clear all address conflicts</span><br><span class="line">  A.B.C.D  Clear a specific conflict</span><br><span class="line">  vrf      DHCP vrf conflicts</span><br></pre></td></tr></table></figure><p>另外还可以查看当前IP池的分配情况:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#sh ip dhcp pool</span></span><br><span class="line"></span><br><span class="line">Pool VLAN10 :</span><br><span class="line"> Utilization mark (high/low)    : 100 / 0</span><br><span class="line"> Subnet size (first/next)       : 0 / 0 </span><br><span class="line"> Total addresses                : 254</span><br><span class="line"> Leased addresses               : 1</span><br><span class="line"> Pending event                  : none</span><br><span class="line"> 1 subnet is currently <span class="keyword">in</span> the pool :</span><br><span class="line"> Current index        IP address range                    Leased addresses</span><br><span class="line"> 10.1.10.2            10.1.10.1        - 10.1.10.254       1</span><br><span class="line"></span><br><span class="line">Pool VLAN20 :</span><br><span class="line"> Utilization mark (high/low)    : 100 / 0</span><br><span class="line"> Subnet size (first/next)       : 0 / 0 </span><br><span class="line"> Total addresses                : 254</span><br><span class="line"> Leased addresses               : 1</span><br><span class="line"> Pending event                  : none</span><br><span class="line"> 1 subnet is currently <span class="keyword">in</span> the pool :</span><br><span class="line"> 10.1.20.2            10.1.20.1        - 10.1.20.254       1</span><br></pre></td></tr></table></figure><p>如果是更想知道IP分配给了谁, 这样看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#sh ip dhcp binding</span></span><br><span class="line">Bindings from all pools not associated with VRF:</span><br><span class="line">IP address          Client-ID/              Lease expiration        Type</span><br><span class="line">                    Hardware address/</span><br><span class="line">                    User name</span><br><span class="line">10.1.10.1           0063.6973.636f.2d61.    Sep 23 2017 01:40 AM    Automatic</span><br><span class="line">                    6162.622e.6363.3030.</span><br><span class="line">                    2e30.3531.302d.4574.</span><br><span class="line">                    302f.31</span><br><span class="line">10.1.20.1           0063.6973.636f.2d61.    Sep 23 2017 01:40 AM    Automatic</span><br><span class="line">                    6162.622e.6363.3030.</span><br><span class="line">                    2e30.3431.302d.4574.</span><br><span class="line">                    302f.31</span><br></pre></td></tr></table></figure><p>接下来, 我们扯扯<strong>DHCP中继</strong>.</p><p>使用的场景在DHCP服务器和客户端不在同一个网络中, 这个时候广播不能跨越网络到达DHCP服务器, 所以我们要将广播封装成单播来实现.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/dhcp%E4%B8%AD%E7%BB%A7.png" alt="dhcp中继"></p><p>现在我们来将CMCC设置成DHCP服务器, 路由器Branch设置了两个dot1q封装的子接口分别对应PC1所处的VLAN10和PC2所处的VLAN20.</p><p>直接来看路由器的配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#int e0/0   </span></span><br><span class="line">Branch(config-if)<span class="comment">#no sh</span></span><br><span class="line">Branch(config-if)<span class="comment">#int e0/0.10</span></span><br><span class="line">Branch(config-subif)<span class="comment">#encapsulation dot1q 10</span></span><br><span class="line">Branch(config-subif)<span class="comment">#ip addr 192.168.1.100 255.255.255.0</span></span><br><span class="line">Branch(config-subif)<span class="comment">#ip helper-address 172.16.1.100</span></span><br><span class="line">Branch(config-subif)<span class="comment">#exi</span></span><br></pre></td></tr></table></figure><p>这里的helper-address就是将广播封装成单播发出去的.</p><p>PC1会受到DHCP分配消息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*Sep 22 02:40:14.398: %DHCP-6-ADDRESS_ASSIGN: Interface Ethernet0/1 assigned DHCP address 192.168.1.1, mask 255.255.255.0, hostname PC1</span><br></pre></td></tr></table></figure><p>同理, PC2和路由器的子接口也做相似的操作就行了.</p><h2 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h2><p>BGP称为边际网关协议, 用于在AS之间进行自动的邻居间的单播路由. 现在我们用一个超小的实验来模拟一下:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/bgp2.png" alt="bgp2"></p><p>现在我们有两个AS, 为了使得AS号100里的PC1和AS号200里的PC2通信, 我们先通过DHCP的方式使得PC1和PC2自动获得IP地址, 接着评定Branch和HQ之间的连通:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#sh ip dhcp pool Branch</span></span><br><span class="line"></span><br><span class="line">Pool Branch :</span><br><span class="line"> Utilization mark (high/low)    : 100 / 0</span><br><span class="line"> Subnet size (first/next)       : 0 / 0 </span><br><span class="line"> Total addresses                : 254</span><br><span class="line"> Leased addresses               : 1</span><br><span class="line"> Pending event                  : none</span><br><span class="line"> 1 subnet is currently <span class="keyword">in</span> the pool :</span><br><span class="line"> Current index        IP address range                    Leased addresses</span><br><span class="line"> 192.168.1.2          192.168.1.1      - 192.168.1.254     1</span><br><span class="line"> ----------------------</span><br><span class="line"> HQ<span class="comment">#sh ip dhcp pool HQ </span></span><br><span class="line"></span><br><span class="line">Pool HQ :</span><br><span class="line"> Utilization mark (high/low)    : 100 / 0</span><br><span class="line"> Subnet size (first/next)       : 0 / 0 </span><br><span class="line"> Total addresses                : 254</span><br><span class="line"> Leased addresses               : 1</span><br><span class="line"> Pending event                  : none</span><br><span class="line"> 1 subnet is currently <span class="keyword">in</span> the pool :</span><br><span class="line"> Current index        IP address range                    Leased addresses</span><br><span class="line"> 192.168.2.2          192.168.2.1      - 192.168.2.254     1</span><br></pre></td></tr></table></figure><p>还是惯例, Ping一下试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#ping 172.16.2.100     </span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 172.16.2.100, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 5/5/6 ms</span><br></pre></td></tr></table></figure><p>好啦 开始设置我们的BGP, 这样来:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#router bgp 100</span></span><br><span class="line">Branch(config-router)<span class="comment">#neighbor 172.16.2.100 remote-as 200</span></span><br><span class="line">Branch(config-router)<span class="comment">#end</span></span><br><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 22 11:57:34.347: %SYS-5-CONFIG_I: Configured from console by console</span><br></pre></td></tr></table></figure><p>对面也这么设置, 过一小会就会有BGP的邻居up的消息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 22 11:58:12.494: %BGP-5-ADJCHANGE: neighbor 172.16.2.100 Up </span><br></pre></td></tr></table></figure><p>激动人心的时候到啦, 我!要!通!信!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 192.168.2.1</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 172.16.2.100, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">.....</span><br><span class="line">Success rate is 0 percent (0/5)</span><br></pre></td></tr></table></figure><p>嘿嘿, 失败了. 为啥? 是因为我们还没有进行BGP路由的<strong>发布</strong> </p><p>现在试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#router bgp 100</span></span><br><span class="line">Branch(config-router)<span class="comment">#network 192.168.1.0 mask 255.255.255.0</span></span><br><span class="line">Branch(config-router)<span class="comment">#network 172.16.0.0 mask 255.255.0.0</span></span><br><span class="line">Branch(config-router)<span class="comment">#^Z</span></span><br></pre></td></tr></table></figure><p>接着对方:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HQ(config)<span class="comment">#router bgp 200</span></span><br><span class="line">HQ(config-router)<span class="comment">#network 192.168.2.0 mask 255.255.255.0</span></span><br><span class="line">HQ(config-router)<span class="comment">#network 172.16.0.0 mask 255.255.0.0</span></span><br><span class="line">HQ(config-router)<span class="comment">#^Z</span></span><br></pre></td></tr></table></figure><p>现在再试试,就可以通信了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 192.168.2.1</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.2.1, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 5/5/5 ms</span><br></pre></td></tr></table></figure><p>建议, 在发布前, 中, 后经常查看一下路由表, 以及使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#sh ip bgp</span></span><br><span class="line">BGP table version is 6, <span class="built_in">local</span> router ID is 192.168.1.100</span><br><span class="line">Status codes: s suppressed, d damped, h <span class="built_in">history</span>, * valid, &gt; best, i - internal, </span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, </span><br><span class="line">              x best-external, a additional-path, c RIB-compressed, </span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *   172.16.0.0       172.16.2.100             0             0 200 i</span><br><span class="line"> *&gt;                   0.0.0.0                  0         32768 i</span><br><span class="line"> *&gt;  192.168.1.0      0.0.0.0                  0         32768 i</span><br><span class="line"> *&gt;  192.168.2.0      172.16.2.100             0             0 200 i</span><br></pre></td></tr></table></figure><p>你会有很多发现, 对BGP发布也会更理解.</p><h2 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h2><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/odpf.png" alt="odpf"></p><p>不想打字.</p><p>配置完成之后, 我们直接进行OSPF路由的设置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">Branch(config)<span class="comment">#router ospf 1</span></span><br><span class="line">Branch(config-router)<span class="comment">#router-id 1.1.1.1</span></span><br><span class="line">Branch(config-router)<span class="comment">#exi</span></span><br><span class="line">Branch(config)<span class="comment">#int e0/0</span></span><br><span class="line">Branch(config-if)<span class="comment">#ip ospf 1 area 0</span></span><br><span class="line">Branch(config-if)<span class="comment">#exi</span></span><br><span class="line">Branch(config)<span class="comment">#int e0/1</span></span><br><span class="line">Branch(config-if)<span class="comment">#ip ospf 1 area 0</span></span><br><span class="line">Branch(config-if)<span class="comment">#end</span></span><br></pre></td></tr></table></figure><p>同样另外一边也做同样的事, 但是这里的ospf的进程号是可以不一样的, 而router-id自然是需要不一样的.</p><p>接着我们就会受到消息通知, 这个时候查看OSPF的邻居也可以看到了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 22 13:30:02.975: %OSPF-5-ADJCHG: Process 1, Nbr 2.2.2.2 on Ethernet0/0 from LOADING to FULL, Loading Done</span><br><span class="line">Branch<span class="comment">#sh ip ospf nei</span></span><br><span class="line"></span><br><span class="line">Neighbor ID     Pri   State           Dead Time   Address         Interface</span><br><span class="line">2.2.2.2           1   FULL/BDR        00:00:35    172.16.1.2      Ethernet0/0</span><br></pre></td></tr></table></figure><p>好了, 这样就行了. 比BGP要容易多了!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 192.168.2.100</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.2.100, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 5/5/6 ms</span><br></pre></td></tr></table></figure><p>接着, 没完. 你会发现有个东西不对劲:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#sh ip ospf nei</span></span><br><span class="line"></span><br><span class="line">Neighbor ID     Pri   State           Dead Time   Address         Interface</span><br><span class="line">2.2.2.2           1   FULL/DR         00:00:37    172.16.1.2      Ethernet0/0</span><br><span class="line">Branch<span class="comment">#sh ip ospf nei</span></span><br><span class="line"></span><br><span class="line">Neighbor ID     Pri   State           Dead Time   Address         Interface</span><br><span class="line">2.2.2.2           1   FULL/DR         00:00:34    172.16.1.2      Ethernet0/0</span><br><span class="line">Branch<span class="comment">#sh ip ospf nei</span></span><br><span class="line"></span><br><span class="line">Neighbor ID     Pri   State           Dead Time   Address         Interface</span><br><span class="line">2.2.2.2           1   FULL/DR         00:00:33    172.16.1.2      Ethernet0/0</span><br></pre></td></tr></table></figure><p>死亡时间在减少 但是你又发现, 这个时间每次到了30的时候会自动增加回去.</p><p>是这样, 死亡时间是指收到Hello的时间间隔, 如果一直没收到DeadTime就会一直减少, 直到降为0. 因此我关闭了Branch这边的ospf路由, 于是HQ这边就会一直收不到Hello消息导致时间一直在下降:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#sh ip ospf nei</span></span><br><span class="line"></span><br><span class="line">Neighbor ID     Pri   State           Dead Time   Address         Interface</span><br><span class="line">1.1.1.1           1   FULL/BDR        00:00:00    172.16.1.1      Ethernet0/0</span><br><span class="line">HQ<span class="comment">#sh ip ospf nei</span></span><br><span class="line">HQ<span class="comment">#</span></span><br><span class="line">*Sep 22 14:10:11.105: %OSPF-5-ADJCHG: Process 1, Nbr 1.1.1.1 on Ethernet0/0 from FULL to DOWN, Neighbor Down: Dead timer expired</span><br></pre></td></tr></table></figure><p>当时间降为0的时候, 邻居就会被删除.</p><p>接下来说说这个Hello消息, 该消息时间默认是10s一次. 如何修改这个Hello时间呢?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#int e0/0</span></span><br><span class="line">Branch(config-if)<span class="comment">#ip ospf hello-interval 15</span></span><br></pre></td></tr></table></figure><p>结果过了一会你发现, 挨!我的邻居怎么又被删除了?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Branch(config-if)<span class="comment">#</span></span><br><span class="line">*Sep 22 14:16:46.466: %OSPF-5-ADJCHG: Process 1, Nbr 2.2.2.2 on Ethernet0/0 from FULL to DOWN, Neighbor Down: Dead timer expired</span><br></pre></td></tr></table></figure><p>这个Hello时间, 要求必须一致. 所以一端改了, 另一端也是需要进行更改的.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HQ(config)<span class="comment">#int e0/0</span></span><br><span class="line">HQ(config-if)<span class="comment">#ip ospf hello-interval 15</span></span><br><span class="line">HQ(config-if)<span class="comment">#end</span></span><br><span class="line">*Sep 22 14:18:07.735: %OSPF-5-ADJCHG: Process 1, Nbr 1.1.1.1 on Ethernet0/0 from LOADING to FULL, Loading Done</span><br><span class="line">HQ<span class="comment">#sh ip ospf nei</span></span><br><span class="line"></span><br><span class="line">Neighbor ID     Pri   State           Dead Time   Address         Interface</span><br><span class="line">1.1.1.1           1   FULL/BDR        00:00:58    172.16.1.1      Ethernet0/0</span><br></pre></td></tr></table></figure><p>这样就可以了. (虽然默认死亡时间是Hello时间的4倍, 但是我们也是可以进行设置的, 同理,两端也要一致</p><p>由一个很重要的东西没有提到, 那就是区域. 这个玩意决定着邻居的发现和建立关系, 必须一致才行.</p><h2 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h2><p>都到RIP了, 这个文章终于快结束了, 好开心. 做了这么多的实验. 虽然我觉得没有什么意思…(好吧, 其实我觉得我走错路了, 玩这些东西简直就是在浪费我的时间啊. 还是老老实实去看我的Linux运维吧..我又不搞这些JB东西…不过呢..写都写了, 不如就把这篇完成掉,收个好尾好了. 做完RIP的实验之后就只剩VPN的实施和ACL了. 把这些结束, 我就继续更新Linux的文章啦!)</p><p>OK, 还是像往常一样, 把我们的实验拓扑图拿出来~~:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/rip.png" alt="rip"></p><p>其实和上面的OSPF的图是一样的啦, 这次我不使用OSPF而是使用RIP来实施路由. 这样来操作:<br>Branch:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#router rip</span></span><br><span class="line">Branch(config-router)<span class="comment">#version 2</span></span><br><span class="line">Branch(config-router)<span class="comment">#no auto-summary </span></span><br><span class="line">Branch(config-router)<span class="comment">#passive-interface default</span></span><br><span class="line">Branch(config-router)<span class="comment">#network 172.16.1.0</span></span><br><span class="line">Branch(config-router)<span class="comment">#network 192.168.1.0</span></span><br><span class="line">Branch(config-router)<span class="comment">#neighbor 172.16.1.2</span></span><br><span class="line">Branch(config-router)<span class="comment">#^Z</span></span><br></pre></td></tr></table></figure><p>HQ:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HQ(config)<span class="comment">#router rip</span></span><br><span class="line">HQ(config-router)<span class="comment">#version 2</span></span><br><span class="line">HQ(config-router)<span class="comment">#no auto-summary </span></span><br><span class="line">HQ(config-router)<span class="comment">#passive-interface default </span></span><br><span class="line">HQ(config-router)<span class="comment">#netwo 192.168.2.0</span></span><br><span class="line">HQ(config-router)<span class="comment">#netwo 172.16.1.0</span></span><br><span class="line">HQ(config-router)<span class="comment">#nei 172.16.1.1</span></span><br><span class="line">HQ(config-router)<span class="comment">#end</span></span><br></pre></td></tr></table></figure><p>接下来就行了, 这就是RIP最经典的配置了. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PC1<span class="comment">#ping 192.168.2.100</span></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.2.100, <span class="built_in">timeout</span> is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 5/5/6 ms</span><br></pre></td></tr></table></figure><p>我们说过RIPv1和v2是不兼容的, 但是就是要折腾一下才好玩嘛, 现在我们把一端的版本改成1版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HQ(config)<span class="comment">#router rip</span></span><br><span class="line">HQ(config-router)<span class="comment">#version 1</span></span><br><span class="line">HQ(config-router)<span class="comment">#no passive-interface default</span></span><br></pre></td></tr></table></figure><p>另外一边也把接口调整一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#router rip</span></span><br><span class="line">Branch(config-router)<span class="comment">#no passive-interface default </span></span><br></pre></td></tr></table></figure><p>现在我们来查看一下两方的路由协议信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Branch<span class="comment">#sh ip protocols </span></span><br><span class="line">...(omitted)</span><br><span class="line">Routing Protocol is <span class="string">&quot;rip&quot;</span></span><br><span class="line">  Outgoing update filter list <span class="keyword">for</span> all interfaces is not <span class="built_in">set</span></span><br><span class="line">  Incoming update filter list <span class="keyword">for</span> all interfaces is not <span class="built_in">set</span></span><br><span class="line">  Sending updates every 30 seconds, next due <span class="keyword">in</span> 3 seconds</span><br><span class="line">  Invalid after 180 seconds, hold down 180, flushed after 240</span><br><span class="line">  Redistributing: rip</span><br><span class="line">  Neighbor(s):</span><br><span class="line">    172.16.1.2</span><br><span class="line">  Default version control: send version 2, receive version 2</span><br><span class="line">    Interface             Send  Recv  Triggered RIP  Key-chain</span><br><span class="line">    Ethernet0/0           2     2                                    </span><br><span class="line">    Ethernet0/1           2     2         </span><br><span class="line">    ..(omitted)</span><br></pre></td></tr></table></figure><p>如你所见, Branch这边接受版本2, 发送版本2. 那么猜也能猜出来了, HQ那边是指接受和发送版本1的报文了, 这样两人是没有办法建立关系的. 但是我们可以使用命令来使得某一个接口接受特定版本的报文从而解决兼容问题.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#int r e0/0 -1</span></span><br><span class="line">Branch(config-if-range)<span class="comment">#ip rip send version 1 2</span></span><br><span class="line">Branch(config-if-range)<span class="comment">#ip rip re version 1 2 </span></span><br></pre></td></tr></table></figure><p>现在其实已经通了. 因为由一方是两种版本都可使用的.</p><p>我们在实验时关闭了自动汇总功能, 这个汇总其实就是我们说的路由汇总啦.</p><h2 id="PAP认证"><a href="#PAP认证" class="headerlink" title="PAP认证"></a>PAP认证</h2><p>实验拓扑异常简单:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ppp.png" alt="ppp"></p><p>其实只是为了展示一下PPP而已嘛</p><p>HQ一端做这样的处理:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HQ<span class="comment">#conf ter</span></span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">HQ(config)<span class="comment">#int s2/0</span></span><br><span class="line">HQ(config-if)<span class="comment">#no sh</span></span><br><span class="line">HQ(config-if)<span class="comment">#ip addr 202.10.100.10 255.255.255.0</span></span><br><span class="line">HQ(config-if)<span class="comment">#encapsulation ppp</span></span><br><span class="line">HQ(config-if)<span class="comment">#</span></span><br><span class="line">*Sep 23 05:45:18.209: %LINK-3-UPDOWN: Interface Serial2/0, changed state to up</span><br><span class="line">HQ(config-if)<span class="comment">#ppp authentication pap</span></span><br><span class="line">HQ(config-if)<span class="comment">#exi</span></span><br><span class="line">HQ(config)<span class="comment">#username justin password justin</span></span><br><span class="line">HQ(config)<span class="comment">#service password-encryption </span></span><br><span class="line">HQ(config)<span class="comment">#end</span></span><br></pre></td></tr></table></figure><p>接着另外一端:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Branch(config)<span class="comment">#in s2/0</span></span><br><span class="line">Branch(config-if)<span class="comment">#no sh</span></span><br><span class="line">Branch(config-if)<span class="comment">#ip addr 202.102</span></span><br><span class="line">*Sep 23 05:47:05.729: %LINK-3-UPDOWN: Interface Serial2/0, changed state to up</span><br><span class="line">*Sep 23 05:47:06.729: %LINEPROTO-5-UPDOWN: Line protocol on Interface Serial2/0, changed state to up</span><br><span class="line">Branch(config-if)<span class="comment">#ip addr 202.10.100.20 255.255.255.0</span></span><br><span class="line">Branch(config-if)<span class="comment">#en</span></span><br><span class="line">Branch(config-if)<span class="comment">#encapsulation ppp</span></span><br><span class="line">*Sep 23 05:47:23.553: %LINEPROTO-5-UPDOWN: Line protocol on Interface Serial2/0, changed state to down</span><br><span class="line">Branch(config-if)<span class="comment">#ppp pap sent-username justin password justi </span></span><br><span class="line"><span class="comment"># 这里我故意输错密码</span></span><br><span class="line">Branch(config-if)<span class="comment">#ppp pap sent-username justin password justin</span></span><br><span class="line">Branch(config-if)<span class="comment">#</span></span><br><span class="line">*Sep 23 05:48:32.410: %LINEPROTO-5-UPDOWN: Line protocol on Interface Serial2/0, changed state to up</span><br><span class="line">Branch(config-if)<span class="comment">#end</span></span><br><span class="line">Branch<span class="comment">#</span></span><br><span class="line">*Sep 23 05:48:48.907: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line">Branch<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>我在另外一端打开了debug调试, 于是在收到了错误的密码之后, 信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*Sep 23 05:48:30.334: Se2/0 PPP: Using default call direction</span><br><span class="line">*Sep 23 05:48:30.334: Se2/0 PPP: Treating connection as a dedicated line</span><br><span class="line">*Sep 23 05:48:30.334: Se2/0 PPP: Session handle[3400000F] Session <span class="built_in">id</span>[15]</span><br><span class="line">*Sep 23 05:48:30.354: Se2/0 PAP: I AUTH-REQ <span class="built_in">id</span> 1 len 17 from <span class="string">&quot;justin&quot;</span></span><br><span class="line">*Sep 23 05:48:30.354: Se2/0 PAP: Authenticating peer justin</span><br><span class="line">*Sep 23 05:48:30.354: Se2/0 PPP: Sent PAP LOGIN Request</span><br><span class="line">*Sep 23 05:48:30.354: Se2/0 PPP: Received LOGIN Response FAIL</span><br><span class="line">*Sep 23 05:48:30.354: Se2/0 PAP: O AUTH-NAK <span class="built_in">id</span> 1 len 26 msg is <span class="string">&quot;Authentication failed&quot;</span></span><br></pre></td></tr></table></figure><p>密码正确之后, 双方都显示接口up, 并且:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*Sep 23 05:48:32.386: Se2/0 PPP: Using default call direction</span><br><span class="line">*Sep 23 05:48:32.386: Se2/0 PPP: Treating connection as a dedicated line</span><br><span class="line">*Sep 23 05:48:32.386: Se2/0 PPP: Session handle[39000010] Session <span class="built_in">id</span>[16]</span><br><span class="line">*Sep 23 05:48:32.402: Se2/0 PAP: I AUTH-REQ <span class="built_in">id</span> 1 len 18 from <span class="string">&quot;justin&quot;</span></span><br><span class="line">*Sep 23 05:48:32.402: Se2/0 PAP: Authenticating peer justin</span><br><span class="line">*Sep 23 05:48:32.403: Se2/0 PPP: Sent PAP LOGIN Request</span><br><span class="line">*Sep 23 05:48:32.403: Se2/0 PPP: Received LOGIN Response PASS</span><br><span class="line">*Sep 23 05:48:32.409: Se2/0 PAP: O AUTH-ACK <span class="built_in">id</span> 1 len 5</span><br></pre></td></tr></table></figure><h2 id="CHAP"><a href="#CHAP" class="headerlink" title="CHAP"></a>CHAP</h2><p>先来搞一个单向认证的, 十分简单:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/chap1.png" alt="chap1"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Router1(config)<span class="comment">#int s2/0</span></span><br><span class="line">Router1(config-if)<span class="comment">#no sh</span></span><br><span class="line">Router1(config-if)<span class="comment">#ip add</span></span><br><span class="line">*Sep 23 06:07:37.658: %LINK-3-UPDOWN: Interface Serial2/0, changed state to up</span><br><span class="line">*Sep 23 06:07:38.666: %LINEPROTO-5-UPDOWN: Line protocol on Interface Serial2/0, changed state to up</span><br><span class="line">Router1(config-if)<span class="comment">#ip addr 202.10.100.10 255.255.255.0</span></span><br><span class="line">Router1(config-if)<span class="comment">#encapsulation ppp</span></span><br><span class="line">Router1(config-if)<span class="comment">#ppp authn</span></span><br><span class="line">*Sep 23 06:07:56.329: %LINEPROTO-5-UPDOWN: Line protocol on Interface Serial2/0, changed state to down</span><br><span class="line">Router1(config-if)<span class="comment">#ppp authen chap</span></span><br><span class="line">Router1(config-if)<span class="comment">#exi     </span></span><br><span class="line">Router1(config)<span class="comment">#username justin password justin</span></span><br><span class="line">Router1(config)<span class="comment">#service password-encryption </span></span><br><span class="line">Router1(config)<span class="comment">#end</span></span><br></pre></td></tr></table></figure><p>同样这个时候我打开了debug, 可以看到.</p><p>在我们为Router2设置的时候, router1一直在尝试进行挑战:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*Sep 23 06:11:13.788: Se2/0 PPP: Using default call direction</span><br><span class="line">*Sep 23 06:11:13.788: Se2/0 PPP: Treating connection as a dedicated line</span><br><span class="line">*Sep 23 06:11:13.788: Se2/0 PPP: Session handle[72000027] Session <span class="built_in">id</span>[39]</span><br><span class="line">*Sep 23 06:11:13.822: Se2/0 CHAP: O CHALLENGE <span class="built_in">id</span> 1 len 28 from <span class="string">&quot;Router1&quot;</span></span><br></pre></td></tr></table></figure><p>接着当我们设置了正确的主机名和密码之后:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*Sep 23 06:14:23.736: Se2/0 PPP: Using default call direction</span><br><span class="line">*Sep 23 06:14:23.736: Se2/0 PPP: Treating connection as a dedicated line</span><br><span class="line">*Sep 23 06:14:23.736: Se2/0 PPP: Session handle[BE000047] Session <span class="built_in">id</span>[70]</span><br><span class="line">*Sep 23 06:14:23.773: Se2/0 CHAP: O CHALLENGE <span class="built_in">id</span> 1 len 28 from <span class="string">&quot;Router1&quot;</span></span><br><span class="line">*Sep 23 06:14:23.784: Se2/0 CHAP: I RESPONSE <span class="built_in">id</span> 1 len 27 from <span class="string">&quot;justin&quot;</span></span><br><span class="line">*Sep 23 06:14:23.784: Se2/0 PPP: Sent CHAP LOGIN Request</span><br><span class="line">*Sep 23 06:14:23.784: Se2/0 PPP: Received LOGIN Response PASS</span><br><span class="line">*Sep 23 06:14:23.790: Se2/0 CHAP: O SUCCESS <span class="built_in">id</span> 1 len 4</span><br><span class="line">Router1<span class="comment">#</span></span><br><span class="line">*Sep 23 06:14:23.790: %LINEPROTO-5-UPDOWN: Line protocol on Interface Serial2/0, changed state to up</span><br></pre></td></tr></table></figure><p>这是一个单向的认证. 十分简单.</p><p>接着我们来看看双向认证是个什么样子</p><p>其实是一样的, 就是把Router2也设置上用户和密码, 但是奇怪的事情发生了, 尽管我们把Router1也设置对了(发送主机名和密码) 但是.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Router1(config-if)<span class="comment">#</span></span><br><span class="line">*Sep 23 06:18:58.433: Se2/0 AUTH: Timeout 8</span><br><span class="line">*Sep 23 06:18:58.433: Se2/0 CHAP: O CHALLENGE <span class="built_in">id</span> 9 len 27 from <span class="string">&quot;justin&quot;</span></span><br><span class="line">*Sep 23 06:18:58.450: Se2/0 CHAP: I CHALLENGE <span class="built_in">id</span> 9 len 27 from <span class="string">&quot;justin&quot;</span></span><br><span class="line">*Sep 23 06:18:58.450: Se2/0 CHAP: Ignoring Challenge with <span class="built_in">local</span> name</span><br></pre></td></tr></table></figure><p>另外一边:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Router2(config-if)<span class="comment">#</span></span><br><span class="line">*Sep 23 06:19:08.457: Se2/0 AUTH: Timeout 9</span><br><span class="line">*Sep 23 06:19:08.457: Se2/0 CHAP: O CHALLENGE <span class="built_in">id</span> 10 len 27 from <span class="string">&quot;justin&quot;</span></span><br><span class="line">*Sep 23 06:19:08.457: Se2/0 CHAP: I CHALLENGE <span class="built_in">id</span> 10 len 27 from <span class="string">&quot;justin&quot;</span></span><br><span class="line">*Sep 23 06:19:08.457: Se2/0 CHAP: Ignoring Challenge with <span class="built_in">local</span> name</span><br></pre></td></tr></table></figure><p>都在疯狂的超时, 奇怪. 我们确认一下配置: (为了确认效果, 暂时把password-encryption的服务撤掉)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Router1<span class="comment">#sh run int s2/0</span></span><br><span class="line">Building configuration...</span><br><span class="line"></span><br><span class="line">Current configuration : 197 bytes</span><br><span class="line">!</span><br><span class="line">interface Serial2/0</span><br><span class="line"> ip address 202.10.100.10 255.255.255.0</span><br><span class="line"> encapsulation ppp</span><br><span class="line"> ppp authentication chap</span><br><span class="line"> ppp chap hostname justin</span><br><span class="line"> ppp chap password 0 justin</span><br><span class="line"> serial restart-delay 0</span><br><span class="line">end</span><br><span class="line">---------</span><br><span class="line">Router2<span class="comment">#sh run int s2/0</span></span><br><span class="line">Building configuration...</span><br><span class="line"></span><br><span class="line">Current configuration : 197 bytes</span><br><span class="line">!</span><br><span class="line">interface Serial2/0</span><br><span class="line"> ip address 202.10.100.20 255.255.255.0</span><br><span class="line"> encapsulation ppp</span><br><span class="line"> ppp authentication chap</span><br><span class="line"> ppp chap hostname justin</span><br><span class="line"> ppp chap password 0 justin</span><br><span class="line"> serial restart-delay 0</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>奇怪, 确认了也没有问题, 难道是用户名不能一样吗?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router2(config)<span class="comment">#username bieber password justin</span></span><br></pre></td></tr></table></figure><p>接着:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router1(config-if)<span class="comment">#ppp chap hostname bieber</span></span><br></pre></td></tr></table></figure><p>突然之间:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*Sep 23 06:28:19.557: Se2/0 CHAP: O CHALLENGE <span class="built_in">id</span> 9 len 27 from <span class="string">&quot;justin&quot;</span></span><br><span class="line">*Sep 23 06:28:19.558: Se2/0 CHAP: I CHALLENGE <span class="built_in">id</span> 9 len 27 from <span class="string">&quot;bieber&quot;</span></span><br><span class="line">*Sep 23 06:28:19.558: Se2/0 PPP: Sent CHAP SENDAUTH Request</span><br><span class="line">*Sep 23 06:28:19.558: Se2/0 PPP: Received SENDAUTH Response PASS</span><br><span class="line">*Sep 23 06:28:19.558: Se2/0 CHAP: Using hostname from interface CHAP</span><br><span class="line">*Sep 23 06:28:19.558: Se2/0 CHAP: Using password from AAA</span><br><span class="line">*Sep 23 06:28:19.558: Se2/0 CHAP: O RESPONSE <span class="built_in">id</span> 9 len 27 from <span class="string">&quot;justin&quot;</span></span><br><span class="line">*Sep 23 06:28:19.564: Se2/0 CHAP: I RESPONSE <span class="built_in">id</span> 9 len 27 from <span class="string">&quot;bieber&quot;</span></span><br><span class="line">*Sep 23 06:28:19.564: Se2/0 PPP: Sent CHAP LOGIN Request</span><br><span class="line">*Sep 23 06:28:19.564: Se2/0 PPP: Received LOGIN Response PASS</span><br><span class="line">*Sep 23 06:28:19.570: Se2/0 CHAP: O SUCCESS <span class="built_in">id</span> 9 len 4</span><br><span class="line">*Sep 23 06:28:19.575: Se2/0 CHAP: I SUCCESS <span class="built_in">id</span> 9 len 4</span><br><span class="line">Router2<span class="comment">#</span></span><br><span class="line">*Sep 23 06:28:19.576: %LINEPROTO-5-UPDOWN: Line protocol on Interface Serial2/0, changed state to up</span><br></pre></td></tr></table></figure><p>连密码都不需要输入, 接口工作了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> CCNA </tag>
            
            <tag> Cisco IOS </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenSSH和其配置</title>
      <link href="/2017/09/13/OpenSSH%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/09/13/OpenSSH%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>一直都在使用OpenSSH这个玩意儿连接我们的Linux, 该仔细看一看他噜~</p><span id="more"></span><h2 id="SSH概述"><a href="#SSH概述" class="headerlink" title="SSH概述"></a>SSH概述</h2><p>首先我们知道, SSH(secure shell)是一个协议, 也就是一个规范. 默认监听在22&#x2F;tcp端口, 提供安全的远程登录功能, 而OpenSSH就是一个开源实现.</p><p>在机房几百几千台服务器, 我们不可能一个一个都去配置上显示器, 所以就想办法通过网络来进行连接. 这里我们所连接上的就是远程终端. 要把对方显示的结果显示到我们本地的显示器上, 并且通过本地键盘键入命令, 获得远程执行的结果. 包括我们在登录时输入的账号和密码, 都需要通过网络来传输. 因此默认情况下, 原本本地的终端使用<code>mingetty</code>来附加上一个<code>login</code>程序, 来让用户登录. BUT! mingetty并没有能使得远程管理的功能. 因此我们就需要在服务器(远程终端)执行一个服务端程序来将本地的基于终端的请求通过某种特定的协议映射到需要交换的对象上. 这也是C&#x2F;S架构的一个应用. </p><p>早期, 上述的实现是使用的telnet. 两地终端通过telnet协议进行通信. telnet同样使用tcp, 但它监听在23端口. telnet没有涉及任何加密, 所以所有的数据都是明文传输, 这是相当于不安全的. 于是telnet的后继者ssh就出现了. 并且解决了除了远程登录的诸多功能.</p><p>在一台CentOS6的机器上实验, 注意, 这个telnet服务属于是<strong>超级守护进程的瞬时激活进程</strong> (不知道这样说对不对?) 也就是由xinetd统一管理的进程之一, xinetd有点像我们之前说的systemd的socket激活机制, 按需激活的机制. 所以我们只要启动xinetd服务即可.</p><p>有关SSH安全机制在 <a href="https://yaoxuannn.com/2017/04/04/%E5%AF%B9SSL-TLS%E7%9A%84%E7%90%86%E8%A7%A3/#%E8%A1%A5%E5%85%85-SSH-Secure-Shell-%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B">补充-SSH-Secure-Shell-的原理和处理过程</a> 说过一点.</p><p>OpenSSH也是C&#x2F;S架构的, 我们的服务器端就叫做: sshd, 而对于客户端则直接叫做: ssh, 并且还有scp这样的工具, 还有sftp这样的子系统.</p><h2 id="SSH命令和配置"><a href="#SSH命令和配置" class="headerlink" title="SSH命令和配置"></a>SSH命令和配置</h2><h3 id="SSH命令"><a href="#SSH命令" class="headerlink" title="SSH命令"></a>SSH命令</h3><p>直接man一下ssh, 其实支持的功能还是蛮多的. 最简单的方法就直接在后面加上主机名就行了. 用户名是可以省略的, 会使用当前系统登录的用户作为默认用户来登录. 除了默认的user@hostname, 也可以使用**-l**来指定user, 也就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -l root 192.168.100.10 <span class="comment"># 就等价于ssh root@192.168.100.10</span></span><br></pre></td></tr></table></figure><p>另外一个很重要的属性是**-p**, 后面指定port. 这个属性通常很有用, 因为作为ssh的安全措施之一就是不使用ssh的默认22号端口. (为什么?因为这不是一个公开服务.)  其他的就不多了.</p><p>但是这里再说一个有意思, 使用SSH进行<strong>隧道建立</strong>以及<strong>内网穿透</strong>.</p><p>首先我们说几个有用的参数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-f 需要和下面的-N进行连用, 意思是说让ssh在后台运行</span><br><span class="line">-N 如果没有加上-f参数会堵塞终端(在前台滞留)</span><br><span class="line">-g 加上这个参数表示允许外部主机进行连接, 否则只允许localhost</span><br><span class="line">-C 压缩数据传输 </span><br><span class="line">-L 本地转发到远端, 可以用来越过防火墙.</span><br><span class="line">-R 远端转发到本地, 可以用于内网的穿透</span><br></pre></td></tr></table></figure><p>比如, 下面的这个例子. 主机A(139.199.XX.130)这个IP是一个公网IP, 小明在寝室使用实验室的代理主机B(59.68.XX.126)连接互联网, 但是由于校园网的防火墙配置使得小明无法使用ssh,ping等访问到校园网以外的网络. 于是小明原来可以先登录到代理主机B, 接着在代理主机B上进行操作登录到主机A. 但是这样很麻烦, 于是小明在主机B上使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CfNg -L 10022:localhost:1022 root@139.199.XX.130 -p 1022</span><br></pre></td></tr></table></figure><p> 搭建了一条SSH转发隧道. 也就是当ssh连接主机B的10022端口的时候, 会被转发到目标主机的1022端口上. 意思就是说在代理主机B上创建了一个端口为10022的套接字, 当有ssh连接请求到这个套接字的时候, 就会将接下来的请求转发到位于主机A的1022那个端口上(说到这里你也就知道了, 都能够进行端口转发了. 其实还有别的用处, 比如说进行穿透的ftp服务访问等等..)</p><p>另外, 小红在实验室遇到了一个问题, 他想让小明远程连接过来帮他解决, 但是实验室内网没有建立VPN, 由于小红能够访问到处在公网的小明. 所以小红就想到使用ssh建立一条隧道, 使得小明能够直接连接进来. 这样该怎么做呢? 反过来建立的方法是这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CfNg -R 10022:localhost:1022 root@139.199.XX.130 -p 1022</span><br></pre></td></tr></table></figure><p>唯一的区别就在于那个参数的改变, 使得监听套接字的创建换成了另外一台主机.</p><p><strong>注意: 这个实验成功的一个注意点是你的iptables设定. 另外直接这么开着一条隧道是一件十分危险的事情! 请务必把他关闭, 或者添加安全措施(增加专用用户等等)</strong></p><h3 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h3><p>客户端的ssh配置文件在<code>/etc/ssh/ssh_config</code>上 而服务器端的就在同一目录下的<code>sshd_config</code>里. 首先我们看一下客户端的咯. </p><p>文件中定义了对于一个特定的Host使用什么样的配置, 而默认的*就是所有主机. 基本上默认的值我们无需进行定制. 其中有一个叫<code>StrictHostKeyChecking</code>的配置, 意思是说是否进行严格主机密钥检查. 如果将该值从ask改为no, 就不会出现询问是否添加RSAkey的消息了, 会直接进行写入. 另外一个常用的值就是port了, 这样在换端口了之后就不需要再每次连接的时候加上-p参数了.</p><blockquote><p><strong>基于密钥的SSH登录</strong> </p><p>每次输入密码有点麻烦, 所以我们不如配个公私钥来免密码登录.</p><p>首先我们需要在本地生成密钥:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># ssh-keygen -t rsa -P &quot;&quot; -f &quot;/root/.ssh/id_rsa&quot;</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line"><span class="built_in">fc</span>:14:0a:bb:22:81:f7:74:21:2c:2a:c7:f4:a5:19:25 root@WWW</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+--[ RSA 2048]----+</span></span><br><span class="line"><span class="string">|    E .          |</span></span><br><span class="line"><span class="string">|   . o           |</span></span><br><span class="line"><span class="string">|  o + +   .      |</span></span><br><span class="line"><span class="string">| = o * = . .     |</span></span><br><span class="line"><span class="string">|+ = = o S .      |</span></span><br><span class="line"><span class="string">|.o + . . o       |</span></span><br><span class="line"><span class="string">|  . o .   .      |</span></span><br><span class="line"><span class="string">|   . .           |</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">+-----------------+</span></span><br><span class="line"><span class="string"># 如果希望得到交互式的结果,可以直接敲ssh-keygen就行了(不过还是建议起码加上-t rsa)</span></span><br></pre></td></tr></table></figure><p>得到了这一对密钥就可以继续. 我们把公钥发送出去. 怎么发送呢? OpenSSH提供了<code>ssh-copy-id</code>的工具帮助我们方便进行公钥的发送, 用法如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id [-n] [-i [identity_file]] [-p port] [-o ssh_option] [user@]hostname</span><br></pre></td></tr></table></figure><p>一般我们只需要指定-i就行了, 这个identity文件的寻找和默认的是不一样的,所以这个参数几乎是必须要加的.<br>添加过后会出现:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># ssh-copy-id -i .ssh/id_rsa.pub root@192.168.56.101</span></span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to <span class="built_in">log</span> <span class="keyword">in</span> with the new key(s), to filter out any that are already installed</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- <span class="keyword">if</span> you are prompted now it is to install the new keys</span><br><span class="line">root@192.168.56.101<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Number of key(s) added: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Now try logging into the machine, with:   &quot;ssh &#x27;</span>root@192.168.56.101<span class="string">&#x27;&quot;</span></span><br><span class="line"><span class="string">and check to make sure that only the key(s) you wanted were added.</span></span><br></pre></td></tr></table></figure><p>接着就可以直接进行免密登陆了.</p></blockquote><p>接着我们再插着所以下之前提到的SCP命令. 这个SCP的意思其实就是secure copy, 也就是说基于SSH进行跨主机的文件传输, 其有两种模式: PULL和PUSH.(和你git的那两个差不多) </p><p>使用起来也很简单:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [options] SRC... DEST/</span><br></pre></td></tr></table></figure><p>存在两种情形所以命令是不一样的, 如果是PULL(拉取服务器数据保存到本地) :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [options] [user@]host:/PATH/FROM/FILE /PATH/TO/SOMEWHERE</span><br></pre></td></tr></table></figure><p>而PUSH(将本地的文件推送到远端主机上)呢?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [options] /PATH/TO/FILE [user@]host:/PATH/TO/SOMEWHERE</span><br></pre></td></tr></table></figure><p>常用的选项有这些:</p><ul><li><strong>-r</strong>: 递归复制</li><li><strong>-p</strong>: 保持源文件的属性信息</li><li><strong>-q</strong>: 静默模式</li><li><strong>-P port</strong>: 远端主机监听的port</li></ul><p>更厉害的是我们的<code>sftp</code> , 他甚至可以像在自己机器上面一样可以做各种各种的事情(当然前提是有权限), 包括制作连接, 进行权限设定啥的.</p><p>OK, 现在就来说一说服务器端的配置文件吧. 这个文件的价值个人觉得是很大的.</p><p>和一般的配置文件相同, 井号开头不加空格的就是可启用的配置项, 加空格的就是注释. </p><p>看一下有哪些配置项吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Port 20022 <span class="comment"># 一般为了安全我们不会使用默认的22端口</span></span><br><span class="line"><span class="comment">#AddressFamily any # 表示监听IPv4还是IPv6, 还是都监听.</span></span><br><span class="line">ListenAddress 192.168.56.101 <span class="comment"># 由于是服务器, 所以可能会有多网卡多地址, 一般这里都会设置成内网监听</span></span><br><span class="line"><span class="comment">#ListenAddress ::</span></span><br><span class="line">SyslogFacility AUTHPRIV <span class="comment"># 这个就是我们之前说过的, 日志记录</span></span><br><span class="line">LoginGraceTime 2m <span class="comment"># 登录的宽限时间, 也就是一直不输入密码结果就断开连接的那个时间间隔</span></span><br><span class="line">PermitRootLogin no <span class="comment"># 是否允许root用户直接登录, 一般改成no比较安全</span></span><br><span class="line">MaxAuthTries 6 <span class="comment"># 最大的尝试次数, 一定程度上可以防止暴力破解</span></span><br><span class="line">MaxSessions 10 <span class="comment"># 最大的并行登录</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span> <span class="comment"># 是否允许使用公钥验证, 当然是允许的啦</span></span><br><span class="line">AuthorizedKeysFile      .ssh/authorized_keys <span class="comment"># 这个就是在定义我们的生成的公钥的放置地方</span></span><br><span class="line">PasswordAuthentication <span class="built_in">yes</span> <span class="comment"># 是否允许密码登录</span></span><br><span class="line">X11Forwarding <span class="built_in">yes</span> <span class="comment"># 是否支持X11转发, 是否允许在远端进行图像化</span></span><br><span class="line">Subsystem       sftp    /usr/libexec/openssh/sftp-server <span class="comment"># 是否启动sftp的子系统</span></span><br></pre></td></tr></table></figure><p><strong>在实验中请把SELINUX的状态改成Permissive或者直接关闭, 否则端口改变会失效.</strong></p><p>值得一提的是, ssh服务端的一个配置项: <code>UseDNS yes</code> 意思是说是否使用DNS反向解析, 默认是打开的, 这会消耗巨量的时间. 短则几十秒, 长则几分钟 因此我们应该将这个关闭.</p><h2 id="SSH服务的最佳实践"><a href="#SSH服务的最佳实践" class="headerlink" title="SSH服务的最佳实践"></a>SSH服务的最佳实践</h2><ul><li><p>不使用默认的端口</p></li><li><p>禁止使用protocol version 1</p></li><li><p>限制可登录用户</p></li><li><p>有两个属性叫做AllowUsers和AllowGroups可以用来做白名单, 反之还有黑名单. <strong>注意, 当你两个都设置的时候, ssh会取两者的交集(就是说:当你允许root和用户test登录, 但是只允许root组登录的时候, test依旧会被拒绝.)</strong></p></li><li><p>设定空闲会话超时时长</p></li><li><p>利用防火墙设置ssh的访问策略</p></li><li><p>仅监听特定的IP地址</p></li><li><p>基于口令认证的时候, 使用强密码策略 ( 一个生成随机数密码的小技巧 )</p><ul><li><pre><code class="bash">tr -cd a-zA-Z0-9_ &lt; /dev/urandom | head -c 30 | xargs<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*  使用基于密钥的验证</span><br><span class="line"></span><br><span class="line">*  禁止使用空密码</span><br><span class="line"></span><br><span class="line">*  禁止root用户直接登录</span><br><span class="line"></span><br><span class="line">*  限制ssh的访问频度, 和同并发数量限制</span><br><span class="line"></span><br><span class="line">*  做好日志记录, 保存在日志服务器上</span><br><span class="line"></span><br><span class="line">*  经常分析记录</span><br><span class="line"></span><br><span class="line">## OpenSSL和CA相关</span><br><span class="line"></span><br><span class="line">我们之前已经说了好大一会openssl这个东西了, 但是当时就草草的随意提了下关于证书的种种. 今天就在这里详细说一下关于CA和证书的事情.</span><br><span class="line"></span><br><span class="line">[OpenSSL初识](https://yaoxuannn.com/2017/09/08/OpenSSL%E5%88%9D%E8%AF%86%E4%B8%8E%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/)</span><br><span class="line"></span><br><span class="line">我们之前提到过 有一个实现现代互联网安全使得最根本的保证, 叫做PKI, 全称是Public Key Infrastructure. 也就是公钥基础设施. 主要有下面几个成分组成, 也就是CA(发证机构), RA(注册机构), CRL(吊销列表), 证书存取库. 其中CA是非常重要的, 而注册机构也是需要发给CA, 然后由CA做签名的.  但是总不能一直都支付那么高的费用, 例如, 日后我需要建立VPN来连接机构组织的内网, 由于这个VPN需要验证而且他本身就是用在我们这个组织内部的, 所以我们可以使用**内部证书**, 或者说**私有证书**, 这种感觉就好像是银行所使用的某某盾, 某某通行证啥的, 这些东西只有在银行内部才能够使用 如果每一个客户的支付通行证都是购买的证书的话, 那开销也太大了.</span><br><span class="line"></span><br><span class="line">建立私有CA, 已经可以满足我们的需要了. 建立私有CA, 有很多专门的工具来做到, 其中由一个非常著名的实现叫做OpenCA, 但是过于复杂和专业, 所以我们使用openssl来实现. 其实OpenCA就是对openssl的高度抽象来实现更多强大的功能. 下面就来说怎么建立私有CA.</span><br><span class="line"></span><br><span class="line">首先就要先了解一下我们的证书申请和签署步骤:</span><br><span class="line"></span><br><span class="line">* 生成申请请求: 提供主机名以及一些唯一标识, 如果是主机间通信的话, 还应该有主机所属的组织, 邮箱地址等等. 这些信息RA会进行核验, 所以一定要写真实的.</span><br><span class="line">* 接着就是RA的核验</span><br><span class="line">* 接着交给CA做签署</span><br><span class="line">* 最后获取证书</span><br><span class="line"></span><br><span class="line">如何创建私有证书? openssl自己就可以进行证书的签署以及吊销他们. 我们来看看如何操作的:</span><br><span class="line"></span><br><span class="line">他的配置文件在: `/etc/pki/tls/openssl.cnf` 这是作为CA时用到的默认配置文件.  其中我们只要先关注CA的部分就行:</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">[ CA_default ]</span><br><span class="line"></span><br><span class="line">dir             = /etc/pki/CA           # Where everything is kept</span><br><span class="line">certs           = $dir/certs            # Where the issued certs are kept 已签署的证书</span><br><span class="line">crl_dir         = $dir/crl              # Where the issued crl are kept 吊销列表</span><br><span class="line">database        = $dir/index.txt        # database index file. 索引文件, 已签署的</span><br><span class="line">#unique_subject = no                    # Set to &#x27;no&#x27; to allow creation of 证书的信息是否可一致</span><br><span class="line">                                        # several ctificates with same subject.</span><br><span class="line">new_certs_dir   = $dir/newcerts         # default place for new certs. 签署过程中的存放位置</span><br><span class="line">certificate     = $dir/cacert.pem       # The CA certificate CA自己的证书</span><br><span class="line">serial          = $dir/serial           # The current serial number 序列号</span><br><span class="line">crlnumber       = $dir/crlnumber        # the current crl number</span><br><span class="line">                                        # must be commented out to leave a V1 CRL</span><br><span class="line">crl             = $dir/crl.pem          # The current CRL</span><br><span class="line">private_key     = $dir/private/cakey.pem# The private key</span><br><span class="line">RANDFILE        = $dir/private/.rand    # private random number file</span><br><span class="line">...(omitted)</span><br><span class="line">default_days    = 365                   # how long to certify for 证书的有效期</span><br><span class="line">default_crl_days= 30                    # how long before next CRL 吊销列表的有效期限</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>后面的注释写的也很清楚了. 这里定义了很多工作目录的位置, 比如说第一个cert就是存放已经签署过的证书所在地. 而总的dir在最一开始进行定义: &#x2F;<code>/etc/pki/CA</code> 我们进去看一看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW CA]<span class="comment"># ls</span></span><br><span class="line">certs  crl  newcerts  private</span><br></pre></td></tr></table></figure><p>缺少了很多东西, 所以第一步我们就需要<strong>创建所需要的文件和准备序列号</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW CA]<span class="comment"># touch index.txt</span></span><br><span class="line">[root@WWW CA]<span class="comment"># echo &quot;01&quot; &gt; serial</span></span><br></pre></td></tr></table></figure><p>第二步, 我们先要给CA签署证书, 也就是<strong>自签</strong>.  要想得到证书, 我们就要先生成密钥对. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW CA]<span class="comment"># (umask 077; openssl genrsa -out private/cakey.pem 2048)</span></span><br><span class="line">Generating RSA private key, 2048 bit long modulus</span><br><span class="line">............................+++</span><br><span class="line">...........................+++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">[root@WWW CA]<span class="comment"># ls -l private/</span></span><br><span class="line">total 4</span><br><span class="line">-rw------- 1 root root 1675 Sep 14 03:45 cakey.pem</span><br></pre></td></tr></table></figure><p>这样就生成了私钥, 接着就应该提取公钥了, 但是现在我们可以不使用pubout了, 可以直接使用openssl提供的req工具. 使用下面的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW CA]<span class="comment"># openssl req -new -x509 -key private/cakey.pem -days 7300 -out cacert.pem</span></span><br><span class="line"><span class="comment"># 这里的-x509只有在进行自签的时候才会用到.</span></span><br><span class="line"><span class="comment"># -new 生成新证书的意思啦</span></span><br><span class="line"><span class="comment"># -days 可用的天数</span></span><br><span class="line"><span class="comment"># -out 输出的证书文件保存路径</span></span><br></pre></td></tr></table></figure><p>接着就是第三步了, <strong>发证</strong></p><p>其中也需要几个小步骤: 首先需要用到证书的主机发出生成证书请求. 把请求文件传输给CA. CA确认没有问题之后就直接签署证书发还给请求者.</p><p>所以现在我们的主机已经是一台CA了. 那么现在我们启动另外一台主机, 像我们这台主机发起证书请求.</p><p>就以httpd来做这个实验:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># cd /etc/httpd/</span></span><br><span class="line">[root@WWW httpd]<span class="comment"># mkdir ssl</span></span><br><span class="line">[root@WWW httpd]<span class="comment"># cd ssl/</span></span><br><span class="line">[root@WWW ssl]<span class="comment"># (umask 077; openssl genrsa -out httpd.key 2048)</span></span><br><span class="line">Generating RSA private key, 2048 bit long modulus</span><br><span class="line">.................................................+++</span><br><span class="line">...............................................................................+++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">[root@WWW ssl]<span class="comment"># ls</span></span><br><span class="line">httpd.key</span><br><span class="line">[root@WWW ssl]<span class="comment"># openssl req -new -key httpd.key -days 3650 -out httpd.csr</span></span><br><span class="line">[root@WWW ssl]<span class="comment"># ls</span></span><br><span class="line">httpd.csr  httpd.key</span><br><span class="line">[root@WWW ssl]<span class="comment"># scp httpd.csr root@192.168.56.101:/tmp/</span></span><br><span class="line">httpd.csr                  100% 1009     1.0KB/s   00:00    </span><br></pre></td></tr></table></figure><p>好了现在, 我们就已经将证书请求发送到目标CA了, 接着回到目标CA所在的主机:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW tmp]<span class="comment"># openssl ca -in httpd.csr -out httpd.crt -days 3650</span></span><br><span class="line">Using configuration from /etc/pki/tls/openssl.cnf</span><br><span class="line">Check that the request matches the signature</span><br><span class="line">Signature ok</span><br><span class="line">Certificate Details:</span><br><span class="line">        Serial Number: 1 (0x1)</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Sep 14 08:25:28 2017 GMT</span><br><span class="line">            Not After : Sep 12 08:25:28 2027 GMT</span><br><span class="line">        Subject:</span><br><span class="line">            countryName               = CN</span><br><span class="line">            stateOrProvinceName       = Hubei</span><br><span class="line">            organizationName          = Default Company Ltd</span><br><span class="line">            commonName                = WWW</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Basic Constraints: </span><br><span class="line">                CA:FALSE</span><br><span class="line">            Netscape Comment: </span><br><span class="line">                OpenSSL Generated Certificate</span><br><span class="line">            X509v3 Subject Key Identifier: </span><br><span class="line">                0C:7B:43:97:E2:92:A8:A4:82:DF:4F:C0:DC:A0:CE:E4:9B:6B:A3:FD</span><br><span class="line">            X509v3 Authority Key Identifier: </span><br><span class="line">                keyid:72:62:EE:58:34:DA:FA:35:BC:DE:53:54:79:E4:25:17:B7:E4:69:CC</span><br><span class="line"></span><br><span class="line">Certificate is to be certified <span class="keyword">until</span> Sep 12 08:25:28 2027 GMT (3650 days)</span><br><span class="line">Sign the certificate? [y/n]:y</span><br><span class="line"></span><br><span class="line">1 out of 1 certificate requests certified, commit? [y/n]y</span><br><span class="line">Write out database with 1 new entries</span><br><span class="line">Data Base Updated</span><br></pre></td></tr></table></figure><p>这样就签署完成了, 并且生成了证书文件. 同时我们注意到最后一行: 数据库更新. 那么来看一下index.txt吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW tmp]<span class="comment"># cat /etc/pki/CA/index.txt</span></span><br><span class="line">V270912082528Z01unknown/C=CN/ST=Hubei/O=Default Company Ltd/CN=WWW</span><br></pre></td></tr></table></figure><p>01号签署证书, 后面还有各种记录. 而新生成的证书就保存了一份到newcerts目录. 其实就是和我们out出来的httpd.crt同一个文件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW newcerts]<span class="comment"># cd /etc/pki/CA/newcerts/</span></span><br><span class="line">[root@WWW newcerts]<span class="comment"># ls</span></span><br><span class="line">01.pem</span><br><span class="line">[root@WWW newcerts]<span class="comment"># diff 01.pem /tmp/httpd.crt</span></span><br><span class="line">[root@WWW newcerts]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>接下来我们把证书发还给客户端.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW newcerts]<span class="comment"># scp /tmp/httpd.crt root@192.168.56.103:/etc/httpd/ssl/</span></span><br><span class="line">httpd.crt                           100% 4401     4.3KB/s   00:00 </span><br></pre></td></tr></table></figure><p>完成了, 以后搭建https的时候就可以直接使用了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW tmp]<span class="comment"># cd /etc/httpd/ssl/</span></span><br><span class="line">[root@WWW ssl]<span class="comment"># ls</span></span><br><span class="line">httpd.crt  httpd.csr  httpd.key</span><br></pre></td></tr></table></figure><p>发证的过程就是这样. 如果日后忘记了可以使用x509来查看. x509就是专门用来进行证书管理的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ssl]<span class="comment"># openssl x509 -in httpd.crt -text</span></span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number: 1 (0x1)</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: C=CN, ST=Hubei, L=Wuhan, O=Default Company Ltd, CN=WWW</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Sep 14 08:25:28 2017 GMT</span><br><span class="line">            Not After : Sep 12 08:25:28 2027 GMT</span><br><span class="line">        Subject: C=CN, ST=Hubei, O=Default Company Ltd, CN=WWW</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    00:c5:46:f7:0a:5d:be:21:7d:93:44:9c:bb:b4:d6:</span><br><span class="line">                    40:30:a2:be:f6:0d:f7:47:1f:ab:d8:57:9c:d0:4e:</span><br><span class="line">                    d5:31:ed:3a:d4:b6:2a:a2:b4:43:e8:04:21:13:24:</span><br><span class="line">                    <span class="built_in">fc</span>:14:75:04:6e:43:f9:10:15:08:a4:28:9c:c5:6c:</span><br><span class="line">                    a4:a9:1f:57:c4:e4:c5:a5:66:d9:3d:86:06:d3:0d:</span><br><span class="line">                    50:18:60:5e:e8:39:7f:97:e5:8d:33:4d:c7:f8:5f:</span><br><span class="line">                    2f:e6:99:<span class="built_in">fc</span>:a2:e6:80:5a:83:26:d0:0c:94:1a:f6:</span><br><span class="line">                    bb:6e:9a:0b:a8:19:74:39:54:22:58:d7:f8:48:66:</span><br><span class="line">                    35:60:07:e0:91:38:e3:67:7a:a5:e3:b3:9b:6f:61:</span><br><span class="line">                    48:26:af:18:74:51:19:b8:77:11:02:a7:fb:e6:33:</span><br><span class="line">                    b2:e6:95:d2:6b:db:eb:94:b1:b7:57:de:18:fb:bc:</span><br><span class="line">                    d0:1f:76:65:78:ad:e1:15:4f:36:50:e0:a5:8f:8f:</span><br><span class="line">                    61:b9:be:3c:17:5c:<span class="built_in">df</span>:71:d0:48:90:26:6c:59:bb:</span><br><span class="line">                    3a:bf:77:b5:d0:12:b6:f0:33:dc:0c:d8:84:70:7f:</span><br><span class="line">                    ad:6f:f3:5e:ea:8a:93:47:ce:22:56:87:e0:1a:9f:</span><br><span class="line">                    aa:fd:29:ea:45:05:46:27:c8:6d:b9:f3:57:44:d5:</span><br><span class="line">                    e2:ea:a6:00:b3:31:40:b6:1b:83:09:e7:7b:57:63:</span><br><span class="line">                    88:9b</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Basic Constraints: </span><br><span class="line">                CA:FALSE</span><br><span class="line">            Netscape Comment: </span><br><span class="line">                OpenSSL Generated Certificate</span><br><span class="line">            X509v3 Subject Key Identifier: </span><br><span class="line">                0C:7B:43:97:E2:92:A8:A4:82:DF:4F:C0:DC:A0:CE:E4:9B:6B:A3:FD</span><br><span class="line">            X509v3 Authority Key Identifier: </span><br><span class="line">                keyid:72:62:EE:58:34:DA:FA:35:BC:DE:53:54:79:E4:25:17:B7:E4:69:CC</span><br><span class="line"></span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">         65:e3:15:f0:bc:06:16:b5:e9:67:ca:48:bc:22:f7:78:bd:48:</span><br><span class="line">         ee:0b:9f:a2:4e:86:11:fb:83:08:21:4d:2a:53:8f:6c:4a:<span class="built_in">fc</span>:</span><br><span class="line">         87:00:af:21:6d:6f:8f:14:b9:0b:cf:c0:78:9b:0c:0c:8f:4f:</span><br><span class="line">         7b:11:f8:d3:83:e0:ba:c1:86:9a:d6:91:d0:c4:45:8c:6c:9a:</span><br><span class="line">         15:d1:72:76:9e:2b:16:ff:37:ae:44:37:f7:16:23:c5:6b:00:</span><br><span class="line">         28:ca:e8:da:72:b8:b9:4a:22:63:8b:29:42:b8:f5:3c:27:cf:</span><br><span class="line">         2d:f7:b2:16:6a:93:a9:f5:89:8a:3d:37:37:7a:fb:46:c4:27:</span><br><span class="line">         81:a5:82:07:44:bc:95:b6:d5:79:fd:74:75:83:b5:a8:fd:93:</span><br><span class="line">         a0:5c:37:42:b3:b8:<span class="built_in">fc</span>:74:ab:13:cf:28:d6:11:33:72:81:7e:</span><br><span class="line">         6a:0f:d9:c4:22:fb:c1:5f:27:b4:9b:47:b8:d1:86:ca:ce:8d:</span><br><span class="line">         87:19:e4:8e:5f:de:55:fd:7e:78:d6:68:a1:<span class="built_in">df</span>:59:77:6f:56:</span><br><span class="line">         a2:8d:da:54:d0:fd:a7:29:<span class="built_in">cd</span>:7c:84:d9:5a:be:2f:f6:72:24:</span><br><span class="line">         63:48:db:2d:d9:5d:7c:0f:01:dc:6c:c4:c0:82:ed:bd:bc:8b:</span><br><span class="line">         1c:b0:e4:77:19:67:a1:2d:34:37:86:e6:b9:eb:b7:9d:e7:c4:</span><br><span class="line">         0d:27:7b:92</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIDmDCCAoCgAwIBAgIBATANBgkqhkiG9w0BAQsFADBZMQswCQYDVQQGEwJDTjEO</span><br><span class="line">MAwGA1UECAwFSHViZWkxDjAMBgNVBAcMBVd1aGFuMRwwGgYDVQQKDBNEZWZhdWx0</span><br><span class="line">IENvbXBhbnkgTHRkMQwwCgYDVQQDDANXV1cwHhcNMTcwOTE0MDgyNTI4WhcNMjcw</span><br><span class="line">OTEyMDgyNTI4WjBJMQswCQYDVQQGEwJDTjEOMAwGA1UECAwFSHViZWkxHDAaBgNV</span><br><span class="line">BAoME0RlZmF1bHQgQ29tcGFueSBMdGQxDDAKBgNVBAMMA1dXVzCCASIwDQYJKoZI</span><br><span class="line">hvcNAQEBBQADggEPADCCAQoCggEBAMVG9wpdviF9k0Scu7TWQDCivvYN90cfq9hX</span><br><span class="line">nNBO1THtOtS2KqK0Q+gEIRMk/BR1BG5D+RAVCKQonMVspKkfV8TkxaVm2T2GBtMN</span><br><span class="line">UBhgXug5f5fljTNNx/hfL+aZ/KLmgFqDJtAMlBr2u26aC6gZdDlUIljX+EhmNWAH</span><br><span class="line">4JE442d6peOzm29hSCavGHRRGbh3EQKn++YzsuaV0mvb65Sxt1feGPu80B92ZXit</span><br><span class="line">4RVPNlDgpY+PYbm+PBdc33HQSJAmbFm7Or93tdAStvAz3AzYhHB/rW/zXuqKk0fO</span><br><span class="line">IlaH4Bqfqv0p6kUFRifIbbnzV0TV4uqmALMxQLYbgwnne1djiJsCAwEAAaN7MHkw</span><br><span class="line">CQYDVR0TBAIwADAsBglghkgBhvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2Vy</span><br><span class="line">dGlmaWNhdGUwHQYDVR0OBBYEFAx7Q5fikqikgt9PwNygzuSba6P9MB8GA1UdIwQY</span><br><span class="line">MBaAFHJi7lg02vo1vN5TVHnkJRe35GnMMA0GCSqGSIb3DQEBCwUAA4IBAQBl4xXw</span><br><span class="line">vAYWtelnyki8Ivd4vUjuC5+iToYR+4MIIU0qU49sSvyHAK8hbW+PFLkLz8B4mwwM</span><br><span class="line">j097EfjTg+C6wYaa1pHQxEWMbJoV0XJ2nisW/zeuRDf3FiPFawAoyujacri5SiJj</span><br><span class="line">iylCuPU8J88t97IWapOp9YmKPTc3evtGxCeBpYIHRLyVttV5/XR1g7Wo/ZOgXDdC</span><br><span class="line">s7j8dKsTzyjWETNygX5qD9nEIvvBXye0m0e40YbKzo2HGeSOX95V/X541mih31l3</span><br><span class="line">b1aijdpU0P2nKc18hNlavi/2ciRjSNst2V18DwHcbMTAgu29vIscsOR3GWehLTQ3</span><br><span class="line">hua567ed58QNJ3uS</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure><p>OK, 最后我们再来说一说如何去吊销证书.(虽然可能用的机会不多)</p><p>首先我们要获取要吊销证书的serial号码, 怎么获取呢?很简单就是用上面的x509子命令, 将-text改成-serial就好了. 接着CA要根据客户提交的信息(serial, subject)和数据库(index.txt)中的信息是否一致. 接着就可以进行证书吊销了.</p><p>怎么做? 还是使用ca子命令, 加上-revoke参数就可以了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW newcerts]<span class="comment"># openssl ca -revoke 01.pem </span></span><br><span class="line">Using configuration from /etc/pki/tls/openssl.cnf</span><br><span class="line">Revoking Certificate 01.</span><br><span class="line">Data Base Updated</span><br></pre></td></tr></table></figure><p>接着生成吊销证书标号就可以了. 如果是第一次进行吊销, 要先在<code>/etc/pki/CA/crlnumber</code>中加上01., 也就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW newcerts]<span class="comment"># echo 01 &gt; /etc/pki/CA/crlnumber</span></span><br></pre></td></tr></table></figure><p>最后一步, 更新证书吊销列表:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW newcerts]<span class="comment"># openssl ca -gencrl -out /etc/pki/CA/crl/httpd.crl</span></span><br><span class="line">Using configuration from /etc/pki/tls/openssl.cnf</span><br></pre></td></tr></table></figure><p>以上.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OpenSSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来,建个DNS服务器吧(Part3)</title>
      <link href="/2017/09/11/%E6%9D%A5-%E5%BB%BA%E4%B8%AADNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%A73/"/>
      <url>/2017/09/11/%E6%9D%A5-%E5%BB%BA%E4%B8%AADNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%A73/</url>
      
        <content type="html"><![CDATA[<p>来稍微说点高级的话题: 子域授权 转发服务器的建立 Bind的安全和权限管理 Bind的编译安装 和 压力测试</p><span id="more"></span><h2 id="子域授权和转发相关话题"><a href="#子域授权和转发相关话题" class="headerlink" title="子域授权和转发相关话题"></a>子域授权和转发相关话题</h2><p>为啥我们要做子域授权 ? 这是我们实现分布式DNS数据库的一个前提. 由于全球DNS的查询量太大了, 所以我们才进行切割不同的部分, 授权不同的服务器, 自顶向下分成N层结构.</p><p>要想完成子域授权(正向解析, 反向解析略麻烦暂且不提), 首先我们需要在正向区域中设定一个子区域, 比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">play.yaoxuannn.com.</span><br><span class="line">music.yaoxuannn.com.</span><br></pre></td></tr></table></figure><p>这里已经是三级域了, <code>play,music</code>已经不再是作为主机了, 而是域名. 因此这个时候他们的记录就已经不再是A了, 而是NS. 接着就在后面写上服务器地址就行了, 就好像是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">play.yaoxuannn.com.INNSns1.play.yaoxuannn.com.</span><br><span class="line">play.yaoxuannn.com.INNSns2.play.yaoxuannn.com. <span class="comment"># 当然也是可以出现两个的啦</span></span><br><span class="line">music.yaoxuannn.com.INNSns1.music.yaoxuannn.com.</span><br><span class="line">ns1.play.yaoxuannn.com.INA192.168.199.33</span><br><span class="line">ns2.play.yaoxuannn.com.INA192.168.199.44</span><br><span class="line">ns1.music.yaoxuannn.comINA192.168.199.20</span><br></pre></td></tr></table></figure><p>这样的记录其实就说明, 在<code>yaoxuannn.com</code>这个域下有两个子域play和music, 分别有2和1台服务器. 但是, 这里的大大大前提是:<strong>父域justin13wyx必须在com域下获得授权.</strong> 否则没法在互联网上获得授权.</p><p>现在我们来说一个稍微有一点混乱的事情: 假设现在有这样的结构(我就是不画图, 你来打我啊hhh): 根域下有一个叫me的子域, me下面又授权一个justin13wyx的子域, 而justin13wyx这个子域里面又有一个子域叫music, 一个DNS解析服务器ns1, 一台主机www, 而在子域music下有一台主机叫s1, 而这个子域music同时又是自己DNS解析服务器. OK , 环境介绍完了. 那么现在来讲这个事情, 如果music.yaoxuannn.com下的主机s1.music.jsutin13wyx.me想要知道<a href="http://www.yaoxuannn.com的地址/">www.yaoxuannn.com的地址</a>, 那么查询的过程是什么样的呢?</p><p>首先, 要明确的是<strong>子域不知道自己父域在哪里, 只有父域知道自己的直接子域的位置. 这种感觉就好像和Java中继承正好相反. 在Java中我们从父类中派生出很多子类. 而父类并不知道自己有哪些子类, 而子类却唯一知道自己的父类是谁.</strong> 接着, 主机s1像他所在的music子域中的DNS服务器music发起请求, 那么这个时候music会怎么做呢? 我们说过子域是不知道自己父域的位置的, 那么此时music会直接去询问根域, 根域告诉他我授权给me这个家伙了, 你去找他. 于是接着me说你去找justin13wyx这个家伙, 我授权给他了. 晕+_+. 结果搞来搞去又回来了, 自己家的事, 结果绕了这么大的圈子.</p><p>那怎么办呀? 在这种情况下, 我们就可以定义<strong>转发区域</strong>了. 其实很简单, 就是当出现了我不负责的域的请求的时候或者我找不到的时候, 那么我就会去将这个请求转交给指定的服务器. 怎么样? 是不是有点像我们的默认路由呢 ? <strong>定义转发</strong> 就是这个意思.</p><p>定义转发服务器也是有要求的:  被转发的服务器必须能够进行递归, 否则不予转发. 另外, 如果我们的请求被转发的服务器也不知道的话, 他还是要去根域去找. 那与其这样干嘛还要麻烦人家呀. 所以这个时候我们不如直接就去找根就好了嘛. 所以我们加上特殊的规则样的约束, 只有当请求这个域的位置的时候, 我们才把他转发到那里, 其他的情况的话我们就直接去找根就好了. (越来越像我们的路由表了..)</p><p>前者叫做全局转发(全部转发), 也就是凡是非本机所负责的解析的区域的请求, 统统转发到指定的服务器, 使用一下结构:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Options &#123;</span><br><span class="line">forward &#123;first|only&#125;</span><br><span class="line">forwarders</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而第二种叫做区域转发: 仅转发对特定区域的请求至某服务器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zone <span class="string">&quot;ZONE_NAME&quot;</span> &#123;</span><br><span class="line"><span class="built_in">type</span> forward;</span><br><span class="line">forward &#123;first|only&#125;</span><br><span class="line">forwarders</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中, forward定义<strong>转发模式</strong> , 转发模式有两种, 一种叫做<strong>first</strong> , 一种是<strong>only</strong>. 什么意思呢? first的意思就是说, 遇到困难我先都不想就把问题抛过去, 如果对方不搭理我, 那就只好乖乖的去找根了. 而only的意思就是说, 如果不搭理我那就放弃了..不玩了</p><p>那现在就来创建一下试试吧!</p><p>还是先来说一下现在的实验环境, 依然是那两台CentOS7主机, 但是我将之前所有的测试解析库文件都挪走了, 也就是说现在的状态是刚刚安装配置好的bind的样子.</p><p>先给我们的实验机一号配上yaoxuannn.com的zone:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$TTL</span> 1D</span><br><span class="line"><span class="variable">$ORIGIN</span> yaoxuannn.com.</span><br><span class="line">@       IN      SOA     ns1.yaoxuannn.com.     admin.yaoxuannn.com. (</span><br><span class="line">                        2017091001</span><br><span class="line">                        1H</span><br><span class="line">                        5M</span><br><span class="line">                        3D</span><br><span class="line">                        1D )</span><br><span class="line">        IN      NS      ns1</span><br><span class="line">        IN      NS      ns2</span><br><span class="line">ns1     IN      A       192.168.56.101</span><br><span class="line">ns2     IN      A       192.168.56.102</span><br><span class="line">www     IN      A       192.168.199.10</span><br><span class="line">*       IN      CNAME   www</span><br></pre></td></tr></table></figure><p>接着又是熟悉的权限配置了. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># cd /var/named/</span></span><br><span class="line">[root@WWW named]<span class="comment"># chown :named yaoxuannn.com.zone </span></span><br><span class="line">[root@WWW named]<span class="comment"># chmod 640 yaoxuannn.com.zone</span></span><br></pre></td></tr></table></figure><p>接下来, 在yaoxuannn.com的zone中定义子域music, 这一步其实就是子域授权了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">music   IN      NS      ns1.music</span><br><span class="line">ns1.music       IN      A       192.168.56.103</span><br></pre></td></tr></table></figure><p>这个时候可先别做测试呀, 你肯定会失败的. 为什么?我们的子域没有配置啊 这样你怎么也不会查询成功的.</p><p>那现在就开始配置子域, 进入实验二号机:</p><p>现在rfc1912.zones里面加上zone记录:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zone <span class="string">&quot;music.yaoxuannn.com&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">type</span> master;</span><br><span class="line">        file <span class="string">&quot;music.yaoxuannn.com.zone&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着书写解析库文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$TTL</span> 1D</span><br><span class="line"><span class="variable">$ORIGIN</span> music.yaoxuannn.com.</span><br><span class="line">@       IN      SOA     ns1.music.yaoxuannn.com.     admin.music.yaoxuannn.com. (</span><br><span class="line">                        2017091001</span><br><span class="line">                        1H</span><br><span class="line">                        5M</span><br><span class="line">                        3D</span><br><span class="line">                        1D )</span><br><span class="line">        IN      NS      ns1</span><br><span class="line">ns1     IN      A       192.168.56.103</span><br><span class="line">www     IN      A       192.168.199.20</span><br><span class="line">*       IN      CNAME   www</span><br></pre></td></tr></table></figure><p>那么现在, 在子域的DNS服务器上, 我们可以进行子域的解析但是不能进行父域的解析.  对于父域的DNS服务器来说, 除了可以进行自己域内的解析以外, 还可以进行子域的DNS服务器(也就是music.yaoxuannn.com)的解析. 你可能在测试的时候发现, 你父域的DNS解析子域的时候总是显示服务器无法到达. 一直报错.</p><p>是这样的, 因为默认我们的各种工具提供的都是递归查找, 这样造成的后果就是每一次都会去找根域. 所以你应该使用dig工具提供的<code>+norecurse</code>选项. 这样才可以得到结果, 但是依然你是得不到答复的 你只能得到子域的DNS服务器的地址而已. 那么怎么样才能得到准确的解析结果呢? 很简单, 配置转发!</p><p>首先我们先来试一试给子域加上转发, 使得他可以进行对父域的解析: (rfc1912.zones)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zone <span class="string">&quot;yaoxuannn.com&quot;</span> IN &#123;</span><br><span class="line">        <span class="built_in">type</span> forward;</span><br><span class="line">        forward only;</span><br><span class="line">        forwarders &#123; 192.168.56.101; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先别急着测试, 接下来我们再把一号试验机加上转发, 使得它可以解析子域的位置:(named.conf)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">options &#123;</span><br><span class="line">        listen-on port 53 &#123; 192.168.56.101; &#125;;</span><br><span class="line">//      listen-on-v6 port 53 &#123; ::1; &#125;;</span><br><span class="line">        directory       <span class="string">&quot;/var/named&quot;</span>;</span><br><span class="line">        dump-file       <span class="string">&quot;/var/named/data/cache_dump.db&quot;</span>;</span><br><span class="line">        statistics-file <span class="string">&quot;/var/named/data/named_stats.txt&quot;</span>;</span><br><span class="line">        memstatistics-file <span class="string">&quot;/var/named/data/named_mem_stats.txt&quot;</span>;</span><br><span class="line">        allow-query     &#123; any; &#125;;</span><br><span class="line">        forward         first;</span><br><span class="line">        forwarders      &#123; 192.168.56.103; &#125;;</span><br></pre></td></tr></table></figure><p>行了, 相信你开心的配置完毕了, 但是却发现似乎P用都没有.</p><p>那么, 接下来将介绍一个大大大大超级无敌大大大大的<strong>坑</strong>:</p><p>请务必要把:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnssec-enable no;</span><br><span class="line">dnssec-validation no;</span><br></pre></td></tr></table></figure><p><strong>关闭</strong> 而不是 <strong>注释</strong> 因为注释的默认值是yes. 所以一定要写清楚NO! 接下来你就可以的得到你想看到的结果了.</p><p>行了, 现在转发配置就这样了吧~ 下面说说简单的安全机制和权限管理</p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>这里我们说一说Bind的安全项目的配置. 首先是<strong>ACL</strong>  访问控制列表</p><p>也就是把一个或者多个主机归并成一个集合, 并通过一个统一的名称调用.这个配置起来就和他的功能一样好懂:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acl acl_name &#123;</span><br><span class="line">ip;</span><br><span class="line">ip;</span><br><span class="line">hostname;</span><br><span class="line">net/prelen;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示个例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acl mynet &#123;</span><br><span class="line">172.16.0.0/16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ACL提供了几个内定义的: none(没有一个主机), any(任意主机), local(本机),localnet(本机IP同掩码进行计算的网络地址)  还记得我们在最一开始提到了allow-query这个属性不? 这个地方我们就写了any啊. 如果内置的不满意, 那么就手写一acl就可以了. 但是注意: 只能先定义后使用, 而且一般我们都把他定义在配置文件中options的前面.</p><p>我们可以来做个试验咯, 比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zone <span class="string">&quot;yaoxuannn.com&quot;</span> IN &#123;</span><br><span class="line">        <span class="built_in">type</span> master;</span><br><span class="line">        file <span class="string">&quot;yaoxuannn.com.zone&quot;</span>;</span><br><span class="line">        allow-query &#123; 127.0.0.1; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment"># 加入了一个allow-query属性</span></span><br></pre></td></tr></table></figure><p>接下来我们尝试用本机的外部IP地址来进行解析:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># dig yaoxuannn.com @192.168.56.101</span></span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-50.el7_3.1 &lt;&lt;&gt;&gt; yaoxuannn.com @192.168.56.101</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 30002</span></span><br><span class="line"><span class="string">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 4096</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;yaoxuannn.com.INA</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; AUTHORITY SECTION:</span></span><br><span class="line"><span class="string">yaoxuannn.com.86400INSOAns1.yaoxuannn.com. admin.yaoxuannn.com. 2017091002 3600 300 259200 86400</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 0 msec</span></span><br><span class="line"><span class="string">;; SERVER: 192.168.56.101#53(192.168.56.101)</span></span><br><span class="line"><span class="string">;; WHEN: Mon Sep 11 11:42:53 EDT 2017</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 89</span></span><br></pre></td></tr></table></figure><p>没有结果了.  不过说实话,作为一台DNS服务器, 我们一般还是应该允许查询的属性设置成any吧.</p><p>除了这个allow-query(允许查询的主机, 白名单), 我们就把他叫做访问控制的指令, 还有allow-transfer(允许进行区域传送的主机, 白名单)</p><p>之前就说过了, 区域传送是十分危险的, 但当时没有提到怎么进行限制, 现在就可已进行尝试了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zone <span class="string">&quot;yaoxuannn.com&quot;</span> IN &#123;</span><br><span class="line">        <span class="built_in">type</span> master;</span><br><span class="line">        file <span class="string">&quot;yaoxuannn.com.zone&quot;</span>;</span><br><span class="line">        allow-transfer &#123; 127.0.0.1; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用我们今天刚刚做好的传送服务器来试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># dig axfr yaoxuannn.com @192.168.56.101</span></span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-50.el7_3.1 &lt;&lt;&gt;&gt; axfr yaoxuannn.com @192.168.56.101</span><br><span class="line">;; global options: +cmd</span><br><span class="line">; Transfer failed.</span><br></pre></td></tr></table></figure><p>这样就达到我们的目的了. 当然ACL是贯穿所有的, 你可以直接把ACL写到这里面. </p><p>接着还有allow-recursion{} 和allow-update {} 这个update在默认的配置文件里也有, 什么意思? 其实就是字面意思了.  允许更新数据库中的内容, 因为有的时候我们的主机IP可能是通过DHCP协议获取的, 那么DNS服务器会得到通知, 于是自动进行改变.</p><h2 id="bind-view-视图"><a href="#bind-view-视图" class="headerlink" title="bind view 视图"></a>bind view 视图</h2><p>先来假设这样的情况, 假设中国移动, 中国电信之间的总入口带宽很小, 只有100G. 那么这样就会带来一个问题. 这样移动的用户访问位于电信机房内的服务器的时候, 就会变得异常的慢. 而访问移动的就不会有什么问题. 这样的影响是很大的. 为了留住用户, 那么站点的组织者就会在各大运营商机房内的都放置了一台服务器. 接着只要使得移动的用户访问移动机房内的机器, 电信的用户访问电信的机器就行了. 但是问题在于 这些机器的域名可都是一个. 也就是说来自不同运营商的用户得到同一个域名的解析是不一样的.</p><p>类似的, 如果小米公司的内部员工在公司访问自己家的服务器(私有地址), DNS解析服务器应该直接返回给他们私有地址, 但是外网用户访问的时候就应该得到小米的防火墙或其他设备的地址, 接着在经过NAT转换连接上. 类似这样的需求. 当然常见的还是第一个例子.</p><p>对于Bind而言, 这个东西就是Bind的View(视图). 简单的说, 你可以把View当做是容器, 就像Docker一样的感觉(不熟悉Docker, 日后再说) 我们可以定义多个view, 每一个view都有同一条域名的记录, 但是他们指向的文件却不同. 每个view指向一组特定的客户端. 原理其实也很简单: Bind提供多个View, 当客户端发起请求的时候, bind自上而下进行匹配, 一旦匹配到View和客户端, 即停止匹配将在得到的view中进行查询. 如果匹配到最后都没有检查到. 那么就直接拒绝请求. 为了防止这样的情况发生. 我们一般都会设置一个匹配特定网络以外的所有网络这么一条view. </p><p>定义一个view是很简单的了, 基本上在options中的属性都可以用在view中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个view的定义:</span></span><br><span class="line">view VIEW_NAME &#123;</span><br><span class="line">match-clients &#123;  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最重要的属性就是上面的那个match-clients了, 另外还有一些注意项: 一旦我们启用了view, 那么所有的zone必须全部放在view中. 由于我们是自上而下匹配的, 所有优先级问题和顺序问题需要规划好. 还有一个问题, 根区域记录放在哪里呢? </p><p>首先, 根区域的存在意义是什么呢? 我们知道当来自互联网的机器询问到我们这边的时候并且请去做递归查询, 遇到我们不知道或者不负责的查询的时候我们就会去请求根去了. 但是, 如果我们压根都不允许递归查询的话, 不写根都是可以的. 一般情况下, 只给本地的机器做递归, 所以 根区域的记录只要放在match本地的view中就可以了.</p><p>我也是拼了老命在做实验啊….我笔记本的风扇在疯狂的旋转.. 不说了, 一共开了三台虚拟机, 两台Cent OS, 一台Ubuntu. 其中两台CentOS的IP分别是192.168.56.101和192.168.56.103, 而Ubuntu是192.168.56.102. 101作为DNS服务器, 而其他的两台CentOS作为内部主机, Ubuntu作为一台外部主机, 其实就是在说他们的view不同罢了. 其中CentOS们是一个acl组的, 叫做test. 而Ubuntu没有分组, 默认直接在view中使用了IP来表示. 那么现在就直接看一下配置和最终的效果吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">acl <span class="built_in">test</span> &#123;</span><br><span class="line">        192.168.56.101;</span><br><span class="line">        192.168.56.103;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment"># 这是101DNS服务器中的acl配置.</span></span><br><span class="line">view external &#123;</span><br><span class="line">        match-clients &#123; 192.168.56.102; &#125;;</span><br><span class="line">        zone <span class="string">&quot;yaoxuannn.com&quot;</span> IN &#123;</span><br><span class="line">                <span class="built_in">type</span> master;</span><br><span class="line">                file <span class="string">&quot;102yaoxuannn.com.zone&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">view internal &#123;</span><br><span class="line">        match-clients &#123; <span class="built_in">test</span>; &#125;;</span><br><span class="line">        allow-recursion &#123; <span class="built_in">test</span>; &#125;;</span><br><span class="line">        zone <span class="string">&quot;yaoxuannn.com&quot;</span> IN &#123;</span><br><span class="line">                <span class="built_in">type</span> master;</span><br><span class="line">                file <span class="string">&quot;yaoxuannn.com.zone&quot;</span>;</span><br><span class="line">                allow-transfer &#123; 127.0.0.1; &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">#上面是两个view的设置</span></span><br></pre></td></tr></table></figure><p>我直接将原来的yaoxuannn.com.zone文件进行<code>cp -a</code> 得到102.yaoxuannn.com, 接着把其中的www对应的记录值改成了192.168.56.20 ( 原来是192.168.56.10 )</p><p>最后测试的结果是什么样子呢? </p><p>Ubuntu能够进行解析, 并且得到192.168.56.20的结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># dig www.yaoxuannn.com @192.168.56.101</span></span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.8-Ubuntu &lt;&lt;&gt;&gt; www.yaoxuannn.com @192.168.56.101</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 56124</span></span><br><span class="line"><span class="string">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 4096</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;www.yaoxuannn.com.INA</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ANSWER SECTION:</span></span><br><span class="line"><span class="string">www.yaoxuannn.com.86400INA192.168.199.20 # 得到20的结果</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; AUTHORITY SECTION:</span></span><br><span class="line"><span class="string">yaoxuannn.com.86400INNSns1.yaoxuannn.com.</span></span><br><span class="line"><span class="string">yaoxuannn.com.86400INNSns2.yaoxuannn.com.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ADDITIONAL SECTION:</span></span><br><span class="line"><span class="string">ns1.yaoxuannn.com.86400INA192.168.56.101</span></span><br><span class="line"><span class="string">ns2.yaoxuannn.com.86400INA192.168.56.102</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 7 msec</span></span><br><span class="line"><span class="string">;; SERVER: 192.168.56.101#53(192.168.56.101)</span></span><br><span class="line"><span class="string">;; WHEN: Tue Sep 12 03:54:49 PDT 2017</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 131</span></span><br></pre></td></tr></table></figure><p>而 ,另外一边103解析得到的结果就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># dig www.yaoxuannn.com @192.168.56.101</span></span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-50.el7_3.1 &lt;&lt;&gt;&gt; www.yaoxuannn.com @192.168.56.101</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 44198</span></span><br><span class="line"><span class="string">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 4096</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;www.yaoxuannn.com.INA</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ANSWER SECTION:</span></span><br><span class="line"><span class="string">www.yaoxuannn.com.86400INA192.168.199.10</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; AUTHORITY SECTION:</span></span><br><span class="line"><span class="string">yaoxuannn.com.86400INNSns2.yaoxuannn.com.</span></span><br><span class="line"><span class="string">yaoxuannn.com.86400INNSns1.yaoxuannn.com.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ADDITIONAL SECTION:</span></span><br><span class="line"><span class="string">ns1.yaoxuannn.com.86400INA192.168.56.101</span></span><br><span class="line"><span class="string">ns2.yaoxuannn.com.86400INA192.168.56.102</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 2 msec</span></span><br><span class="line"><span class="string">;; SERVER: 192.168.56.101#53(192.168.56.101)</span></span><br><span class="line"><span class="string">;; WHEN: Tue Sep 12 07:02:10 EDT 2017</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 131</span></span><br></pre></td></tr></table></figure><p>接下来我们说说CDN吧, 这个写前端的小伙伴肯定都很熟悉, 因为通常都会选择一些合适的CDN来进行JS库的快速加载. 那么什么到底啥是CDN嘞? 其实就是内容分发网络的意思, 能够把同一个服务的内容分发到多处. 说白了其实就是大量的缓存服务器, 假设我们很土豪, 在全世界各地的机房内都放上我们的服务器, 他们都保存(缓存)我们原始服务器的副本. 这样来自某个网络的用户进行查看的时候, 得到不同的DNS解析结果, 从而访问属于他那个位置的缓存服务器. 这样分布式的内容分发服务, 就叫做CDN. 而构建这样的CDN网络, 一种实现方式就是智能DNS. 除了这种方法, 还有负载均衡调度用户到不同的服务器上. 这种又叫做全局负载均衡网络.</p><h2 id="Bind的编译安装"><a href="#Bind的编译安装" class="headerlink" title="Bind的编译安装"></a>Bind的编译安装</h2><p>首先当然是<a href="https://ftp.isc.org/isc/bind9/cur/9.10/bind-9.10.6.tar.gz">获取源码</a>咯. 接着解包之后我们进入目录看到的应该是下面这样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW bind-9.10.6]<span class="comment"># ls</span></span><br><span class="line">acconfig.h  bind.keys     config.h.in        configure     doc      HISTORY.md             isc-config.sh.html  ltmain.sh      OPTIONS     srcid    win32utils</span><br><span class="line">aclocal.m4  bind.keys.h   config.h.win32     configure.in  docutil  install-sh             isc-config.sh.in    make           OPTIONS.md  unit</span><br><span class="line">Atffile     CHANGES       config.sub         contrib       FAQ.xml  isc-config.sh.1        lib                 Makefile.<span class="keyword">in</span>    README      util</span><br><span class="line">bin         config.guess  config.threads.in  COPYRIGHT     HISTORY  isc-config.sh.docbook  libtool.m4          mkinstalldirs  README.md   version</span><br></pre></td></tr></table></figure><p>我们说过编译一个C语言程序无非就是configure, make, make install. 当然这个也不例外. </p><p>在这里说一下常用的configure选项, 首先是 –prefix和 –sysconfdir这两个超常用通用选项. 以后要是想删除这个就直接把这个而目录删除就好了. 接着是关闭ipv6和关闭chroot功能, 以及启用多线程功能. 这样Bind可以在多核机器上表现更优异.</p><p>最后的configure命令就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW bind-9.10.6]<span class="comment"># ./configure --prefix=/usr/local/bind9 --sysconfdir=/etc/bind9 --disable-ipv6 --disable-chroot --enable-threads</span></span><br></pre></td></tr></table></figure><p>:arrow_right_hook:直接回车吧!</p><p>接着我们想到了一个问题, 我们使用rpm包进行安装完的之后, named会用普通用户named来运行named来着. 所以我们要先创建用户:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW bind-9.10.6]<span class="comment"># groupadd -g 53 named -r</span></span><br><span class="line">[root@WWW bind-9.10.6]<span class="comment"># useradd -u 53 -g named named -r</span></span><br><span class="line">[root@WWW bind-9.10.6]<span class="comment"># id named</span></span><br><span class="line">uid=53(named) gid=53(named) <span class="built_in">groups</span>=53(named)</span><br></pre></td></tr></table></figure><p>好了, 接下来就是常规的几步了.</p><p><strong>加入&#x2F;etc&#x2F;profile.d&#x2F;内的PATH环境变量</strong></p><p><strong>导出链接库编辑&#x2F;etc&#x2F;ld.so.conf.d&#x2F;*.conf加入自己的lib目录, 使用ldconfig重建</strong></p><p><strong>链接头文件到&#x2F;usr&#x2F;include下</strong></p><p><strong>编辑&#x2F;etc&#x2F;man.config, 加入man的路径</strong></p><p>总之就先这样吧, 回去看一下我们的Bind源码目录, 里面有一个叫contrib的目录, 里面是一些第三方的辅助Bind的程序, 其中有个叫queryperf的, 这个是一个做压力测试的工具, 很小, 直接configure, make就可以使用了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW queryperf]<span class="comment"># queryperf -h</span></span><br><span class="line"></span><br><span class="line">DNS Query Performance Testing Tool</span><br><span class="line">Version: <span class="variable">$Id</span>: queryperf.c,v 1.12 2007/09/05 07:36:04 marka Exp $</span><br><span class="line"></span><br><span class="line">Usage: queryperf [-d datafile] [-s server_addr] [-p port] [-q num_queries]</span><br><span class="line">                 [-b bufsize] [-t <span class="built_in">timeout</span>] [-n] [-l <span class="built_in">limit</span>] [-f family] [-1]</span><br><span class="line">                 [-i interval] [-r arraysize] [-u unit] [-H histfile]</span><br><span class="line">                 [-T qps] [-e] [-D] [-R] [-c] [-v] [-h]</span><br></pre></td></tr></table></figure><p>首先我们需要一个测试文件很简单, <code>域名 类型</code>就行了 .</p><p>比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.yaoxuannn.com A</span><br></pre></td></tr></table></figure><p>接下来使用<code>queryperf -d CONFIGFILE -s SERVER</code> 就行了. 完成后就会受到一份报告:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># queryperf -d test -s 192.168.56.101</span></span><br><span class="line"></span><br><span class="line">DNS Query Performance Testing Tool</span><br><span class="line">Version: <span class="variable">$Id</span>: queryperf.c,v 1.12 2007/09/05 07:36:04 marka Exp $</span><br><span class="line"></span><br><span class="line">[Status] Processing input data</span><br><span class="line">[Status] Sending queries (beginning with 192.168.56.101)</span><br><span class="line">[Status] Testing complete</span><br><span class="line"></span><br><span class="line">Statistics:</span><br><span class="line"></span><br><span class="line">  Parse input file:     once</span><br><span class="line">  Ended due to:         reaching end of file</span><br><span class="line"></span><br><span class="line">  Queries sent:         1451520 queries</span><br><span class="line">  Queries completed:    1451520 queries</span><br><span class="line">  Queries lost:         0 queries</span><br><span class="line">  Queries delayed(?):   0 queries</span><br><span class="line"></span><br><span class="line">  RTT max:         0.035401 sec</span><br><span class="line">  RTT min:              0.000362 sec</span><br><span class="line">  RTT average:          0.001011 sec</span><br><span class="line">  RTT std deviation:    0.000838 sec</span><br><span class="line">  RTT out of range:     0 queries</span><br><span class="line"></span><br><span class="line">  Percentage completed: 100.00%</span><br><span class="line">  Percentage lost:        0.00%</span><br><span class="line"></span><br><span class="line">  Started at:           Tue Sep 12 08:30:05 2017</span><br><span class="line">  Finished at:          Tue Sep 12 08:31:27 2017</span><br><span class="line">  Ran <span class="keyword">for</span>:              81.967886 seconds</span><br><span class="line"></span><br><span class="line">  Queries per second:   17708.398628 qps</span><br></pre></td></tr></table></figure><p>不过这样的压力测试由于我是本机测试所以无法得到带宽带来的性能损耗. 接下来我们玩一个好玩的, 可以试试把rndc的日志记录功能打开, 再进行测试.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> DNS </tag>
            
            <tag> Bind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来,建个DNS服务器吧(Part2)</title>
      <link href="/2017/09/10/%E6%9D%A5-%E5%BB%BA%E4%B8%AADNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%A72/"/>
      <url>/2017/09/10/%E6%9D%A5-%E5%BB%BA%E4%B8%AADNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%A72/</url>
      
        <content type="html"><![CDATA[<p>这次来说说反向解析和主从同步的话题.</p><span id="more"></span><h2 id="反向解析"><a href="#反向解析" class="headerlink" title="反向解析"></a>反向解析</h2><p>之前的Part1中 ,我们已经搭建了能够正向解析的DNS服务器.</p><p>首先我们来看看反向区域这个概念.</p><p>反向区域是什么呢? 首先他的区域名称是很独特的, 要讲注册的得到的网络名称反过来写并且加上in-addr.arpa.</p><p>例如: 得到了172.16.100 这个非变化部分就是我们的网络地址, 那么就写成: <code>100.16.172.in-addr.arpa.</code>  [注意后面的.]</p><p>那么怎么定义这个反向区域呢? 和定义正向区域基本相似:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zone <span class="string">&quot;ZONE_NAME&quot;</span> IN &#123;</span><br><span class="line"><span class="built_in">type</span> &#123;master|slave|forward&#125;;</span><br><span class="line">file <span class="string">&quot;网络地址.zone&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下就是提供解析库文件了. 反向区域和正向区域的解析库是有区别的, 他需要SOA和NS记录, 但它不需要A,AAAA,MX, 以PTR记录为主.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个解析库文件示例, 和Part1对应</span></span><br><span class="line"><span class="variable">$TTL</span> 86400</span><br><span class="line"><span class="variable">$ORIGIN</span> 199.168.192.in-addr.arpa.</span><br><span class="line">@INSOAns1.yaoxuannn.com.admin.yaoxuannn.com (</span><br><span class="line">2017090101</span><br><span class="line">1H</span><br><span class="line">5M</span><br><span class="line">7D</span><br><span class="line">1D )</span><br><span class="line">INNSns1.yaoxuannn.com.</span><br><span class="line">INNSns2.yaoxuannn.com.</span><br><span class="line">1INPTRns1.yaoxuannn.com. <span class="comment"># 这些数字其实就是主机名了, 会自动用上面的$ORIGIN补全</span></span><br><span class="line">2INPTRns2.justin13wxy.me.</span><br><span class="line">10INPTRwww.yaoxuannn.com.</span><br><span class="line">10INPTRwwww.yaoxuannn.com.</span><br></pre></td></tr></table></figure><p>与之对应, 我们在&#x2F;etc&#x2F;named.rfc1912.zones里面加上一条:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zone <span class="string">&quot;199.168.192.in-addr.arpa&quot;</span> IN &#123;</span><br><span class="line"><span class="built_in">type</span> master;</span><br><span class="line">file <span class="string">&quot;199.168.192.zone&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着重新载入解析库文件之后, 我们进行反向解析:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># host -t ptr 192.168.199.10</span></span><br><span class="line">10.199.168.192.in-addr.arpa domain name pointer www.yaoxuannn.com.</span><br><span class="line">10.199.168.192.in-addr.arpa domain name pointer wwww.yaoxuannn.com.</span><br><span class="line">[root@WWW named]<span class="comment"># dig -x 192.168.199.1</span></span><br><span class="line">...(omitted)</span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">1.199.168.192.in-addr.arpa. 86400 INPTRns1.yaoxuannn.com.</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">199.168.192.in-addr.arpa. 86400INNSns1.yaoxuannn.com.</span><br><span class="line">199.168.192.in-addr.arpa. 86400INNSns2.yaoxuannn.com.</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>dig还有一个特别神奇的技能, 他可以进行<strong>模拟区域传送</strong> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># dig -t axfr yaoxuannn.com</span></span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-50.el7_3.1 &lt;&lt;&gt;&gt; -t axfr yaoxuannn.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">yaoxuannn.com.86400INSOAns1.justn13wyx.me. admin.yaoxuannn.com.yaoxuannn.com. 2017090101 3600 300 604800 86400</span><br><span class="line">yaoxuannn.com.86400INNSns1.yaoxuannn.com.</span><br><span class="line">yaoxuannn.com.86400INNSns2.yaoxuannn.com.</span><br><span class="line">ns1.yaoxuannn.com.86400INA192.168.199.1</span><br><span class="line">ns2.yaoxuannn.com.86400INA192.168.199.2</span><br><span class="line">www.yaoxuannn.com.86400INA192.168.199.10</span><br><span class="line">wwww.yaoxuannn.com.86400INCNAMEwww.yaoxuannn.com.</span><br><span class="line">yaoxuannn.com.86400INSOAns1.justn13wyx.me. admin.yaoxuannn.com.yaoxuannn.com. 2017090101 3600 300 604800 86400</span><br><span class="line">;; Query time: 3 msec</span><br><span class="line">;; SERVER: 192.168.56.101<span class="comment">#53(192.168.56.101)</span></span><br><span class="line">;; WHEN: Sat Sep 09 11:44:59 EDT 2017</span><br><span class="line">;; XFR size: 8 records (messages 1, bytes 247)</span><br><span class="line"><span class="comment">#  看吧, 所有区域的记录一览无余.</span></span><br></pre></td></tr></table></figure><p>这种全量区域传送是挺不安全的, 因为如果大家都可以进行这种, 那么全公司的网络拓扑甚至可以猜测出来.</p><p>如果用户想要访问 <a href="https://yaoxuannn.com/">www.yaoxuannn.com</a> 这个优秀的网站, 但是不小心它在前面加了一个 nizubang.yaoxuannn.com 这样解析就会出现问题, 所以 我们可以为刚才的解析库中增加一条泛解析条目:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># echo -e &quot;*\tIN\tCNAME\twww&quot; &gt;&gt; /var/named/yaoxuannn.com.zone</span></span><br><span class="line">[root@WWW named]<span class="comment"># tail -2 /var/named/yaoxuannn.com.zone </span></span><br><span class="line">wwww INCNAMEwww</span><br><span class="line">*INCNAMEwww</span><br></pre></td></tr></table></figure><p>OK, reload之后, 就可试着解析了. 但是试着试着又发现了一个问题, 如果我什么都不写的话好像还是解析不了, 那么就需要再添加一条:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># echo -e &quot;yaoxuannn.com.\tIN\tA\t192.168.199.10&quot; &gt;&gt; /var/named/yaoxuannn.com.zone </span></span><br><span class="line">[root@WWW named]<span class="comment"># tail -4 /var/named/yaoxuannn.com.zone </span></span><br><span class="line">wwwINA192.168.199.10</span><br><span class="line">wwww INCNAMEwww</span><br><span class="line">*INCNAMEwww</span><br><span class="line">yaoxuannn.com.INA192.168.199.10</span><br><span class="line">[root@WWW named]<span class="comment"># rndc reload</span></span><br><span class="line">server reload successful</span><br><span class="line">[root@WWW named]<span class="comment"># dig yaoxuannn.com</span></span><br><span class="line">...(omitted)</span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">yaoxuannn.com.86400INA192.168.199.10</span><br></pre></td></tr></table></figure><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主从复制并不是说就那么死板的安排的. 其实你可以有很多种不同的主从设计, 一台主服务器同时可以成从服务器, 从服务器也可以成为另一台从服务器的主服务器等等..</p><p>现在我的实验环境是这样安排的:</p><blockquote><p>实验机一号: CentOS Linux release 7.3.1611 (Core)  IP: 192.168.56.101 – 主</p><p>实验机二号: CentOS Linux release 7.3.1611 (Core)  IP: 192.168.56.103 – 从 </p></blockquote><p>OK, 实验环境已经准备好了, 现在现在我们的二号机上做个测试:</p><h3 id="正向解析"><a href="#正向解析" class="headerlink" title="正向解析"></a>正向解析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># dig axfr yaoxuannn.com @192.168.56.101</span></span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-50.el7_3.1 &lt;&lt;&gt;&gt; axfr yaoxuannn.com @192.168.56.101</span><br><span class="line">;; global options: +cmd</span><br><span class="line">yaoxuannn.com.86400INSOAns1.justn13wyx.me. admin.yaoxuannn.com.yaoxuannn.com. 2017090101 3600 300 604800 86400</span><br><span class="line">yaoxuannn.com.86400INA192.168.199.10</span><br><span class="line">yaoxuannn.com.86400INNSns1.yaoxuannn.com.</span><br><span class="line">yaoxuannn.com.86400INNSns2.yaoxuannn.com.</span><br><span class="line">*.yaoxuannn.com.86400INCNAMEwww.yaoxuannn.com.</span><br><span class="line">ns1.yaoxuannn.com.86400INA192.168.56.101</span><br><span class="line">ns2.yaoxuannn.com.86400INA192.168.56.102</span><br><span class="line">www.yaoxuannn.com.86400INA192.168.199.10</span><br><span class="line">wwww.yaoxuannn.com.86400INCNAMEwww.yaoxuannn.com.</span><br><span class="line">yaoxuannn.com.86400INSOAns1.justn13wyx.me. admin.yaoxuannn.com.yaoxuannn.com. 2017090101 3600 300 604800 86400</span><br><span class="line">;; Query time: 3 msec</span><br><span class="line">;; SERVER: 192.168.56.101<span class="comment">#53(192.168.56.101)</span></span><br><span class="line">;; WHEN: Sun Sep 10 01:06:08 EDT 2017</span><br><span class="line">;; XFR size: 10 records (messages 1, bytes 279)</span><br></pre></td></tr></table></figure><p>显然没有问题, <strong>和Part1不同的是, 我把ns1和ns2的地址进行了更改, 因此和之前的解析库不一样了.</strong></p><p>配置一个从服务器是比主服务器要简单的(废话啊), 我们先安装bind.</p><p>接着编辑namd.conf文件, 监听地址, 查询权限, dnssec啥的. 在Part1这些都提到过了, 所以就不说了.</p><p>我们先从正向区域的从服务器开始建立.  首先, 我们前往rfc1912.zones:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zone <span class="string">&quot;yaoxuannn.com&quot;</span> IN &#123;</span><br><span class="line">        <span class="built_in">type</span> slave; <span class="comment"># 种类已经是从了</span></span><br><span class="line">        masters &#123; 192.168.56.101; &#125;; <span class="comment"># 不论主服务器有几个, 都要使用复数形式</span></span><br><span class="line">        file <span class="string">&quot;slaves/yaoxuannn.com.zone&quot;</span>; <span class="comment"># 注意这里的路径</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可能想问, 难道说我们一定要把文件放在slaves这个目录下? 一般来说, 是的. 我们观察一下这个named目录下的构造:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># ls -lF /var/named/</span></span><br><span class="line">total 16</span><br><span class="line">drwxrwx--- 2 named named   23 Sep  9 03:39 data/</span><br><span class="line">drwxrwx--- 2 named named   60 Sep 10 01:22 dynamic/</span><br><span class="line">-rw-r----- 1 root  named 2281 May 22 05:51 named.ca</span><br><span class="line">-rw-r----- 1 root  named  152 Dec 15  2009 named.empty</span><br><span class="line">-rw-r----- 1 root  named  152 Jun 21  2007 named.localhost</span><br><span class="line">-rw-r----- 1 root  named  168 Dec 15  2009 named.loopback</span><br><span class="line">drwxrwx--- 2 named named   33 Sep 10 01:35 slaves/</span><br><span class="line">[root@WWW named]<span class="comment"># ls -ld /var/named/</span></span><br><span class="line">drwxr-x--- 5 root named 127 Sep 10 01:02 /var/named/</span><br></pre></td></tr></table></figure><p>经过观察可以很清楚的看出来, named用户仅仅可以对slaves, data, dynamic有写权限, 事实上. 这个就是bind为我们提供的结构. 凡是从解析库文件都扔到slaves里面就可以了.</p><p>接下来我们进行配置reload:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># rndc reload</span></span><br><span class="line">server reload successful</span><br><span class="line">[root@WWW named]<span class="comment"># tail /var/log/messages</span></span><br><span class="line">Sep 10 01:35:20 WWW named[10333]: reloading configuration succeeded</span><br><span class="line">Sep 10 01:35:20 WWW named[10333]: reloading zones succeeded</span><br><span class="line">Sep 10 01:35:20 WWW named[10333]: all zones loaded</span><br><span class="line">Sep 10 01:35:20 WWW named[10333]: running</span><br><span class="line">Sep 10 01:35:20 WWW named[10333]: zone yaoxuannn.com/IN: Transfer started.</span><br><span class="line">Sep 10 01:35:20 WWW named[10333]: transfer of <span class="string">&#x27;yaoxuannn.com/IN&#x27;</span> from 192.168.56.101<span class="comment">#53: connected using 192.168.56.103#59331</span></span><br><span class="line">Sep 10 01:35:20 WWW named[10333]: zone yaoxuannn.com/IN: transferred serial 2017090101</span><br><span class="line">Sep 10 01:35:20 WWW named[10333]: transfer of <span class="string">&#x27;yaoxuannn.com/IN&#x27;</span> from 192.168.56.101<span class="comment">#53: Transfer completed: 1 messages, 10 records, 279 bytes, 0.008 secs (34875 bytes/sec)</span></span><br><span class="line">Sep 10 01:35:20 WWW named[10333]: zone yaoxuannn.com/IN: sending notifies (serial 2017090101)</span><br></pre></td></tr></table></figure><p>看到没~ 我们的文件传输过来了, 来看一下是否多出了个文件? 你可能会有有趣的发现.</p><p>接下来, 我们再看看<strong>主服务器那边</strong>的情况吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># tail /var/log/messages</span></span><br><span class="line">Sep 10 01:35:19 WWW named[10298]: client 192.168.56.103<span class="comment">#59331 (yaoxuannn.com): transfer of &#x27;yaoxuannn.com/IN&#x27;: AXFR started</span></span><br><span class="line">Sep 10 01:35:19 WWW named[10298]: client 192.168.56.103<span class="comment">#59331 (yaoxuannn.com): transfer of &#x27;yaoxuannn.com/IN&#x27;: AXFR ended</span></span><br><span class="line">Sep 10 01:35:20 WWW named[10298]: client 192.168.56.103<span class="comment">#21742: received notify for zone &#x27;yaoxuannn.com&#x27;</span></span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>如果刷新时间没有到, 但是我们主服务的解析记录发生了变化的话, 那么从服务器会得到更改吗? 我们来做这个实验:</p><ol><li>首先我们为yaoxuannn.com这个域增加一个MX记录并且更新Serial Num.(+1)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">        IN      MX 10   mx1</span><br><span class="line">mx1     IN      A       192.168.199.20</span><br></pre></td></tr></table></figure><ol start="2"><li>接着我们reload配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># rndc reload</span></span><br><span class="line">server reload successful</span><br></pre></td></tr></table></figure><ol start="3"><li>看看日志怎么样</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># tail /var/log/messages</span></span><br><span class="line">Sep 10 02:35:33 WWW named[10298]: reloading configuration succeeded</span><br><span class="line">Sep 10 02:35:33 WWW named[10298]: reloading zones succeeded</span><br><span class="line">Sep 10 02:35:33 WWW named[10298]: zone yaoxuannn.com/IN: loaded serial 2017090102</span><br><span class="line">Sep 10 02:35:33 WWW named[10298]: all zones loaded</span><br><span class="line">Sep 10 02:35:33 WWW named[10298]: running</span><br><span class="line">Sep 10 02:35:33 WWW named[10298]: zone yaoxuannn.com/IN: sending notifies (serial 2017090103)</span><br><span class="line">Sep 10 02:35:33 WWW named[10298]: client 192.168.56.103<span class="comment">#59346 (yaoxuannn.com): transfer of &#x27;yaoxuannn.com/IN&#x27;: AXFR-style IXFR started</span></span><br><span class="line">Sep 10 02:35:33 WWW named[10298]: client 192.168.56.103<span class="comment">#59346 (yaoxuannn.com): transfer of &#x27;yaoxuannn.com/IN&#x27;: AXFR-style IXFR ended</span></span><br></pre></td></tr></table></figure><p>不错, 我们更改过后, 主服务器就直接去通知自己的从服务器去更新这份记录了.</p><p>那么现在来稍微总结一下:</p><ul><li>从服务器应该为一台独立的名称服务器</li><li>主服务器的区域解析库文件中必须有一条NS记录是指向从服务器的</li><li>从服务器只需要定义区域, 不需要提供解析库文件</li><li>主服务器需要仅允许从服务器做区域传送</li><li>主从服务器的时间应该得到同步</li><li>bind程序的版本应该保持一致, 即使不一样, 也需要保证从服务器的版本高于主服务器.</li></ul><p>定义从服务器的方法上面也说明的挺详细了. 这就是正向解析从服务器的建立啦.</p><h3 id="反向解析-1"><a href="#反向解析-1" class="headerlink" title="反向解析"></a>反向解析</h3><p>上面都铺垫这么多了, 我们就直接进行zone的编辑就好了! 其实超乎想象的快:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zone <span class="string">&quot;56.168.192.in-addr.arpa&quot;</span> IN &#123;</span><br><span class="line">        <span class="built_in">type</span> slave;</span><br><span class="line">        masters &#123; 192.168.56.101; &#125;;</span><br><span class="line">        file <span class="string">&quot;slaves/56.168.192.in-addr.arpa.zone&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>哦对了, 这里的示例记录也和Part1是不一样的.</p></blockquote><p>接下来, check一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW slaves]<span class="comment"># named-checkconf </span></span><br><span class="line">[root@WWW slaves]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>OK!万事俱备, 只差reload啦.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW slaves]<span class="comment"># rndc reload</span></span><br><span class="line">server reload successful</span><br><span class="line">[root@WWW slaves]<span class="comment"># tail /var/log/messages</span></span><br><span class="line">Sep 10 02:51:10 WWW named[10333]: client 192.168.56.101<span class="comment">#46304: received notify for zone &#x27;56.168.192.in-addr.arpa&#x27;</span></span><br><span class="line">Sep 10 02:51:10 WWW named[10333]: zone 56.168.192.in-addr.arpa/IN: Transfer started.</span><br><span class="line">Sep 10 02:51:10 WWW named[10333]: transfer of <span class="string">&#x27;56.168.192.in-addr.arpa/IN&#x27;</span> from 192.168.56.101<span class="comment">#53: connected using 192.168.56.103#56337</span></span><br><span class="line">Sep 10 02:51:10 WWW named[10333]: zone 56.168.192.in-addr.arpa/IN: transferred serial 2017090101</span><br><span class="line">Sep 10 02:51:10 WWW named[10333]: transfer of <span class="string">&#x27;56.168.192.in-addr.arpa/IN&#x27;</span> from 192.168.56.101<span class="comment">#53: Transfer completed: 1 messages, 8 records, 276 bytes, 0.007 secs (39428 bytes/sec)</span></span><br><span class="line">Sep 10 02:51:10 WWW named[10333]: zone 56.168.192.in-addr.arpa/IN: sending notifies (serial 2017090101)</span><br></pre></td></tr></table></figure><p>这样就完成了. 同理 如果我们改变了主服务器上的记录, 从服务器也会被通知来改变.</p><h2 id="RNDC"><a href="#RNDC" class="headerlink" title="RNDC"></a>RNDC</h2><p>来说说RNDC吧. 这个小东西管理named通过连接一个套接字来实现. 这是客户端的情况 而服务器端是通过监听在953&#x2F;tcp端口的. 可以这么理解 rndc客户端(A主机)会去连接rndc服务端(B主机 953&#x2F;tcp)来进行管理. 但是这样十分的不安全 所以你可以理解成这个A主机和B主机是一台主机. rndc只允许连接自己.</p><p>那么这个rndc到底除了reload还有什么能力呢? 直接<code>rndc -help</code> 我们可以得到很多子命令.</p><blockquote><p>Usage: rndc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-b address][-c config][-s server][-p port][-k key-file ] [-y key] [-V] <span class="built_in">command</span></span><br></pre></td></tr></table></figure></blockquote><p>由于一般不会特别需要指定server port key-file什么的, 所以我们就直接专注于command就好.</p><p>COMMAND:</p><ul><li><strong>reload</strong>: 重新载入主配置文件和区域解析库文件</li><li><strong>retransfer</strong>: 手动触发zone传送, 不看serial number</li><li><strong>notify</strong>: 对区域传送发送通知</li><li><strong>reconfig</strong>: 重载主配置文件</li><li><strong>querylog</strong>: 开启&#x2F;关闭查询日志</li><li><strong>trace [LEVEL]</strong>: 开启DEBUG, 后面用0-5来表示等级, 不添加LEVEL只递增等级VEL]**: 开启DEBUG, 后面用0-5来表示等级, 不添加LEVEL只递增等级</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> DNS </tag>
            
            <tag> Bind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来,建个DNS服务器吧(Part 1)</title>
      <link href="/2017/09/09/%E6%9D%A5-%E5%BB%BA%E4%B8%AADNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%A7/"/>
      <url>/2017/09/09/%E6%9D%A5-%E5%BB%BA%E4%B8%AADNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%A7/</url>
      
        <content type="html"><![CDATA[<p>DNS与BIND.</p><span id="more"></span><h2 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h2><p>大家都知道啦, 我们的DNS就是Domain Name Service, DNS作为一个(C&#x2F;S架构的)协议, 也是一个规范. 对DNS协议的实现, 最标准的就是BIND了. 原先是Bekerley Internet Name Domain, 后来移交给了ISC来维护.</p><p>既然是C&#x2F;S架构, 那么不可避免会使用到套接字, 那么也就需要端口和双方地址. 作为一个基础服务, 端口必须是众所周知的. DNS使用<strong>UDP&#x2F;TCP的53端口</strong>, 在我们正常使用的一般是UDP协议的53端口, 原因也很简单了: 快啊~ 事实上, DNS服务不是在网络开始的时候出现的, 只是因为时间的推移, 主机越来越多, 人记忆IP地址实在是太难了所以才催生了DNS的诞生. </p><p>所以在互联网上使用名字也就不能随便想叫什么就叫啥了. 管理这些的组织是IANA, 一旦一个地址被分配出去了决不能在分配给另外一个主机了. 因此, 出现了一种应用机制: 比如&#x2F;etc&#x2F;hosts这个文件 , 而Windows是%WINDOWS%&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts</p><p>他的格式就像是: X.X.X.X <a href="http://www.test.com/">www.test.com</a> 其实就类似的数据库的查找匹配</p><p>但是, 这种实现方式在后来接入网络主机越来越多, 越来越快, 本机维护hosts文件就越来越困难了. 于是IANA就维护一个单独的公共的服务器, 当有人申请的时候就会想办法把映射存进去. 后来条目又越来越多, 使得检索变得困难.所以这个服务器的数据进行了Hash化, 并且是Hash桶的形式, 存入内存 这样就会更快了.</p><p>但是, 随着主机记录更多了的时候, 这样一个服务器先不说需要多大的内存来存储, 还需要应付同时几十万的查询请求, 甚至还出现了Hash碰撞. 而每次加入数据库, 都需要重新更新, 载入内存. 这样对于一个服务器来说, 压力太多了!</p><p>所以, 我们就采取分布式的办法, 进行功能划分. 采用层级管理的方法, 每一级只需要知道自己一级的和自己下一级的地址就好. </p><p>这样最上级来管理的服务器, 我们就称为<strong>根名称服务器(root nameserver)</strong>: 根服务器一共有13个IP, 但是服务器本身并不是就这么13个设备, 有很多镜像, 他们的安全等级非常高.</p><p>接下来说说解析的类型, 我们的名称解析是可以进行反向解析的, 在DNS诞生之前, 反向解析是十分简单的, 因为他就是两个键而已.但是DNS之后再想进行反向解析就不是这么简单了, 为什么? 请问: IP地址怎么做分布式? 很困难, 即使是现在(可以通过线索提示的方式进行检索), 反向解析也是一件尚未解决的问题. 而反向解析其实也是很重要的, 比如在我们的垃圾邮件判断上, 反向解析就是一种有效的手段, 通过判断名称和IP双向对应才会认为不是垃圾邮件. 需要注意的是: <strong>正向解析和反向解析是两个不同的命名空间, 是两颗不同的树.</strong></p><p>我们的DNS服务器的类型也是有很多的:</p><ul><li>主DNS服务器: 维护所负责的解析域内的解析库DNS服务器. 这个解析域是管理员维护的.</li><li>从DNS服务器: 从主DNS服务器或者其他的DNS服务器那里”复制” ( 区域同步 )<ul><li>由于 ,这个复制是自动的, 没有人工. 所以要考虑到主服务器内记录发生变化,而从服务器却没有得到同步的情况. 这个就是通过解析记录来完成的, 首先, 从服务器定期进行检查. 早期是通过版本号(序列号)来实现的, 每次主服务器解析库发生变化, 他的序列号就会发生变化. 一旦发生出现变化, 从服务器就会请求同步. 同步的方式有两种, 一种叫做全量传送: 传递整个解析库, 一种叫做增量传送: 传递解析库变化的那部分内容. 那好, 定期检查, 这个定期到底改定成多少呢? 我们把这个时间间隔叫做刷新时间, 一旦刷新失败了, 进行重试. 这里就又会有一个重试时间, 也就是再次尝试的时间间隔. 很显然, 重试时间一定小于刷新时间. 另外, 还有一个时间叫做过期时长. 当主服务器始终不上线, 连不上的话, 从服务器就会!放弃自己的一切职务!停止提供服务! 所以如果出现故障的话就要立即修复.  为了避免从服务器落后于主服务器, 主服务区还可以有一种通知机制来告知从服务器内容有更新快来更新.</li></ul></li><li>缓存DNS服务器: 为了加速每一个用户的互联网访问, 才会需要进行缓存.所谓缓存就是一段内存空间, 向上面一样使用Hash存储, O(1)的速度. 在缓存失效之前, 所有的查询都会使用缓存. 缓存时间长, 可以减少耗时,性能优秀, 但是过时内容可能积攒太多. 缓存时间短, 内容可得到及时的更新, 但是带宽和性能消耗大. 所有这个时间的折中很重要. 其实每一个条目都有他自己的缓存.</li><li>转发器</li></ul><p>我们刚才一直在说<strong>区域</strong> (区域传送) 而没有说 <strong>域</strong> 这两者是有区别的. 对于DNS服务器来说, 他有正向的和反向的两棵树, 对于任意一个域(Domain)来说:</p><p>正向: FQDN –&gt; IP, 反向: IP –&gt; FQDN. 他们的解析库也不是一个解析库, 来分别负责本地域名的正反向解析. 对于正向解析库来讲, 它属于正向解析区域. 所有我们说<strong>域</strong>的时候, 可能是说正向和反向 而说<strong>区域</strong>的时候, 只能是单向的, 有可能是正向有可能是反向的.</p><p>FQDN就是指 <strong>完全合格域名</strong> 比如: <a href="http://www.baidu.com/">www.baidu.com</a>. 而 www 就不是. </p><h3 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h3><p>Client –&gt; hosts (如果没有结果) –&gt; DNS Service</p><p>而在查询DNS Server的时候, 先检查Local DNS Cache –&gt; 如果没有结果 –&gt; DNS server(recursion) –&gt; Server DNS Cache –&gt; iteration(迭代)</p><p>解析答案有两种: 一种是肯定答案, 一种是否定答案(请求的条目不存在). 除此之外, 我们还有权威答案和非权威答案(缓存)</p><p>而我们每一个解析条目在解析库中, 叫做一个资源记录, 简称为RR. 记录有类型: </p><p><strong>A记录</strong>, Address之意, 标记FQDN–&gt;ipv4. 反过来的是<strong>PTR记录</strong>, <strong>CNAME</strong>(Canonical Name), 别名记录.  <strong>SOA</strong>(Start Of Authority起始授权记录)定义域的负责, 一个区域解析库只能有一个SOA记录而且必须出现在第一条, <strong>NS</strong>就是Name Server的记录, 专门用于表明当前区域的DNS服务器, <strong>MX</strong>(mail exchange), 邮件交换器,<strong>AAAA</strong>定义ipv6的地址, 也就是FQDN–&gt;ipv6 这些就是最常用的几个.</p><p>一条资源记录是有着格式的: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">语法: name [TTL] IN rr_type value</span><br><span class="line">1) TTL 可以从全局继承</span><br><span class="line">2) 可以直接使用@来引用当前区域的名字</span><br><span class="line">3) 相邻的两个记录name相同的时候, 可以省略</span><br><span class="line">接下来就一个一个来看上面各个记录的格式:</span><br><span class="line">SOA:</span><br><span class="line">name: 当前区域的名字, 例如<span class="string">&#x27;yaoxuannn.com.&#x27;</span></span><br><span class="line">value: 有多部分组成</span><br><span class="line">1) 当前区域的主DNS服务器的FQDN, 也可以使用当前区域的名字</span><br><span class="line">2) 当前区域管理员的邮箱地址, 但是地址中不能使用@符号, 一般使用.来替换. e.g:justin.126.com</span><br><span class="line">3) (主从服务协调属性(各种时间间隔)的定义以及否定答案的统一TTL值)</span><br><span class="line"></span><br><span class="line">比如请求stackoverflow.com的记录:</span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">com.815INSOAa.gtld-servers.net. nstld.verisign-grs.com. 1504938845 1800 900 604800 86400</span><br><span class="line">后面的数字分别代表: 序列号, 刷新时间, 重试时间, 过期时间, 否定答案的TTL值.</span><br><span class="line"></span><br><span class="line">NS:</span><br><span class="line">name: 当前区域的名字, 和SOA的name一样</span><br><span class="line">value: 当前区域的DNS服务器名字, 一个区域可以有多个NS记录.</span><br><span class="line">后续都应该有一个A记录</span><br><span class="line"></span><br><span class="line">MX:</span><br><span class="line">name: 当前区域的名字</span><br><span class="line">value: 当前区域的某邮件服务器的主机名</span><br><span class="line">MX记录可以有多个, 但是每个记录的value之前都应该有一个数字(0-99), 表示此服务器的优先级, 数字越小,优先级越高</span><br><span class="line">后续都应该有一个A记录</span><br><span class="line"></span><br><span class="line">A:</span><br><span class="line">name: 某主机的完整名字, FQDN</span><br><span class="line">value: 对应主机的IP地址</span><br><span class="line">还有泛域名解析的方式, 避免用户写错名称时给出错误答案</span><br><span class="line"></span><br><span class="line">AAAA:</span><br><span class="line">name: FQDN</span><br><span class="line">value: IPv6</span><br><span class="line"></span><br><span class="line">PTR:</span><br><span class="line">name: IP, 有特定格式,需要反过来写, 而且有特定后缀: in-addr.arpa. 但网络地址可省</span><br><span class="line">value: FQDN</span><br><span class="line"></span><br><span class="line">CNAME:</span><br><span class="line">name: 别名的FQDN</span><br><span class="line">value: 正式名称的FQDN</span><br></pre></td></tr></table></figure><h2 id="BIND"><a href="#BIND" class="headerlink" title="BIND"></a>BIND</h2><p>我们搭建DNS服务器的程序包叫做BIND. BIND这个程序包包含多个程序子包, 有趣的是, 虽然程序包叫做BIND, 但提供的工具却叫做named.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># yum list bind*</span></span><br><span class="line">Installed Packages</span><br><span class="line">bind.x86_64                                                                         32:9.9.4-50.el7_3.1                                                            @updates</span><br><span class="line">bind-libs.x86_64                                                                    32:9.9.4-50.el7_3.1                                                            @updates</span><br><span class="line">bind-libs-lite.x86_64                                                               32:9.9.4-50.el7_3.1                                                            @updates</span><br><span class="line">bind-license.noarch                                                                 32:9.9.4-50.el7_3.1                                                            @updates</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>其中有一个util包很重要, 提供基础DNS查询还有测试工具, 我们的dig工具就是这个包提供的. 在bind开头的程序包中有一个叫做chroot的包, 他可以使得我们的DNS圈进在&#x2F;var&#x2F;named&#x2F;chroot&#x2F;, 把这个当做根来使用.</p><p>bind的主配置文件在named.conf, 但是惯例了, 为了不使配置文件过于庞大, 所以进行切片到一个叫做named.rfc1912.zones的文件中. 另外还有一个文件叫做: &#x2F;etc&#x2F;rndc.key 这个rndc是什么玩意? </p><p>rndc &#x3D;&#x3D; remote name domain controller, 远程名称域控制器. 能够实现清理缓存, 重新装载区域配置文件, 查看状态. 但是默认只适用于本地主机, 通过127.0.0.1本地回环地址来进行管理, 它提供了很多辅助性的管理功能.</p><p>rndc也是一个服务, 监听在953&#x2F;tcp端口. 所有的认证就依靠那个key文件. </p><p>OK, 现在回到BIND上, 最重要的部分就是我们的解析库文件了对不. 但是现在很肯定是空的嘛. 默认我们把解析解析库放在&#x2F;var&#x2F;named这个目录下. 每一个区域由一个解析库文件, 一个DNS服务区可以同时解析多个区域, 而且都可以进行正向和反向的解析. 一般约定俗成的都叫做ZONE_NAME.ZONE文件, 负责保存本地的区域数据. 这里面应该还有一个最重要的区域文件, 叫做<strong>根区域文件</strong> 这个文件叫做named.ca 另外还会解析localhost, 对于这两个特殊的区域(甚至更多, 如果包括ipv6的话)来实现本地回环地址和localhost的解析库.</p><p>我们来到&#x2F;var&#x2F;named, 来看看这个目录下的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># pwd</span></span><br><span class="line">/var/named</span><br><span class="line">[root@WWW named]<span class="comment"># ls</span></span><br><span class="line">data  dynamic  named.ca  named.empty  named.localhost  named.loopback  slaves</span><br><span class="line">[root@WWW named]<span class="comment"># cat named.ca </span></span><br><span class="line">...(omitted)</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">.518400INNSa.root-servers.net.</span><br><span class="line">.518400INNSb.root-servers.net.</span><br><span class="line">.518400INNSc.root-servers.net.</span><br><span class="line">.518400INNSd.root-servers.net.</span><br><span class="line">.518400INNSe.root-servers.net.</span><br><span class="line">...(omitted)</span><br><span class="line"></span><br><span class="line">;; ADDITIONAL SECTION:</span><br><span class="line">a.root-servers.net.3600000INA198.41.0.4</span><br><span class="line">a.root-servers.net.3600000INAAAA2001:503:ba3e::2:30</span><br><span class="line">b.root-servers.net.3600000INA192.228.79.201</span><br><span class="line">b.root-servers.net.3600000INAAAA2001:500:84::b</span><br><span class="line">c.root-servers.net.3600000INA192.33.4.12</span><br><span class="line">c.root-servers.net.3600000INAAAA2001:500:2::c</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>看, 这个就是我们的根区域的记录. 其实这个文件是使用dig工具生成的. 剩下两个localhost和loopback就是我们的本机:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># cat named.localhost </span></span><br><span class="line"><span class="variable">$TTL</span> 1D</span><br><span class="line">@IN SOA@ rname.invalid. (</span><br><span class="line">0; serial</span><br><span class="line">1D; refresh</span><br><span class="line">1H; retry</span><br><span class="line">1W; expire</span><br><span class="line">3H ); minimum</span><br><span class="line">NS@</span><br><span class="line">A127.0.0.1</span><br><span class="line">AAAA::1</span><br><span class="line">[root@WWW named]<span class="comment"># cat named.loopback </span></span><br><span class="line"><span class="variable">$TTL</span> 1D</span><br><span class="line">@IN SOA@ rname.invalid. (</span><br><span class="line">0; serial</span><br><span class="line">1D; refresh</span><br><span class="line">1H; retry</span><br><span class="line">1W; expire</span><br><span class="line">3H ); minimum</span><br><span class="line">NS@</span><br><span class="line">A127.0.0.1</span><br><span class="line">AAAA::1</span><br><span class="line">PTRlocalhost.</span><br></pre></td></tr></table></figure><p>那么这个区域名称@是什么呢, 在哪里定义的? 我们转向主配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># vim /etc/named.conf </span></span><br><span class="line"><span class="comment"># 这个配置文件有四个部分构成</span></span><br><span class="line"><span class="comment"># options 全局配置</span></span><br><span class="line"><span class="comment"># logging 日志子系统配置</span></span><br><span class="line"><span class="comment"># zone 对于单独的一个区域的定义, 像解析哪些就要定义哪些: zone &quot;ZONE_NAME&quot; IN &#123;&#125;</span></span><br><span class="line"><span class="comment"># include 引入其他的文件</span></span><br><span class="line">...</span><br><span class="line">include <span class="string">&quot;/etc/named.rfc1912.zones&quot;</span>;</span><br><span class="line">include <span class="string">&quot;/etc/named.root.key&quot;</span>;</span><br><span class="line"><span class="comment"># 引入了两个文件, 我们主要来看下rfc1912.zones</span></span><br><span class="line">[root@WWW named]<span class="comment"># cat /etc/named.rfc1912.zones </span></span><br><span class="line"><span class="comment"># 这两个就是刚刚localhost的配置项目</span></span><br><span class="line">zone <span class="string">&quot;localhost.localdomain&quot;</span> IN &#123;</span><br><span class="line"><span class="built_in">type</span> master;</span><br><span class="line">file <span class="string">&quot;named.localhost&quot;</span>;</span><br><span class="line">allow-update &#123; none; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zone <span class="string">&quot;localhost&quot;</span> IN &#123;</span><br><span class="line"><span class="built_in">type</span> master;</span><br><span class="line">file <span class="string">&quot;named.localhost&quot;</span>;</span><br><span class="line">allow-update &#123; none; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>由于这个rpm包已经是来源做过的了的, 所以其实直接启动的话他已经可以作为一个缓存DNS服务器了, 虽然只能解析自己和根, 而且只能给localhost用. 所有我们需要让它监听在一个可以和外部连接的IP上. 那么我们现在来修改一下他的配置文件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># cp -av /etc/named.conf&#123;,.bak&#125;</span></span><br><span class="line">‘/etc/named.conf’ -&gt; ‘/etc/named.conf.bak’</span><br><span class="line"><span class="comment"># 别忘了先做个备份</span></span><br><span class="line">------</span><br><span class="line">options &#123;</span><br><span class="line">        listen-on port 53 &#123; 192.168.56.101; 127.0.0.1; &#125;; <span class="comment"># 注意空格和分号, 否则语法错误</span></span><br><span class="line">//      listen-on-v6 port 53 &#123; ::1; &#125;; <span class="comment"># 如果需要进行注释,使用//, 多行注释/**/也支持</span></span><br><span class="line">        directory       <span class="string">&quot;/var/named&quot;</span>;</span><br><span class="line">        dump-file       <span class="string">&quot;/var/named/data/cache_dump.db&quot;</span>;</span><br><span class="line">        statistics-file <span class="string">&quot;/var/named/data/named_stats.txt&quot;</span>;</span><br><span class="line">        memstatistics-file <span class="string">&quot;/var/named/data/named_mem_stats.txt&quot;</span>;</span><br><span class="line">        allow-query     &#123; localhost; &#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着重启服务就可以了.</p><p>考虑到现在DNS服务的安全性, 这些年流行了一种新的机制, 叫做dnssec, 也就是每一个DNS都加上数字签名来进行校验. 但是由于其配置很复杂, 而且如果大家都没开就你一个人开了, 意义不大. 所以建议测试的时候把他关掉:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dnssec-enable <span class="built_in">yes</span>;</span><br><span class="line">dnssec-validation <span class="built_in">yes</span>;</span><br><span class="line"></span><br><span class="line">/* Path to ISC DLV key */</span><br><span class="line">bindkeys-file <span class="string">&quot;/etc/named.iscdlv.key&quot;</span>;</span><br><span class="line"></span><br><span class="line">managed-keys-directory <span class="string">&quot;/var/named/dynamic&quot;</span>;</span><br></pre></td></tr></table></figure><p>把上面这一段都注释掉吧, 注意注释的嵌套. </p><p>还有一个关键的一项, 就是<code>allow-query</code>这个选项 可以选择把他注释掉, 或者把里面的localhost改成any, 这个是named内置的访问控制列表, 允许任何主机进行查询.</p><p>好, 接下来我们来看看怎么配一个主DNS服务器.</p><p>首先第一步, 我们在rfc1912.zones文件中加上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zone <span class="string">&quot;yaoxuannn.com&quot;</span> IN &#123;</span><br><span class="line">        <span class="built_in">type</span> master; <span class="comment"># 主服务器类型, 这个地方只能写&#123;master|salve|hint(根)|forward&#125;</span></span><br><span class="line">        file <span class="string">&quot;yaoxuannn.com.zone&quot;</span>; <span class="comment"># 对应的文件, 当然现在是没有这个文件的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们进行文件的创建 (定义区域解析库文件), 这个时候就要好好看看上面的记录格式了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$TTL</span> 86400 <span class="comment"># 定义宏</span></span><br><span class="line">@       IN      SOA     ns1.justn13wyx.me.      admin.yaoxuannn.com (</span><br><span class="line">                        2017090101</span><br><span class="line">                        1H</span><br><span class="line">                        5M</span><br><span class="line">                        7D</span><br><span class="line">                        1D ) <span class="comment"># 首先定义SOA记录, 上面说过的对不</span></span><br><span class="line">        IN      NS      ns1.yaoxuannn.com. <span class="comment"># 接着是两个NS记录, 别忘记了加上根域的.</span></span><br><span class="line">        IN      NS      ns2.yaoxuannn.com.</span><br><span class="line">ns1.yaoxuannn.com.     IN      A       192.168.199.1 <span class="comment"># 必然会跟着NS的A记录</span></span><br><span class="line">ns2.yaoxuannn.com.     IN      A       192.168.199.2</span><br><span class="line">www     IN      A       192.168.199.10</span><br><span class="line">wwww    IN      CNAME   www <span class="comment"># 别名指向www</span></span><br></pre></td></tr></table></figure><p>这样写有没有觉得的很麻烦啊, 其实我们可以把区域名省略, 这样文件就变成了这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$TTL</span> 86400</span><br><span class="line">@       IN      SOA     ns1.justn13wyx.me.      admin.yaoxuannn.com (</span><br><span class="line">                        2017090101</span><br><span class="line">                        1H</span><br><span class="line">                        5M</span><br><span class="line">                        7D</span><br><span class="line">                        1D )</span><br><span class="line">        IN      NS      ns1</span><br><span class="line">        IN      NS      ns2</span><br><span class="line">ns1     IN      A       192.168.199.1</span><br><span class="line">ns2     IN      A       192.168.199.2</span><br><span class="line">www     IN      A       192.168.199.10</span><br><span class="line">wwww    IN      CNAME   www</span><br></pre></td></tr></table></figure><p>注意啦, 如果采取省略写法,那么一定不要在后面加上.了哦.</p><p>这么麻烦,  那人工检查是不是太麻烦了啊, 所以named提供了两条命令帮助你进行检查:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># named-checkconf </span></span><br><span class="line"><span class="comment"># 没有任何输出, 没有消息就是最好的消息</span></span><br><span class="line">[root@WWW named]<span class="comment"># named-checkzone &quot;yaoxuannn.com&quot; yaoxuannn.com.zone </span></span><br><span class="line">zone yaoxuannn.com/IN: loaded serial 2017090101</span><br><span class="line">OK</span><br><span class="line">------------------------------</span><br><span class="line">[root@WWW named]<span class="comment"># rndc status # 通过rndc提供的小工具查看当前服务器状态</span></span><br><span class="line">version: 9.9.4-RedHat-9.9.4-50.el7_3.1 &lt;<span class="built_in">id</span>:8f9657aa&gt;</span><br><span class="line">CPUs found: 1</span><br><span class="line">worker threads: 1</span><br><span class="line">UDP listeners per interface: 1</span><br><span class="line">number of zones: 101</span><br><span class="line">debug level: 0</span><br><span class="line">xfers running: 0</span><br><span class="line">xfers deferred: 0</span><br><span class="line">soa queries <span class="keyword">in</span> progress: 0</span><br><span class="line">query logging is OFF</span><br><span class="line">recursive clients: 0/0/1000</span><br><span class="line">tcp clients: 0/100</span><br><span class="line">server is up and running</span><br><span class="line">[root@WWW named]<span class="comment"># rndc reload # 使用rndc的reload子命令来进行解析库reload</span></span><br><span class="line">server reload successful</span><br></pre></td></tr></table></figure><p>现在就可以进行尝试解析了.我们来看看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># dig www.yaoxuannn.com</span></span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-50.el7_3.1 &lt;&lt;&gt;&gt; www.yaoxuannn.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 4592</span></span><br><span class="line"><span class="string">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 4096</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;www.yaoxuannn.com.INA</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ANSWER SECTION:</span></span><br><span class="line"><span class="string">www.yaoxuannn.com.86400INA192.168.199.10</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; AUTHORITY SECTION:</span></span><br><span class="line"><span class="string">yaoxuannn.com.86400INNSns2.yaoxuannn.com.</span></span><br><span class="line"><span class="string">yaoxuannn.com.86400INNSns1.yaoxuannn.com.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ADDITIONAL SECTION:</span></span><br><span class="line"><span class="string">ns1.yaoxuannn.com.86400INA192.168.199.1</span></span><br><span class="line"><span class="string">ns2.yaoxuannn.com.86400INA192.168.199.2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 1 msec</span></span><br><span class="line"><span class="string">;; SERVER: 192.168.56.101#53(192.168.56.101)</span></span><br><span class="line"><span class="string">;; WHEN: Sat Sep 09 07:40:20 EDT 2017</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 131</span></span><br></pre></td></tr></table></figure><p>哇!出现了! 解析成功了! 经测试同一个子网的另外一台机器也能够成功解析!</p><p>OK, 那么现在回过头来看看&#x2F;var&#x2F;named这个目录:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># cd /var/named/</span></span><br><span class="line">[root@WWW named]<span class="comment"># ls -l</span></span><br><span class="line">total 20</span><br><span class="line">drwxrwx--- 2 named named   23 Sep  9 03:39 data</span><br><span class="line">drwxrwx--- 2 named named   60 Sep  9 06:40 dynamic</span><br><span class="line">-rw-r--r-- 1 root  root  214 Sep  9 07:37 yaoxuannn.com.zone</span><br><span class="line">-rw-r----- 1 root  named 2281 May 22 05:51 named.ca</span><br><span class="line">-rw-r----- 1 root  named  152 Dec 15  2009 named.empty</span><br><span class="line">-rw-r----- 1 root  named  152 Jun 21  2007 named.localhost</span><br><span class="line">-rw-r----- 1 root  named  168 Dec 15  2009 named.loopback</span><br><span class="line">drwxrwx--- 2 named named    6 Jul  5 06:15 slaves</span><br></pre></td></tr></table></figure><p>发现我们创建的文件是属于root组的, 而且权限是644, 这样并不好, 所以我们要把它改成和其他一样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW named]<span class="comment"># chmod 640 yaoxuannn.com.zone </span></span><br><span class="line">[root@WWW named]<span class="comment"># chown :named yaoxuannn.com.zone</span></span><br></pre></td></tr></table></figure><p>好了. 至此我们的DNS服务器就初步搭建完成了.</p><h3 id="DNS服务器的测试"><a href="#DNS服务器的测试" class="headerlink" title="DNS服务器的测试"></a>DNS服务器的测试</h3><h4 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h4><blockquote><p>测试命令dig的使用:</p><p>dig [-t type] name [@SERVER] [query-options]</p><p>这个命令是不会进行dns系统hosts文件查询的</p><p>查询选项:</p><p>​+[no]trace:  跟踪解析过程</p><p>​+[no]recurse:  使用递归解析</p></blockquote><h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><blockquote><p>测试命令host的使用:</p><p>host [-t type] name [SERVER]</p><p>十分简单, 就不说了</p></blockquote><h4 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h4><blockquote><p>更多的使用在交互式模式下, </p><p>nslookup&gt;</p><p>​server IP: 指明DNS服务器</p><p>​set q&#x3D;RR_TYPE: 指明查询的资源类型.</p><p>​NAME: 接着输入需要查询的内容就可以了.</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> DNS </tag>
            
            <tag> Bind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenSSL初识与简单的网络通信安全</title>
      <link href="/2017/09/08/OpenSSL%E5%88%9D%E8%AF%86%E4%B8%8E%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/"/>
      <url>/2017/09/08/OpenSSL%E5%88%9D%E8%AF%86%E4%B8%8E%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>初识OpenSSL与简单的密码学知识~</p><span id="more"></span><h2 id="一次通信"><a href="#一次通信" class="headerlink" title="一次通信"></a>一次通信</h2><p>以Web服务为例, 当我们从应用程序向远端服务器发送一个请求的时候, 通过创建一个套接字经由随机端口发送, 经由路由设备层层转发, 服务器端监听套接字接收到之后, 应用程序将从磁盘上取得的结果通过协议栈封装成可以相应的报文格式重新托付给相同的套接字, 作为响应返回给客户端. </p><p>简单来描述就是这样. 不过协议报文在我们封装完在互联网上传输时, 大多数的应用层协议以及底层的TCP层都会有问题. 在过程中我们的数据包仅仅是加了头部啥的, 他们都是<strong>明文</strong>的. 数据是原封不动的. 这样只要是网络上能够收到这个数据包的人, 他们都可以存一个副本, 接着查看内容, 一览无余.</p><blockquote><p>TCP的四层一次又一次的封装数据包, 那么为什么要封装这么多次呢, 为什么不能一步到位呢?</p><p>分层设计的目的, 由于我们互联网通信的问题很大很复杂, 而分层就是为了把这个大问题分解成小问题, 接着每个问题单独解决.  更重要的是, 上下层之间互相服务, 他们之间通过接口进行通信. 这样的又一个好处是,如果某一层出现问题, 那么我们直接修改那一层的代码就可以了, 其他的层根本不需要知道这些. 只要提供能力没啥区别就行了. 这就类似于我们局域网通信, 不论通过双绞线或者无线调制通信, 和IP包是没有什么关系的. 底层怎么变换, 上层对于服务的接口不变, 就没有什么影响.</p></blockquote><p>这样太不安全啦! 那么为什么做不到加密传输呢, 为啥一定要明文呢? 我们现在使用的这些协议, 都是上个世纪的产物啊..当时能够把数据发送过去就已经很不容易了. 更别提有人要搞破坏了. 但是对于网络安全话题,美国国家安全署(NIST)定义了安全的三个方面: <strong>保密性, 完整性, 可用性</strong>. 也就是数据要保密, 未被授权的第三方不能获取到,即使被存下来也不能被获取到内容, 数据自己的完整性, 系统的完整性, 真正授权的第三方要能够收倒且获取到内容.</p><p>使用我们现在的协议栈在互联网上进行通信的时候, 他们面临各种各样的攻击. 对于这种安全攻击, 主要有两种:</p><ul><li>被动攻击: 窃听</li><li>主动攻击: 伪装, 重放, 消息篡改, 拒绝服务</li></ul><p>那么为了我们的安全, 我们就要尽可能的验证, 防止篡改, 拒绝接受伪装balabala, 就是要<strong>加密</strong>, 或者 <strong>数字签名</strong> 还有<strong>访问控制</strong> 以及想办法确保 <strong>数据完整性</strong> 还有所谓的 <strong>密钥认证交换机制</strong> , 还有比如 <strong>进行流量填充</strong> 还有 <strong>路由控制, 不走不安全的路由</strong>.</p><p>为了实现这些安全机制, 就要有安全服务来支持, 这些服务主要包括:</p><ul><li>认证</li><li>访问控制</li><li>数据保密性<ul><li>连接保密性</li><li>无连接保密性</li><li>选择域保密性</li><li>流量保密性</li></ul></li><li>数据完整性</li><li>不可否认性</li></ul><p>那么为了保证这些安全服务, 就要有密码算法和协议, 常见的加密算法:</p><p><strong>对称加密</strong>  <strong>公钥加密</strong>  <strong>单向加密</strong>  </p><p><strong>认证协议</strong>  </p><p>说到密码, 这个东西其实并不是程序员所研究的东西, 通常都是一些研究机构, 数学科学家, 军方在研究. 而各国都有自己秘而不宣的加密算法, 至于我们现在在生产环境中所使用的这些, 至少他们对于信息获取没有什么阻碍.</p><h2 id="Linux上的通信安全工具"><a href="#Linux上的通信安全工具" class="headerlink" title="Linux上的通信安全工具"></a>Linux上的通信安全工具</h2><p><strong>OpenSSL</strong> 和 <strong>gpg</strong> , 后者是对pgp协议的实现. 接下来我们就说说常见的加密技术吧.</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>首先是<strong>对称加密</strong>技术: 其实就是说,加密和解密使用的是同一个密钥. 这里需要说的一件事是, 其实加密算法倒不是最重要的(不是说不重要啊), 算法可以公开, 但是问题在于即使知道了算法,也很难揣测出密钥是什么. 所以加密的关键是这个密钥, 比如AES-128,AES-256大家都知道算法的思想是什么,但是就是没法逆推. 那怎么解密呢, 我们有密钥啊, 对称加密使用的是一样的密钥. 这样带来的缺陷是 如果通信有n组用户, 那么就会存在n组密钥. 这样错误率就会出增大. </p><p>在早期的: DES(Data Encryption Standard), 56位的密钥. 但是在2003年前后就被攻破了, 可以非常容易的进行逆推. 所以DES就进行了改进, 变成了3DES. 后来继续征集新的安全标准, 于是出现了AES, 也就是Advance ES, 这个标准支持128.192,258,384,512bits的长度. 类似的还有BlowFish, TwoFish, IDEA, RC6, CAST5(相信你都没听说过吧..现在互联网上使用最多的也就是3DES和AES了)</p><p><strong>特性</strong>:</p><ul><li>加密解密使用的密钥相同</li><li>将原始数据分割成关于固定大小的块, 逐个进行加密</li></ul><p><strong>缺陷</strong>:</p><ul><li>密钥过多</li><li>密钥分发有问题</li></ul><h3 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h3><p><strong>公钥加密</strong>极大地推动了现在互联网安全. 公钥加密中, 密钥是成对出现的. 公钥(publiic key)可以公开给所有人, 私钥(private key)是自己留存的, 必须保证安全性. 但是密钥长度非常长, 通常都是1024,2048位为起点的.长则4096, 甚至还有8192位的都有. 使用公钥加密的数据, 仅仅能通过与之配对的私钥解密, 反之亦然.</p><p>常见的公钥加密有三种功能: <strong>身份认证(数字签名)</strong>, <strong>密钥交换</strong>, <strong>数据加密</strong>   </p><p>常见的算法有: RSA[数字签名和加密都能实现], DSA(DSS)[仅能用于数字签名], ELGamal</p><p>一般情况下, 我们很少使用公钥加密来进行数据加密, 因为太长了, 光加密就需要很长时间. 基本上慢对称加密的三个数量级. 但事实上, 我们可以用来加密密钥. 这样就解决了之前对称加密的密钥分发问题. 发送方使用接收方的公钥进行密钥加密, 接着接收方使用自己的私钥进行解密. 最后就可以通过这个对称密钥进行加密通信了.</p><p>那么数字签名是怎么实现的呢? 数字签名的作用是让接收方知道发送方的身份. 过程如下: 发送方在发送前使用单向计算得到自己要发送数据的特征码, 接着使用自己的私钥加密这个特征码附在数据的尾部发送过去, 接收方先尝试使用发送方的公钥进行特征码解密, 如果能解开, 就说明是发送方的发的,但是数据是否被人篡改过呢,使用同样的单向算法进行特征码计算, 最后再进行对比. 这样就可以了. </p><p>但是这样就安全了吗? 不. 这一个过程依靠于最开始的公钥上.如果在通信线路上潜伏的人截取了最一开始的公钥, 而把自己的公钥发送过去的话, 后面就可想而知了.</p><p>所以引入CA, 也就是证书签署机构. 在一开始扔过去的公钥不是公钥本身, 而是自己的证书.证书中有他的公钥.首先找到有公信力的组织, 证明身份, 接着机构就会扔给他证书, 证书上会有自己的戳. 所以接收方先对证书进行完整性验证, 接着验证证书机构, 最后才会接收到公钥.</p><p>如果使用公钥加密, 我们只要维护一对儿密钥就行啦.</p><h3 id="单向加密-签名"><a href="#单向加密-签名" class="headerlink" title="单向加密(签名)"></a>单向加密(签名)</h3><p>只能加密, 不能解密. 因为主要目的是为了提取数据指纹, 用来保证数据的完整性.</p><p>特性: 定长输出(无论数据是什么长度的, 加密后的都是一样长度的), 雪崩效应(源数据的微小改变都会引起结果的巨大改变)</p><p>常见的加密算法有: MD5, SHA1, SHA256, SHA512</p><p>OK, 现在我们来说一种糅合了所有方法的通信过程, 让第三方无计可施!</p><p>首先, 发信人使用单向加密算法提取发送数据的特征码, 接着用自己的私钥加密这段特征码并附在数据的最末尾. 接着发信人使用对称密钥加密整段数据, 包括特征码在内的全部数据 (此时收信人没有解密该数据的能力–没有密钥) 接着发信人使用收信人的公钥加密自己的对称密钥并附在这段数据的最后面. 就是这样, 发送过去.</p><p>收信人收到了之后, 就可以先用自己的私钥去解密这段密钥, 如果能解密就得到了配对的对称密钥, 这样就可以继续得到数据和尾部加了密的特征码. 所以, 接着使用对方的公钥得到特征码, 再使用同样的单向加密算法进行计算, 比对指纹. 这样就完成了一次数据收发.</p><p>虽然看起来已经很理想了, 但是这样的密钥交换还是不安全啊.</p><p>所以我们又引入了一种密钥交换协议: IKE ( Internet Key Exchange ). </p><p>另外一种常见的算法是: DH ( Deffie-Hellman ) 这个算法很独特, 密钥不需要在互联网上发送.怎么实现的呢?简单的说一下: </p><p>首先, 双方为了实现密钥交换, 需要选择一个<strong>大的质数(p)<strong>和一个</strong>生成器(g)</strong> , 这个信息是公开的 通信过程也都是明文. 接着双方各生成一个保留数据(隐私, 只有自己知道, 假定为x,y) 接着发送方发送p^x%g的<strong>结果</strong>, 接收方也发送p^y%g<strong>结果</strong>. 接着双方各自进行y,x的次方运算. 结果一样! <strong>这个结果,就是密钥</strong>.</p><h2 id="证书和CA"><a href="#证书和CA" class="headerlink" title="证书和CA"></a>证书和CA</h2><p>一些概念:</p><p><strong>PKI</strong>: public key Insfrastructure</p><p>签证机构: CA</p><p>注册机构: RA</p><p>证书吊销列表: CRL (revoke list)</p><p>证书存取库</p><p>X.509: 定义了证书的结构和认证协议标准 它规定一个证书需要包含下面的要素:</p><ul><li>版本号</li><li>序列号</li><li>签名算法ID</li><li>发行者的名称</li><li>有效期限</li><li>主体名称(拥有者)</li><li>主体公钥</li><li>发行者的唯一标识</li><li>主体的唯一标识</li><li>扩展</li><li>发行者签名</li></ul><p>在上面 的例子中, 我们说关于证书的一些, 其实并不能确保这些证书就是可以信任的. 所以我们还是要验证对方的证书是否可信. 首先,接收方找到证书发行者的签名. 接着,在本地我找到CA的证书使用公钥进行解密, 如果可以, 那么<strong>姑且认为这个证书可能是可信的</strong>. 接着还是, 经过了完整性验证, 才会认为是可信的.</p><p>在我们的机器上有两种类型的证书: <strong>主机证书</strong>和<strong>个人证书</strong> .</p><h2 id="SSL-x2F-TLS"><a href="#SSL-x2F-TLS" class="headerlink" title="SSL&#x2F;TLS"></a>SSL&#x2F;TLS</h2><p>之前说过SSL&#x2F;TLS的一些原理啥的. 但是没有怎么说说历史, 现在列在下面:</p><ul><li>1995, SSL 2.0, Netscape</li><li>1996, SSL 3.0</li><li>1999, TLS 1.0 (Transport Layer Security)</li><li>2006, TLS 1.1 RFC 4346</li><li>2008, TLS 1.2</li><li>2015, TLS 1.3</li></ul><p>现在nginx等已经支持TLS1.3, 而各大现代浏览器也推出TLS1.3的实验性支持. 对于SSL&#x2F;TLS的简单理解, 可以参考之前的 <a href="https://yaoxuannn.com/2017/04/04/%E5%AF%B9SSL-TLS%E7%9A%84%E7%90%86%E8%A7%A3/">我对SSl&#x2F;TLS的理解</a> (已更新)</p><h2 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h2><p>OpenSSL是什么? OpenSSL开源项目, 主要包含了三个组件:</p><ul><li>openssl: 多用途的命令行工具</li><li>libcrypto: 公共加密库</li><li>libssl: 库, 实现了SSL&#x2F;TLS的功能.</li></ul><p>OK, 现在就来看一下我们的主角.openssl命令行客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Standard commands</span><br><span class="line">asn1parse         ca                ciphers           cms               </span><br><span class="line">crl               crl2pkcs7         dgst              dh                </span><br><span class="line">dhparam           dsa               dsaparam          ec                </span><br><span class="line">ecparam           enc               engine            errstr            </span><br><span class="line">gendh             gendsa            genpkey           genrsa            </span><br><span class="line">nseq              ocsp              passwd            pkcs12            </span><br><span class="line">pkcs7             pkcs8             pkey              pkeyparam         </span><br><span class="line">pkeyutl           prime             rand              req               </span><br><span class="line">rsa               rsautl            s_client          s_server          </span><br><span class="line">s_time            sess_id           smime             speed             </span><br><span class="line">spkac             ts                verify            version           </span><br><span class="line">x509              </span><br><span class="line"></span><br><span class="line">Message Digest commands (see the `dgst<span class="string">&#x27; command for more details)</span></span><br><span class="line"><span class="string">md2               md4               md5               rmd160            </span></span><br><span class="line"><span class="string">sha               sha1              </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Cipher commands (see the `enc&#x27;</span> <span class="built_in">command</span> <span class="keyword">for</span> more details)</span><br><span class="line">aes-128-cbc       aes-128-ecb       aes-192-cbc       aes-192-ecb       </span><br><span class="line">aes-256-cbc       aes-256-ecb       <span class="built_in">base64</span>            bf                </span><br><span class="line">bf-cbc            bf-cfb            bf-ecb            bf-ofb            </span><br><span class="line">camellia-128-cbc  camellia-128-ecb  camellia-192-cbc  camellia-192-ecb  </span><br><span class="line">camellia-256-cbc  camellia-256-ecb  cast              cast-cbc          </span><br><span class="line">cast5-cbc         cast5-cfb         cast5-ecb         cast5-ofb         </span><br><span class="line">des               des-cbc           des-cfb           des-ecb           </span><br><span class="line">des-ede           des-ede-cbc       des-ede-cfb       des-ede-ofb       </span><br><span class="line">des-ede3          des-ede3-cbc      des-ede3-cfb      des-ede3-ofb      </span><br><span class="line">des-ofb           des3              desx              idea              </span><br><span class="line">idea-cbc          idea-cfb          idea-ecb          idea-ofb          </span><br><span class="line">rc2               rc2-40-cbc        rc2-64-cbc        rc2-cbc           </span><br><span class="line">rc2-cfb           rc2-ecb           rc2-ofb           rc4               </span><br><span class="line">rc4-40            seed              seed-cbc          seed-cfb          </span><br><span class="line">seed-ecb          seed-ofb          zlib  </span><br></pre></td></tr></table></figure><p>支持的命令和参数都超级多!  三种命令: 标准命令, 消息摘要加密命令以及加密命令. 我们使用前两个的场合多一些.</p><p>来说一下加密命令enc吧, 比如说就用fstab为例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># openssl enc -e -des3 -a -salt -in fstab -out fstab.ciphertext</span></span><br><span class="line">enter des-ede3-cbc encryption password:</span><br><span class="line">Verifying - enter des-ede3-cbc encryption password:</span><br><span class="line"><span class="comment"># 上面的各项参数, -e表示加密, -d就是解密啦, 直接用-来表明自己想用的算法, -a表示使用文本格式存储而不是二进制, -salt表示加入杂质, -in和-out分别表示输入文件和输出文件</span></span><br><span class="line">[root@WWW ~]<span class="comment"># rm -rf fstab</span></span><br><span class="line">[root@WWW ~]<span class="comment"># cat fstab.ciphertext </span></span><br><span class="line">U2FsdGVkX1826FuxTIr5mUu49Nri1/xwwPeaPVy1vc8KQ8jkWPvOzvEgNLGjATM7</span><br><span class="line">YA7uVD3+FjXeykyxs8zn6alg3WZ9AbwBynaTYfJqtBytcdWv8g1pD/BbfWbZrxNI</span><br><span class="line">JUsgkz5RweTNTMQRwNBKlclhsc8H3YxXtBma6haR6kT6nR9defYzWvRXyrqzKm7d</span><br><span class="line">lJXhLXI/NXuKiZGwfjYaYRw/8u5P3gp2k4Ufux5O4co5Co8zIs1137BdzD4h2W08</span><br><span class="line">ncj9BZ316n8yeFENQGirScU+6Jnda6/qrNSHqKb8c25VKT9OtdjWpdBhboS2sUq7</span><br><span class="line">S5gAo0+Jpm2Hy8xF7RJm9LAyVImqTTn5NfOmobC9cBq3Jt9EYEgiCZI1mH0SADEX</span><br><span class="line">+iofQayvy4a04okQbt1umxW9DYzBd1cUByPGC6qXwbv3JstkzuLKMak8Lm1awGCw</span><br><span class="line">8fjVkzlbdEpGsMCJNfvNtus5gWc6oPQ6ztUvJXSi30YsKc1Kqu3c09ituMcIppwL</span><br><span class="line">oe0B3bTRpZsxRx/K8P74E61tk065C6Wgy0EwMXrN7I8q1oS2dSFtfS9on177I6p6</span><br><span class="line">VX6wVe71f7Vrnt+kCtda40dHF4CUZYppmDvR7XFFDfPuBYpjLtWLq6oQpLzwDACy</span><br><span class="line">sj70VGSCw7c=</span><br><span class="line"><span class="comment"># 现在尝试解密这个文件</span></span><br><span class="line">[root@WWW ~]<span class="comment"># openssl enc -d -des3 -a -salt -in fstab.ciphertext -out fstab</span></span><br><span class="line">enter des-ede3-cbc decryption password:</span><br><span class="line"><span class="comment"># 和刚才其实是一样的, 只要把-e改成-d就行了</span></span><br><span class="line">[root@WWW ~]<span class="comment"># cat fstab</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># /etc/fstab</span></span><br><span class="line"><span class="comment"># Created by anaconda on Sat Jun 24 22:20:05 2017</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;</span></span><br><span class="line"><span class="comment"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">/dev/mapper/cl-root     /                       xfs     defaults        0 0</span><br><span class="line">UUID=74cf0f28-3566-4155-bfbb-4c9057316c8e /boot                   xfs     defaults        0 0</span><br><span class="line">/dev/mapper/cl-swap     swap                    swap    defaults        0 0</span><br></pre></td></tr></table></figure><p>接下来介绍单向加密的工具: md5sum, sha1sum, sha224sum, sha256sum, … , openssl dgst</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># md5sum fstab</span></span><br><span class="line">06f9bcd23c16ba2f608412119455c7c6  fstab</span><br><span class="line">[root@WWW ~]<span class="comment"># openssl dgst -md5 fstab</span></span><br><span class="line">MD5(fstab)= 06f9bcd23c16ba2f608412119455c7c6</span><br><span class="line"><span class="comment"># 如果想要把这段保存到文件中, 可以在前面加上-out参数哦</span></span><br></pre></td></tr></table></figure><p>再认识一个MAC, 我们已经认识到很多MAC了啊hhh, 这个MAC是单向加密的一种延伸应用, 用于实现网络传输中的数据完整性. 所使用的机制就是CBC-MAC或者HMAC(常用): 使用md5或者sha1算法. 这个玩意在集群中有很大的用处, 通过预共享密钥来证明彼此之间的身份.</p><p>还可以用来生成用户密码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># openssl passwd -1 -salt 12345</span></span><br><span class="line">Password: </span><br><span class="line">$1$12345<span class="variable">$0kPkvHGvrNZfdM</span>/fFERea.</span><br></pre></td></tr></table></figure><p>还可以生成随机数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># openssl rand -base64 10</span></span><br><span class="line">13eS4qtUtsu6qg==</span><br><span class="line">[root@WWW ~]<span class="comment"># openssl rand -base64 10</span></span><br><span class="line">t3Fx1SermE8v7w==</span><br><span class="line">[root@WWW ~]<span class="comment"># openssl rand -base64 10</span></span><br><span class="line">Q2tqCLDtAQWm9w==</span><br><span class="line">[root@WWW ~]<span class="comment"># openssl rand -hex 10</span></span><br><span class="line">9c12c8bf820066d2e964</span><br><span class="line">[root@WWW ~]<span class="comment"># openssl rand -hex 10</span></span><br><span class="line">5545589b64df7477e382</span><br><span class="line">[root@WWW ~]<span class="comment"># openssl rand -hex 10</span></span><br><span class="line">f60aadd685c548cd6d25</span><br></pre></td></tr></table></figure><p>还可以进行公钥加密&#x2F;数字签名.</p><blockquote><p>稍微扯一下随机数生成器.只要是软件的随机都是有规律可寻的, 不是完全的随机. 哪些才叫做随机呢?比如你敲击键盘两次的时间间隔, 磁盘IO中断的时间间隔等等. 操作系统维护了一个内存空间专门用来这些值存进去, 当程序需要随机数的时候, 就从这里取就行了. 这个空间, 我们把它叫做<strong>熵池</strong> 这个熵池已经作为一个device存在了. 所以有专门的虚拟设备random和urandom. 都位于&#x2F;dev下. 他们的主要区别就是random只从熵池中取随机数, 如果没有了就堵塞了. 但是urandom在熵池空了的情况下就会使用软件 的方式来生成伪随机数. 这样并不安全, 但不会堵塞.</p></blockquote><p>接下来看一下怎么产生一对密钥:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># openssl genrsa -out rsa.pri</span></span><br><span class="line">Generating RSA private key, 1024 bit long modulus</span><br><span class="line">.....................++++++</span><br><span class="line">...........++++++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">[root@WWW ~]<span class="comment"># openssl genrsa -out rsa.pri 2048 # 默认是1024, 也可指定</span></span><br><span class="line">Generating RSA private key, 2048 bit long modulus</span><br><span class="line">..............+++</span><br><span class="line">.............................................+++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">[root@WWW ~]<span class="comment"># openssl rsa -in rsa.pri -pubout</span></span><br><span class="line">writing RSA key</span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyhOpjjSkWIRR6ONXMRcC</span><br><span class="line">GehrYjngRqQ4mWgr0LTdKispXhKBnGnu7TaVTB+lJnE1H8Rozd9oja/YCSxtfn/R</span><br><span class="line">LJWCFx3HAoL+o8JGcvRAJuqGHIoTjR5njzInsu81ZuhTVBn01TmfXlfbDLDxqWrz</span><br><span class="line">vrUg0fywBqtIbI9wzdrjuvJlIiHB8JUwkPK+CDb9htERhkhrr/X1P44XA4lI0LA2</span><br><span class="line">RIbCK7fiOVMaqQB2HA21s7dxZ5UZ7pH3KQ5SHeF+8F0/8DZZieO6Z2HCqgtwtrUN</span><br><span class="line">1Mx/wSXmO271cprwM2v01t2tqvED2OYMeN6aVsgCbdbBdVHzYgLgBxlZYE1NL0GU</span><br><span class="line">8QIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line"><span class="comment"># 这样就得到了一对公私钥</span></span><br><span class="line"><span class="comment"># 但是这个时候查看一下文件</span></span><br><span class="line">[root@WWW ~]<span class="comment"># ls rsa.pri -l</span></span><br><span class="line">-rw-r--r-- 1 root root 1675 Sep  8 12:12 rsa.pri</span><br><span class="line"><span class="comment"># 这可不行 这个文件可是最重要的私钥文件啊</span></span><br><span class="line">[root@WWW ~]<span class="comment"># chmod og= rsa.pri </span></span><br><span class="line">[root@WWW ~]<span class="comment"># ls rsa.pri -l</span></span><br><span class="line">-rw------- 1 root root 1675 Sep  8 12:12 rsa.pri</span><br><span class="line"><span class="comment"># 但是这样有点麻烦 为什么不在生成的时候就是这样呢, 所以我们可以这样执行</span></span><br><span class="line">[root@WWW ~]<span class="comment"># (umask 077 ;openssl genrsa -out rsa2.pri 2048)</span></span><br><span class="line">Generating RSA private key, 2048 bit long modulus</span><br><span class="line">..........................+++</span><br><span class="line">..+++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">[root@WWW ~]<span class="comment"># ls rsa2.pri -l</span></span><br><span class="line">-rw------- 1 root root 1679 Sep  8 12:20 rsa2.pri</span><br><span class="line">[root@WWW ~]<span class="comment"># umask </span></span><br><span class="line">0022</span><br><span class="line"><span class="comment"># 在子shell中进行umask临时修改, 这样就很方便啦</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OpenSSL </tag>
            
            <tag> password </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux日志服务</title>
      <link href="/2017/09/07/Linux%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1/"/>
      <url>/2017/09/07/Linux%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>日志是我们排错的重要参考, 现在就来学习一下Linux上重要的日志吧.</p><span id="more"></span><h2 id="Linux日志简要说明"><a href="#Linux日志简要说明" class="headerlink" title="Linux日志简要说明"></a>Linux日志简要说明</h2><p>众所周知的是, Linux上跑了很多daemons, 他们在运行的时候总归会有很多通知要显示, 这些通知最终就会被记录到日志中了. 换句话说, 记录这些重要信息和通知就是日志服务所要做的工作了.</p><p>日志服务可以很方便的帮助管理人员: 1) 解决系统错误 2) 查看过去时间的事件 3) 解决网络服务的问题</p><p>现在我们就来了解一下常见的Linux日志文件都是记录了什么东西: (就假定前缀都是&#x2F;var&#x2F;log了, 懒得写了)</p><h3 id="boot-log"><a href="#boot-log" class="headerlink" title="boot.log"></a>boot.log</h3><p>这个日志中记录的就是我们进入系统的时候看到的那一大串输出信息, 关于系统是如何启动的,从这里面也可以学到很多~ 但是 这个文件仅仅会记录这一次开机的信息, 前次的信息都会被覆盖.</p><h3 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h3><p>这个日志我们在之前的 <a href="https://yaoxuannn.com/2017/04/27/Crontab%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/">Crontab学习日志</a> 中提到了一下 对于crontab进程是否正常进行, 是否正确书写crontab 的debug很有帮助.</p><h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><p>这个文件记录的是开机时, 内核扫描硬件过程所产生的各种信息, 这些信息CentOS预设将他们取消显示, 所以额外记录一份在这里面. 直接提供有同名的命令可以来输出dmesg的信息.</p><h3 id="lastlog"><a href="#lastlog" class="headerlink" title="lastlog"></a>lastlog</h3><p>记录系统上所有账号最近一次登录系统的相关信息, 和dmesg一样, 有同名命令来查看输出, 不同的是, 这个文件是一个data文件, 所以你不能直接cat它. </p><h3 id="maillog-x2F-mail-x2F"><a href="#maillog-x2F-mail-x2F" class="headerlink" title="maillog&#x2F;mail&#x2F;*"></a>maillog&#x2F;mail&#x2F;*</h3><p>记录邮件的往来. 其实主要是记录postfix (SMTP提供者)与dovecot (POP3提供者)所产生的信息 .</p><blockquote><p>SMTP是发信所使用的通讯协议， POP3则是收信使用的通讯协议</p><p>postfix与dovecot则分别是两套使用这个通讯协议的软件. </p></blockquote><h3 id="message"><a href="#message" class="headerlink" title="message"></a>message</h3><p>这个日志非常重要啦. 系统错误或者重要的信息都会记录在这里. 我们在查看系统错误的时候, 这个文件是一定要查查看的之一.</p><h3 id="secure"><a href="#secure" class="headerlink" title="secure"></a>secure</h3><p>只要是涉及到用户登录,密码输入的程序(ssh, login, telnet, su, sudo啥的..)都会有记录在这个文件里, 不论登录的结果是成功还是错误.</p><h3 id="wtmp-faillog"><a href="#wtmp-faillog" class="headerlink" title="wtmp, faillog"></a>wtmp, faillog</h3><p>这两个日志可以记录正确登入系统的账号信息以及错误的时候的信息, 如果要读取wtmp, 可以使用last程序~.</p><h3 id="x2F-httpd-x2F-samba-x2F"><a href="#x2F-httpd-x2F-samba-x2F" class="headerlink" title="&#x2F;httpd&#x2F;* , samba&#x2F;*"></a>&#x2F;httpd&#x2F;* , samba&#x2F;*</h3><p>常见的网络服务啥的, 会用自己的日志文件来记录他们自己产生的各项信息.</p><p><strong>上面就是一些常见的日志文件, 但是要说明的是, 不同的Linux distribution的日志文件是不一样的, 有的可能有, 有的可能没有, 但是大家都会有一个messages文件.</strong></p><p>那么问题来了, 这些日志是怎么产生的呢? 或者说, 是谁写的呢?</p><p>除了上面说过的, 有应用程序自己处理的日志文件之外, 另一种就是Linux distribution提供的日志服务来统一管理了, 只需要将信息传递给这个服务, 他就会自己分门别类按照格式将信息放到对应的日志文件中去. CentOS中提供<strong>rsyslog.service</strong>这个服务来统一管理. </p><p>那么我们在提出第二个问题,如果说这些日志服务一直奋力的工作, 那么几天之后我们的日志文件岂不是就会变得无比巨大嘛~ 而太大的文件读写效率并不高,所以就要想办法来进行备份和更新. 为了解决这个问题, 引入logrotate这个东西, 它就是来自动化的实现这一过程的.</p><p>总结一下，针对日志文件所需的功能，我们需要的服务与程序有：</p><ul><li>systemd-journald.service：最主要的信息收受者, 由systemd提供</li><li>rsyslog.service：主要登录系统与网络等服务的信息</li><li>logrotate：主要在进行日志文件的轮替功能</li></ul><h2 id="使用systemd来进行简单的日志管理"><a href="#使用systemd来进行简单的日志管理" class="headerlink" title="使用systemd来进行简单的日志管理"></a>使用systemd来进行简单的日志管理</h2><p>刚刚上面的总结好像多了个什么奇怪的东西, emmm..这个journald其实就像是中间件一样, 由于系统是由systemd在管理, 所以消息日志会先发到systemd身上, 接着journald会把这些记录下来, 基于内存的方式. 这样的好处是快速, 却在开机重启后 丢失, 所以journald再将日志发送给rsyslogd, 接着日志信息就会被记录到磁盘中了.</p><p>journalctl就是我们实际使用的查看日志的工具了, 基本上你可以使用它来查看全部的日志, 所有的信息!! 而且更方便的是, 不同于rsyslogd分类的方式会使得你在一个日志里左找右找, journald可以使得你很快的定位到能看到的地方.</p><p>现在就来试用一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># journalctl # 什么参数也不加, 直接执行</span></span><br><span class="line">-- Logs begin at Wed 2017-09-06 00:09:06 EDT, end at Wed 2017-09-06 01:01:01 EDT. --</span><br><span class="line">Sep 06 00:09:06 localhost.localdomain systemd-journal[89]: Runtime journal is using 8.0M (max allowed 91.9M, trying to leave 137.9M free of 911.7M available → current limi</span><br><span class="line">Sep 06 00:09:06 localhost.localdomain kernel: Initializing cgroup subsys cpuset</span><br><span class="line">Sep 06 00:09:06 localhost.localdomain kernel: Initializing cgroup subsys cpu</span><br><span class="line">Sep 06 00:09:06 localhost.localdomain kernel: Initializing cgroup subsys cpuacct</span><br><span class="line">Sep 06 00:09:06 localhost.localdomain kernel: Linux version 3.10.0-514.21.2.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-11) (GC</span><br><span class="line">Sep 06 00:09:06 localhost.localdomain kernel: Command line: BOOT_IMAGE=/vmlinuz-3.10.0-514.21.2.el7.x86_64 root=/dev/mapper/cl-root ro crashkernel=auto rd.lvm.lv=cl/root r</span><br><span class="line">...(omitted)</span><br><span class="line"><span class="comment"># 从这次开机以来的所有记录, 量非常大</span></span><br><span class="line">[root@WWW ~]<span class="comment"># journalctl --since today # 从今天开始的所有记录, 由于我刚开的机, 所以和上面一样</span></span><br><span class="line">-- Logs begin at Wed 2017-09-06 00:09:06 EDT, end at Wed 2017-09-06 01:01:01 EDT. --</span><br><span class="line">Sep 06 00:09:06 localhost.localdomain systemd-journal[89]: Runtime journal is using 8.0M (max allowed 91.9M, trying to leave 137.9M free of 911.7M available → current limi</span><br><span class="line">Sep 06 00:09:06 localhost.localdomain kernel: Initializing cgroup subsys cpuset</span><br><span class="line">Sep 06 00:09:06 localhost.localdomain kernel: Initializing cgroup subsys cpu</span><br><span class="line">Sep 06 00:09:06 localhost.localdomain kernel: Initializing cgroup subsys cpuacct</span><br><span class="line">Sep 06 00:09:06 localhost.localdomain kernel: Linux version 3.10.0-514.21.2.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-11) (GC</span><br><span class="line">Sep 06 00:09:06 localhost.localdomain kernel: Command line: BOOT_IMAGE=/vmlinuz-3.10.0-514.21.2.el7.x86_64 root=/dev/mapper/cl-root ro crashkernel=auto rd.lvm.lv=cl/root r</span><br><span class="line">...(omitted)</span><br><span class="line"><span class="comment"># 既然有了since, 自然就有until, 其实这两个可以直接写成-S和-U, 如果是昨天的话, 也可以直接使用yesterday</span></span><br><span class="line">[root@WWW ~]<span class="comment"># journalctl --since &quot;2017-09-06 00:00:00&quot; --until &quot;2017-09-07 00:00:00&quot; </span></span><br><span class="line">...(omitted)</span><br><span class="line"><span class="comment"># 方便的是, 我们可以直接指定查看哪一个的UNIT的日志, 使用-u或者--unit, 比如:</span></span><br><span class="line">[root@WWW ~]<span class="comment"># journalctl -u rsyslog</span></span><br><span class="line">-- Logs begin at Wed 2017-09-06 00:09:06 EDT, end at Wed 2017-09-06 01:26:47 EDT. --</span><br><span class="line">Sep 06 00:09:34 WWW systemd[1]: Starting System Logging Service...</span><br><span class="line">Sep 06 00:09:34 WWW systemd[1]: Started System Logging Service.</span><br><span class="line"><span class="comment"># 如果有的时候输出太多了, 或者我只想查看部分怎么办呢, 有-n参数帮你解决</span></span><br><span class="line">[root@WWW ~]<span class="comment"># journalctl -n 10</span></span><br><span class="line">[root@WWW ~]<span class="comment"># journalctl -n 5</span></span><br><span class="line">-- Logs begin at Wed 2017-09-06 00:09:06 EDT, end at Wed 2017-09-06 01:26:47 EDT. --</span><br><span class="line">Sep 06 01:26:47 WWW NetworkManager[742]: &lt;info&gt;  [1504675607.0186] dhcp4 (enp0s3): state changed bound -&gt; bound</span><br><span class="line">Sep 06 01:26:47 WWW dbus[593]: [system] Activating via systemd: service name=<span class="string">&#x27;org.freedesktop.nm_dispatcher&#x27;</span> unit=<span class="string">&#x27;dbus-org.freedesktop.nm-dispatcher.service&#x27;</span></span><br><span class="line">Sep 06 01:26:47 WWW systemd[1]: Starting Network Manager Script Dispatcher Service...</span><br><span class="line">Sep 06 01:26:47 WWW dbus-daemon[593]: dbus[593]: [system] Activating via systemd: service name=<span class="string">&#x27;org.freedesktop.nm_dispatcher&#x27;</span> unit=<span class="string">&#x27;dbus-org.freedesktop.nm-dispatcher.ser</span></span><br><span class="line"><span class="string">Sep 06 01:26:47 WWW dhclient[845]: bound to 192.168.56.101 -- renewal in 584 seconds.</span></span><br><span class="line"><span class="string">lines 1-6/6 (END) # 这样就可以仅仅查看部分, 节选的日志</span></span><br><span class="line"><span class="string"># 另外, 还可以直接指定PID/UID.~</span></span><br><span class="line"><span class="string">[root@WWW ~]# journalctl _PID=`pidof crond`</span></span><br><span class="line"><span class="string">-- Logs begin at Wed 2017-09-06 00:09:06 EDT, end at Wed 2017-09-06 01:36:31 EDT. --</span></span><br><span class="line"><span class="string">Sep 06 00:09:22 WWW crond[614]: (CRON) INFO (RANDOM_DELAY will be scaled with factor 88% if used.)</span></span><br><span class="line"><span class="string">Sep 06 00:09:22 WWW crond[614]: (CRON) INFO (running with inotify support)</span></span><br><span class="line"><span class="string"># 还可以只查看相对应等级的日志</span></span><br><span class="line"><span class="string">[root@WWW ~]# journalctl -p err</span></span><br><span class="line"><span class="string">-- Logs begin at Wed 2017-09-06 00:09:06 EDT, end at Wed 2017-09-06 01:36:31 EDT. --</span></span><br><span class="line"><span class="string">Sep 06 00:09:19 WWW kernel: intel_rapl: no valid rapl domains found in package 0</span></span><br><span class="line"><span class="string">Sep 06 00:09:27 WWW systemd[1]: Failed to start vboxadd.service.</span></span><br><span class="line"><span class="string">Sep 06 00:09:27 WWW systemd[1]: Failed to start vboxadd-service.service.</span></span><br><span class="line"><span class="string">Sep 06 00:09:35 WWW postfix/sendmail[1437]: fatal: parameter inet_interfaces: no local interface found for ::1</span></span><br><span class="line"><span class="string">Sep 06 00:09:35 WWW postfix[1450]: fatal: parameter inet_interfaces: no local interface found for ::1</span></span><br><span class="line"><span class="string">Sep 06 00:09:36 WWW systemd[1]: Failed to start Postfix Mail Transport Agent.</span></span><br><span class="line"><span class="string"># 最后说两个常用的参数, -r和-f</span></span><br><span class="line"><span class="string"># -r就是reverse的意思啦, 最近时间的日志先输出</span></span><br><span class="line"><span class="string"># -f就是follow的意思, 和tail -f的-f是一样的效果了</span></span><br></pre></td></tr></table></figure><h2 id="rsyslog"><a href="#rsyslog" class="headerlink" title="rsyslog"></a>rsyslog</h2><p>rsyslog其实一个升级版的syslog, 它支持更多特性, 例如: </p><ul><li>多线程</li><li>SSL, TLS, UDP, TCP</li><li>MySQL, PGSQl, Oracle实现日志存储</li><li>过滤器, 实现过滤日志中的任意部分</li><li>自定义输出格式</li></ul><p>这些介绍在其RPM包的介绍中也有:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpm -qi rsyslog</span></span><br><span class="line">Name        : rsyslog                      Relocations: (not relocatable)</span><br><span class="line">Version     : 4.6.2                             Vendor: CentOS</span><br><span class="line">Release     : 12.el6                        Build Date: Thu 08 Dec 2011 05:40:21 AM CST</span><br><span class="line">Install Date: Fri 16 Dec 2011 01:49:45 PM CST      Build Host: c6b4.bsys.dev.centos.org</span><br><span class="line">Group       : System Environment/Daemons    Source RPM: rsyslog-4.6.2-12.el6.src.rpm</span><br><span class="line">Size        : 1560043                          License: GPLv3+</span><br><span class="line">Signature   : RSA/SHA1, Fri 09 Dec 2011 05:07:22 AM CST, Key ID 0946fca2c105b9de</span><br><span class="line">Packager    : CentOS BuildSystem &lt;http://bugs.centos.org&gt;</span><br><span class="line">URL         : http://www.rsyslog.com/</span><br><span class="line">Summary     : Enhanced system logging and kernel message trapping daemons</span><br><span class="line">Description :</span><br><span class="line">Rsyslog is an enhanced, multi-threaded syslog daemon. It supports MySQL,</span><br><span class="line">syslog/TCP, RFC 3195, permitted sender lists, filtering on any message part,</span><br><span class="line">and fine grain output format control. It is compatible with stock sysklogd</span><br><span class="line">and can be used as a drop-in replacement. Rsyslog is simple to <span class="built_in">set</span> up, with</span><br><span class="line">advanced features suitable <span class="keyword">for</span> enterprise-class, encryption-protected syslog</span><br><span class="line">relay chains.</span><br></pre></td></tr></table></figure><p>而现在一些中型的互联网公司会选择使用elasticsearch, logstash, kibana &#x3D; elk组合, 也就是分布式日志存储系统 + 日志收集器 + 前端日志展示组合. </p><p>现在就来正经的说说这个rsyslog服务吧.  先来看一下我们的日志的一般格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sep 06 00:09:22 WWW  crond[614]: (CRON) INFO (running with inotify support)</span><br><span class="line">|---日期/时间---|主机|服务/程序/[PID]| 具体信息...</span><br></pre></td></tr></table></figure><p>OK, 接下来就先从rsyslog.service的配置文件来说起!</p><blockquote><p>可能你会觉得奇怪, 为什么要有主机这个选项. 日志不就是自己机器的记录嘛. 这是因为我们的机器是可以充当日志服务器 收集记录其他机器的日志.</p></blockquote><p>看一下rsyslog这个服务:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW <span class="built_in">log</span>]<span class="comment"># systemctl status rsyslog</span></span><br><span class="line">● rsyslog.service - System Logging Service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/rsyslog.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Wed 2017-09-06 00:09:34 EDT; 1h 57min ago</span><br><span class="line"> Main PID: 1005 (rsyslogd)</span><br><span class="line">   CGroup: /system.slice/rsyslog.service</span><br><span class="line">           └─1005 /usr/sbin/rsyslogd -n</span><br><span class="line"></span><br><span class="line">Sep 06 00:09:34 WWW systemd[1]: Starting System Logging Service...</span><br><span class="line">Sep 06 00:09:34 WWW systemd[1]: Started System Logging Service.</span><br></pre></td></tr></table></figure><p>显然是启动了的, 而且也已经开机自动启动了~.</p><p>rsyslog的配置很好找, 就在&#x2F;etc&#x2F;下, 重点在这个文件的<code>RULES</code>部分. 规定了<strong>什么服务</strong>, <strong>什么等级</strong>, <strong>需要被记录在哪里</strong> 这三个东西 所以设定起来就是这个样子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以mail这个服务产生的info等级为例：</span></span><br><span class="line">mail.info /var/log/maillog_info</span><br><span class="line"><span class="comment"># 这一行说明：mail 服务产生的**大于等于** info 等级的讯息，都记录到 </span></span><br><span class="line"><span class="comment"># /var/log/maillog_info 档案中</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是那个 服务名和等级中间的**.**  .</p><p>这个点就像是运算符一样的东西, 规则是这样的:</p><ul><li>. ：代表比后面还要严重的等级(含该等级)都被记录下来，例如： mail.info代表只要是mail的信息，而且该信息等级严重于info (含info本身)时，就会被记录下来.</li><li>.&#x3D; ：代表所需要的等级就是后面接的等级而已(完全匹配)</li><li>.! ：有点反向选择的感觉，代表忽略大于等于这个等级的信息(低于这个等级的才会被纪录)</li></ul><p>那么有哪些信息等级呢? 下表:</p><table><thead><tr><th align="left">等级数值</th><th>等级名称</th><th>说明</th></tr></thead><tbody><tr><td align="left">7</td><td>debug</td><td>用来debug (除错) 时产生的</td></tr><tr><td align="left">6</td><td>info</td><td>一些基本的说明</td></tr><tr><td align="left">5</td><td>notice</td><td>正常信息, 但比info 需要被注意到的一些内容</td></tr><tr><td align="left">4</td><td>warning (warn)</td><td>警示的讯息，可能有问题，但是还不至于影响到某个daemon 运作. 基本上， info, notice, warn 这三个都是在告知一些基本信息而已，还不至于干扰到系统运作</td></tr><tr><td align="left">3</td><td>err (error)</td><td>一些重大的错误讯息，例如配置文件的某些设定造成该服务无法启动的说明， 通常藉由err 的错误告知，可以了解到该服务无法启动的原因</td></tr><tr><td align="left">2</td><td>crit</td><td>比error 还要严重的错误信息，这个crit 是临界点(critical) 的缩写，这个错误已经很严重了</td></tr><tr><td align="left">1</td><td>alert</td><td>警告等级，已经很有问题的等级，比crit 还要严重</td></tr><tr><td align="left">0</td><td>emerg (panic)</td><td>疼痛等级，意指系统已经几乎要当机的状态. 很严重的错误资讯.  通常只有硬件出问题，导致整个核心无法顺利运行的时候，才会出现这样的等级的讯息</td></tr></tbody></table><p>syslog提供了多个不同的服务类型, 只要软件daemon进行对自己想要响应的服务类型发起调用, 就可以将日志托付到对应的文件里了. 用一张图可以来表示这个:</p><p><img src="http://linux.vbird.org/linux_basic/0570syslog//syslog_daemon.gif" alt="syslog 所制订的服务与软件调用的方式"></p><p>而如果这样的调用分配的不是很好的话, 就会造成某一个日志文件特别大, 其他的日志几乎没有什么内容. 所以在rsyslog.conf中所作的规范, 就要好好想想咯~.</p><p>OK~那现在我们就来看一下默认CentOS7所写的rsyslog.conf 是由哪些项目吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW etc]<span class="comment"># vim /etc/rsyslog.conf</span></span><br><span class="line"><span class="comment">#kern.*                                                 /dev/console</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none                /var/log/messages</span><br><span class="line">authpriv.*                                              /var/log/secure</span><br><span class="line">mail.*                                                  -/var/log/maillog</span><br><span class="line">cron.*                                                  /var/log/cron</span><br><span class="line">*.emerg                                                 :omusrmsg:*</span><br><span class="line">uucp,news.crit                                          /var/log/spooler</span><br><span class="line">local7.*                                                /var/log/boot.log</span><br></pre></td></tr></table></figure><p>首先第一个, 表示只要是内核产生的信息都进行终端的输出, 而这个console一般就是外部设备连接过来到一些封闭系统主机的.</p><p>后面都是一般的规则了, 但是我们注意到maillog那一行的前面加上了一个-号, 这个是什么意思呢? 有-号标识的表示日志较多(或者不是特别关键),优先放入buffer, 临界后再输出到磁盘的策略(简单的说就是异步写入).  那么<code>:omusrmsg:*</code> 又是什么意思呢? * 号表示当前在线的所有人, 而前面的那一串意思是发送消息, 也就是类似wall的效果.</p><p>当然了, 之前也说过了, 不同的发行版对于日志是不一样的, 其实就是因为这个默认配置文件不一样.</p><p>再回到文件的开头, 这里面加载了一些rsyslog会用到的模块, 这些模块都是rpm包安装的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### MODULES ####</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$ModLoad</span> imuxsock.so    <span class="comment"># provides support for local system logging (e.g. via logger command)</span></span><br><span class="line"><span class="variable">$ModLoad</span> imklog.so      <span class="comment"># provides kernel logging support (previously done by rklogd)</span></span><br><span class="line"><span class="comment">#$ModLoad immark.so     # provides --MARK-- message capability</span></span><br><span class="line">...(omitted)</span><br><span class="line">:! rpm -ql rsyslog</span><br><span class="line">/lib64/rsyslog/imfile.so</span><br><span class="line">/lib64/rsyslog/imklog.so</span><br><span class="line">/lib64/rsyslog/immark.so</span><br><span class="line">/lib64/rsyslog/imtcp.so</span><br><span class="line">/lib64/rsyslog/imudp.so</span><br><span class="line">/lib64/rsyslog/imuxsock.so</span><br><span class="line">/lib64/rsyslog/lmnet.so</span><br><span class="line">/lib64/rsyslog/lmnetstrms.so</span><br><span class="line">/lib64/rsyslog/lmnsd_ptcp.so</span><br><span class="line">/lib64/rsyslog/lmregexp.so</span><br><span class="line">/lib64/rsyslog/lmstrmsrv.so</span><br><span class="line">/lib64/rsyslog/lmtcpclt.so</span><br><span class="line">/lib64/rsyslog/lmtcpsrv.so</span><br><span class="line">/lib64/rsyslog/lmzlibw.so</span><br><span class="line">/lib64/rsyslog/ommail.so</span><br><span class="line">/lib64/rsyslog/omtesting.so</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>这些模块由一个共同的特点, 那就是有的是用im开头, 用的用om开头, 相信你也猜出来了, i就是输入, o就是输出.</p><h3 id="日志服务器的设定"><a href="#日志服务器的设定" class="headerlink" title="日志服务器的设定"></a>日志服务器的设定</h3><p>设定一个日志服务器其实是有很多好处的, 假如某一天你的主机遭到了入侵, Hacker删除了所有的日志, 但是由于你的日志还放到了日志服务器上, 这样就可以很快的追查到对方. 不仅如此, 10台服务器你就要挨个查看各自的日志, 但是如果有日志服务器的话, 你就可以直接去那一台机器上查看了.</p><p>那么说了这么多, 怎么设定一个日志服务器呢?</p><p>先来说说Server端的设定: </p><p>打开配置文件&#x2F;etc&#x2F;rsyslog.conf, 接着找到:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">14 # Provides UDP syslog reception</span><br><span class="line">15 #$ModLoad imudp</span><br><span class="line">16 #$UDPServerRun 514</span><br><span class="line">17 </span><br><span class="line">18 # Provides TCP syslog reception</span><br><span class="line">19 $ModLoad imtcp</span><br><span class="line">20 $InputTCPServerRun 514</span><br></pre></td></tr></table></figure><p>如果网络环境稳定, 就用UDP吧, 如果想要的是数据的可靠传输, 那么就用TCP, 解掉注释就行了.</p><p>接下来就很简单了, 只要重启服务, 这台Linux主机就可以作为一台日志服务器了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW etc]<span class="comment"># systemctl restart rsyslog</span></span><br><span class="line">[root@WWW etc]<span class="comment"># ss -antp</span></span><br><span class="line">State       Recv-Q Send-Q                                        Local Address:Port                                                       Peer Address:Port              </span><br><span class="line">LISTEN      0      128                                                       *:22                                                                    *:*                   <span class="built_in">users</span>:((&quot;sshd&quot;,pid=<span class="number">1011</span>,fd=<span class="number">3</span>))</span><br><span class="line">LISTEN      0      25                                                        *:514                                                                   *:*                   <span class="built_in">users</span>:((&quot;rsyslogd&quot;,pid=<span class="number">3087</span>,fd=<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>查看监听端口, 也可发现rsyslogd已经监听在514端口了.</p><p>Client端也很简单, 在配置文件的最下面, 有这样一句:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">89 <span class="comment"># remote host is: name/ip:port, e.g. 192.168.0.1:514, port optional</span></span><br><span class="line">90 <span class="comment">#*.* @@remote-host:514</span></span><br><span class="line">91 <span class="comment"># ### end of the forwarding rule ###</span></span><br></pre></td></tr></table></figure><p>解掉第90行的注释, 将remote-host改成日志服务器的IP就可以了. </p><blockquote><p>tip: 如果是TCP传输, 就写@@. 如果是UDP, 就只有一个@</p></blockquote><h2 id="logrotate"><a href="#logrotate" class="headerlink" title="logrotate"></a>logrotate</h2><p>最后来看看这个玩意的设定吧.</p><p>我们说过这个东西是一个自动化的工具, 用来定时将日志写入磁盘. 说到定时任务, 那么第一时间就想到了crontab! 进入&#x2F;etc&#x2F;cron.daily&#x2F;, 果然里面有logrotate. </p><p>现在就说说怎么设计这个logrotate. 首先, 这个日志轮替显然是有一定条件的, 这个条件就记录在&#x2F;etc&#x2F;logrotate.conf这个配置文件里面. 包括在&#x2F;etc&#x2F;logrotate.d&#x2F;下面的文件. 这些也一贯的会主动调用到conf文件里面.  在我们的log目录下, 一般都会有末尾序号或时间的日志或者有的经过了压缩. 而一段时间了之后, 太老的日志就会被删除.</p><p>OK, 现在就来看看默认的logrotate.conf这个配置文件吧.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">weekly     &lt;== 时间频率</span><br><span class="line">rotate 4   &lt;== 保留日志的个数</span><br><span class="line">create     &lt;== 由于日志被更名，因此建立一个新的来继续储存</span><br><span class="line">dateext    &lt;== 让被轮替的日志名称加上日期</span><br><span class="line"><span class="comment">#compress &lt;== 被轮替的日志是否需要压缩</span></span><br><span class="line">include /etc/logrotate.d</span><br><span class="line"><span class="comment"># 将/etc/logrotate.d/ 这个目录中的所有配置都读进来执行rotate的工作</span></span><br><span class="line"><span class="comment"># 下面就是单一设定, 如果由单一的设定就按照单一的处理, 没有的话就使用全局设定</span></span><br><span class="line">/var/log/wtmp &#123;        &lt;== 仅针对/var/log/wtmp所设定的参数 </span><br><span class="line">    monthly            &lt;== 每个月一次</span><br><span class="line">    create 0664 root utmp &lt;== 指定新建文件的权限与所属帐号/群组 </span><br><span class="line">    minsize 1M         &lt;== 档案容量一定要超过1M后才进行rotate (覆盖时间参数) </span><br><span class="line">    rotate 1           &lt;== 仅保留一个</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样就很清楚了吧, 当我们安装需要日志记录的程序的时候, 在RPM执行过程中就会把开发者写的logrotate配置文件拷贝到&#x2F;etc&#x2F;logrotate.d&#x2F;下面.</p><p>好吧, 现在就来看一下syslog是怎么写的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/var/log/cron</span><br><span class="line">/var/log/maillog</span><br><span class="line">/var/log/messages</span><br><span class="line">/var/log/secure</span><br><span class="line">/var/log/spooler</span><br><span class="line">&#123;</span><br><span class="line">    missingok <span class="comment"># 即使log丢了也没关系</span></span><br><span class="line">    sharedscripts <span class="comment"># 脚本开头声明</span></span><br><span class="line">    postrotate <span class="comment"># 脚本执行时机, post之后 pre之前.</span></span><br><span class="line">        /bin/kill -HUP `<span class="built_in">cat</span> /var/run/syslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || <span class="literal">true</span></span><br><span class="line">    endscript <span class="comment"># 脚本结束声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个脚本是要干什么啊, HUP这个信号是说重新读取配置文件, 也就相当是要平滑重启一次啦.  一般我们在post时期都会选择重新启动(因为名字变了啊), 而在pre的时候修改日志的属性.(比如a属性).</p><p>尽管是定时任务, 但是我们还是可以显式的调用Ta, 这样玩:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># logrotate -v /etc/logrotate.conf </span></span><br><span class="line">reading config file /etc/logrotate.conf</span><br><span class="line">including /etc/logrotate.d</span><br><span class="line">reading config file chrony</span><br><span class="line">reading config file httpd</span><br><span class="line">reading config file ppp</span><br><span class="line">reading config file syslog</span><br><span class="line">reading config file wpa_supplicant</span><br><span class="line">reading config file yum</span><br><span class="line">Allocating <span class="built_in">hash</span> table <span class="keyword">for</span> state file, size 15360 B</span><br><span class="line"></span><br><span class="line">Handling 8 logs</span><br><span class="line"></span><br><span class="line">rotating pattern: /var/log/chrony/*.<span class="built_in">log</span>  weekly (4 rotations)</span><br><span class="line">empty <span class="built_in">log</span> files are rotated, old logs are removed</span><br><span class="line">considering <span class="built_in">log</span> /var/log/chrony/*.<span class="built_in">log</span></span><br><span class="line">  <span class="built_in">log</span> /var/log/chrony/*.<span class="built_in">log</span> does not exist -- skipping</span><br><span class="line">not running postrotate script, since no logs were rotated</span><br><span class="line"></span><br><span class="line">...(omitted)</span><br><span class="line">rotating pattern: /var/log/wtmp  monthly (1 rotations)</span><br><span class="line">empty <span class="built_in">log</span> files are rotated, only <span class="built_in">log</span> files &gt;= 1048576 bytes are rotated, old logs are removed</span><br><span class="line">considering <span class="built_in">log</span> /var/log/wtmp</span><br><span class="line">  <span class="built_in">log</span> does not need rotating (<span class="built_in">log</span> has been already rotated)</span><br><span class="line">rotating pattern: /var/log/btmp  monthly (1 rotations)</span><br><span class="line">empty <span class="built_in">log</span> files are rotated, old logs are removed</span><br><span class="line">considering <span class="built_in">log</span> /var/log/btmp</span><br><span class="line">  <span class="built_in">log</span> does not need rotating (<span class="built_in">log</span> has been already rotated)</span><br></pre></td></tr></table></figure><p>加上<code>-v</code>参数使得logrotate展示出实际上做了哪些工作. 由于时间未到 所以没有执行. 如果非要手动更新一次日志的话, 就加上<code>-f|--force</code>参数即可.</p><p><strong>更新 17.10.4</strong>:</p><p>现在我们来试试将日志存储在MySQL服务器上. 首先找一台MYSQL服务器, 这里我们就选择使用日志服务器本身, 如果你要另开机器的话,别忘记了权限设定哦.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># ss -ant</span></span><br><span class="line">State       Recv-Q Send-Q                                        Local Address:Port                                                       Peer Address:Port              </span><br><span class="line">LISTEN      0      50                                                        *:3306                                                                  *:*                  </span><br><span class="line">LISTEN      0      128                                                       *:111                                                                   *:*                  </span><br><span class="line">LISTEN      0      10                                                127.0.0.1:53                                                                    *:*                  </span><br><span class="line">LISTEN      0      128                                                       *:22                                                                    *:*                  </span><br><span class="line">LISTEN      0      128                                               127.0.0.1:953                                                                   *:*                  </span><br><span class="line">LISTEN      0      25                                                        *:514                                                                   *:*                  </span><br><span class="line">ESTAB       0      0                                            192.168.56.103:22                                                         192.168.56.1:1780               </span><br><span class="line">ESTAB       0      0                                            192.168.56.103:514                                                      192.168.56.101:54647</span><br></pre></td></tr></table></figure><p>3306端口已经开始监听, 本机的514已经和目标主机建立连接, 现在来设定数据库连接.</p><p>为了能够使得rsyslog和mysql能够建立连接, 我们需要安装一个驱动包:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># yum install rsyslog-mysql</span></span><br><span class="line">[root@WWW ~]<span class="comment"># rpm -ql rsyslog-mysql</span></span><br><span class="line">/usr/lib64/rsyslog/ommysql.so</span><br><span class="line">/usr/share/doc/rsyslog-8.24.0/mysql-createDB.sql</span><br></pre></td></tr></table></figure><p>其实就是一个共享对象和一个sql文件. ( 这个sql其实就是创建一个日志数据库, 接着创建了两张表, 正如其名 )</p><p>接着我们就需要由一个用于来访问这个数据库了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># mysql -u root -p </span></span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection <span class="built_in">id</span> is 12</span><br><span class="line">Server version: 5.5.56-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; </span><br><span class="line">MariaDB [(none)]&gt; </span><br><span class="line">MariaDB [(none)]&gt; grant all on Syslog.* to <span class="string">&#x27;syslog&#x27;</span>@<span class="string">&#x27;192.168.56.%&#x27;</span> identified by <span class="string">&#x27;syslogpasswd&#x27;</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>现在就可以进行sql文件读入了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># mysql -usyslog -h 192.168.56.103 -p &lt; /usr/share/doc/rsyslog-8.24.0/mysql-createDB.sql </span></span><br><span class="line">Enter password: </span><br><span class="line">[root@WWW ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>此时再使用syslog用户就可以看到数据库和表了.</p><p>接下来就简单了, 我们在配置文件中导入模块, 并且进行一下配置就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ModLoad</span> ommysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#*.info;mail.none;authpriv.none;cron.none                /var/log/messages</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none                :ommysql:192.168.56.103,Syslog,syslog,syslogpasswd</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**注意: 这个模块一定要在第一个Section里写, ** 我们把原来的注释掉, 改成记录到数据库中.</p><p>接着随便做些什么, 在数据库中就会有记录了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7启动流程</title>
      <link href="/2017/09/06/CentOS7%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2017/09/06/CentOS7%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>哈~结束了systemd和GRUB2的了解, 我们就可以更新之前CentOS5&amp;6启动流程啦!</p><span id="more"></span><h2 id="进入系统前"><a href="#进入系统前" class="headerlink" title="进入系统前"></a>进入系统前</h2><p>关于从我们摁下电源到BIOS legacy到bootloader的过程, 是没有什么变化的, 所以可以参考前面说过的:  <a href="https://yaoxuannn.com/2017/07/12/Linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#%E6%AD%A3%E9%A4%90">BIOS到BootLoader</a></p><p>这次又学习到了一点更细致更具体的, 所以再来谈一谈开机流程这个事情.</p><h3 id="传统BIOS开机流程"><a href="#传统BIOS开机流程" class="headerlink" title="传统BIOS开机流程"></a>传统BIOS开机流程</h3><p>我们按下主机的电源键, 接着储存在主板上的EEPROM中的BIOS就会开始下面的工作:</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>每当我们电脑打开, CPU就会自动重置成初始状态, 准备工作. BIOS boot block(开机区块)初始化阶段开始启动. 因为此时我们的内存啥的都是空的, 没有内容可以执行, 所以主板厂商会让CPU去寻找系统BIOS ROM中的reset vector(重置向量): 也就是用一个固定的位置来启动所谓的BIOS boot program开机程序.</p><p>一般来说, 我们的这个程序会出现在内存的0xFFFF的位置, 当然里面其实只有一个jump指令, 进一步真正的BIOS启动程序. 各个BIOS供应商也可以把程序放在不同的位置, 只要通过jump来指定就可以了.</p><h4 id="POST-Power-On-Self-Test开机自我检测"><a href="#POST-Power-On-Self-Test开机自我检测" class="headerlink" title="POST(Power On Self Test开机自我检测)"></a>POST(Power On Self Test开机自我检测)</h4><p>接着BIOS就会开始实行POST, 在过程中检查电脑的各项组件及设定. 然后再物理内存的开头处构建实模式的中断向量表, 这样我们就可以通过特定的中断来寻找硬件了. 接着是BIOS的数据区 以及 中断程序(仅仅是用于实模式的, 在后面加载操作系统的时候就会被抹除.)</p><p>这些工作都是硬件层面设计好的 和操作系统没有一点关系.</p><h4 id="寻找操作系统"><a href="#寻找操作系统" class="headerlink" title="寻找操作系统"></a>寻找操作系统</h4><p>OK~到了这个阶段, BIOS就会根据使用者的设定来决定搜索顺序, 产生INT_19来让CPU执行相应的中断服务程序. 这个程序把启动盘的第一扇区加载到物理内存的0x0700处, 这个也是硬件厂商设定的(因为不知道用户会安装什么操作系统). 这个扇区就是我们的引导程序所在的地方了. 接着就是我们的GRUB来做了. BIOS的使命结束.</p><h3 id="UEFI-搭配-GPT"><a href="#UEFI-搭配-GPT" class="headerlink" title="UEFI 搭配 GPT"></a>UEFI 搭配 GPT</h3><blockquote><p>在这里顺便更新一下这种较新的组合是怎么搞得. </p></blockquote><p>先来对比一下, 传统BIOS( BIOS legacy )和UEFI的区别.</p><table><thead><tr><th>比较项目</th><th>传统BIOS</th><th>UEFI</th></tr></thead><tbody><tr><td>使用语言</td><td>组合语言</td><td>C 语言</td></tr><tr><td>硬件资源控制</td><td>使用中断(IRQ)管理不可变的内存存取不可变的输入&#x2F;输出存取</td><td>使用驱动程序与协定</td></tr><tr><td>处理器运行环境</td><td>16位</td><td>CPU 保护模式</td></tr><tr><td>扩充方式</td><td>透过IRQ 连结</td><td>直接载入驱动程式</td></tr><tr><td>第三方厂商支援</td><td>较差</td><td>较佳且可支持多平台</td></tr><tr><td>图形化能力</td><td>较差</td><td>较佳</td></tr><tr><td>内建简化作业系统前环境</td><td>不支持</td><td>支持</td></tr></tbody></table><p>可以看出来, 这个UEFI要比传统的BIOS高级很多, 从WikiPedia中摘录一段, 我觉得写的挺清楚:</p><blockquote><p>(UEFI)突破传统16位代码的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AF%BB%E5%9D%80%E8%83%BD%E5%8A%9B&action=edit&redlink=1">寻址能力</a>，达到处理器的最大寻址。它利用加载EFI驱动程序的形式，识别及操作硬件，不同于BIOS利用挂载真实模式<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%AD">中断</a>的方式增加硬件功能。后者必须将一段类似于驱动程序的16位代码（如RAID卡的Option ROM）放置在固定的0x000C0000至0x000DFFFF之间存储区中，运行这段代码的初始化部分，它将挂载实模式下约定的中断向量向其他程序提供服务。例如，<a href="https://zh.wikipedia.org/wiki/%E6%98%BE%E5%8D%A1">VGA</a>图形及文本输出中断（INT 10h），磁盘访问中断服务（INT 13h）等等。由于这段存储空间有限（128KB），BIOS对于所需放置的驱动程序代码大小超过空间大小的情况无能为力。</p><p>另外，BIOS的硬件服务程序都以16位代码的形式存在，这就给运行于增强模式的操作系统访问其服务造成了困难。因此BIOS提供的服务在现实中只能提供给操作系统引导程序或MS-DOS类操作系统使用。而UEFI系统下的驱动程序可以由<a href="https://zh.wikipedia.org/w/index.php?title=EFI_Byte_Code&action=edit&redlink=1">EFI Byte Code</a>（EBC）编写而成，EFI Byte Code是一组专用于EFI驱动程序的虚拟<a href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80">机器语言</a>，必须在EFI驱动程序运行环境（Driver Execution Environment，或DXE）下被解释运行。</p></blockquote><p>加上EFI driver开发简单，所有的PC零组件厂商都可以参与，就像现代操作系统的开发模式，这样的模式曾使Windows系统短短几年就变得无比强大. 有了EFI driver，也可以让显卡在开机阶段就载入某种程度的功能，进而可以把传统文字界面为主的BIOS转成图形界面。</p><p>至于GPT, 是GUID Partition Table的缩写, 而GUID就是全局唯一标识符的简称. 下面的一张图就把GPT的状态说的很清楚啦. </p><p>**<em>LBA是指逻辑区块地址</em> **</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/07/GUID_Partition_Table_Scheme.svg" alt="GPT"></p><p>尽管GPT对分区数量没有限制 但是Windows最大就支持128个分区. 至于为什么是128,这是这是因为EFI标准的最小值.</p><blockquote><p>最后补充一个小点, 我们的BIOS设定中由一个secure boot的选项, 这个选项是为了UEFI的安全, 开启后就只会运行经过事先写过的数字签名的验证的程序. 但是这一点遭到了RedHat的反对, 因为大部分的Windows用户的电脑上主板上仅仅写入了OEM和微软的数字签名, 这对Linux的安装就造成了麻烦. 尽管说会提供这个值的修改设置…但是你懂得</p></blockquote><h2 id="进入系统"><a href="#进入系统" class="headerlink" title="进入系统"></a>进入系统</h2><h3 id="载入内核和initramfs"><a href="#载入内核和initramfs" class="headerlink" title="载入内核和initramfs"></a>载入内核和initramfs</h3><p>虽然这个部分在之前还是说过了, 但是还是再提一遍…因为一些内容是新学到的~</p><p>我们通过 Bootloader的管理而开始读取内核的时候, 接下来, 整个内核就会被解压到物理内存中. 接着利用内核的功能来测试周边装置, 也就是各个硬件啦 储存装置,CPU,网卡,声卡等等. 其实这个时候这些硬件的信息已经有了, 这是BIOS扫描得到的. 但是我们的Linux内核是不相信这个结果的, 所以要再次扫描一遍.</p><p>有关的文件都放在&#x2F;boot下了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># ls --format=single-column -F /boot </span></span><br><span class="line">config-3.10.0-229.el7.x86_64                 &lt;==此版本内核被编译时选择的功能与模块设定文件 </span><br><span class="line">grub/                                        &lt; ==旧版grub1 没啥用了</span><br><span class="line">grub2/                                       &lt;==就是开机管理程序grub2相关目录 </span><br><span class="line">initramfs-0-rescue-309eb890d3d95ec7a.img     &lt;==下面几个都是虚拟文件系统 这一个是用来救援的</span><br><span class="line">initramfs-3.10.0-229.el7.x86_64.img          &lt;==正常开机会用到的虚拟文件系统</span><br><span class="line">initramfs-3.10.0-229.el7.x86_64kdump.img     &lt;==内核出问题时会用到的虚拟文件系统 </span><br><span class="line">System.map-3.10.0-229.el7.x86_64             &lt;==内核功能放置到内存地址的对应表 </span><br><span class="line">vmlinuz-0-rescue-309eb890d09543d95ec7a*      &lt;==救援用的内核</span><br><span class="line">vmlinuz-3.10.0- 229.el7.x86_64*               &lt;==这就是内核啦</span><br></pre></td></tr></table></figure><p>我们知道Linux内核是可以动态加载模块的, 模块在哪里呢? 在我们的&#x2F;lib&#x2F;module&#x2F;$VERSION下面.所以我们也可以自信的说他们在根目录下, 因此为了开机就一定要挂载根目录, 而担心影响到磁盘中的文件系统, 这个根会用只读的方式挂载.</p><p>接着又回到了那个难题. 如果你的linux是安装在SATA磁盘上的, 那么通过INT_13取得的Bootloader与kernel来开机, 接着kernel就会开始扫描硬件,尝试挂载根目录.  但是内核无法获得SATA磁盘, 所以需要驱动程序. 但是驱动程序在根目录下, 这就是那个经典的两难问题.</p><p>解决方法就是上面的虚拟文件系统. 跟着Bootloader一起载入, 接着在内存中模拟成根目录, 并且提供一堆可执行程序(通常是USB,RAID,LVM啥的驱动程序), 载入模块.</p><p>那么这个神奇的initramfs究竟有什么东西呢? 之前我一直傻傻的用cpio在复原, 其实有一个命令专门用来输出这个文件的内容的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW boot]<span class="comment"># lsinitrd initramfs-3.10.0-514.21.2.el7.x86_64.img | less</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Image: initramfs-3.10.0-514.21.2.el7.x86_64.img: 19M</span><br><span class="line">========================================================================</span><br><span class="line">Early CPIO image</span><br><span class="line">========================================================================</span><br><span class="line">drwxr-xr-x   3 root     root            0 Jun 25 08:40 .</span><br><span class="line">-rw-r--r--   1 root     root            2 Jun 25 08:40 early_cpio</span><br><span class="line">drwxr-xr-x   3 root     root            0 Jun 25 08:40 kernel</span><br><span class="line">drwxr-xr-x   3 root     root            0 Jun 25 08:40 kernel/x86</span><br><span class="line">drwxr-xr-x   2 root     root            0 Jun 25 08:40 kernel/x86/microcode</span><br><span class="line">-rw-r--r--   1 root     root        97280 Jun 25 08:40 kernel/x86/microcode/GenuineIntel.bin</span><br><span class="line">========================================================================</span><br><span class="line">Version: dracut-033-463.el7_3.1</span><br><span class="line">...(omitted)</span><br><span class="line">drwxr-xr-x   3 root     root            0 Jun 25 08:40 usr/lib/modules</span><br><span class="line">drwxr-xr-x   3 root     root            0 Jun 25 08:40 usr/lib/modules/3.10.0-514.21.2.el7.x86_64</span><br><span class="line">drwxr-xr-x   8 root     root            0 Jun 25 08:40 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel</span><br><span class="line">drwxr-xr-x   3 root     root            0 Jun 25 08:40 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/arch</span><br><span class="line">drwxr-xr-x   3 root     root            0 Jun 25 08:40 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/arch/x86</span><br><span class="line">drwxr-xr-x   2 root     root            0 Jun 25 08:40 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/arch/x86/crypto</span><br><span class="line">-rw-r--r--   1 root     root        21581 Jun 20 09:11 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/arch/x86/crypto/crc32c-intel.ko</span><br><span class="line">-rw-r--r--   1 root     root        12037 Jun 20 09:11 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/arch/x86/crypto/crct10dif-pclmul.ko</span><br><span class="line">drwxr-xr-x   2 root     root            0 Jun 25 08:40 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/crypto</span><br><span class="line">-rw-r--r--   1 root     root         5021 Jun 20 09:11 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/crypto/crct10dif_common.ko</span><br><span class="line">-rw-r--r--   1 root     root         6229 Jun 20 09:11 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/crypto/crct10dif_generic.ko</span><br><span class="line">drwxr-xr-x  12 root     root            0 Jun 25 08:40 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers</span><br><span class="line">drwxr-xr-x   2 root     root            0 Jun 25 08:40 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers/ata</span><br><span class="line">-rw-r--r--   1 root     root        68437 Jun 20 09:11 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers/ata/ahci.ko</span><br><span class="line">-rw-r--r--   1 root     root        13797 Jun 20 09:11 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers/ata/ata_generic.ko</span><br><span class="line">-rw-r--r--   1 root     root        52829 Jun 20 09:11 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers/ata/ata_piix.ko</span><br><span class="line">-rw-r--r--   1 root     root        53245 Jun 20 09:11 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers/ata/libahci.ko</span><br><span class="line">-rw-r--r--   1 root     root       410141 Jun 20 09:11 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers/ata/libata.ko</span><br><span class="line">-rw-r--r--   1 root     root        12685 Jun 20 09:11 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers/ata/pata_acpi.ko</span><br><span class="line">drwxr-xr-x   2 root     root            0 Jun 25 08:40 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers/block</span><br><span class="line">-rw-r--r--   1 root     root        27885 Jun 20 09:11 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers/block/virtio_blk.ko</span><br><span class="line">drwxr-xr-x   2 root     root            0 Jun 25 08:40 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers/cdrom</span><br><span class="line">-rw-r--r--   1 root     root        69893 Jun 20 09:11 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers/cdrom/cdrom.ko</span><br><span class="line">drwxr-xr-x   2 root     root            0 Jun 25 08:40 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers/char</span><br><span class="line">-rw-r--r--   1 root     root        53709 Jun 20 09:11 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers/char/virtio_console.ko</span><br><span class="line">drwxr-xr-x   2 root     root            0 Jun 25 08:40 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers/firmware</span><br><span class="line">-rw-r--r--   1 root     root        15893 Jun 20 09:11 usr/lib/modules/3.10.0-514.21.2.el7.x86_64/kernel/drivers/firmware/iscsi_ibft.ko</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>输出很庞大. 通过观察输出, 我们可以知道这个文件前面是一个文档宣告, 但是后面才是真正用到的部分. 里面有个init程序, 已经给systemd管理了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx   1 root     root           23 Jun 25 08:40 init -&gt; usr/lib/systemd/systemd</span><br></pre></td></tr></table></figure><p>之前说过, systemd的默认target取决于default.target这个软链:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx   1 root     root           13 Jun 25 08:40 usr/lib/systemd/system/default.target -&gt; initrd.target</span><br></pre></td></tr></table></figure><p>那么这个initrd.target就是开机启动的第一个target了~ 怎么启动的呢?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">initrd.target</span><br><span class="line">● ├─dracut-cmdline.service</span><br><span class="line">● ├─dracut-initqueue.service</span><br><span class="line">● ├─dracut-mount.service</span><br><span class="line">● ├─dracut-pre-mount.service</span><br><span class="line">● ├─dracut-pre-pivot.service</span><br><span class="line">● ├─dracut-pre-trigger.service</span><br><span class="line">● ├─dracut-pre-udev.service</span><br><span class="line">● ├─initrd-parse-etc.service</span><br><span class="line">● ├─basic.target</span><br><span class="line">● │ ├─firewalld.service</span><br><span class="line">● │ ├─microcode.service</span><br><span class="line">● │ ├─rhel-autorelabel-mark.service</span><br><span class="line">● │ ├─rhel-autorelabel.service</span><br><span class="line">● │ ├─rhel-configure.service</span><br><span class="line">● │ ├─rhel-dmesg.service</span><br><span class="line">● │ ├─rhel-loadmodules.service</span><br><span class="line">● │ ├─selinux-policy-migrate-local-changes@targeted.service</span><br><span class="line">● │ ├─paths.target</span><br><span class="line">● │ ├─slices.target</span><br><span class="line">● │ │ ├─-.slice</span><br><span class="line">● │ │ └─system.slice</span><br><span class="line">● │ ├─sockets.target</span><br><span class="line">● │ │ ├─dbus.socket</span><br><span class="line">● │ │ ├─dm-event.socket</span><br><span class="line">● │ │ ├─systemd-initctl.socket</span><br><span class="line">● │ │ ├─systemd-journald.socket</span><br><span class="line">● │ │ ├─systemd-shutdownd.socket</span><br><span class="line">● │ │ ├─systemd-udevd-control.socket</span><br><span class="line">● │ │ └─systemd-udevd-kernel.socket</span><br><span class="line">● │ ├─sysinit.target</span><br><span class="line">....(omitted)</span><br></pre></td></tr></table></figure><p>这样, 在内核完整载入完毕之后, 就是我们的systemd的主场了!</p><h2 id="进入系统之后"><a href="#进入系统之后" class="headerlink" title="进入系统之后"></a>进入系统之后</h2><p>接下来系统连接到&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system这个目录去取按照用户的设定, 读取default.target所指向的目标target(注意呀,刚刚上面说的那个default是由系统生成的根文件系统, 和我们进入系统的那个不是一回事, 所以两个default.target不一样的), 读取完了之后, 就会去下面的两个地方,加载设定</p><ul><li>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;XXX(你设置的).target.wants&#x2F;：使用者设定载入的unit</li><li>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;XXX.target.wants&#x2F;：系统预设载入的unit</li></ul><p>一直这样XXX不是个事, 一般都是multi-user吧, 所以就拿这个好了.</p><p>我们来看看multi-user.target:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Multi-User System</span><br><span class="line">Documentation=man:systemd.special(7)</span><br><span class="line">Requires=basic.target</span><br><span class="line">Conflicts=rescue.service rescue.target</span><br><span class="line">After=basic.target rescue.service rescue.target</span><br><span class="line">AllowIsolate=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>也就是说, 在必须在basic.target运行完毕之后才能载入…载入什么呢? 我们来看看对应的wants文件夹:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW system]<span class="comment"># ls /etc/systemd/system/multi-user.target.wants/</span></span><br><span class="line">atd.service      crond.service       mdmonitor.service       remote-fs.target  sysstat.service  vboxadd-service.service</span><br><span class="line">auditd.service   irqbalance.service  NetworkManager.service  rsyslog.service   tuned.service    vboxadd-x11.service</span><br><span class="line">chronyd.service  kdump.service       postfix.service         sshd.service      vboxadd.service</span><br></pre></td></tr></table></figure><p><em>因为我使用的是Virtual Box来着, 所以可以忽略一些</em></p><p>系统加载的unit有这些:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW system]<span class="comment"># ls /usr/lib/systemd/system/multi-user.target.wants/</span></span><br><span class="line">brandbot.path  getty.target           plymouth-quit-wait.service      systemd-logind.service                systemd-user-sessions.service</span><br><span class="line">dbus.service   plymouth-quit.service  systemd-ask-password-wall.path  systemd-update-utmp-runlevel.service</span><br></pre></td></tr></table></figure><p>简单分析一下<code>systemctl list-dependencies multi-user.target</code>所输出的依赖服务，基本上我们CentOS 7.x 的systemd 开机流程大约是这样：</p><ol><li>local-fs.target + swap.target：这两个target 主要在挂载本机&#x2F;etc&#x2F;fstab 里面所规范的文件系统与相关的内存置换空间</li><li>sysinit.target：这个target 主要在扫描硬件，载入所需要的内核模块等</li><li>basic.target：载入主要的周边硬件驱动程序与防火墙相关任务</li><li>multi-user.target 底下的其它一般系统或网络服务的载入</li></ol><p>第一个步骤的那两个target, 很好理解 只要根据fstab就可以了. 那后面呢? 我们可以查看一下他们所启动的服务就知道了.</p><h4 id="sysinit-target"><a href="#sysinit-target" class="headerlink" title="sysinit.target"></a>sysinit.target</h4><p>基本上，我们可以将这些服务归类成几个大项就是了:</p><ul><li>特殊文件系统装置的挂载：包括dev-hugepages.mount dev-mqueue.mount 等挂载服务，主要在挂载跟巨量内存分页使用与信息队列的功能。挂载成功后，会在&#x2F;dev 底下建立&#x2F;dev&#x2F;hugepages&#x2F;, &#x2F;dev&#x2F;mqueue&#x2F; 等目录；</li><li>特殊文件系统的启用：包括磁盘阵列(RAID)、网路磁盘(iscsi)、LVM、文件系统对照服务(multipath) 等等，也会在这里被扫描和使用.</li><li>开机过程的信息传递与动画执行：使用plymouthd 服务搭配plymouth 指令来传递动画与信息</li><li>登录日志的使用：就是systemd-journald 这个服务的启用.</li><li>载入额外的内核模块：透过&#x2F;etc&#x2F;modules-load.d&#x2F;*.conf 文件的设定，让内核额外载入所需要的内核模块.</li><li>载入额外的内核参数设定：包括&#x2F;etc&#x2F;sysctl.conf 以及&#x2F;etc&#x2F;sysctl.d&#x2F;*.conf 内部设定</li><li>启动系统的随机产生器：随机产生器可以帮助系统进行一些密码加密演算的功能</li><li>设定终端(console)字体</li><li>启动动态设备管理服务：就是udevd 啦 用在动态对应实际设备存取与设备档名对应的一个服务.</li></ul><p>不论你即将使用哪种操作环境来使用系统，这个sysinit.target 几乎都是必要的工作 从上面你也可以看的出来，基本的内核功能、文件系统、文件系统硬件的驱动等等， 都在这个时刻处理完毕～所以，这个sysinit.target 的阶段是挺重要.</p><h4 id="basic-target"><a href="#basic-target" class="headerlink" title="basic.target"></a>basic.target</h4><p>执行完sysinit.target 之后，再来则是basic.target 这个项目了.</p><p>sysinit.target 在初始化系统，而basic.target 的阶段主要启动的服务大概有这些：</p><ul><li>载入firewalld 防火墙：CentOS 7.x 以后使用firewalld 取代iptables 的防火墙设定，虽然最终都是使用iptables 的架构, 不过在设定上面差很多.</li><li>载入CPU 的微指令功能；</li><li>启动与设定SELinux 的安全上下文：如果由disable 的状态改成enable 的状态，或者是管理员设定强制重新设定一次SELinux 的安全上下</li><li>将目前的开机过程所产生的开机信息写入到&#x2F;var&#x2F;log&#x2F;dmesg 当中</li><li>由&#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;*.modules 及&#x2F;etc&#x2F;rc.modules 载入管理员指定的模块</li><li>载入systemd 支持的timer 功能；</li></ul><h2 id="系统启动完毕"><a href="#系统启动完毕" class="headerlink" title="系统启动完毕"></a>系统启动完毕</h2><p>这样就差不多了, 接下来就是关于模块的一些内容 关于这个 和之前的就没有什么不同了, 参考这个地方就可以了: <a href="https://yaoxuannn.com/2017/07/16/Linux%E7%9A%84%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86%E5%92%8C%E7%BC%96%E8%AF%91%E5%88%9D%E6%AD%A5/#%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86%E5%88%9D%E6%AD%A5">内核管理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootloader-GRUB2</title>
      <link href="/2017/09/05/bootloader-GRUB2/"/>
      <url>/2017/09/05/bootloader-GRUB2/</url>
      
        <content type="html"><![CDATA[<p>之前说过了grub的0.X版本, 而新版本是相当于重构了整个bootloader. 来学习一下.</p><span id="more"></span><h2 id="grub2整体观"><a href="#grub2整体观" class="headerlink" title="grub2整体观"></a>grub2整体观</h2><p>这些是和grub1的区别:</p><ul><li>配置文件的名称改变了。在grub中，配置文件为grub.conf或menu.lst(grub.conf的一个软链接)，在grub2中改名为grub.cfg</li><li>grub2增添了许多语法，更接近于脚本语言了，例如支持变量、条件判断、循环</li><li>grub2中，设备名称从1开始，而在grub中是从0开始的<ul><li>举个例子, 当我们表示第一块硬盘的时候还是hd(0) 但是当说道分区的时候就变了, (hd0, msdos1)就表示第一块硬盘的第一个mbr分区, 而(hd0, gpt1)就表示第一块硬盘的第一个gpt分区.</li></ul></li><li>grub2使用img文件，不再使用grub中的stage1、stage1.5和stage2。</li><li>在已进入操作系统环境下，不再提供grub命令，也就是不能进入grub交互式界面，只有在开机时才能进入</li><li>在grub2中取消了find命令.</li></ul><h3 id="引导方式"><a href="#引导方式" class="headerlink" title="引导方式"></a>引导方式</h3><p>grub2有两种引导方式,但是第二种几乎不会用到,除非你需要引导grub2无法引导的操作系统.</p><p>这两种方式分别是:</p><ul><li>直接引导(direct): grub2直接通过默认的grub2 bootloader来引导写在默认配置文件中的操作系统</li><li>链式引导(indirect): 使用默认的grub2 bootloader 来引导另一个bootloader而不是操作系统.</li></ul><h3 id="文件位置以及安装位置"><a href="#文件位置以及安装位置" class="headerlink" title="文件位置以及安装位置"></a>文件位置以及安装位置</h3><p>当使用grub来管理启动菜单时，那么boot loader都是grub程序安装的。</p><p>传统的grub(legacy)将stage1转换后的内容安装到MBR(VBR或EBR)中的boot loader部分，将stage1_5转换后的内容安装在紧跟在MBR后的扇区中，将stage2转换后的内容安装在&#x2F;boot分区中。</p><p>而grub2将boot.img转换后的内容安装到MBR(VBR或EBR)中的boot loader部分，将diskboot.img和kernel.img结合成为core.img(刚刚在上面说过img文件)，同时还会嵌入一些模块或加载模块的代码到core.img中，然后将core.img转换后的内容安装到磁盘的指定位置处。</p><p>它们之间更具体的关系后面会有说.</p><p>根据分区表格式的不同, grub的安装位置(严格说是core.img的安装位置)也有所不同, 由于我的试验机器是MBR分区,所以就只说一下这个.</p><p>MBR允许四个主分区和额外的逻辑分区, 有两种方式安装GURB：</p><ol><li>嵌入到MBR和第一个分区中间的空间，这部分就是大众所称的”boot track”,”MBR gap”或”embedding area”，它们大致需要31kB的空间；</li><li>将core.img安装到某个文件系统中，然后使用分区的第一个扇区(严格地说不是第一个扇区，而是第一个block)存储启动它的代码。</li></ol><p>这两种方法有不同的问题。</p><p>使用嵌入的方式安装grub，就没有保留的空闲空间来保证安全性，例如有些专门的软件就是使用这段空间来实现许可限制的；另外分区的时候，虽然会在MBR和第一个分区中间留下空闲空间，但可能留下的空间会比这更小.</p><p>方法二安装grub到文件系统，但这样的grub是脆弱的 例如，文件系统的某些特性需要做尾部包装，甚至某些fsck检测，它们可能会移动这些block.</p><p><strong>GRUB开发团队建议将GRUB嵌入到MBR和第一个分区之间，除非有特殊需求，但仍必须要保证第一个分区至少是从第31kB(第63个扇区)之后才开始创建的.</strong></p><p>现在的磁盘设备，一般都会有分区边界对齐的性能优化提醒，所以第一个分区可能会自动从第1MB处开始创建的.</p><h3 id="img文件"><a href="#img文件" class="headerlink" title="img文件"></a>img文件</h3><p>img文件是GRUB2的关键了, 也是他的核心. 我们来说一下这些文件的作用和GRUB legacy中的stage的对应关系.</p><p>grub2生成了好几个img文件，有些分布在&#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc目录下，有些分布在&#x2F;boot&#x2F;grub2&#x2F;i386-pc目录下, </p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/img.png" alt="img"></p><p>事实上, 我们的core.img是动态生成的.而其他的img则存在在&#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&#x2F;下. 在安装grub2的时候 boot.img会拷贝一份到&#x2F;boot&#x2F;grub2&#x2F;i386-pc&#x2F;目录下</p><p><img src="http://images2015.cnblogs.com/blog/733013/201706/733013-20170629150034914-1219800403.png" alt="imgs"></p><p>上图描述了各个模块的关系和层级.</p><p><strong>boot.img</strong>是grub启动的第一个img文件 我们先把他当成入口好了. 这个玩意存在于MBR中或者分区的boot sector里. 因为我们的boot sector大小就是512字节 所以我们的boot.img也正好是这个大小. boot.img的唯一作用就是读取core的第一扇区并跳转上去 接着移交控制权, 由于最大512所以boot.img是无法理解文件系统的. 因此这个core.img的路径是经过硬编码的, 确保boot.img能够找到core.img的位置.</p><p><strong>core.img</strong>是给grub2-mkimage程序根据diskboot.img、kernel.img和一系列的模块动态创建的 core.img中嵌入了足够多的功能模块以保证grub能访问&#x2F;boot&#x2F;grub，并且可以加载相关的模块实现相关的功能，例如加载启动菜单、加载目标操作系统的信息等，由于grub2大量使用了动态功能模块，使得core.img体积变得足够小. core.img中包含了多个img文件的内容，包括diskboot.img&#x2F;kernel.img等等.. 至于core.img的位置 我们在上面也说过啦.</p><p>根据启动环境的不同, core.img第一个扇区的内容是不同的.如果你的启动设备是磁盘, 那么第一个扇区就是diskboot.img, 如果是光盘,那么第一个扇区的内容就是cdboot.img, 作用和diskboot.img是一样的.</p><p><strong>kernel.img</strong>文件包含了grub的基本运行时环境:设备框架, 文件句柄, 环境变量, 救援模式下的命令行解析器等等. 很少直接使用, 因为它们已经整个嵌入到了core.img中了. 注意, kernel.img是grub的kernel, 和操作系统的内核无关. </p><p>如果再多观察一下的话就会发现, kernel.img的大小是比core.img大的.这是因为生成的core中压缩了kernel.</p><p>除了这些***.img** 文件 各种*.mod其实就是各种功能模块, 部分模块已经嵌入到core.img中, 或者会被grub自动加载, 但有时也需要使用insmod命令手动加载.</p><p>还记得我们在说GRUB的时候, 简单的说了一下stage文件的作用. 现在我们把他们做一个简单的对应.</p><p>stage1在功能上就等于boot.img, stage1_5有点类似于core.img中的加载响应文件系统的代码, 但是core.img的功能显然比stage1 _5要多很多. </p><h3 id="GRUB2的配置"><a href="#GRUB2的配置" class="headerlink" title="GRUB2的配置"></a>GRUB2的配置</h3><p>我们已经知道了GRUB2中的磁盘代号的表示, 现在就来看一下grub.cfg这个重要的配置文件了. grub的官方并不期望用户直接修改这个文件, 而是通过修改其他的配置项接着在使用<code>grub2-mkconfig</code>来生成配置文件, 这个程序会参考&#x2F;etc&#x2F;default&#x2F;grub作为模板, 这个文件中有很多宏. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># cat /etc/default/grub</span></span><br><span class="line">GRUB_TIMEOUT=5                   <span class="comment"># 指定预设的倒数秒数, 如果一定要用户来选择, 那么就写成-1即可</span></span><br><span class="line">GRUB_DEFAULT=saved               <span class="comment"># 指定预设选单</span></span><br><span class="line">GRUB_DISABLE_SUBMENU=<span class="literal">true</span>        <span class="comment"># 是否要隐藏次选单</span></span><br><span class="line">GRUB_TERMINAL_OUTPUT=<span class="string">&quot;console&quot;</span>   <span class="comment"># 指定data的输出, 通常是终端控制台</span></span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;rd.lvm.lv=centos/root rd.lvm.lv=centos/swap crashkernel=auto rhgb quiet&quot;</span></span><br><span class="line">                                 <span class="comment"># 就是在 menuentry 括号内的 linux16 后面的核心参数</span></span><br><span class="line">GRUB_DISABLE_RECOVERY=<span class="string">&quot;true&quot;</span>     <span class="comment"># 取消救援选单的制作</span></span><br></pre></td></tr></table></figure><p>每次修改完这个模板文件, 为了使其生效, 我们执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># vim /etc/default/grub </span></span><br><span class="line">[root@WWW ~]<span class="comment"># grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br><span class="line">Generating grub configuration file ...</span><br><span class="line">Found linux image: /boot/vmlinuz-3.10.0-514.21.2.el7.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-3.10.0-514.21.2.el7.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-3.10.0-514.el7.x86_64</span><br><span class="line">Found initrd image: /boot/initramfs-3.10.0-514.el7.x86_64.img</span><br><span class="line">Found linux image: /boot/vmlinuz-0-rescue-9a3f06751f26419c8e00e76f67d74f6b</span><br><span class="line">Found initrd image: /boot/initramfs-0-rescue-9a3f06751f26419c8e00e76f67d74f6b.img</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>观察输出 这个程序能够主动的抓到对应的vmlinuz和initramfs. 这是怎么做到的呢?</p><p>这是因为grub2-mkconfig程序会去找&#x2F;etc&#x2F;grub.d&#x2F;*里面的shell脚本, 所以这些脚本就显得尤为重要了<del>我们来看一下(你会发现 这些脚本的名称在grub.cfg中就出现了</del>):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW grub.d]<span class="comment"># ls -lh</span></span><br><span class="line">total 72K</span><br><span class="line">-rwxr-xr-x. 1 root root 8.5K Nov 22  2016 00_header</span><br><span class="line">-rwxr-xr-x. 1 root root  992 Jun 16  2016 00_tuned</span><br><span class="line">-rwxr-xr-x. 1 root root  232 Nov 22  2016 01_users</span><br><span class="line">-rwxr-xr-x. 1 root root  11K Nov 22  2016 10_linux</span><br><span class="line">-rwxr-xr-x. 1 root root  11K Nov 22  2016 20_linux_xen</span><br><span class="line">-rwxr-xr-x. 1 root root 2.5K Nov 22  2016 20_ppc_terminfo</span><br><span class="line">-rwxr-xr-x. 1 root root  11K Nov 22  2016 30_os-prober</span><br><span class="line">-rwxr-xr-x. 1 root root  214 Nov 22  2016 40_custom</span><br><span class="line">-rwxr-xr-x. 1 root root  216 Nov 22  2016 41_custom</span><br><span class="line">-rw-r--r--. 1 root root  483 Nov 22  2016 README</span><br></pre></td></tr></table></figure><p>首先是00_header, 我们在模板文件中所设定的大部分参数都体现在这个脚本中, 因为该脚本主要建立在初始的显示项目上, 比如需要的模块, 终端的格式, 倒计时, 是否隐藏菜单等等.</p><p>关于00_tuned, 其实也就只是设置了几个tune这个daemon的参数而已, 我们先忽略. 01 _users我没看懂 为什么是cat了一段shell?? (啊…我好像明白了, 这一段cat的内容会原封不动的跑到最终生成的配置文件里)</p><p>接着就是重要的10_linux了 这个脚本主要是为了制作菜单项, 它尝试分析&#x2F;boot下的配置, 并且尝试找到对应的所需模块和参数.</p><p>后面的不想学了(摔!)</p><p>一般我们所需要用的就是40_custom了, 也就是手动加上菜单的时候才会动他. 至于怎么写, 从生成好的配置文件里模仿就好了..我不学了.</p><h3 id="为菜单加上密码"><a href="#为菜单加上密码" class="headerlink" title="为菜单加上密码"></a>为菜单加上密码</h3><p>grub2在用户管理上有一点像Linux, 有两种用户:</p><ul><li>superusers 可以修改grub2下所有的项目的权限, 但是设定了这个参数之后所有指令的修改将变成受限制的</li><li>users 可以设置多个, 就是简单的进入某个菜单, 搭配账号</li></ul><p>我们来看一个grub.cfg:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个部分就是设定好管理员和用户的账号和密码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> superusers=<span class="string">&quot;root&quot;</span>    <span class="comment"># 设定系统管理员的账号</span></span><br><span class="line">password root mimamima   <span class="comment"># 接下来就是设定账号和密码啦</span></span><br><span class="line">password justin justinjustin  <span class="comment"># 沒有输入 superusers 的其他账号, 就判定成一般账号</span></span><br><span class="line"></span><br><span class="line">menuentry <span class="string">&quot;For Everyone!&quot;</span> --unrestricted &#123;</span><br><span class="line"><span class="built_in">set</span> root=(hd0,1)</span><br><span class="line">chainloader +1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menuentry <span class="string">&quot;For 管理员 ONLY&quot;</span> --<span class="built_in">users</span> <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="built_in">set</span> root=(hd0,2)</span><br><span class="line">chainloader +1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menuentry <span class="string">&quot;For 管理员 和 justin&quot;</span> --<span class="built_in">users</span> justin &#123;</span><br><span class="line"><span class="built_in">set</span> root=(hd0,3)</span><br><span class="line">chainloader +1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是问题是, 我们之前就说过了, 这个配置文件是不推荐进行修改的. 那么怎么让配置文件中出现这些内容呢?</p><p>在上文说的那些脚本文件中, 就出现了superusers这个关键词, 对了, 就是01_users这个文件, 我们如果要设置密码的话, 就对这个文件进行修改.</p><p>同grub-legacy一样, grub2也提供了密码工具, 叫做<code>grub2-mkpasswd-pbkdf2</code> 这是一个交互式的密码生成工具, 使用起来实在是太简便了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW grub.d]<span class="comment"># grub2-mkpasswd-pbkdf2</span></span><br><span class="line">Enter password: </span><br><span class="line">Reenter password: </span><br><span class="line">PBKDF2 <span class="built_in">hash</span> of your password is grub.pbkdf2.sha512.10000.DEDC4DF8BD3FC85D670AA4D86C957432131B0824F81B47EAA2B1542CCD7E1AE32D136B606A2D5786FBC137C8632A417886EF48B82ED74E2E3DB386E22A890205.0DA123913F52203900B012E20FF57FA5DE0402814DAC5FF700ECC829139B2F8257F191147148BE97CC6EF87072DE32049CE70E1D43724D682EDC6972B8E67BE7</span><br></pre></td></tr></table></figure><p>这个从grub2.pbkdf2开始的一大串字符串就是密码了.</p><p>这样, 我们直接修改01_users这个脚本, 具体的修改就像这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh -e</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">set superusers=&quot;justin&quot;</span></span><br><span class="line"><span class="string">password_pbkdf2 justin grub.pbkdf2.sha512.10000.27E9FC1D4955E2DB0542F7198D86A4103A525B20CC500577BD646EA48785D3EFB70CFA05BBF8B536E73AB4F144F4F9FC76040B745B1F3A0E2EE2F2DFEE5A4145.442DE0D08D00B21FE793DA96588D1144AF1597519921BC6125E35C13E345A8E738FF5D3A3EA90B94D023CA51148F5BEAF8C2A17C43081C5F371B33278D1BCDDE</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment"># 也可以指定(多个)一般用户, 这里懒得弄了 hhhh 你打我啊</span></span><br></pre></td></tr></table></figure><p>接着我们修改10_linux这个脚本, 在第一个CLASS的位置, 我们把原本在后面的–unrestricted的参数移除.</p><p>重启机器. 在开机的时候就会看到请求输入用户名和密码的界面了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
            <tag> bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7-systemd</title>
      <link href="/2017/07/21/CentOS7-systemd/"/>
      <url>/2017/07/21/CentOS7-systemd/</url>
      
        <content type="html"><![CDATA[<p>systemd是CentOS7所使用的全新的init程序.</p><p>Systemd:</p><blockquote><p>POST -&gt; Boot Sequence -&gt; Bootloader -&gt; kernel + initramfs(initrd) -&gt; rootfs -&gt; &#x2F;sbin&#x2F;init</p></blockquote><p>systemd的架构图:</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030703.png" alt="systemd"></p><span id="more"></span><h2 id="Systemd"><a href="#Systemd" class="headerlink" title="Systemd"></a>Systemd</h2><p>之前就已经说过, CnetOS5,6上的<strong>运行级别</strong>这个概念在systemd上已经失去了意义.但是systemd依然可以兼容之前的SysV init脚本, 但是即使不使用脚本, systemd仍然可以进行服务的启动.但是, 当然, 使用脚本的启动速度是很慢的.</p><p>接下来说一下Systemd的新特性有哪些:</p><ul><li>实现系统引导的时候服务的并行启动</li><li>可以实现按需激活进程, 也就是说在需要这个进程的时候才去激活它, 这样就比较节省资源</li><li>支持系统状态快照 ( 蛤?这也可以?没用过呢…)</li><li>基于依赖关系来定义服务控制逻辑</li></ul><p>因此到了CentOS7上, systemd已经完全取代了之前的init. </p><blockquote><p>这么说来, CentOS6所使用的Startup init是十分短命的, 而当时Systemd的开发者就已经建议RH使用Systemd instead of StartUp了, 然而我们都知道RH以安全著称, 因此并没有使用. 当时的新版Fedora就使用了(小白鼠).</p></blockquote><p>对于Systemd而言有一个核心概念 – <strong>unit</strong> 也就是<strong>单元</strong></p><p>而这个unit的配置主要是依靠其配置文件进行标示和配置: 文件主要包括了系统服务,监听的套接字, 保存的系统快照以及其他和init相关的信息. 每一个unit都有一个配置文件. 这些配置文件都保存在这些位置:</p><p><code>/usr/lib/systemd/system</code> &amp;&amp; <code>/run/systemd/system</code>&amp;&amp;<code>/etc/systemd/system</code> </p><p>目前我们可以简单的把unit当做之前的一个一个服务脚本, 负责进行服务的启动, 重载, 终止, 重启等等… 但要明确的是, 决不能把unit和这些服务脚本画上等号. 这是因为, unit除了进行这些服务的管理之外还有别的功能.归根结底: <strong>unit是有类型的</strong></p><h3 id="Unit的类型"><a href="#Unit的类型" class="headerlink" title="Unit的类型"></a>Unit的类型</h3><p>其中最多最重要的就是这个服务类型的unit,叫做<code>Service Unit</code>  这些文件的扩展名就是<code>*.service</code> 比如: <code>httpd.service sshd.service crond.service</code> 等等</p><p>在之前说init的时候, 我们可以在<code>/etc/rc.d/init.d/</code>里面看到许许多多的的服务脚本 而在systemd来看这些类似的东西都放在<code>/usr/lib/systemd/system</code> 里面, 这个目录里还有很多其他扩展名的东西: path target wants …</p><p>而且如你所见, 这些文件不需要执行权限 因为他们仅仅是systemd的配置文件.</p><p>除开service, 第二重要的配置文件就是target类型的, 叫做目标单元. 主要用于模拟实现”运行级别”</p><p>第三种叫做device unit, 文件扩展名就是device, 这个文件主要用来负责定义内核识别的设备.</p><p>接着还有进行文件系统挂载的mount unit, 也就是用来定义文件系统挂载点</p><p>还有socket unit, 后缀名.socket, 用来标识进程间进行通信的socket文件.</p><p>另外, 还有snapshot unit, 后缀名就叫做.snapshot, 用于管理系统快照.</p><p>下一个swap unit, 后缀.swap, 用来干什么也很容易就知道了: 表示和管理swap设备.</p><p>最后还有两项, 一个后缀是叫.automount, 用来定义文件系统的自动挂载点, 以及Path unit, 后缀名就是.path, 用来定义文件系统中与一个文件或者一个目录. 仅在某些特定的场景下才会使用.</p><p>以上这些就是unit的类型, 用一张图来说明就是:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/Unit.png" alt="Unit"></p><h3 id="systemd的关键特性"><a href="#systemd的关键特性" class="headerlink" title="systemd的关键特性"></a>systemd的关键特性</h3><h4 id="基于socket的激活机制"><a href="#基于socket的激活机制" class="headerlink" title="基于socket的激活机制"></a>基于socket的激活机制</h4><p>在系统引导的时候systemd对所有支持这种模式的服务, 分别创建需要监听的套接字, 并在服务启动之后, 立即将这个套接字传递给它.</p><p>这样做的好处是: 可以实现多个服务的并行启动, 而且如果用不到这个服务的时候我就不启动, 反正套接字创建好了(我不关心服务的启动与否),这样当有人访问套接字, systemd就会收到, 接着就可以去激活相应的进程服务, 也就是按需激活.  这就像CentOS5,6上的超级守护进程和瞬时启动进程.</p><blockquote><p>其实也就是: 1. socket和服务程序分离, 由一个统一的systemd来进行启动. 2. 只要我套接字建立完毕,那么其他依赖服务都可以进行启动(因为认定已经启动), 从而实现并行启动.</p></blockquote><h4 id="基于bus的激活机制"><a href="#基于bus的激活机制" class="headerlink" title="基于bus的激活机制"></a>基于bus的激活机制</h4><p>D-bus是一个最早见于Linux的IPC实现, 用于桌面. 其实就是一个用于桌面应用的消息系统&#x2F;通讯机制.</p><p>systemd可以使得所有使用D-Bus的服务在第一次访问的时候按需激活.</p><h4 id="基于Device的激活机制"><a href="#基于Device的激活机制" class="headerlink" title="基于Device的激活机制"></a>基于Device的激活机制</h4><p>就像是在Windows上插入U盘之后就会有相应的进程被激活一样, 这一机制使得当我们有硬件上的更新(可用)的时候有systemd有能力激活相应服务.(就比如说automount)</p><h4 id="基于Path的激活机制"><a href="#基于Path的激活机制" class="headerlink" title="基于Path的激活机制"></a>基于Path的激活机制</h4><p>也就是某个目录下文件发生变动的时候, 激活相应的程序.说白了就是特定文件路径的监控从而激活.</p><h4 id="系统快照"><a href="#系统快照" class="headerlink" title="系统快照"></a>系统快照</h4><p>就像我们所使用的vmware等虚拟化应用的暂停功能一样. systemd能够将当前系统的各个unit的临时数据(当前状态信息)进行持久化(写入磁盘..), 说白了就是保存状态. 然后再下次开机的时候载入这些文件从而使得系统恢复之前的状态.</p><h4 id="向后兼容sysV-init脚本"><a href="#向后兼容sysV-init脚本" class="headerlink" title="向后兼容sysV init脚本"></a>向后兼容sysV init脚本</h4><p>这个大家再熟悉不过了, 最起码systemd可以完美兼容<code>start, stop, status, restart</code>这样的操作脚本. 而CentOS7 也保留了这种风格.</p><p>以上就是systemd的关键特性, 现在我们说说他和sysV不兼容(不同)的地方以及一些point</p><ul><li>systemd对之前sysV的系统运行级别的模拟和兼容是有限的, <strong>0,6,3,5</strong>, 事实上systemd用不到这个东西, 他只是通过target unit来进行模拟.</li><li>target unit和之前的运行级别是不能做对等的, 因为target unit有十几个之多.</li><li>systemd使用systemctl来进行服务操作的命令, 其支持的子命令不仅仅是上述4个. 在sysV时代, 用户可以进行拓展和自定义脚本, 但在systemd中, 子命令是固定不变的.</li><li>systemd只能与systemd相通信的应用通信, 也就是说非systemd的应用他没法管.(比如service启动的)</li><li>我们知道在init的时候, 当我们进行运行级别的切换的时候, 会执行&#x2F;etc&#x2F;rcX.d&#x2F;init.d&#x2F;对应级别的脚本, 所有K开头的都会执行stop操作, 而S的进行start操作. 但是这样存在的问题就是, 如果我的服务没有启动,还是会执行一遍stop操作, 这就是多余操作. 因此systemd就不会这样了, systemd会动态进行关闭操作, 仅关闭需要关闭以及当前正在运行的服务和程序.同理,S开头的也是.</li><li>系统服务不会读取来自标准输入的数据,systemd启动时不会和标准输入进行交互,他自行控制着所以服务的管理.</li><li>我们的系统服务不会从用户那里继承任何信息, 包括PATH等环境变量等等. 因此建议在使用应用程序使用绝对路径 这样每个服务都会在最纯净的运行环境中, 而和用户没有任何关系.</li><li>每个服务operation的timeout都设置成5min</li></ul><h3 id="管理系统服务"><a href="#管理系统服务" class="headerlink" title="管理系统服务"></a>管理系统服务</h3><p>使用service unit, 也可以兼容早期的运行脚本. 运行的命令叫做: <strong>systemctl</strong> 完整的一个命令是: <strong>systemctl COMMAND name.service</strong> </p><p>比如我们现在以久负盛名,大名鼎鼎的httpd.service来做个实验:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># rpm -q httpd</span></span><br><span class="line">httpd-2.4.6-45.el7.centos.4.x86_64 <span class="comment"># 系统已经安装此软件包</span></span><br><span class="line"><span class="comment"># 默认可以省略.service, 也就是说 你可以直接写应用的名字</span></span><br><span class="line">[root@WWW ~]<span class="comment"># systemctl status httpd</span></span><br><span class="line">● httpd.service - The Apache HTTP Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">     Docs: man:httpd(8)</span><br><span class="line">           man:apachectl(8)</span><br><span class="line"><span class="comment"># 显然此时服务是非激活的, 也就是未启动.</span></span><br><span class="line">[root@WWW ~]<span class="comment"># systemctl start httpd</span></span><br><span class="line"><span class="comment"># 启动服务了, 现在来看一下当前服务的状态</span></span><br><span class="line">[root@WWW ~]<span class="comment"># systemctl status httpd</span></span><br><span class="line">● httpd.service - The Apache HTTP Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; vendor preset: disabled) <span class="comment"># disabled 表示该服务不会随着开机启动</span></span><br><span class="line">   Active: active (running) since Sun 2017-09-03 08:42:26 EDT; 2s ago</span><br><span class="line">     Docs: man:httpd(8)</span><br><span class="line">           man:apachectl(8)</span><br><span class="line"> Main PID: 2553 (httpd)</span><br><span class="line">   Status: <span class="string">&quot;Processing requests...&quot;</span></span><br><span class="line">   <span class="comment"># 刚启动的状态, 处理请求</span></span><br><span class="line">   CGroup: /system.slice/httpd.service</span><br><span class="line">           ├─2553 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─2554 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─2555 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─2556 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─2557 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           └─2558 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line"></span><br><span class="line">Sep 03 08:42:26 WWW systemd[1]: Starting The Apache HTTP Server...</span><br><span class="line">Sep 03 08:42:26 WWW httpd[2553]: AH00558: httpd: Could not reliably determine the server<span class="string">&#x27;s fully qualified domain name, using 192.168.56.101. Set the &#x27;</span>ServerNa...his message</span><br><span class="line">Sep 03 08:42:26 WWW systemd[1]: Started The Apache HTTP Server.</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br><span class="line">[root@WWW ~]<span class="comment"># systemctl status httpd</span></span><br><span class="line">● httpd.service - The Apache HTTP Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Sun 2017-09-03 08:42:26 EDT; 6min ago</span><br><span class="line">     Docs: man:httpd(8)</span><br><span class="line">           man:apachectl(8)</span><br><span class="line"> Main PID: 2553 (httpd)</span><br><span class="line">   Status: <span class="string">&quot;Total requests: 0; Current requests/sec: 0; Current traffic:   0 B/sec&quot;</span></span><br><span class="line">   <span class="comment"># 状态出现了更新, 没有请求, 流量为0</span></span><br><span class="line">   CGroup: /system.slice/httpd.service</span><br><span class="line">           ├─2553 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─2554 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─2555 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─2556 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─2557 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           └─2558 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line"></span><br><span class="line">Sep 03 08:42:26 WWW systemd[1]: Starting The Apache HTTP Server...</span><br><span class="line">Sep 03 08:42:26 WWW httpd[2553]: AH00558: httpd: Could not reliably determine the server<span class="string">&#x27;s fully qualified domain name, using 192.168.56.101. Set the &#x27;</span>ServerNa...his message</span><br><span class="line">Sep 03 08:42:26 WWW systemd[1]: Started The Apache HTTP Server.</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br><span class="line"><span class="comment"># 现在停止服务</span></span><br><span class="line">[root@WWW ~]<span class="comment"># systemctl stop httpd</span></span><br></pre></td></tr></table></figure><p>在旧的sysV时代, 我们的status只有一句干巴巴的说明, 服务已经启动&#x2F;服务没有启动.. 现在的systemd可以提供非常详细的信息来让我们进行debug或者查看相关信息.</p><p>现在我们来列举一下systemctl</p><ul><li>启动: systemctl start name.service &#x3D;&#x3D; service name start</li><li>停止: systemctl stop name.service &#x3D;&#x3D; service name stop</li><li>重启: systemctl restart name.service &#x3D;&#x3D; service name restart</li><li>状态: systemctl status name.service &#x3D;&#x3D; service name status</li><li>条件式重启: systemctl try-restart name.service &#x3D;&#x3D; service name condrestart # 条件式重启是指: 如果这个服务启动了, 那么就停掉他再进行启动操作, 如果没有启动就不作操作.</li><li>查看某服务当前是否激活: systemctl is-active name.service</li><li>查看所有已经激活的服务: systemctl list-units<ul><li>查看所有的 在后面加上 –all, 可以组合</li><li>查看特定的类型的 在后面加上 –type&#x3D;{target,service…}, 可以组合.</li></ul></li></ul><p>与chkconfig的对应关系:</p><p>设定某服务开机自启&#x2F;关闭: chkconfig name on&#x2F;off &#x3D;&#x3D;&gt; systemctl enable&#x2F;disable name.service</p><p>比disable更强大的禁止自启是: systemctl mask name.service 这将会连接到&#x2F;dev&#x2F;null, 从而使启动这些变成不可能. 翻过来就是systemctl umask name.service 可以取消mask的效果.</p><p>为了查看服务是否开机自启, 上面也已经展示了, 使用systemctl status name.service就可以了.</p><p>如果要查看所有开机自启的服务, 在chkconfig时代, 还是使用: chkconfig –list</p><p>但是systemctl就提供了非常清晰的信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># systemctl list-unit-files --type=service</span></span><br><span class="line"><span class="comment"># 这样展示的是所有的unit, 其中有disabled的, 有enabled的, 有static的</span></span><br><span class="line"><span class="comment"># 如果仅仅想要列出特定STATE的, 就在后面加上筛选条件就行了</span></span><br><span class="line">UNIT FILE                                     STATE   </span><br><span class="line">arp-ethers.service                            disabled</span><br><span class="line">atd.service                                   enabled </span><br><span class="line">auditd.service                                enabled </span><br><span class="line">autovt@.service                               enabled </span><br><span class="line">blk-availability.service                      disabled</span><br><span class="line">brandbot.service                              static  </span><br><span class="line">chrony-dnssrv@.service                        static  </span><br><span class="line">...(omitted)</span><br><span class="line">[root@WWW ~]<span class="comment"># systemctl list-unit-files --type=service --state=enabled</span></span><br><span class="line"><span class="comment"># 别忘了要加d</span></span><br><span class="line">UNIT FILE                                   STATE  </span><br><span class="line">atd.service                                 enabled</span><br><span class="line">auditd.service                              enabled</span><br><span class="line">autovt@.service                             enabled</span><br><span class="line">chronyd.service                             enabled</span><br><span class="line">crond.service                               enabled</span><br><span class="line">dbus-org.fedoraproject.FirewallD1.service   enabled</span><br><span class="line">dbus-org.freedesktop.NetworkManager.service enabled</span><br><span class="line">dbus-org.freedesktop.nm-dispatcher.service  enabled</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>现在我们就来谈谈这个<strong>target unit</strong>.</p><p>我们说过这个是用来实现运行级别的模拟的. 因此所有以target结尾的文件就是用来将需要启动的服务定义在一起, 使得他们能够一起启动.</p><p>在<code>/usr/lib/systemd/system</code>这个目录下, 我们可以看到:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx. 1 root root  15 Jun 25 08:38 runlevel0.target -&gt; poweroff.target</span><br><span class="line">lrwxrwxrwx. 1 root root  13 Jun 25 08:38 runlevel1.target -&gt; rescue.target</span><br><span class="line">lrwxrwxrwx. 1 root root  17 Jun 25 08:38 runlevel2.target -&gt; multi-user.target</span><br><span class="line">lrwxrwxrwx. 1 root root  17 Jun 25 08:38 runlevel3.target -&gt; multi-user.target</span><br><span class="line">lrwxrwxrwx. 1 root root  17 Jun 25 08:38 runlevel4.target -&gt; multi-user.target</span><br><span class="line">lrwxrwxrwx. 1 root root  16 Jun 25 08:38 runlevel5.target -&gt; graphical.target</span><br><span class="line">lrwxrwxrwx. 1 root root  13 Jun 25 08:38 runlevel6.target -&gt; reboot.target</span><br></pre></td></tr></table></figure><p>这些就是在模拟不同的运行级别, 可以很清晰的看到2,3,4都是一样的. 我们在使用init的时候, 切换运行等级的命令是init N. 而在systemd中使用的是以子命令的形式: <strong>systemctl isolate name.target</strong> 另外建议在使用systemd的机器上就不再要用<code>runlevel</code>来查看运行等级了, 因为意义不大.当然使用也是可以使用的. 那么应该使用什么命令来查看. 在上面已经说过了!其实就是<code>systemctl list-units --type target</code> 这会展示当前已经加载的unit. 如果是获取默认的运行级别, 在过去使用的&#x2F;etc&#x2F;inittab, 现在使用的命令是<strong>systemctl get-default</strong> 如果是修改默认的运行级别呢? 过去我们要修改iinittab这个文件, 但是现在封装的更友好, 我们直接使用<strong>systemctl set-default name.target</strong>就行了. 其实这一步骤做的操作就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW system]<span class="comment"># systemctl get-default</span></span><br><span class="line">multi-user.target</span><br><span class="line">[root@WWW system]<span class="comment"># systemctl set-default multi-user.target</span></span><br><span class="line">Removed symlink /etc/systemd/system/default.target. <span class="comment"># 删除符号链接</span></span><br><span class="line">Created symlink from /etc/systemd/system/default.target to /usr/lib/systemd/system/multi-user.target. <span class="comment"># 创建一个新的符号链接</span></span><br></pre></td></tr></table></figure><p>所以默认的target就取决于这个软链接的指向. </p><p>systemd可以非常快速的切换到救急模式和紧急模式, 命令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># systemctl emergency</span></span><br><span class="line">PolicyKit daemon disconnected from the bus.</span><br><span class="line">We are no longer a registered authentication agent.</span><br><span class="line"></span><br><span class="line">Broadcast message from root@WWW on pts/0 (Mon 2017-09-04 07:51:33 EDT):</span><br><span class="line"></span><br><span class="line">The system is going down to emergency mode NOW!</span><br><span class="line"><span class="comment"># 会有一个广播, 告知正在使用这台机器的用户.</span></span><br><span class="line"><span class="comment"># 来看一下现在机器的状态.</span></span><br><span class="line">[root@WWW ~]<span class="comment"># systemctl list-units --type target</span></span><br><span class="line">UNIT             LOAD   ACTIVE SUB    DESCRIPTION</span><br><span class="line">emergency.target loaded active active Emergency Mode</span><br><span class="line"></span><br><span class="line">LOAD   = Reflects whether the unit definition was properly loaded.</span><br><span class="line">ACTIVE = The high-level unit activation state, i.e. generalization of SUB.</span><br><span class="line">SUB    = The low-level unit activation state, values depend on unit <span class="built_in">type</span>.</span><br><span class="line"></span><br><span class="line">1 loaded units listed. Pass --all to see loaded but inactive units, too.</span><br><span class="line">To show all installed unit files use <span class="string">&#x27;systemctl list-unit-files&#x27;</span>.</span><br><span class="line"><span class="comment"># 仅仅只载入了一个target文件</span></span><br><span class="line">[root@WWW ~]<span class="comment"># systemctl rescue</span></span><br><span class="line">Error getting authority: Error initializing authority: Could not connect: Connection refused (g-io-error-quark, 39)</span><br><span class="line">[root@WWW ~]<span class="comment"># systemctl list-units --type target</span></span><br><span class="line">UNIT                LOAD   ACTIVE SUB    DESCRIPTION</span><br><span class="line">cryptsetup.target   loaded active active Encrypted Volumes</span><br><span class="line">local-fs-pre.target loaded active active Local File Systems (Pre)</span><br><span class="line">local-fs.target     loaded active active Local File Systems</span><br><span class="line">rescue.target       loaded active active Rescue Mode</span><br><span class="line">swap.target         loaded active active Swap</span><br><span class="line">sysinit.target      loaded active active System Initialization</span><br><span class="line"></span><br><span class="line">LOAD   = Reflects whether the unit definition was properly loaded.</span><br><span class="line">ACTIVE = The high-level unit activation state, i.e. generalization of SUB.</span><br><span class="line">SUB    = The low-level unit activation state, values depend on unit <span class="built_in">type</span>.</span><br><span class="line"></span><br><span class="line">6 loaded units listed. Pass --all to see loaded but inactive units, too.</span><br><span class="line">To show all installed unit files use <span class="string">&#x27;systemctl list-unit-files&#x27;</span>.</span><br><span class="line"><span class="comment"># 进入了rescue模式</span></span><br><span class="line">[root@WWW ~]<span class="comment"># systemctl isolate multi-user.target</span></span><br><span class="line">Error getting authority: Error initializing authority: Could not connect: Connection refused (g-io-error-quark, 39)</span><br><span class="line"><span class="comment"># 现在就切换回来吧</span></span><br></pre></td></tr></table></figure><p>那么emergency和rescue的区别是什么呢? 从加载的target模块就可以看出来了. emergency更加彻底.</p><p>在CentOS6上, 我们也可以使用emergency模式, 只需要在grub的e 编辑模式下, 传递emergency这个参数就可以了.</p><p>最后我们再来说一下其他的常用命令:</p><p>关机, hhh没有想到这个我也会说吧~ 熟知的shutdown当然也可以使用, 但是你也可以使用<code>systemct halt</code>. 同时也可以使用<code>systemctl poweroff</code> 重启就是<code>systemctl restart</code> 我们还可以挂起系统: 使用<code>systemctl suspend</code> 如果你是虚拟机在实验, 那么这个暂停我是不知道怎么恢复..如果你知道还请告知.使用<code>systemctl hibernate</code> 来使得机器休眠. 其实这个休眠就是systemd的快照功能, 他可以保持当前的工作状态, 当你回头重启的时候还可以继续下去. 当然, 如果不是仅仅做个快照, 还同时挂起, 就使用<code>systemdctl hybrid-sleep</code> 简单的说就是一个是重启, 一个是关闭啦 需要注意的是, 你的登录状态会保留, 所以还是要小心使用.</p><p>如果你的服务不能正常启动是因为依赖的话, 那么你可以使用systemctl的子命令来查看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># systemctl list-dependencies httpd</span></span><br></pre></td></tr></table></figure><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/dependencies.png" alt="dependencies"></p><p>所依赖的会使用树形结构表示出来, 还会注明当前的激活情况.</p><blockquote><p>systemd的子命令实在是太多了. 在启用之初曾被人说, 违背了UNIX的simple原则. 当然他确实强大 方便.</p></blockquote><h3 id="Unit设定文件及自定义"><a href="#Unit设定文件及自定义" class="headerlink" title="Unit设定文件及自定义"></a>Unit设定文件及自定义</h3><p>关于此项, 暂时忽略. 后续补充.</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>我们知道在Linux下找回密码只要能够进入并且挂载&#x2F;, 再重新设定root的密码就可以了. 以前我们使用rescue模式&#x2F;单用户来操作.但在systemd上这就没有用了.</p><p>在新版的systemd 的管理机制中，预设的rescue 模式是无法直接取得root 权限的！还是得要使用root 的密码才能够登入rescure 环境！所以我们透过一个名为<strong>rd.break</strong>的核心参数来处理！只是需要注意的是， rd.break 是在Ram Disk 里面的作业系统状态，因此你不能直接取得原本的linux 系统操作环境。所以，还需要chroot 的支援. 更由于SELinux 的问题，你可能还得要加上某些特殊的流程才能顺利的搞定root 密码的重新设置. 这样说有些不清楚. 我们来走一个流程.</p><p>首先在grub界面使用e进入编辑模式, 在标有linux16的那一行的最后加上<code>rd.break</code>这个核心参数.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/rd.break.png" alt="rd"></p><p>之后就可以执行了,使用ctrl+x,这时开机你会看到这样的界面</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/rd.start.png" alt="rd"></p><p>这个时候我们不需要输入密码就可以进入系统! 但是注意这个时候我们进入的位置是&#x2F;sysroot 并且使用mount查看当前挂载情况的时候, 你会发现当前的系统挂载了&#x2F;sysroot这个目录,并且是仅仅可读不可写的.所以我们要先把他重新挂载成可读写.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch_root:/<span class="comment"># mount -o remount, rw /sysroot</span></span><br></pre></td></tr></table></figure><p>接着我们进行根切换, 注意这是<strong>暂时</strong>切换. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">switch_root:/<span class="comment"># chroot /sysroot</span></span><br><span class="line">sh-4.2<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>接着就可以进行密码更改了. 你会发现这时的&#x2F;sys &#x2F;proc都是空的.</p><p>更改完毕后, 别忘了要先退出这个根. 然后在重新启动就可以了.</p><p>关于这些的原理和其他的一些, 在后面的GRUB2中会说明. 后面的GRUB2中会说明.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python操作Rabbitmq, Redis, MySQL</title>
      <link href="/2017/07/20/Python%E6%93%8D%E4%BD%9CRabbitmq-Redis-MySQL/"/>
      <url>/2017/07/20/Python%E6%93%8D%E4%BD%9CRabbitmq-Redis-MySQL/</url>
      
        <content type="html"><![CDATA[<p>Python后端一锅端.</p><span id="more"></span><h2 id="消息队列-–-RabbitMQ"><a href="#消息队列-–-RabbitMQ" class="headerlink" title="消息队列 – RabbitMQ"></a>消息队列 – RabbitMQ</h2><p><img src="https://www.rabbitmq.com/img/RabbitMQ-logo.svg" alt="rabbit"></p><p>要明确个的一点是, 所有的消息队列都是<strong>异步</strong>的.</p><p>最简单的一种消息队列模型就是P2P的模式, 一个生产者, 一个消费者, 通过一个队列进行通信.</p><p><img src="https://www.rabbitmq.com/img/tutorials/python-one-overall.png" alt="p2p"></p><p>这种模型有这样的特点: 只有一个消费者和一个生产者, 并且消息一旦被消费就不再存在于消息队列中.当然, 它也是异步的, 生产者在发送完消息之后就可以干自己的事情了.</p><p>进阶一点的模型是这样的:</p><p><img src="https://www.rabbitmq.com/img/tutorials/python-two.png" alt="work queues"></p><p>这时我们的任务队列就支持多个工作人员进行分担处理. 一旦任务较为复杂(比如是一个调整图像大小, 渲染PDF等等), 单个消费者进行起来也比较耗时, 而且任务发送的比较密集, 这时就需要进行任务的分担. 当第二条任务发送过来, 而第一个任务还没有结束的时候(C1忙碌, 处于阻塞的状态), C2就会来接手这个任务.</p><p>此时应该出现了一些问题了. 如果我们的C1和C2忙碌的工作着, 这个时候突然断电了! 我们的仍然滞留在消息队列中的消息怎么办呢? 因此这里我们就引入一种<strong>确认机制</strong>以及消息的<strong>持久化</strong>. </p><p>确认机制和TCP的ACK确认特别相像, 只要消息队列收到了确认说明就会将该消息从队列中移除 这样我们就可以确保在消费者死亡的情况下, 任务也不会丢失.</p><p>另外, 断电的时候我们的消息队列也会停止, 任务依旧会丢失.</p><p>这个时候就要将我们的队列中标记成永久的任务进行磁盘写入 ,在下一次加载的时候进行读取载入, 从而恢复队列.</p><p>至此, 我们的消息队列仍然不完整. 因为他缺少一个重要的部件: <strong>消息交换机</strong>(<code>exchange</code>), 或者叫他控制器, 随你怎么叫, 现在的模型变成了这个样子:</p><p><img src="https://www.rabbitmq.com/img/tutorials/exchanges.png" alt="exchange"></p><p>所有的信息都会经过这个<code>x</code>来进行路由: 根据发送过来的消息上带着的路由标识, 来决定该消息发向哪一个队列. 不仅如此, 我们还可以指定不同的交换类型, 来很方便的进行消息的调度.  此时这些队列都是有名字的队列(要不然向发送对象怎么进行路由啊) 所以为了更加简化这个操作,我们采取随机队列名的方式. 但是这样的话, 我们就不知道怎么进行将信息发送到指定的对象了. 所以这里就又多了一个<strong>绑定</strong>的概念:</p><p><img src="https://www.rabbitmq.com/img/tutorials/bindings.png" alt="binding"></p><p>这样我就可以很简单的实现<code>广播</code>了. 不仅这样, 我们还实现了消息队列附加到消息交换机上.</p><p>现在已经是一个比较标准的消息队列了! 借由routing_key的特性,我们又可以实现很多不同种的路由交换了:</p><p>比如:</p><p><img src="https://www.rabbitmq.com/img/tutorials/python-four.png" alt="direct"></p><p>在上图的实例中, 我们假象出一种日志发送的场景, 我们一个的队列用来发送所有级别的日志, 而单独提供一条队列仅仅的发送错误级别高的(也就是error).</p><p>最后, 再看一下更加深入一点的消息过滤广播模式, 这种模式仍然基于我们上面的routing_key, 只不过我们把这个称作<code>topic</code> :</p><p><img src="https://www.rabbitmq.com/img/tutorials/python-five.png" alt="topic"></p><p>消息队列另一个高级一点的用法就是远程的过程调用(Remote Process Call, RPC)  这个的组成需要一个客户机和一个可以扩展的RPC服务器: </p><p><img src="https://www.rabbitmq.com/img/tutorials/python-six.png" alt="RPC"></p><p>首先说下回调队列是个什么东西. 上图中的随机队列(就是那个返回给客户的)就是回调队列, 这里面还有一个属性值得关注, 就是相关编号. 这是因为为了能够清晰的我知道哪一个回应对应之前的请求, 不仅如此,如果出现不存在的id, 我们可以进行优雅的忽略或者丢弃. 这种情况是怎么会出现的呢? 当服务端发送回来应答但是在收到客户的应答之前却挂了. 在下一次启动时就会进行重复的发送.</p><p>我们的RPC将像这样工作：</p><ul><li>当客户端启动时, 它创建一个匿名独占回调队列</li><li>对于RPC请求，客户端发送一个具有两个属性的消息： reply_to: 它被设置为回调队列. correlation_id: 它被设置为每个请求的唯一值.</li><li>请求被发送到rpc_queue队列</li><li>RPC worker（aka：server）正在等待队列上的请求. 当请求出现时, 它将执行该作业, 并使用reply_to字段中的队列将结果发回给客户端</li><li>客户端等待回调队列中的数据.当信息出现时,它检查correlation_id属性. 如果它与请求中的值相匹配，则返回对应用程序的响应</li></ul><p>至此消息队列(RabbitMQ)的基本就是这样了.</p><p>接下来来看一下Python是怎么来和Rabbit服务器进行连接和交互的.</p><h3 id="pika-–-RabbitMQ官方推荐的连接器"><a href="#pika-–-RabbitMQ官方推荐的连接器" class="headerlink" title="pika – RabbitMQ官方推荐的连接器"></a>pika – RabbitMQ官方推荐的连接器</h3><p>RabbitMQ的架构大体是这样:</p><p><img src="http://images2015.cnblogs.com/blog/820332/201601/820332-20160124221240875-1959295808.png" alt="rabbitMQ"></p><p>其中几个重要概念: (其中有一些在上面也说过了)</p><p>​Broker：简单来说就是消息队列服务器实体.</p><p>　　Exchange：消息交换机,它指定消息按什么规则,路由到哪个队列.</p><p>　　Queue：消息队列载体,每个消息都会被投入到一个或多个队列.</p><p>　　Binding：绑定,它的作用就是把exchange和queue按照路由规则绑定起来.</p><p>　　Routing Key：路由关键字,exchange根据这个关键字进行消息投递.</p><p>　　vhost：虚拟主机,一个broker里可以开设多个vhost,用作不同用户的权限分离.</p><p>　　producer：消息生产者,就是投递消息的程序.</p><p>　　consumer：消息消费者,就是接受消息的程序.</p><p>　　channel：消息通道,在客户端的每个连接里,可建立多个channel,每个channel代表一个会话任务.</p><p>消息队列的使用过程,如下：</p><ol><li>客户端连接到消息队列服务器,打开一个channel.</li><li>客户端声明一个exchange,并设置相关属性.</li><li>客户端声明一个queue,并设置相关属性.</li><li>客户端使用routing key,在exchange和queue之间建立好绑定关系.</li><li>客户端投递消息到exchange.</li><li>exchange接收到消息后,就根据消息的key和已经设置的binding,进行消息路由,将消息投递到一个或多个队列里.</li></ol><p><strong>pika</strong>是一个第三方的RMQ连接器, 使用起来也很方便. 常规的步骤和上面使用消息队列的方法是一样的.</p><p>一个最简单的发布者例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&quot;localhost&quot;</span>))</span><br><span class="line"></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">publish</span>(<span class="params">message</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sending msg: &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(message))</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                          routing_key=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                          body=message)</span><br><span class="line"></span><br><span class="line">publish(<span class="string">&quot;This is a msg.&quot;</span>)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure><p>对应的订阅者例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line"></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] waiting for logs.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(body.decode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=<span class="string">&#x27;hello&#x27;</span>, no_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>这就对应最简单的那一种P2P的模型. 一个订阅者和一个发布者.</p><p>那么如何使用pika来进行持久化呢? 很简单, 如果要实现队列的持久化, 只需要在声明的时候声明一下<code>durable</code>属性就可以了: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_declare(queue=<span class="string">&quot;queueName&quot;</span>, durable=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>但是, 这只能保住队列的持久化, 却无法使得队列中的消息保持. </p><p>如果想要使得消息保持呢? 之前就说了我们只有把想要持久化的消息才保留, 因此我们在发送消息的时候就要明确的说:”这个消息是要持久化的!” 这样的一个功能的实现就是依靠消息的发送类型:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                      routing_key=<span class="string">&#x27;dest&#x27;</span>, <span class="comment"># 这个其实就是消息的目的地</span></span><br><span class="line">                      body=<span class="string">&#x27;Hello world&#x27;</span>,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                          delivery_mode=<span class="number">2</span>,  <span class="comment"># make the msg persistent, 通过设置模式为2来告诉RabbitMQ持久化(默认是1, 不持久化)</span></span><br><span class="line">                      ))</span><br></pre></td></tr></table></figure><p>你注意到了, 在上面的订阅者的那里有一个<code>no_ack</code>的选项设定成了<code>True</code> 这个意思就是说, 不进行收到检查, 也即是说不向服务端发送确认token. 这样所有的消息就会在发送出去之后从队列中消失.</p><p>如果将该语句注释掉, 情况就大不一样了, 订阅者必须在每次收到消息之后进行确认回复, 否则. <strong>消息会永久留在队列中</strong>, 因为服务端认为该消息没有被客户端收到.</p><p>这个时候就要在客户端的回调函数中加上这样一条语句: ( 手动发送一条 )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.basic_ack(delivery_tag=method.delivery_tag)</span><br></pre></td></tr></table></figure><p>接着如果我们开了两个消费者和一个生产者的话, RabbitMQ已经默认实现均衡分配任务, 但是假如说我们的任务是偶数耗时长而奇数任务很轻松的话, 就会造成一个消费者疯狂的工作, 另一只就很轻松.</p><p>为了解决这个问题也就是每一个消费者都只有一个固定的任务量, 当到达这个限度的时候, 就将后来的任务发送给下一个消费者. 这个任务量我们可以把它叫做服务质量(QoS):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)  <span class="comment"># Let each consumer can only handle one msg per time, 这样每一个worker都只能最大同时执行一个任务了</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>重要提示:如果你使用了no_ack选项, 那么这个功能会失效! 因为这是基于客户应答来判断当前消费者的情况的.</strong></p></blockquote><p>接着我们再来看一下上面的路由交换功能实现. 在上面说消息保持的时候, 代码段中由有一个<code>routing_key</code>这个东西就决定这路由的转发方向, 所以我们可以通过这个实现消息的转发. </p><p>来直接看这么一个日志记录的示例:</p><p>发送端:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">conn = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&quot;localhost&quot;</span>))</span><br><span class="line"></span><br><span class="line">channel = conn.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&quot;log&quot;</span>, <span class="built_in">type</span>=<span class="string">&quot;direct&quot;</span>) <span class="comment"># 注意这里使用的消息发送类型是direct</span></span><br><span class="line"></span><br><span class="line">levels = [<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;error&#x27;</span>]</span><br><span class="line"></span><br><span class="line">logs = [<span class="string">&quot;You system has to restart.&quot;</span>, <span class="string">&quot;You PyCharm will shut down&quot;</span>, <span class="string">&quot;GoodBye, administrator.&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    level = levels[random.randint(<span class="number">0</span>, <span class="number">2</span>)]</span><br><span class="line">    log = logs[random.randint(<span class="number">0</span>,<span class="number">2</span>)]</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;log&#x27;</span>,</span><br><span class="line">                          routing_key=level,</span><br><span class="line">                          body=log)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Send msg [&#123;0&#125;] &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(level, log))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>接收端:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">conn = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&quot;localhost&quot;</span>))</span><br><span class="line"></span><br><span class="line">channel = conn.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;log&#x27;</span>,</span><br><span class="line">                         <span class="built_in">type</span>=<span class="string">&#x27;direct&#x27;</span>)</span><br><span class="line"></span><br><span class="line">queue_name = channel.queue_declare(exclusive=<span class="literal">True</span>).method.queue</span><br><span class="line"></span><br><span class="line">level = <span class="string">&#x27;&#x27;</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">&#x27;info&#x27;</span></span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">&#x27;log&#x27;</span>,</span><br><span class="line">                   queue=queue_name, <span class="comment"># 根据执行时不同的参数, 会绑定不同的队列</span></span><br><span class="line">                   routing_key=level)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] waiting for logs.(&#123;0&#125;)&quot;</span>.<span class="built_in">format</span>(level))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[x] %r:%r&quot;</span> % (method.routing_key, body))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>这样指明就可以只收到客户想要的类型数据了.</p><p>最后一个, 也就是基于topic的消息过滤广播模式, 事实上也就是上面这一种的变体. 所以在代码上也没什么特别的. 唯一的不同就是type改成<code>topic</code>就行.</p><p>最后一种应用, 在说具体的实现前, 我们先来把消息的几个常见属性列举一下(属性一共有14个, 但是大部分都很少使用)</p><blockquote><p><strong>delivery_mode:</strong> 将消息标记成持久(也就是2)或者transient(任何其他值), 我们在之前说消息持久化的时候提到过这个属性 em? </p><p>**content_type: **用于描述MIME的编码, 现在流行常见也就是<code>application/json</code> </p><p>**reply_to: **用于命名回调队列. (和 RPC 相关 .这个待会我们会说)</p><p>**correlation_id: **( 和RPC相关 ) 用于将RPC响应与请求相关联.</p></blockquote><p>由于我在瞎折腾, 关于RPC的具体实现就省略了吧( 不过基础功能实现了!我只是想再扩展通用化一下(｡・&#96;ω´･) ).</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>有关Redis的基本使用, 由于以前有过使用并且写了一个<a href="https://yaoxuannn.com/2017/05/21/First2Redis/">简单的上手使用文档</a>.</p><p>现在就直接来看实现啦: (这里使用的是**<code>redis-py</code>**库)</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接有两种实现方式.</p><p>第一种: – <strong>直接连接</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">r = redis.Redis(host=<span class="string">&#x27;localhost&#x27;</span>) <span class="comment"># 直接进行连接</span></span><br><span class="line">r.<span class="built_in">set</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.get(<span class="string">&quot;foo&quot;</span>).decode(<span class="string">&quot;utf-8&quot;</span>)) <span class="comment"># 在Python3中, 所以的socket传输都是byte</span></span><br><span class="line"><span class="comment"># test</span></span><br></pre></td></tr></table></figure><p>但是在使用redis的场景中, 连接是一件很常见事情, 有可能会有大量的连接活动进行.而这样的方式显然是很低效的. 因此一种更常见的连接实现是这样的:</p><p>第二种: 使用<strong>连接池</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;localhost&#x27;</span>, max_connections=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line">r.<span class="built_in">set</span>(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;foo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.get(<span class="string">&quot;test&quot;</span>).decode(<span class="string">&quot;utf-8&quot;</span>)) </span><br></pre></td></tr></table></figure><p>这样就通过一个一个连接池来进行所有连接的管理, 从而避免每次连接建立, 释放连接的开销 , 并且由于每个Redis实例都会维护自己的连接池, 所以这样也实现 多个Redis实例来共享一个连接池.</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(name, value, ex=<span class="literal">None</span>, px=<span class="literal">None</span>, nx=<span class="literal">False</span>, xx=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 设置接口:</span></span><br><span class="line"><span class="comment"># ex: 过期时间(秒)</span></span><br><span class="line"><span class="comment"># px: 过期时间(毫秒)</span></span><br><span class="line"><span class="comment"># nx: name不存在的时候才执行操作</span></span><br><span class="line"><span class="comment"># xx: name存在时进行操作</span></span><br><span class="line">get(name)</span><br><span class="line"><span class="comment"># 获取接口</span></span><br></pre></td></tr></table></figure><p>后面的一些参数也可以有单独的接口来设置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setnx() <span class="comment"># 相当于是nx=True</span></span><br><span class="line">setex() <span class="comment"># 相当于是ex=True</span></span><br><span class="line">psetex(name,time_ms, value) <span class="comment"># 设置过期时间的快速接口, 这里的时间单位是毫秒, 同样支持timedelta</span></span><br></pre></td></tr></table></figure><p>多个的设置和获取基本和<code>redis</code>的原生接口是一样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mset(*args, **kwargs)</span><br><span class="line"><span class="comment"># 使用起来就像这样:</span></span><br><span class="line"><span class="comment"># mset(k1=&#x27;v1&#x27;, k2=&#x27;v2&#x27;)</span></span><br><span class="line"><span class="comment"># 或者:</span></span><br><span class="line"><span class="comment"># mset(&#123;&#x27;k1&#x27;: &#x27;v1&#x27;, &#x27;k2&#x27;: &#x27;v2&#x27;&#125;)</span></span><br><span class="line">mget(keys, *args)</span><br><span class="line"><span class="comment"># 就像这样:</span></span><br><span class="line"><span class="comment"># mget(&#x27;k1&#x27;, &#x27;k2&#x27;)</span></span><br><span class="line"><span class="comment"># 或者:</span></span><br><span class="line"><span class="comment"># mget[&#x27;k1&#x27;, &#x27;k2&#x27;]</span></span><br></pre></td></tr></table></figure><p>还有一些多功能的获取和设置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getset(name, value)</span><br><span class="line"><span class="comment"># 设置一个新值的时候, 同时返回当前的值</span></span><br><span class="line">r.<span class="built_in">set</span>(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.getset(<span class="string">&quot;k1&quot;</span>, <span class="string">&#x27;v2&#x27;</span>)) <span class="comment"># &quot;v1&quot;</span></span><br><span class="line"><span class="built_in">print</span>(r.get(<span class="string">&quot;k1&quot;</span>)) <span class="comment"># &quot;v2&quot;</span></span><br></pre></td></tr></table></figure><p>范围操作: ( 基本和redis的操作是一样的, 略过 )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getrange(key,start,end)</span><br><span class="line">setrange(name,offset,value)</span><br></pre></td></tr></table></figure><p>运算函数: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incr(self, name, amount=<span class="number">1</span>) <span class="comment"># 做一个自增操作, 如果name不存在, 那么创建name = amount</span></span><br><span class="line"><span class="comment"># 这里的amount必须是整数 该函数和incrby等价</span></span><br><span class="line">incrbyfloat(self,name,amount=<span class="number">1.0</span>) <span class="comment"># 和incr使用起来没有什么不同, 只不过支持小数</span></span><br></pre></td></tr></table></figure><p>如果对一个不支持运算的字符进行运算会出现: <code>redis.exceptions.ResponseError: value is not an integer or out of range</code>.</p><p>如果要在已经存在的值后面进行插入操作, 就是<code>append(key,value)</code> 接口都设置的很好使用</p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>和redis的哈希操作基本保持一致, 其实大部分的函数执行都是通过Socket远端过程调用( :废话 (｀⌒´メ) )</p><p>这些最基本的接口签名列举在下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hset(name,key,value)</span><br><span class="line">hmset(name, mapping)</span><br><span class="line"><span class="comment"># mapping 是指字典:</span></span><br><span class="line"><span class="comment"># 使用起来的一个示例是这样:</span></span><br><span class="line"><span class="comment"># hmset(&#x27;user:1&#x27;, &#123;&#x27;number&#x27;: &#x27;123456&#x27;, &#x27;passwd&#x27;: &#x27;8Q7N03TCksw5o1&#x27;&#125;)</span></span><br><span class="line">hget(name, key)</span><br><span class="line">hmget(name, keys, *args)</span><br><span class="line"><span class="comment"># 支持多种的方式的获取:</span></span><br><span class="line"><span class="comment"># hmget(&#x27;user:1&#x27;, [&#x27;number&#x27;, &#x27;passwd&#x27;]) 或者 hmget(&#x27;user:1&#x27;, &#x27;number&#x27;, &#x27;passwd&#x27;)</span></span><br><span class="line"><span class="comment"># 和上面一样, 可以加上nx这样的标志</span></span><br><span class="line"><span class="comment"># 比如: hsetnx(name,key,value) # 只有不存在的时候才会进行添加</span></span><br><span class="line">hgetall(name)</span><br><span class="line"><span class="comment"># 获取所有的键值对 字典返回</span></span><br></pre></td></tr></table></figure><p>接着就是一些辅助类的接口:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hlen(name) <span class="comment"># 获取一个name对应的hash中所有的键值的个数</span></span><br><span class="line">hkeys(name)</span><br><span class="line">hvals(name) <span class="comment"># 返回所有的Key或者Val, list的形式返回</span></span><br><span class="line">hexists(name, key) </span><br><span class="line">hdel(name, *keys) <span class="comment"># 删除一个或者n个键值对</span></span><br><span class="line">hincrby(name, key, amount=<span class="number">1</span>)</span><br><span class="line">hincrbyfloat(name, key, amount=<span class="number">1.0</span>) <span class="comment"># 使用规则都和上面字符串的操作是一样的, 不再赘述</span></span><br></pre></td></tr></table></figure><p>最后再说两个Hash迭代的接口:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hscan(name, cursor=<span class="number">0</span>, <span class="keyword">match</span>=<span class="literal">None</span>, count=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>这个是增量式的迭代获取, 对于数据大的数据很有用, 因为这是分片获取的数据, 并非一次性将所有的数据读取完, 他的参数也基本和redis原生的接口保持一致性.</p><blockquote><p>关于这个hscan方法, 在使用的时候你可能会有疑问: 为什么我的cursor始终是0. 关于这个问题.我在使用scan的时候是正常的, 但是一使用hscan的时候就始终都会一次性的把所有的键遍历一遍. 后续解决</p></blockquote><p>封装了一层返回迭代器的方法: <code>hscan_iter</code> 通过封装hscan来创建生成器 由于是二次封装, 因此参数更精简.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hscan_iter(name, <span class="keyword">match</span>=<span class="literal">None</span>, count=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># for item in r.hscan_iter(&#x27;xx&#x27;):</span></span><br><span class="line"><span class="comment">#    print(item)</span></span><br></pre></td></tr></table></figure><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>基本上都很好记, 过一遍就行了:</p><p>基本的操作:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r.lpush(name, *values) <span class="comment"># 当然反过来就是 rpush(name, *values)</span></span><br><span class="line"><span class="comment"># 同样带上标志位的版本:</span></span><br><span class="line">r.lpushx(name, value) <span class="comment"># 只有name已经存在的时候, 值添加到列表的最左侧 (rpushx)</span></span><br><span class="line"><span class="comment"># 如果是多个值同时插入, 那么最后的存储顺序将会反过来</span></span><br><span class="line">linsert(name, where, refvalue, value) <span class="comment"># 在一个标杆值的前面或者后面插入一个值, 这个where只有两个值, AFTER 和 BEFORE, 接着就是参考值, 如果没有就会返回-1</span></span><br><span class="line">lset(name, index, value) <span class="comment"># 对某一个索引的位置进行重新赋值</span></span><br><span class="line">lrem(name, value, num) <span class="comment"># 删除指定位置的值</span></span><br><span class="line">lpop(name) <span class="comment"># 这里的l可以理解成left, 所以也有rpop(name), 删除对应方向上的元素并返回之</span></span><br><span class="line">lrange(name, start. end)</span><br><span class="line"><span class="comment"># 分片获取数据.</span></span><br><span class="line"><span class="comment"># 获取全部数据就是 lrange(name, 0, -1) [从第0个到最后一个]</span></span><br></pre></td></tr></table></figure><p>辅助方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">llen(name) <span class="comment"># 返回长度</span></span><br><span class="line">ltrim(name, start, end) <span class="comment"># 仅保留start-end之间的值</span></span><br><span class="line">lindex(name, index) <span class="comment"># 相当于是数组取下标一样使用就行</span></span><br></pre></td></tr></table></figure><p>堵塞操作:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blpop(keys,timeout=<span class="number">0</span>) <span class="comment"># 将多个列表排列，按照从左到右去pop对应列表的元素</span></span><br><span class="line">brpoplpush(src, dst, timeout=<span class="number">0</span>) <span class="comment"># 从一个列表的右侧, 将其添加到另一个表的左侧</span></span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>集合的操作:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sadd(name,values)</span><br><span class="line"><span class="comment"># name对应的集合中添加元素</span></span><br><span class="line">scard(name)</span><br><span class="line">获取name对应的集合中元素个数</span><br><span class="line">sdiff(keys, *args)</span><br><span class="line"><span class="comment"># keys中去掉和后面的集合所拥有的元素集合</span></span><br><span class="line">sdiffstore(dest, keys, *args)</span><br><span class="line"><span class="comment"># 将sdiff的结果加入到dest对应的集合中</span></span><br><span class="line">sinter(keys, *args)</span><br><span class="line"><span class="comment"># 获取多一个name对应集合的并集</span></span><br><span class="line">sinterstore(dest, keys, *args)</span><br><span class="line"><span class="comment"># 将sinter的结果加入到dest对应的集合中</span></span><br><span class="line">sismember(name, value)</span><br><span class="line"><span class="comment"># 检查value是否是name对应的集合的成员</span></span><br><span class="line">smembers(name)</span><br><span class="line"><span class="comment"># 获取name对应的集合的所有成员</span></span><br><span class="line">smove(src, dst, value)</span><br><span class="line"><span class="comment"># 将某个成员从一个集合中移动到另外一个集合</span></span><br><span class="line">spop(name)</span><br><span class="line"><span class="comment"># 从集合的右侧（尾部）移除一个成员，并将其返回</span></span><br><span class="line">srandmember(name, numbers)</span><br><span class="line"><span class="comment"># 从name对应的集合中随机获取 numbers 个元素</span></span><br><span class="line">srem(name, values)</span><br><span class="line"><span class="comment"># 在name对应的集合中删除某些值</span></span><br><span class="line">sunion(keys, *args)</span><br><span class="line"><span class="comment"># 获取多一个name对应的集合的并集</span></span><br><span class="line">sunionstore(dest,keys, *args)</span><br><span class="line"><span class="comment"># 将sunionstore结果保存到dest对应的集合中</span></span><br><span class="line">sscan(name, cursor=<span class="number">0</span>, <span class="keyword">match</span>=<span class="literal">None</span>, count=<span class="literal">None</span>)</span><br><span class="line">sscan_iter(name, <span class="keyword">match</span>=<span class="literal">None</span>, count=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大</span></span><br></pre></td></tr></table></figure><h4 id="sorted-list"><a href="#sorted-list" class="headerlink" title="sorted list"></a>sorted list</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">zadd(name, *args, **kwargs)</span><br><span class="line"><span class="comment"># 在name对应的有序集合中添加元素</span></span><br><span class="line"><span class="comment"># 如：</span></span><br><span class="line">     <span class="comment"># zadd(&#x27;zz&#x27;, &#x27;n1&#x27;, 1, &#x27;n2&#x27;, 2)</span></span><br><span class="line">     <span class="comment"># 或</span></span><br><span class="line">     <span class="comment"># zadd(&#x27;zz&#x27;, n1=11, n2=22)</span></span><br><span class="line">zcard(name)</span><br><span class="line"><span class="comment"># 获取name对应的有序集合元素的数量</span></span><br><span class="line">zcount(name, <span class="built_in">min</span>, <span class="built_in">max</span>)</span><br><span class="line"><span class="comment"># 获取name对应的有序集合中分数 在 [min,max] 之间的个数</span></span><br><span class="line">zincrby(name, value, amount)</span><br><span class="line"><span class="comment"># 自增name对应的有序集合的 name 对应的分数</span></span><br><span class="line">r.zrange( name, start, end, desc=<span class="literal">False</span>, withscores=<span class="literal">False</span>, score_cast_func=<span class="built_in">float</span>)</span><br><span class="line"><span class="comment"># 按照索引范围获取name对应的有序集合的元素</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line">    <span class="comment"># name，redis的name</span></span><br><span class="line">    <span class="comment"># start，有序集合索引起始位置（非分数）</span></span><br><span class="line">    <span class="comment"># end，有序集合索引结束位置（非分数）</span></span><br><span class="line">    <span class="comment"># desc，排序规则，默认按照分数从小到大排序</span></span><br><span class="line">    <span class="comment"># withscores，是否获取元素的分数，默认只获取元素的值</span></span><br><span class="line">    <span class="comment"># score_cast_func，对分数进行数据转换的函数</span></span><br><span class="line"><span class="comment"># 更多：</span></span><br><span class="line">    <span class="comment"># 从大到小排序</span></span><br><span class="line">    <span class="comment"># zrevrange(name, start, end, withscores=False, score_cast_func=float)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 按照分数范围获取name对应的有序集合的元素</span></span><br><span class="line">    <span class="comment"># zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)</span></span><br><span class="line">    <span class="comment"># 从大到小排序</span></span><br><span class="line">    <span class="comment"># zrevrangebyscore(name, max, min, start=None, num=None, withscores=False, score_cast_func=float)</span></span><br><span class="line">zrank(name, value)</span><br><span class="line"><span class="comment"># 获取某个值在 name对应的有序集合中的排行（从 0 开始）</span></span><br><span class="line"><span class="comment"># 更多：</span></span><br><span class="line">    <span class="comment"># zrevrank(name, value)，从大到小排序</span></span><br><span class="line">zrem(name, values)</span><br><span class="line"><span class="comment"># 删除name对应的有序集合中值是values的成员</span></span><br><span class="line"><span class="comment"># 如：zrem(&#x27;zz&#x27;, [&#x27;s1&#x27;, &#x27;s2&#x27;])</span></span><br><span class="line">zremrangebyrank(name, <span class="built_in">min</span>, <span class="built_in">max</span>)</span><br><span class="line"><span class="comment"># 根据排行范围删除</span></span><br><span class="line">zremrangebyscore(name, <span class="built_in">min</span>, <span class="built_in">max</span>)</span><br><span class="line"><span class="comment"># 根据分数范围删除</span></span><br><span class="line">zscore(name, value)</span><br><span class="line"><span class="comment"># 获取name对应有序集合中 value 对应的分数</span></span><br><span class="line">zinterstore(dest, keys, aggregate=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 获取两个有序集合的交集，如果遇到相同值不同分数，则按照aggregate进行操作</span></span><br><span class="line"><span class="comment"># aggregate的值为:  SUM  MIN  MAX</span></span><br><span class="line">zunionstore(dest, keys, aggregate=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 获取两个有序集合的并集，如果遇到相同值不同分数，则按照aggregate进行操作</span></span><br><span class="line"><span class="comment"># aggregate的值为:  SUM  MIN  MAX</span></span><br><span class="line">zscan(name, cursor=<span class="number">0</span>, <span class="keyword">match</span>=<span class="literal">None</span>, count=<span class="literal">None</span>, score_cast_func=<span class="built_in">float</span>)</span><br><span class="line">zscan_iter(name, <span class="keyword">match</span>=<span class="literal">None</span>, count=<span class="literal">None</span>,score_cast_func=<span class="built_in">float</span>)</span><br><span class="line"><span class="comment"># 同字符串相似，相较于字符串新增score_cast_func，用来对分数进行操作</span></span><br></pre></td></tr></table></figure><h4 id="others"><a href="#others" class="headerlink" title="others"></a>others</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">delete(*names)</span><br><span class="line"><span class="comment"># 根据删除redis中的任意数据类型</span></span><br><span class="line">exists(name)</span><br><span class="line"><span class="comment"># 检测redis的name是否存在</span></span><br><span class="line">keys(pattern=<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"><span class="comment"># 根据模型获取redis的name</span></span><br><span class="line"><span class="comment"># 更多：</span></span><br><span class="line">    <span class="comment"># KEYS * 匹配数据库中所有 key 。</span></span><br><span class="line">    <span class="comment"># KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。</span></span><br><span class="line">    <span class="comment"># KEYS h*llo 匹配 hllo 和 heeeeello 等。</span></span><br><span class="line">    <span class="comment"># KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo</span></span><br><span class="line">expire(name ,time)</span><br><span class="line"><span class="comment"># 为某个redis的某个name设置超时时间</span></span><br><span class="line">rename(src, dst)</span><br><span class="line"><span class="comment"># 对redis的name重命名为</span></span><br><span class="line">move(name, db))</span><br><span class="line"><span class="comment"># 将redis的某个值移动到指定的db下</span></span><br><span class="line">randomkey()</span><br><span class="line"><span class="comment"># 随机获取一个redis的name（不删除）</span></span><br><span class="line"><span class="built_in">type</span>(name)</span><br><span class="line"><span class="comment"># 获取name对应值的类型</span></span><br><span class="line">scan(cursor=<span class="number">0</span>, <span class="keyword">match</span>=<span class="literal">None</span>, count=<span class="literal">None</span>)</span><br><span class="line">scan_iter(<span class="keyword">match</span>=<span class="literal">None</span>, count=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 同字符串操作，用于增量迭代获取key</span></span><br></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>由于redis-py默认每一次的操作都会创建和断开一次连接( 之前说过优化就是使用连接池 但是这个治标不治本, 因为最后还是要连接池申请和归还释放连接池的 ) 因此 使用管道来在一次请求中指定多个命令, 在默认的情况下pipeline也是原子操作:</p><p>e.g:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pipe = r.pipeline(transaction=False)</span></span><br><span class="line">pipe = r.pipeline(transaction=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;WWW&#x27;</span>)</span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&#x27;role&#x27;</span>, <span class="string">&#x27;STU&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pipe.execute()</span><br></pre></td></tr></table></figure><h2 id="Sqlalchemy"><a href="#Sqlalchemy" class="headerlink" title="Sqlalchemy"></a>Sqlalchemy</h2><p><img src="http://www.sqlalchemy.org/img/sqla_logo.png" alt="SQLAlchemy"></p><p>sqlalchemy是一个超级强大超级复杂的ORM框架, 主要是用来操作MySQL, 也支持sqlite, oracle好像.</p><p>这个sqlalchemy说实话, 我感觉在日后的使用中, 我连这个框架的80%都用不到, 认真的. 这个ORM实在是太庞大了. 那么就一些常用功能, 记录用法在下.</p><p>我们都知道ORM主要是为了避免直接在代码中插入SQL语句, 另外将数据和对象进行映射, 使得对对象的种种操作可以转换成为对数据的操作, 这个过程由框架完成, 程序员只需要处理熟悉的对象就行了.</p><p>现在我们一边复习SQL, 一边将其转换成为Python实现代码. </p><h3 id="连接-1"><a href="#连接-1" class="headerlink" title="连接"></a>连接</h3><p>这个就没有MySQL的代码了, 直接看下sqlalchemy是怎么进行的吧:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line">engine = create_engine(<span class="string">&quot;mysql+pymysql://user:password@192.168.56.101/db_name&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, echo=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>很简单吧, 这里使用的连接器是pymysql, 接着写下用户名密码地址数据库名就可以了</p><p>后面的参数echo就是说是否进行显示sqlalchemy做了些什么.</p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>创建表, 就是定义对象的行为, 请看:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, Integer, String</span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;user&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">32</span>))</span><br><span class="line">    password = Column(String(<span class="number">64</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">   </span><br><span class="line">Base.metadata.create_all(engine)</span><br></pre></td></tr></table></figure><p>这样就会将表user创建.</p><p>对应的SQL语句是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">  id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(32),</span><br><span class="line">  password VARCHAR(64) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果想要创建外键约束, 很简单, 这么写:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Record(Base):</span><br><span class="line">    __tablename__ = <span class="string">&quot;record&quot;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=True, autoincrement=True)</span><br><span class="line">    day = Column(Integer, nullable=False)</span><br><span class="line">    status = Column(String(16), default=<span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">    user_id = Column(Integer, ForeignKey(<span class="string">&#x27;user.id&#x27;</span>))</span><br></pre></td></tr></table></figure><p>当然, 这是需要导入的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import ForeignKey</span><br></pre></td></tr></table></figure><p>转换成为SQL语句就是这样子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE record (</span><br><span class="line">  id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">  day INT NOT NULL,</span><br><span class="line">  status VARCHAR(16) DEFAULT &#x27;N&#x27;,</span><br><span class="line">  CONSTRAINT FOREIGN KEY (user_id) REFERENCES user (id)</span><br><span class="line">) ;</span><br></pre></td></tr></table></figure><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><p>首先操作之前, 我们需要拿到一个cursor, 在这里的表现是session:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line">Session = sessionmaker(bind=engine)</span><br><span class="line">session = Session()</span><br></pre></td></tr></table></figure><p>通过这个session, 我们就可以做进一步的操作. 首先来看增加(插入操作). 首先为了插入一条数据, 我们要做的就是创建一个表的实例, 也就是相当于是数据库中的一个条目啦:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_obj = User(name=<span class="string">&quot;Justin&quot;</span>, password=password_str)</span><br><span class="line">session.add(user_obj)</span><br></pre></td></tr></table></figure><p>此时并没有插入到数据库中.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.commit()</span><br></pre></td></tr></table></figure><p>现在就可以了.</p><p>对应的SQL语句是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO user (name,password) VALUES(&quot;Justin&quot;, password_str);</span><br></pre></td></tr></table></figure><p>删除也很简单, 直接把对象实例传过去就行了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.delete(user_obj)</span><br></pre></td></tr></table></figure><p>即:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM user WHERE XXXX #(这里就不好表示了...);</span><br></pre></td></tr></table></figure><p>那么更改呢? 得益于数据对象映射, 更改变得再简单不过了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user_obj = User(name=&quot;Justin&quot;, password=password_str)</span></span><br><span class="line"><span class="comment"># 直接修改属性就行了</span></span><br><span class="line">user_obj.name = <span class="string">&quot;Bieber&quot;</span></span><br></pre></td></tr></table></figure><p>对应的SQL语句就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE user SET name = &#x27;Bieber&#x27; WHERE name = &#x27;Justin&#x27;;</span><br></pre></td></tr></table></figure><p>接下来就说说较为复杂的查吧:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = session.query(User).<span class="built_in">all</span>()</span><br><span class="line">data = session.query(User).first()</span><br></pre></td></tr></table></figure><p>这是最简单的两种了, 其中query方法会返回一个Query对象, 后面的all方法其实就是返回一个list()之后的Query , 而first也就是多了一层判断, 返回list的第一个.</p><p>这样查询就和:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user;</span><br></pre></td></tr></table></figure><p>一样.</p><p>接着看下带有条件的查询:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = session.query(User).<span class="built_in">filter</span>(User.<span class="built_in">id</span> &gt; <span class="number">1</span>, User.<span class="built_in">id</span> &lt; <span class="number">3</span>).<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure><p>我故意没有写成&#x3D;号形式, 就是想说明一下这个filter函数的签名:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">filter</span>(<span class="params">self, *criterion</span>):</span><br></pre></td></tr></table></figure><p>这样就可以进行条件查询, 也就相当于是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE id &gt; 1 AND id &lt; 3;</span><br></pre></td></tr></table></figure><p>还有数目查询:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = session.query(Admin).count()</span><br></pre></td></tr></table></figure><p>先这样吧. 脖子疼..</p><p><strong>来自未来尝试自行实现一个ORM框架的我的补充: 这个地方其实很多细节都没有提到, 例如Python的运算符重载, metaclass等等, 以后有时间可以写点.</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Python </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> SQLAlchemy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux模块-SELinux和PAM库</title>
      <link href="/2017/07/17/Linux%E6%A8%A1%E5%9D%97-SELINUX%E5%92%8CPAM%E5%BA%93/"/>
      <url>/2017/07/17/Linux%E6%A8%A1%E5%9D%97-SELINUX%E5%92%8CPAM%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>SELinux (Secure Enhanced Linux)<br>PAM (Pluggable Authentication Modules)</p><span id="more"></span><h2 id="PAM"><a href="#PAM" class="headerlink" title="PAM"></a>PAM</h2><p>PAM是一套程序编程接口, 它提供了一连串的验证机制, 只要将需求交给PAM, 然后PAM就会将验证的结果告知客户端. 就像这样:</p><p><img src="https://docs.oracle.com/cd/E26926_01/html/E25912/figures/pam.overview.1.png" alt="PAM 与其他程序的相关性"></p><p>有没有想到什么?对了这个就有一点像OAuth对不, 我们只要发起申请, 接着等到结果就行了, 当然OAuth是多对多, 和这个也是有区别的.但是他们的思想都是一样的, 使得账号密码或者其他的方式验证具有一致的结果, 使得程序员方便处理验证的问题.</p><p>如图, PAM作为一个独立的API存在, 用来进行验证的部分叫做模块. 各个模块负责的事情也不一样. 比如在进行密码设置的时候, 会有检测密码强度的提示, 这个就来源于PAM的<code>pam_cracklib.so</code>模块 .</p><p>我们就直接以一次密码验证的过程来说说程序调用PAM的工作流程:</p><ol><li>用户开始执行passwd程序, 输入密码</li><li>PAM到&#x2F;etc&#x2F;pam.d&#x2F;寻找与程序同名的配置文件</li><li>根据&#x2F;etc&#x2F;pam.d&#x2F;passwd内的设置, 引用相关的PAM模块逐步进行验证分析</li><li>将验证的结果(成功,失败,其他信息)返回给调用者(passwd)</li><li>passwd根据返回的结果进行下一步的操作.</li></ol><p>对于客户端而言, 编码过程和OAuth几乎是一样的.</p><p>那么看起来最重要的即使&#x2F;etc&#x2F;pam.d&#x2F;下面的配置文件了, 我们来看一看:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW pam.d]<span class="comment"># cat passwd</span></span><br><span class="line"><span class="comment">#%PAM-1.0</span></span><br><span class="line">auth       includesystem-auth</span><br><span class="line">account    includesystem-auth</span><br><span class="line">password   substacksystem-auth</span><br><span class="line">-password   optionalpam_gnome_keyring.so use_authtok</span><br><span class="line">password   substackpostlogin</span><br></pre></td></tr></table></figure><p>挨 又是自己的文件结构. 我们来逐行看一下</p><blockquote><p>除了第一行表示PAM的版本以外, 只要后面出现的<code>#</code>都会被视作注释. 显然易见的PAM将配置分成三个栏目, 分别是:</p><ul><li>验证类型  ( type )</li><li>控制标准 ( control )</li><li>PAM的模块和模块参数</li></ul></blockquote><p>下面就结合这三个参数来说一下</p><p><strong>第一个字段:: 验证类型</strong></p><p>主要分成四种:</p><p><strong>auth</strong>: 是authentication的缩写, 这种类型主要用来进行用户的身份验证,通常是使用的密码, 所以后面的模块是用来检验用户的身份的</p><p><strong>account</strong>: 大部分是用来进行授权的, 主要用于进行用户是否具有正确的权限</p><p><strong>session</strong>: 这个说来应该大家会很熟悉, 只要你经常使用su或者sudo, 当你使用这个进入sudoer的状态, 或者进入其他用户的状态而没有退出的时候, 你就处在一个session里面, 可以去&#x2F;var&#x2F;log&#x2F;secure里面看一下, 会有很多session open, session close的记录(close就说明你logout或者exit了)</p><p><strong>password</strong>: 就是再说密码, 当进行密码的修改时候就是这个模块发挥威力的时候了</p><p>一般情况下, 这些验证到的调用是有顺序的( 因为正常情况下, 你总是要先验证身份, 再进行授权, 接着才有登录, 而在运行时候改变密码 )</p><p><strong>第二个字段:: 验证的控制标志</strong></p><p>这些标志说白了就是验证的通过标准, 说之前提一下上面例子中的那个<code>include</code>, 这个不是控制标志哦, 只是说这个时候使用后面指定的配置文件的配置. 所以include不是控制标志.</p><p>有这些控制标志:</p><p><strong>required</strong>: 如果验证成功, 就带上一个success的标识, 如果验证失败则带上failure的标识, 但是不论验证结果是成功还是失败都继续验证下去, 这样对数据的日志有利. 所以PAM采用的最多的就是这个标志.</p><p><strong>requisite</strong>: 如果失败立即返回failure的标志, 直接终止后序的验证流程, 如果成功就继续. 和required唯一的不同就在于处理失败</p><p><strong>sufficient</strong>: 只要成功就立即回传success的标识, 同时结束验证过程. 但是验证失败的话,会继续过程. 和requisite正好相反.</p><p><strong>optional</strong>: 不作具体的验证, 而是用来显示信息.</p><p>用一张图来表示的话就是这样:</p><p><img src="http://linux.vbird.org/linux_basic/0410accountmanager//pam-2.gif" alt="PAM 控制旗标所造成的回报流程"></p><p>在新版的CentOS7上, 预装的PAM进行了更新, 多了这个控制位:</p><p><strong>substack</strong> ：运行其他配置文件中的流程，并将整个运行结果作为该行的结果进行输出.该模式和 <code>include</code> 的不同点在于认证结果的作用域：如果某个流程栈 <code>include</code> 了一个带 <code>requisite</code> 的栈，这个 <code>requisite</code> 失败将直接导致认证失败，同时退出栈；而某个流程栈 <code>substack</code> 了同样的栈时，<code>requisite</code> 的失败只会导致这个子栈返回失败信号，母栈并不会在此退出.</p><p>上面的这些叫做简单机制, 而还有一种叫做复杂机制, 也就是使用一个或者多个status&#x3D;action形式的组合表示.可以根据不同的返回状态来决定不同的action. 不过说实话啊, 这个机制真心..运维不需要手动的写吧. 能看就行了.</p><p>行了, 这样我们就可以看懂这些配置文件了. 在系统的启动中我们说过了getmintty这个程序调用login来提供登录, 那么这个login会不会就在我们的配置文件中呢</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW pam.d]<span class="comment"># cat login </span></span><br><span class="line"><span class="comment">#%PAM-1.0</span></span><br><span class="line">auth [user_unknown=ignore success=ok ignore=ignore default=bad] pam_securetty.so</span><br><span class="line">auth       substack     system-auth</span><br><span class="line">auth       include      postlogin</span><br><span class="line">account    required     pam_nologin.so</span><br><span class="line">account    include      system-auth</span><br><span class="line">password   include      system-auth</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>login也调用了多次system-auth. 迫不及待的打开system-auth:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW pam.d]<span class="comment"># cat system-auth</span></span><br><span class="line"><span class="comment">#%PAM-1.0</span></span><br><span class="line"><span class="comment"># This file is auto-generated.</span></span><br><span class="line"><span class="comment"># User changes will be destroyed the next time authconfig is run.</span></span><br><span class="line">auth        required      pam_env.so</span><br><span class="line">auth        sufficient    pam_unix.so nullok try_first_pass</span><br><span class="line">auth        requisite     pam_succeed_if.so uid &gt;= 1000 quiet_success</span><br><span class="line">auth        required      pam_deny.so</span><br><span class="line"></span><br><span class="line">account     required      pam_unix.so</span><br><span class="line">account     sufficient    pam_localuser.so</span><br><span class="line">account     sufficient    pam_succeed_if.so uid &lt; 1000 quiet</span><br><span class="line">account     required      pam_permit.so</span><br><span class="line"></span><br><span class="line">password    requisite     pam_pwquality.so try_first_pass local_users_only retry=3 authtok_type=</span><br><span class="line">password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok</span><br><span class="line">password    required      pam_deny.so</span><br><span class="line"></span><br><span class="line">session     optional      pam_keyinit.so revoke</span><br><span class="line">session     required      pam_limits.so</span><br><span class="line">-session     optional      pam_systemd.so</span><br><span class="line">session     [success=1 default=ignore] pam_succeed_if.so service <span class="keyword">in</span> crond quiet use_uid</span><br><span class="line">session     required      pam_unix.so</span><br></pre></td></tr></table></figure><p>这么多库, 他们都放置在<code>/lib64/security/*</code>里面 如果想要具体了解某些库提供的功能是什么, 还是要查看文档啊. 还是就以这个login为一个例子, 说一下相关的库吧.</p><table><thead><tr><th align="center">模块名</th><th align="center">功能和用途</th></tr></thead><tbody><tr><td align="center">pam_securetty.so</td><td align="center">限制root用户只能从安全的终端登入系统(安全终端就是在&#x2F;etc&#x2F;securetty里说明的)</td></tr><tr><td align="center">pam_nologin.so</td><td align="center">就是那个大名鼎鼎的nologin文件, 只要存在所有的用户(除了root和已经登录的)就不能再登录进系统了.</td></tr><tr><td align="center">pam_selinux.so</td><td align="center">可以将selinux(后面会说)暂时关闭, 由PAM来进行验证, 通过了之后就会恢复启动</td></tr><tr><td align="center">pam_console.log</td><td align="center">可以使用一些特殊的终端接口来登录系统</td></tr><tr><td align="center">pam_loginuid.so</td><td align="center">规范登录进系统的用户的UID(区分系统账号和用户账号)</td></tr><tr><td align="center">pam_env.so</td><td align="center">用来设定环境变量的库</td></tr><tr><td align="center">pam_UNIX.so</td><td align="center">这是一个复杂的模块了, 可以用于验证阶段的认证功能, 也可以在授权阶段进行账号的许可证管理, 并且在session阶段也可以进行日志的记录, 甚至可以进行密码的更新</td></tr><tr><td align="center">pam_cracklib.so</td><td align="center">之前也说过了, 这个是用来进行密码强度的检验的</td></tr><tr><td align="center">pam_limits.so</td><td align="center">ulimits的神奇能力都依靠于这个库</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><p>行了, 那么就可以来把login的过程讲清楚了.</p><blockquote><ol><li>验证阶段(auth)：首先，(a)会先经过pam_securetty.so 判断，如果使用者是root 时，则会参考&#x2F;etc&#x2F;securetty 的设定； 接下来(b)经过pam_env.so 设定额外的环境变数；再(c)透过pam_unix.so 检验密码，若通过则回报login 程式；若不通过则(d)继续往下以pam_succeed_if.so 判断UID 是否大于1000 ，若小于1000则回报失败，否则再往下(e)以pam_deny.so 拒绝连接.</li><li>授权阶段(account)：(a)先以pam_nologin.so 判断&#x2F;etc&#x2F;nologin 是否存在，若存在则不许一般使用者登入； (b)接下来以pam_unix.so 及pam_localuser.so 进行帐号管理，再以(c) pam_succeed_if.so 判断UID 是否小于1000 ，若小于1000 则不记录登录资讯.(d)最后以pam_permit.so 允许该帐号登录.</li><li>密码阶段(password)：(a)先以pam_pwquality.so 设定密码仅能尝试错误3 次；(b)接下来以pam_unix.so 透过sha512, shadow 等功能进行密码检验，若通过则回报login 程序，若不通过则(c)以pam_deny.so 拒绝登录.</li><li>会话阶段(session)：(a)先以pam_selinux.so 暂时关闭SELinux；(b)使用pam_limits.so 设定好使用者能够操作的系统资源； (c)登入成功后开始记录相关信息在登录文件中； (d)以pam_loginuid.so 规范不同的UID 权限；(e)开启pam_selinux.so 的功能.</li></ol></blockquote><p>最后再说一句, 如果 关于这个出现了什么难以解决的不明问题, 最好的解决方法个人认为就是去查看日志, 也即是&#x2F;var&#x2F;log&#x2F;messages和&#x2F;var&#x2F;log&#x2F;secure.(不同发行版不同哦,不确定的话查看rsyslog的配置吧)</p><h2 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h2><p>在开头说过了, SELinux是指安全加强的Linux. 他的来头很大,是美国国家安全委员会负责研发的. </p><p>然而在实际的生产环境中却没有**1%**的人选择使用. </p><blockquote><p>美国国家安全委员会对操作系统进行了安全评分, 从最安全的A到最次的D. Windows Server的安全评级为C2, 也就是仅次于最差的D, 那么Linux呢? 和WinServer一样, 都是C2. 有些人总说使用Linux是因为安全, 其实这样是不合理的.只是说由于Linux的学习曲线陡峭导致Linux的用户都花了精力研究过的. 而Windows由于用户中多自然针对的攻击脚本也多.</p></blockquote><p>Selinux工作在内核中, 使用了一种强制访问控制(MAC). 原来的Linux使用的是一种自主访问控制.(DAC)自主访问控制就是说当你的文件想要让别人可以进行写操作的时候, 可以进行chmod, 这种操作Linux系统是不加限制的. 在之前说到进程的时候.说到了一个安全执行上下文的东西, 就是说决定进程能访问那些文件的时候. 我们首先看的是进程的属主, 检查文件的属主和进程的属主是否为同一个, 如果是应用属主权限否则就是其他用户权限.简单的说, 只要用户有权限那么进程就可以访问(有权限)</p><p>这一点就给我们的系统带来了风险, 这样的设计已经违反了操作系统中安全法则中的最根本的: <strong>最小权限法则</strong> 也就是说一个进程在运行的时候, 如果一共仅需要访问10个文件, 那么最多他所获得的权限就是这10个文件的权限.  就好像说现在的沙箱, 即便进程脱离了我们的控制, 他所能够达到的范围就是这个沙箱的范围.这就没问题了, 但是难度就在于, 我们怎么根据不同的进程来创建不同的沙箱呢? 而且有可能由于SUID等原因, 进程也可能会从A沙箱切换到B沙箱, 因此这么一个安全机制是很麻烦复杂的.</p><p>但是并不是所有的程序都需要进行这样的监控.一般像<code>ls</code>这样的程序被劫持的可能性几乎没有, 但是如果是<code>httpd</code>就不一定了, 作为这种的服务进程应该是被重点关注的对象. 对于SELinux有两种种工作级别.</p><ul><li>strict 严格模式, 每一个进程都收到SELinux的监视</li><li>targeted: 仅有限个进程收到SELinux的控制</li></ul><p>我们 知道进程也就是进行文件的读写操作, 但是进程是可以操作进程的就像是这样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subject operate object</span><br><span class="line"> -subject: 进程</span><br><span class="line"> -object: 文件, 进程</span><br><span class="line"> -operate: 根据被操作对象的种类, 操作方式自然也是不同的.</span><br><span class="line">   文件: open, <span class="built_in">read</span>, write, close, <span class="built_in">chown</span>, <span class="built_in">chmod</span></span><br></pre></td></tr></table></figure><p>我们可以考虑给进程加上一个域(domain)的概念; 接着再给object一个类型的概念.</p><p>现在找一个非空的目录试一试, 使用<code>ls- Z</code> 会看到一列复杂的字串, 这个就是SELinux给文件分配的安全上下文环境, 也可以直接就说是文件的一个标签.同样使用<code>ps Z</code>也可以看到进程的标签.</p><p>被冒号分割实际上一共有5项但只有前三个比较重要, 所以就先忽略最后面的两个吧.</p><p>一个安全标签的基本组成是这样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user:role:<span class="built_in">type</span>:...(omitted)</span><br><span class="line">这里的user不是在说Linux的系统用户呢, 是指SELinux的user</span><br></pre></td></tr></table></figure><p>所以简单的说, SELinux的工作原理就是基于沙箱, 尽管你有权限访问该用户权限下的所有的文件, 但是你们的标签不符, 因此就会直接拒绝访问.对于进程而言, 第三个type就是进程的域.</p><p>那么类型和域是怎么进行匹配的呢?那些类型和域又存在兼容呢?</p><p>这些都依靠SELinux的规则库, SELinux事先有一些生成的规则, 你也可以进行规则的自定义.再说这个之前, 还是先谈一下SELinux的验证过程:</p><blockquote><p>当一个进程要去访问一个文件的时候会先开始进行属主的检查, 如果属主都没有权限访问就直接拒绝了, 接着开始进行规则集的匹配, 尝试进行类型和域的匹配. 匹配时还是会针对每一个操作进行权限检查(可以类比数据库) 如果该操作有匹配, 则可以进行 否则直接拒绝, 并进行日志记录.</p><p>还有一条, 如果没有规则记录, 那么不论什么情况直接拒绝.</p></blockquote><p>那么就直接来看SELinux的配置吧 主要有这些设定: SELinux是否启用 给文件重新就打标签, 设定某些布尔型特性.</p><p><strong>SELinux的启用和关闭</strong></p><p>这个之前就提到过了, 在&#x2F;etc&#x2F;selinux下的config中, 可以配置三种状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SELINUX= can take one of these three values:</span></span><br><span class="line"><span class="comment">#     enforcing - SELinux security policy is enforced.</span></span><br><span class="line"><span class="comment">#     permissive - SELinux prints warnings instead of enforcing.</span></span><br><span class="line"><span class="comment">#     disabled - No SELinux policy is loaded.</span></span><br></pre></td></tr></table></figure><ul><li>enforcing; 强制, 每一个受限的进程都必然受限</li><li>permissive: 启用, 每一个受限的进程违规操作都不会被禁, 但会被记录于审计日志</li><li>disabled: 关闭</li></ul><p>只要从disabled到其他任意的状态, 都需要进行重新启动系统(因为要进行重新标签)</p><p>相关的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ getenforce <span class="comment"># 获取SELinux的状态</span></span><br><span class="line">[root@WWW ~]$ setenforce <span class="comment"># 设置SELinux的状态 0 | 1</span></span><br></pre></td></tr></table></figure><p>这样设定的方法只有当时有效, 重启后会重新变成配置文件中的状态. 另外每次进行配置文件的修改都只有重启系统后才会生效.</p><p><strong>安全上下文的修改</strong></p><p>现在就将注意点聚焦到之前的<strong>类型</strong>吧. 一般是要到的情况也只是修改这个文件的类型. 相关的命令就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">chcon</span> <span class="comment"># 就是change context的意思</span></span><br><span class="line"><span class="comment">#       chcon [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...</span></span><br></pre></td></tr></table></figure><p>那么修改这个类型有什么用处呢 ?</p><p>我们直接来看一个完整的实例就知道了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW html]<span class="comment"># ps auxZ | grep httpd</span></span><br><span class="line">system_u:system_r:httpd_t:s0    root      2440  0.0  0.1 228204  5104 ?        Ss   03:38   0:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">system_u:system_r:httpd_t:s0    apache    2441  0.0  0.0 228340  3744 ?        S    03:38   0:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">[root@WWW html]<span class="comment"># ll -Z</span></span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 .</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 ..</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 index.html</span><br><span class="line"><span class="comment"># 显然这是个httpd的子类型</span></span><br><span class="line">[root@WWW html]<span class="comment"># ll -Z ~/.bashrc</span></span><br><span class="line">-rw-r--r--. root root system_u:object_r:admin_home_t:s0 /root/.bashrc</span><br><span class="line"><span class="comment"># root用户的家目录内是这样的</span></span><br></pre></td></tr></table></figure><p>现在直接访问的样子是这样的:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/selinux1.png" alt="selinux1"></p><p>好, 一切正常, 那么现在将他改成root家目录下的类型:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW html]<span class="comment"># chcon -t admin_home_t index.html</span></span><br></pre></td></tr></table></figure><p>刷新页面!</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/selinux2.png" alt="selinux2"></p><p>出现了403! httpd进程没有访问index.html的权限了.</p><blockquote><p>如果你的页面没有发生变化, 就检查一下SELinux的开启状态(getenforce), 并且注意, 你的SELinux的状态必须是1才行.</p></blockquote><p>把他再改回去:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW html]<span class="comment"># chcon -t httpd_sys_content_t index.html </span></span><br></pre></td></tr></table></figure><p>就可以访问了.</p><p>如果需要递归的进行打标, 就加上<code>-R</code>参数就行了. </p><p>如果要还原文件的默认标签就使用: <code>restorecon</code> SELinux为一些文件都存了默认的标签值, 因此可以很快的进行回复. 同样, 递归的回复的话 就使用<code>-R/-r</code>就行了</p><p>接着是布尔型规则的设定, 他的设定和获取就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ getsebool [-a] [boolean]</span><br><span class="line"><span class="comment"># e.g:</span></span><br><span class="line">[root@WWW html]<span class="comment"># getsebool tftp_home_dir</span></span><br><span class="line">tftp_home_dir --&gt; off</span><br><span class="line"><span class="comment"># 要查看所有的boolean值就直接加上-a就行了</span></span><br><span class="line">setsebool [ -PNV ] boolean value | bool1=val1 bool2=val2 ... <span class="comment"># 支持多布尔值同时设定</span></span><br><span class="line"><span class="comment"># P 写入磁盘</span></span><br><span class="line"><span class="comment"># N 仅写入磁盘, 不让内核重载(话说我觉得这个选项没啥用啊..)</span></span><br><span class="line">[root@WWW html]<span class="comment"># setsebool tftp_home_dir on # 也可使用 1 或者 true</span></span><br><span class="line">[root@WWW html]<span class="comment"># getsebool tftp_home_dir</span></span><br><span class="line">tftp_home_dir --&gt; on</span><br><span class="line"><span class="comment"># 如果要永久加上就加上 -P 选项就行了 会比较卡,因为会在策略库中遍历,找到之后还要转成二进制再写入进去</span></span><br></pre></td></tr></table></figure><p>SELinux的日志文件都在<code>/var/log/audit</code>里面.</p><p>由于现在使用SELuinx的场景越来越小了, 所以我也就不在展开了吧, 更多的东西就这里吧:</p><p><a href="http://linux.vbird.org/linux_basic/0440processcontrol.php#selinux">鸟哥!!</a></p><p><strong>更新 17.10.05:</strong></p><h2 id="nsswitch"><a href="#nsswitch" class="headerlink" title="nsswitch"></a>nsswitch</h2><p>除了上面说过的框架级别的认证服务PAM, 现在再介绍一个框架级别的服务, 即<strong>nsswitch</strong> 即网络服务交换. 这个服务主要负责进行名称解析 ( name:id )</p><p> 和PAM一样, 或者说和所有框架级别的服务一样, 当我们需要进行解析的时候, 我们知道有很多种介质, 例如文件解析, MySQL数据库解析, LDAP解析, DNS解析等等. 如果想要支持这些解析, 那么就需要程序员在自己的程序中内置这些解析介质的驱动. 这显然并不好, 所以为了提供一个大家都能够进行解析的平台, 就这样出现了这样的一个通用层, 中间层. 也就是这个通用框架 – nsswitch. 但是我不一定会使用到所有的解析介质. 因此, nsswitch提供一个配置文件来指明解析顺序, 方式. 这样就会<strong>通用且灵活</strong>. 这种概念在整个计算机科学中各个地方都有体现.</p><p>关于nsswitch服务的模块在<code>/usr/lib64/</code>下可以找到, 我们来看一眼:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW lib64]<span class="comment"># ls libnss*</span></span><br><span class="line">libnss3.so             libnss_db-2.17.so  libnss_dns-2.17.so    libnss_files.so.2       libnss_mymachines.so.2  libnss_nis.so     libnss_winbind.so</span><br><span class="line">libnssckbi.so          libnssdbm3.chk     libnss_dns.so         libnss_hesiod-2.17.so   libnss_nis-2.17.so      libnss_nis.so.2   libnss_winbind.so.2</span><br><span class="line">libnss_compat-2.17.so  libnssdbm3.so      libnss_dns.so.2       libnss_hesiod.so        libnss_nisplus-2.17.so  libnsspem.so      libnss_wins.so</span><br><span class="line">libnss_compat.so       libnss_db.so       libnss_files-2.17.so  libnss_hesiod.so.2      libnss_nisplus.so       libnsssysinit.so  libnss_wins.so.2</span><br><span class="line">libnss_compat.so.2     libnss_db.so.2     libnss_files.so       libnss_myhostname.so.2  libnss_nisplus.so.2     libnssutil3.so</span><br></pre></td></tr></table></figure><p>其中有dns, nis, nisplus, wins, winbind等等等..</p><p>直接切进nsswitch的配置文件吧, 一个<strong>条目</strong>占一行: 意思也很好懂, 就是什么的解析使用什么方式, 按照优先级(从左到右)来尝试.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hosts:      files dns myhostname</span><br><span class="line">ethers:     files</span><br><span class="line">netmasks:   files</span><br><span class="line">networks:   files</span><br><span class="line">protocols:  files</span><br><span class="line">rpc:        files</span><br></pre></td></tr></table></figure><p>这里我们可以把这个和数据库做类比, 把左边的部分当做数据库名字, 右边的当做键. 所以, 尽管键都是files, 但他们对应的文件是不一样的, 因为数据库不同.</p><p>其中有个命令可以来获得对应数据库的某个特定键的值, 例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># getent passwd root</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">[root@WWW ~]<span class="comment"># getent services http</span></span><br><span class="line">http                  80/tcp www www-http</span><br><span class="line">[root@WWW ~]<span class="comment"># getent services ftp</span></span><br><span class="line">ftp                   21/tcp</span><br></pre></td></tr></table></figure><p>如果不加上特定的键, 就会将整个数据库的值输出. getent的意味: get entry</p><p>当然, 找不到是有可能的. 那么找不到怎么办呢, 当然是返回了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每种存储中查找的几种状态: STATUS =&gt; success | notfound | unavail | tryagain</span><br><span class="line">对应于每种状态所采取的行为: ACTION =&gt; <span class="built_in">return</span> | <span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>这样的一种应用是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hosts file nis [NOTFOUND=<span class="built_in">return</span>] dns</span><br></pre></td></tr></table></figure><p>意思是说, 只要nis解析服务可用, 如果没有找到就不去找dns服务了, 而nis挂掉了, 那么就直接去找dns(因为此时nis的返回应该是unavail)</p><p>关于nsswitch就是这样吧, 其实没什么</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
            <tag> SELinux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核管理和编译初步</title>
      <link href="/2017/07/16/Linux%E7%9A%84%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86%E5%92%8C%E7%BC%96%E8%AF%91%E5%88%9D%E6%AD%A5/"/>
      <url>/2017/07/16/Linux%E7%9A%84%E5%86%85%E6%A0%B8%E7%AE%A1%E7%90%86%E5%92%8C%E7%BC%96%E8%AF%91%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>现在让我们一起来看看这只企鹅到底是个什么吧</p><span id="more"></span><h2 id="内核管理初步"><a href="#内核管理初步" class="headerlink" title="内核管理初步"></a>内核管理初步</h2><p>之前的Linux系统基本原理我们说过, Linux是单内核体系设计, 但它充分借鉴了微内核体系的优点, 引入了模块化的机制. </p><p>内核的组成部分有这些:</p><ul><li>kernel: 内核核心, 一般为bzImage的映像文件, 放在&#x2F;boot下, 名称为vmlinuz;</li><li>kernel object: 内核对象, 一般放置与&#x2F;lib&#x2F;mudule&#x2F;VERSION-RELEASE&#x2F;下</li></ul><p>对于内核对象我们有三种选择:</p><ul><li><p><code>[ ]</code>: 不选择此功能</p></li><li><p><code>[M]</code>: 编译成模块</p></li><li><p><code>[*]</code>: 编译进内核核心</p></li></ul><p>要注意的是, 不是所有的内核代码都可以抽成模块的, 正常情况下, 内核核心自己有自己的框架结构, 压缩之后大小应该为1M左右, 而CentOS默认的内核已经有4M了, 这就说明已经将一些功能编译进了内核. 同样有些东西是不支持的模块化的, 对于这些功能来说就只有两种结果: 编译进内核和不编译进去.</p><p>为了内核能够在启动时加载真正的根文件系统我们 还需要一些辅助的文件: ramdisk. (分成两种格式: initrd, initramfs) 这些是我们站在静态的角度看到的情况.</p><p>而在系统运行起来的时候, 我们正在运行的内核是已经被加载到内存中的, 相当于是才能够磁盘上的文件复制的一个副本. 此时如果查看版本,就使用那个<code>uname</code>或者直接<code>cat /proc/version</code>就行.这个地方了解的仅仅是内核核心, 而我们更关注的应该是内核的模块:</p><p> 之前说过一个命令可以列出已经装载使用哪些模块, 这个就是<code>lsmod</code>指令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ lsmod</span><br><span class="line">Module                  Size  Used by</span><br><span class="line">autofs4                26888  3 </span><br><span class="line">sunrpc                243758  1 </span><br><span class="line">bnx2fc                120526  0 </span><br><span class="line">cnic                   53443  1 bnx2fc</span><br><span class="line">uio                    10974  1 cnic</span><br><span class="line">fcoe                   20748  0 </span><br><span class="line">libfcoe                39661  2 bnx2fc,fcoe</span><br><span class="line">libfc                 105924  3 bnx2fc,fcoe,libfcoe</span><br><span class="line">scsi_transport_fc      52241  3 bnx2fc,fcoe,libfc</span><br><span class="line">scsi_tgt               12173  1 scsi_transport_fc</span><br><span class="line">8021q                  23575  0 </span><br><span class="line">garp                    7344  1 8021q</span><br><span class="line">stp                     2173  1 garp</span><br><span class="line">llc                     5642  2 garp,stp</span><br><span class="line">ipt_REJECT              2383  2 </span><br><span class="line">nf_conntrack_ipv4       9506  2 </span><br><span class="line">nf_defrag_ipv4          1483  1 nf_conntrack_ipv4</span><br><span class="line">iptable_filter          2793  1 </span><br><span class="line">ip_tables              17831  1 iptable_filter</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>这个命令其实读取的是<code>/proc/modules</code>这个文件的内容. 这不过可读性太差了所以对结果进行了封装.</p><p>单独查看某一个模块的详细信息使用<code>modinfo</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ modinfo ext4</span><br><span class="line">filename:       /lib/modules/2.6.32-220.el6.x86_64/kernel/fs/ext4/ext4.ko</span><br><span class="line">license:        GPL</span><br><span class="line">description:    Fourth Extended Filesystem</span><br><span class="line">author:         Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts<span class="string">&#x27;o and others</span></span><br><span class="line"><span class="string">srcversion:     A80608676B83D55514B450E</span></span><br><span class="line"><span class="string">depends:        mbcache,jbd2</span></span><br><span class="line"><span class="string">vermagic:       2.6.32-220.el6.x86_64 SMP mod_unload modversions </span></span><br></pre></td></tr></table></figure><p>modinfo除了查看已经加载使用的内核外, 也支持查看还没有使用的内核(当然前提是你已经安装了).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ lsmod | grep xfs</span><br><span class="line">[root@WWW ~]$ modinfo xfs</span><br><span class="line">filename:       /lib/modules/2.6.32-220.el6.x86_64/kernel/fs/xfs/xfs.ko</span><br><span class="line">license:        GPL</span><br><span class="line">description:    SGI XFS with ACLs, security attributes, large block/inode numbers, no debug enabled</span><br><span class="line">author:         Silicon Graphics, Inc.</span><br><span class="line">srcversion:     004A543AFBA52F9C2C6AF51</span><br><span class="line">depends:        exportfs</span><br><span class="line">vermagic:       2.6.32-220.el6.x86_64 SMP mod_unload modversions</span><br><span class="line"><span class="comment"># 一般我们不需要这么多信息, 更多其实是路径比较重要</span></span><br><span class="line"><span class="comment"># 所以可以加上 -n 参数, 让modinfo仅输出路径</span></span><br><span class="line">[root@WWW ~]$ modinfo -n xfs</span><br><span class="line">/lib/modules/2.6.32-220.el6.x86_64/kernel/fs/xfs/xfs.ko</span><br></pre></td></tr></table></figure><p>之所以能查到, 并且速度这么快显然不是访问的磁盘, 其实modinfo是访问的数据库.</p><p>我们说过Linux是支持模块的动态改变的, 所以我们卸载和加载.<strong>Warning:: 一定不要把正在使用的模块或者一些基础模块给卸载了否则会出大麻烦的.</strong></p><p>支持的命令是: <code>modprobe</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ modprobe [ modulename ] [ module parameters... ] <span class="comment"># 加载模块, 还可以带上参数</span></span><br><span class="line">[root@WWW ~]$ modprobe [ -r ] [ -n ] [ modulename... ]</span><br><span class="line">-r remove 移除一个模块</span><br><span class="line">-n --dry-run 测试运行</span><br><span class="line">-q quiet</span><br><span class="line">-v verbose</span><br></pre></td></tr></table></figure><p>默认不加参数的时候, 会自动从<code>/etc/modprobe.conf</code>读取获得.先来做个实验:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ lsmod | grep xfs</span><br><span class="line">[root@localhost ~]$ modprobe -v xfs</span><br><span class="line">insmod /lib/modules/2.6.32-220.el6.x86_64/kernel/fs/exportfs/exportfs.ko </span><br><span class="line">insmod /lib/modules/2.6.32-220.el6.x86_64/kernel/fs/xfs/xfs.ko </span><br><span class="line">[root@localhost ~]$ lsmod | grep xfs</span><br><span class="line">xfs                  1042093  0 </span><br><span class="line">exportfs                4236  1 xfs</span><br><span class="line">[root@localhost ~]$ modprobe -rv xfs</span><br><span class="line">rmmod /lib/modules/2.6.32-220.el6.x86_64/kernel/fs/xfs/xfs.ko</span><br><span class="line">rmmod /lib/modules/2.6.32-220.el6.x86_64/kernel/fs/exportfs/exportfs.ko</span><br><span class="line">[root@localhost ~]$ lsmod | grep xfs</span><br></pre></td></tr></table></figure><p>很容易吧.</p><p>我们说过在模块之间是存在依赖关系的, 这些都被存在modules.dep里面, 但是我们几乎不会使用到他, 更多的是使用的已经编译之后的二进制文件 – <code>modules.dep.bin</code>. 这个文件损坏了也没关系, 会有工具来帮我们生成回来.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost 2.6.32-220.el6.x86_64]$ <span class="built_in">ls</span> -l</span><br><span class="line">...(omitted)</span><br><span class="line">-rw-r--r--.  1 root root 191785 Jul 11 17:08 modules.dep</span><br><span class="line">-rw-r--r--.  1 root root 280509 Jul 11 17:08 modules.dep.bin</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p><code>depmod</code> 这个命令不仅可以帮我们生成module.dep还可以生成我们在说grub中见到的<code>System.map-2.6.32-220.el6.x86_64</code>这样的文件. 说的标准点, depmod是内核模块依赖关系文件及系统信息映射文件的生成工具.在大多数情况下, 我们都无需手动调用.</p><p>不知道你有没有注意到, 在上面进行modprobe的试验演示的时候, 分别出现了<code>insmod</code>和<code>rmmod</code>.</p><p>这个其实才是真正的加载模块和卸载模块的命令, 不同的地方在于, 这两个命令仅仅在乎加载和卸载, 而不在意依赖关系, 这些命令的关系就有点类似是yum&#x2F;apt和rpm&#x2F;dpkg的关系. 不仅如此, 你也注意到了吧, 在执行insmod和rmmod的时候 后面跟上的参数是完整的绝对路径文件名. 其实也只有加载的时候麻烦点. 卸载时可以直接写模块名, 但是依然的, 不能解决依赖问题.</p><p>&#x2F;proc目录是内核的状态映射输出, 内核有很多状态信息和可设置的参数, 这些就通过这么一个伪文件系统.有关&#x2F;proc的信息在<a href="https://yaoxuannn.com/2017/07/02/Linux%E7%B3%BB%E7%BB%9F-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Linux系统-服务管理学习笔记</a>中提到了一些. </p><p>内核的参数分成两种: 只读的和可写的. 只读的也就是那些输出的状态信息, 而可写的就是提供了设置参数, 来实现对内核某功能或特性的配置.</p><p>一个控制的重要命令就是<code>sysctl</code>. 可用来查看和设定&#x2F;proc下的诸多参数(内核参数) 我们不能通过直接修改文件的方式来进行修改, 但是还可以通过<code>echo</code>重定向来修改大部分参数的值.</p><p>当我们想要进行某个属性修改的时候, 就: <code>sysctl -w path.to.parameter</code> 或者 <code>echo &quot;VALUE&quot; &gt; path/to/parameter</code> 在使用<code>sysctl -w</code> 路径的开头就直接是<code>/proc/sys/</code>了.</p><p> 还是举个例子吧.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">uname</span> -n</span><br><span class="line">WWW</span><br><span class="line">[root@WWW ~]$ <span class="built_in">echo</span> <span class="string">&quot;TestHost&quot;</span> &gt; /proc/sys/kernel/hostname</span><br><span class="line">[root@WWW ~]$ hostname</span><br><span class="line">TestHost</span><br><span class="line">[root@WWW ~]$ sysctl -w kernel.hostname=Test</span><br><span class="line">kernel.hostname = Test</span><br><span class="line">[root@WWW ~]$ hostname</span><br><span class="line">Test</span><br><span class="line">[root@WWW ~]$ sysctl kernel.hostname <span class="comment"># 直接加上Key就可以查看对应的Value了</span></span><br></pre></td></tr></table></figure><p>那么现在我想知道一共有哪些可以配置的选项怎么办?直接使用<code>sysctl -a</code>就行 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ sysctl -a</span><br><span class="line">kernel.printk_ratelimit_burst = 10</span><br><span class="line">...</span><br><span class="line">kernel.hung_task_timeout_secs = 120</span><br><span class="line">kernel.keys.maxbytes = 20000</span><br><span class="line">...</span><br><span class="line">kernel.shmmni = 4096</span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line">kernel.msgmni = 1985</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line">kernel.sem = 2503200032128</span><br><span class="line">(....)</span><br><span class="line">vm.hugepages_treat_as_movable = 0</span><br><span class="line">vm.nr_overcommit_hugepages = 0</span><br><span class="line">vm.lowmem_reserve_ratio = 25625632</span><br><span class="line">vm.drop_caches = 0</span><br><span class="line">(....)</span><br><span class="line">fs.inode-nr = 2735531</span><br><span class="line">fs.inode-state = 273553100000</span><br><span class="line">fs.file-nr = 928098253</span><br><span class="line">fs.file-max = 98253</span><br><span class="line">(....)</span><br><span class="line">fs.suid_dumpable = 0</span><br><span class="line">fs.binfmt_misc.status = enabled</span><br><span class="line">fs.quota.reads = 0</span><br><span class="line">fs.quota.writes = 0</span><br><span class="line">(...)</span><br><span class="line">dev.raid.speed_limit_max = 200000</span><br><span class="line">dev.hpet.max-user-freq = 64</span><br><span class="line">dev.mac_hid.mouse_button_emulation = 0</span><br><span class="line">(...)</span><br><span class="line">dev.cdrom.autoeject = 0</span><br><span class="line">dev.cdrom.debug = 0</span><br><span class="line">dev.cdrom.lock = 1</span><br><span class="line">dev.cdrom.check_media = 0</span><br><span class="line">net.netfilter.nf_log.0 = NONE</span><br><span class="line">(...)</span><br><span class="line">net.netfilter.nf_conntrack_max = 31900</span><br><span class="line">net.netfilter.nf_conntrack_log_invalid = 0</span><br><span class="line">net.netfilter.nf_conntrack_expect_max = 128</span><br><span class="line">(....)</span><br><span class="line">net.core.rps_sock_flow_entries = 0</span><br><span class="line">net.core.netdev_budget = 300</span><br><span class="line">net.core.warnings = 1</span><br><span class="line">net.ipv4.route.gc_thresh = 32768</span><br><span class="line">net.ipv4.route.max_size = 524288</span><br><span class="line">(....)</span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line">net.ipv4.xfrm4_gc_thresh = 262144</span><br><span class="line">net.ipv4.ipfrag_high_thresh = 262144</span><br><span class="line">(....)</span><br><span class="line">net.ipv4.icmp_ratelimit = 1000</span><br><span class="line">net.ipv4.icmp_ratemask = 6168</span><br><span class="line">net.ipv6.neigh.default.mcast_solicit = 3</span><br><span class="line">net.ipv6.neigh.default.ucast_solicit = 3</span><br><span class="line">(....)</span><br><span class="line">net.ipv6.neigh.lo.mcast_solicit = 3</span><br><span class="line">net.ipv6.neigh.lo.ucast_solicit = 3</span><br><span class="line">net.ipv6.neigh.lo.app_solicit = 0</span><br><span class="line">(....)</span><br><span class="line">net.ipv6.bindv6only = 0</span><br><span class="line">net.ipv6.ip6frag_secret_interval = 600</span><br><span class="line">net.ipv6.mld_max_msf = 64</span><br><span class="line">net.nf_conntrack_max = 31900</span><br><span class="line">net.unix.max_dgram_qlen = 10</span><br><span class="line">abi.vsyscall32 = 1</span><br><span class="line">crypto.fips_enabled = 0</span><br><span class="line">(....)</span><br><span class="line">sunrpc.min_resvport = 665</span><br><span class="line">sunrpc.max_resvport = 1023</span><br><span class="line">sunrpc.tcp_fin_timeout = 15</span><br></pre></td></tr></table></figure><p>好多, 我们直接wc来看一下吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ sysctl -a | <span class="built_in">wc</span> -l</span><br><span class="line">696</span><br></pre></td></tr></table></figure><p><code>sysctl</code>有个配置文件, 就是<code>/etc/sysctl.conf</code> 通过这个配置文件也可来进行内核参数的修改. 说道这里就要提一句了, 用之前的方式(sysctl -w和echo都是进行的当前修改, 一旦重新启动就会sysctl<strong>重新读取配置文件</strong>, 之前所作的修改就没有了), 那么使得修改持久化的方式显然易见: 修改配置文件.</p><p>直接进入配置文件修改值之后要主带调用一次<code>sysctl -p</code>, 才可以读取 .(这个地方可以联想bash的配置, 修改后不会立即向生效而是要调用一次source&#x2F;.)</p><p>e.g: 配置内核中的路由转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 路由转发的功能就是net.ipv4.ip_forward这个Key, 现在编辑sysctl.conf来把它开启吧</span></span><br><span class="line">[root@WWW ~]$ <span class="built_in">head</span> -3 /etc/sysctl.conf</span><br><span class="line"><span class="comment"># Kernel sysctl configuration file for Red Hat Linux</span></span><br><span class="line"><span class="comment"># Controls IP packet forwarding</span></span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line"><span class="comment"># vim编辑保存之后</span></span><br><span class="line">[root@WWW ~]$ <span class="built_in">head</span> -3 /etc/sysctl.conf</span><br><span class="line"><span class="comment"># Kernel sysctl configuration file for Red Hat Linux</span></span><br><span class="line"><span class="comment"># Controls IP packet forwarding</span></span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">[root@WWW ~]$ sysctl net.ipv4.ip_forward</span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line"><span class="comment"># 没有变化?重新读取一次配置文件!</span></span><br><span class="line">[root@WWW ~]$ sysctl -p</span><br><span class="line">net.ipv4.ip_forward = 1 <span class="comment"># 值得到了更新!</span></span><br><span class="line">[root@WWW ~]$ sysctl net.ipv4.ip_forward</span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure><p>再举一个例子咯, 我们都知道Linux使用内存来吃充当缓存和缓冲, 这个也是可以关掉的.</p><p>位置就在<code>vm.drop_cache</code>这个地方, 将他的值设置成1就行了. 接着在使用<code>free</code>就会发现<code>buffer</code>的值已经是<code>0</code>了.</p><p>先前介绍过了&#x2F;proc&#x2F;*, 现在再让我们来看看&#x2F;sys这个虚拟目录.</p><h2 id="x2F-sys"><a href="#x2F-sys" class="headerlink" title="&#x2F;sys"></a>&#x2F;sys</h2><p>不同于&#x2F;proc, &#x2F;sys用来输出硬件相关参数, 包括生产厂商信息, ROM大小, 序列号等等… 也有内核对硬件特性的设定信息, 有些参数可以进行修改, 用于调整硬件的工作特性.  </p><p>现在我们先说点东西: 我们都知道&#x2F;dev是用来输出设备文件的对吗, 那么我们当前主机是怎么知道怎么创建那些设备文件呢? 内核启动时, 从各个硬件的IO端口 以及这些硬件自己的电压输出的信息就能知道. 这是内核, 但是内核是不可能创建设备文件, 他<strong>根本就不需要</strong>这些东西哇, 内核读取硬件可以直接访问, 只有用户空间需要借助这些设备文件, 仅此而已. 这意味着内核根本不会创建这些设备文件.在原先的2.4版的内核上, 这个&#x2F;dev&#x2F;内的设备文件是实现存在的, 无论你是否使用. 这个版本的&#x2F;dev下有<strong>近两万个文件</strong>. 但实际上我们使用到的, 也不过区区几十个. 所以后来内核就使用一种更精巧的方式: <strong>使用&#x2F;sys目录</strong>. </p><p>在2.6版本的内核上 , 我们的设备文件是这样创建的: 内核启动时探测硬件设备, 探测完之后该启动的启动, 当用户空间需要调用某个硬件的时候, 就会触发一个内建机制通知内核探测一遍,并且将探测完的结果输出到sys目录(这个时候用户空间 已经是存在的, 在内核第一次探测硬件的时候用户空间并没有启动输出也不知道往哪里输出) 这样当我们想要创建设备文件的时候, 就会通过udev这样的命令去读取sys内的内容来按需创建&#x2F;dev&#x2F;*.</p><p>通过sys下的输出信息来动态的对各设备创建所需要的设备文件, udev是运行在用户空间的程序, 所以也不会直接和内核打交道.他也不能自己产生硬件, 内核扫描一遍之后就停止了, 所以只能再次探测一遍.</p><p>udev在进行设备文件的时候, 创建的设备文件实际上是这个设备的驱动, 而驱动的名字是根据创建规则来新建的.这些规则文件一般在: <code>/etc/udev/rules.d &amp;&amp; /usr/lib/udev/rules.d</code> (但是我找了半天试了Ubuntu&#x2F;CentOS&#x2F;VMWare&amp;VM Box 都没有发现类似重命名网卡规则的规则文件, 以后再研究.)</p><p>那么现在就说一下ramdisk的制作, 在说grub的时候我们就说过了这个东西. 使用的指令依然是二次封装过后的.但他很好用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ mkinitrd /boot/initramfs-$(<span class="built_in">uname</span> -r).img $(<span class="built_in">uname</span> -r)</span><br></pre></td></tr></table></figure><p>如果你的&#x2F;boot下已经有同名的文件了, 那么就会收到一个提示, 和一个广播:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Will not override existing initramfs (/boot/initramfs-3.10.0-514.el7.x86_64.img) without --force</span><br><span class="line"></span><br><span class="line">Broadcast message from systemd-journald@localhost.localdomain (Thu 2017-07-13 13:41:11 EDT):</span><br><span class="line">dracut[2420]: Will not override existing initramfs (/boot/initramfs-3.10.0-514.el7.x86_64.img) without --force</span><br></pre></td></tr></table></figure><p>这个<code>mkinitrd</code> 封装的操作就是使用了<code>dracut</code>命令.</p><p>这个命令有很多参数但是同样, 我们并不会用到他们 可以直接将<code>mklinitrd</code>换成<code>dracut</code> 基本上效果是一样的.必要的时候也就是使用了with-module这样的功能, 不过真的不多.</p><p>现在我们来仔细看一下initramfs这个img的真实内容吧!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ file initramfs-3.10.0-514.el7.x86_64.img </span><br><span class="line">initramfs-3.10.0-514.el7.x86_64.img: ASCII cpio archive (SVR4 with no CRC)</span><br></pre></td></tr></table></figure><p>是一个cpio的文档, 那么现在就把它解开来看一下:</p><blockquote><p>CPIO的使用:</p><p>CPIO是一个近乎全能的备份工具., 因为他可以备份所有的文件, 包括这个&#x2F;dev下的任何设备文件.使用起来有三种模式, 分别是压缩(备份), 还原, 查看. 下面简单的介绍一下:</p><p>**压缩:<code>cpio -ovcB &gt; [file|device]</code> ** </p><p><strong>还原:<code>cpio -ivcdu &lt; [file|device] </code></strong> </p><p><strong>查看:<code>cpio -ivct &lt; [file|device] </code></strong> </p><p>参数太多记不住吗? 其实这些组合都已经是套装了. 可以直接使用…不过还是要了解下各个参数是什么意思吧. 首先要明确的是使用cpio必须出现这四个参数中的其中一个: <code>o i p t </code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-o 将数据 cOpy 到文件或者硬盘上</span><br><span class="line">-i 将数据自文件或设备复制到系统当中</span><br><span class="line">-p copy-pass模式</span><br><span class="line">-t 配合-i参数, 查看新建的文件或设备内容</span><br><span class="line">-c 使用较新的portable format方式存储</span><br><span class="line">-B 可以使得大文件的速度加快, 因为这个选项将block的大小512 -&gt; 5120</span><br><span class="line">-d 自动新建目录</span><br><span class="line">-u 使用较新的文件覆盖旧的</span><br><span class="line">-v verbose, 不用说了</span><br></pre></td></tr></table></figure></blockquote><p>使用CPIO来进行还原:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ cpio -ivcd &lt; initramfs-2.6.32-220.el6.x86_64.img</span><br><span class="line">...(omitted)</span><br><span class="line">[root@WWW ~]$ <span class="built_in">ls</span> -l</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 bin</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 cmdline</span><br><span class="line">drwxr-xr-x. 3 root root     4096 Jul 14 00:00 dev</span><br><span class="line">-rw-r--r--. 1 root root       19 Jul 14 00:00 dracut-004-256.el6</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 emergency</span><br><span class="line">drwxr-xr-x. 7 root root     4096 Jul 14 00:00 etc</span><br><span class="line">-rwxr-xr-x. 1 root root     8874 Jul 14 00:00 init</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 initqueue</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 initqueue-finished</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 initqueue-settled</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 initqueue-timeout</span><br><span class="line">-rw-r--r--. 1 root root 45508096 Jul 13 23:57 initramfs-2.6.32-220.el6.x86_64.img</span><br><span class="line">drwxr-xr-x. 7 root root     4096 Jul 14 00:00 lib</span><br><span class="line">drwxr-xr-x. 4 root root     4096 Jul 14 00:00 lib64</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 mount</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 pre-pivot</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 pre-trigger</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 pre-udev</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 proc</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 sbin</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 sys</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 sysroot</span><br><span class="line">drwxr-xr-x. 2 root root     4096 Jul 14 00:00 tmp</span><br><span class="line">drwxr-xr-x. 7 root root     4096 Jul 14 00:00 usr</span><br><span class="line">drwxr-xr-x. 4 root root     4096 Jul 14 00:00 var</span><br></pre></td></tr></table></figure><p>目录文件是否很熟悉呢?这些就是熟悉的根目录fs.在sbin里也都是最基本需要的程序.像lvm和raid的支持也在这里呀~这里面还有一个叫<code>switch_root</code> 这个就是在帮助我们做根切换的!</p><h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>编译内核的步骤分这么几步:</p><ul><li>准备开发环境</li><li>获取主机的硬件设备相关信息</li><li>获取到主机上系统功能的相关信息(要启用的文件系统等等)</li><li>获取内核源代码包</li></ul><p>一步一步的来说吧:</p><h3 id="准备开发环境"><a href="#准备开发环境" class="headerlink" title="准备开发环境"></a>准备开发环境</h3><p>在说yum的时候, 我们提到过包组的概念, 由一些专门负责系统开发的库, 就CentOS6而言, 有:</p><ul><li>Server Platform Development</li><li>Development tools</li></ul><h3 id="获取硬件信息"><a href="#获取硬件信息" class="headerlink" title="获取硬件信息"></a>获取硬件信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.获取CPU信息</span></span><br><span class="line">[root@WWW ~]$ <span class="built_in">cat</span> /proc/cpuinfo</span><br><span class="line">[root@WWW ~]$ lscpu</span><br><span class="line"><span class="comment"># 2. 获取PCI设备</span></span><br><span class="line">[root@WWW ~]$ lspci <span class="comment"># 查看PCI桥</span></span><br><span class="line">    -v verbose</span><br><span class="line">    -vv more verbose</span><br><span class="line">[root@WWW ~]$ lsusb <span class="comment"># 查看USB</span></span><br><span class="line">    -v verbose</span><br><span class="line">    -vv more verbose</span><br><span class="line">[root@WWW ~]$ lsblk <span class="comment"># 查看块设备</span></span><br></pre></td></tr></table></figure><p>有一个可以用来查看所有的硬件, 这个命令就是<code>hal-device</code> .</p><h3 id="获取系统信息"><a href="#获取系统信息" class="headerlink" title="获取系统信息"></a>获取系统信息</h3><p>&#x2F;boot&#x2F;下有叫做<code>config-VERSION</code>的文件, 这个就是一个系统信息的模板, 在这里也推荐使用模板, 当然模板也是有兼容性的. 也即是后面的版本号.怎么进行修改, 等到我们获取到内核源代码之后再说.</p><h3 id="获取内核源代码"><a href="#获取内核源代码" class="headerlink" title="获取内核源代码"></a>获取内核源代码</h3><p>内核的源码包的官方下载地址就是<code>kernel.org</code> , 在这上面直接Down想要的版本内核就行了, 注意如果使用wget下载, 需要跳过证书验证.</p><p>好了, 现在就可以开始编译内核了!</p><p>我们把内核的源码包进行解压, 解压到.&#x2F;usr&#x2F;src下, 接着就可以进去看一下了, 首先我们说过要加入配置对嘛, 所以: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">cp</span> -a /boot/config-2.6.32-220.el6.x86_64  .config</span><br></pre></td></tr></table></figure><p>接下来就是执行第一步, 开始进行配置(config), 刚刚说过了我们不能直接就拿来用还是要调用内核源码提供的接口进行配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ make menuconfig</span><br></pre></td></tr></table></figure><p>在执行这一步的时候, 会先尝试从当前目录寻找<code>.config</code>文件, 这个就是通过这个命令配置的产物, 如果没有找到, 会尝试从&#x2F;boot&#x2F;下找config-VERSION, 如果找到了就会加载它作为默认的配置. 如果还是没有, 就会根据当前系统的架构尝试从自己的<code>arch</code>下寻找相配的默认配置. 但现在我们把这个配置文件已经加载进来了.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/Kernel_config.png" alt="Kernel_config"></p><p>根据具体需求来进行配置之后就可以开始进行安装啦! 但是, 先别急着安装! 想一个问题先, 在我们安装时, 网络会断开 那么我们session断掉了, 整个安装进程也就直接结束了. 那岂不是就陷入了死循环了吗. 所以我们可以考虑使用screen这么一个工具. 他可以创建一个虚拟的屏幕, 使得任务只要虚拟机不关机, 就不会终止.</p><p>好了! 开始编译吧! 编译的时候可以根据自己机器的情况加上<code>-j</code>参数来加快速度.</p><blockquote><p>编译了两个多小时…大家注意啊..(当然也许和我的电脑配置有关…) 如果不是必要的话就不要加进去这么多功能啊…10G的硬盘, 光编译个内核就6个G了,我都没怎么选就进行make了, 所以说在进行上面的配置的时候要多花点时间来筛选啊.</p></blockquote><p>(编译到大半夜开始继续码字的我) 编译结束之后就可以开始安装了, 在执行常规的<code>make install</code>之前 要先将内核进行模块的安装.</p><p>模块安装以及系统安装(会自动写入GRUB引导文件)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ make modules_install</span><br><span class="line">[root@WWW ~]$ make install</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BootLoader-GRUB</title>
      <link href="/2017/07/14/BootLoader-GRUB/"/>
      <url>/2017/07/14/BootLoader-GRUB/</url>
      
        <content type="html"><![CDATA[<p>如果没有loader, 那么kernel根本没有办法被系统加载, 现在来说说grub吧, 当前Linux里最主流的boot loader.</p><span id="more"></span><h2 id="GRUB-old-version"><a href="#GRUB-old-version" class="headerlink" title="GRUB (old version)"></a>GRUB (old version)</h2><p>在CentOS5&#x2F;6系统启动流程中我们就已经提过了grub这个小东西. 全称叫<code>GRand Unified Bootloader</code>.</p><p>  从CentOS7开始, 使用了新版的grub, 也就是1.x版本, 这个被叫做grub2. 而原先的CentOS5&#x2F;6使用的就是grub 0.x版本 也就是所谓grub legacy. 并且这两者也已经出现了巨大的变化.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grub legacy:</span><br><span class="line">    stage1: mbr</span><br><span class="line">    stage1_5: mbr之后的扇区, 让stage1中的bootloader可以识别stage2所在分区的文件系统</span><br><span class="line">    stage2: 磁盘分区(/boot/grub/)</span><br></pre></td></tr></table></figure><p>这些在前文都已经提过了.</p><p>先从旧版的开始吧. :)</p><p>grub的配置文件就位于&#x2F;boot&#x2F;grub&#x2F;grub.conf, 在当前目录就有一个符号链接指向他, 这个先不说, 另外还有一个&#x2F;etc&#x2F;grub.conf也指向它. </p><p>尽管在前文曾经提到过, 但是现在我们再把这个grub的引导过程顺一遍: 首先在主板识别了硬盘并且通过INT_13中断(管他是什么, 反正能将第一扇区的内容export出去)来进行bootloader的读取之后, 此时bootloader已经可以读取主机上的硬盘设备了, 但此时仍然不能读取文件系统(软件组织的), 因此这个时候通过文件系统驱动的帮助, 就进入了stage2, stage2和内核等都放在一个基本的磁盘分区.接着主程序就开始读取配置文件了.</p><p>这里需要先明确grub的功用:</p><ul><li>提供菜单, 并提供交互接口<ul><li>e: 编辑模式, 用于编辑菜单</li><li>c: 命令模式, 交互式接口</li></ul></li><li>加载用户选择的内核或操作系统, 允许传递参数给内核, 可隐藏菜单</li><li>保护机制, 为编辑菜单, 启用内核进行认证</li><li>控制权移交功能(important)</li></ul><p>我们进入&#x2F;boot&#x2F;grub下看一看里面的关键文件:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/grub_stg.png" alt="grub_stg"></p><p>这里面的stage1文件就是我们说的, 用来进行跳转的.</p><p>*stage1_ 5文件包含了各种识别文件系统的代码，使得grub可以从文件系统中读取体积更大功能更复杂的stage2文件. stage1_ 5一般安装在MBR后、第一个分区前的那段空闲空间中，也就是MBR gap空间，它的作用是跳转到stage2的第一个扇区.</p><p>其实传统的grub在某些环境下是可以不用stage1_5文件就能正常运行的.</p><p>stage2的作用就是加载各种环境和加载内核 当跳转到stage2的第一个扇区后，该扇区的代码负责加载stage2剩余的内容. 需要说的一点是: stage2是存放在磁盘上的. 这点和后面我们要说的GRUB2有对应.</p><p>下面就来看一下grub的命令行接口吧:</p><p>进入grub菜单的方式就是在出现boot的界面的时候按下任意键就行了.</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/enter_grub.png" alt="enter_grub"></p><p>接着就会看到这样的菜单:</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/grub_menu.png" alt="grub_menu"></p><p>使用<code>help</code>就可以显示所有支持的命令, 还可以单独的进行<code>help [KEYWORD]</code> 来查看单个命令的使用方式</p><p>比如设置挂载根文件系统的命令<code>root</code>. 在后面加上设备路径, 把他当成根来挂载. (<strong>这里的根是指要被挂载成grub根的根哦!</strong>)</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/root_help.png" alt="root_help"></p><p>在仔细说说命令行的使用前, 让我们再来讨论一下 这个**&#x2F;boot**. 可以分区 也可以不分区而是根的一个目录, 这些都是可能的. 我们都知道,如果想要访问某个设备就要先将其挂载到我们的目录上, 有一个入口才行.所以第一种情况, boot在根分区上(一个分区), 那么就是一个目录文件. 所以在读取vmlinuz的时候, 我就需要先加载根文件系统才可以读取到也就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/boot/vmlinuz --- 这里的根是 根文件系统那个的根</span><br></pre></td></tr></table></figure><p>第二种情况 如果&#x2F;boot是一个不同于根的分区, 是挂载上去的. 那么这个时候访问路径就变成了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/vmlinuz --- 这里的根就变成了 boot对应的那个分区的文件系统的根</span><br></pre></td></tr></table></figure><p>我们知道这个时候, 是系统启动之前, 所以根是没有装载起来的, 但是现在要访问vmlinuz文件哇, 这个时候访问就是向第一种情况的那种. 此时如果grub想要从根访问&#x2F;boot, 一个要求就是根必须是基本的文件系统, 不能是那种复杂的逻辑卷. 这,就是为什么推荐将boot单独分区, 且是那种很简单的, 这样在根使用了一些叫高级复杂的文件系统架构时候也可以确保正常启动内核.</p><p>那么如何识别设备呢? 在进入菜单之后, 其实就可以看到一个默认的根:</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/dev.png" alt="dev"></p><p><code>hd0,0</code> 表示的就是 hard disk 第一块磁盘的第一个分区. 也就是说<code>hd磁盘编号,分区编号</code> </p><p>好, 让我们继续吧!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grub&gt; find FILENAME</span><br><span class="line"><span class="comment"># 这个寻找指令不是简单的输入文件名就好了哦,要指定具体的分区, 写出完整的路径</span></span><br><span class="line">grub&gt; find (hd0,0)/vmlinuz-2.6.32-220.el6.x86_64</span><br><span class="line">  (hd0,0)</span><br><span class="line"><span class="comment"># 通过这个可以快速的确定文件的存在性</span></span><br><span class="line"><span class="comment"># 但其实我也可以先指定根的所在, 这样就可以不同每一次都加上分区了</span></span><br><span class="line">grub&gt; root (hd0,0)</span><br><span class="line">grub&gt; find /vmlinuz-2.6.32-220.el6.x86_64</span><br><span class="line">  (hd0,0)</span><br></pre></td></tr></table></figure><p>接下来就是设置要加载的内核文件镜像以及ramdisk是什么, 使用<code>kernel</code>和<code>initrd</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grub&gt; kernel /vmlinuz-2.6.32-220.el6.x86_64</span><br><span class="line">grub&gt; initrd /initramfs-2.6.32-220.el6.x86_64.img</span><br></pre></td></tr></table></figure><p>这里一定要做到: <strong>版本完完全全匹配</strong></p><p>最后执行<code>boot</code>就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub&gt; boot</span><br></pre></td></tr></table></figure><p>我们还可以手动在加上一些参数, 比如: <code>selinux=0</code>, 以及开机等级什么的.</p><p>所以现在就会明白了: 当我们直接选择这个选项并且直接回车的时候…</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/boot_2.png" alt="boot_2"></p><p>其实执行的就是敲击<code>e</code>进入的编辑页面的这些:</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/boot_3.png" alt="boot_3"></p><p>列举一些常用选项: <strong>quiet</strong> 表示静默模式, 显示较少的信息, 也可以直接加上等级, 一种常见的就是加上1或者single, 进入单用户维护模式.</p><p>前面说过了 读取完配置文件就会有这么一个菜单, 这么个配置文件就决定这么个菜单的表现形式.位置也已经在上面说过了, 现在就先来看一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">cat</span> /etc/grub</span><br><span class="line"><span class="comment"># grub.conf generated by anaconda</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that you do not have to rerun grub after making changes to this file</span></span><br><span class="line"><span class="comment"># NOTICE:  You have a /boot partition.  This means that</span></span><br><span class="line"><span class="comment">#          all kernel and initrd paths are relative to /boot/, eg.</span></span><br><span class="line"><span class="comment">#          root (hd0,0)</span></span><br><span class="line"><span class="comment">#          kernel /vmlinuz-version ro root=/dev/mapper/vg_livecd-lv_root</span></span><br><span class="line"><span class="comment">#          initrd /initrd-[generic-]version.img</span></span><br><span class="line"><span class="comment">#boot=/dev/sda</span></span><br><span class="line">default=0 <span class="comment"># 哪一个是默认启动的菜单</span></span><br><span class="line"><span class="built_in">timeout</span>=5 <span class="comment"># 超时5秒</span></span><br><span class="line">splashimage=(hd0,0)/grub/splash.xpm.gz <span class="comment"># 默认的背景图片, 最大支持14位颜色深度(2^14)</span></span><br><span class="line">hiddenmenu <span class="comment"># 隐藏菜单</span></span><br><span class="line">title CentOS (2.6.32-220.el6.x86_64) <span class="comment"># 这个就是一开始看到的一级菜单的那个选项内容, 下面的缩进三只就是进去看到的二级菜单</span></span><br><span class="line">root (hd0,0)</span><br><span class="line">kernel /vmlinuz-2.6.32-220.el6.x86_64 ro root=/dev/mapper/vg_livecd-lv_root rd_NO_LUKS LANG=en_US.UTF-8 rd_LVM_LV=vg_livecd/lv_swap rd_NO_MD quiet rd_LVM_LV=vg_livecd/lv_root SYSFONT=latarcyrheb-sun16 rhgb crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM</span><br><span class="line">initrd /initramfs-2.6.32-220.el6.x86_64.img</span><br></pre></td></tr></table></figure><p>.我们还可以对菜单进行加密:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">default=0</span><br><span class="line"><span class="built_in">timeout</span>=5</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xpm.gz</span><br><span class="line">hiddenmenu</span><br><span class="line"><span class="comment"># 在这里可以插进来一条全局的配置, 菜单编辑认证(防编辑)</span></span><br><span class="line">password [--md5] STRING</span><br><span class="line">title CentOS (2.6.32-220.el6.x86_64)</span><br><span class="line">    password [--md5] STRING <span class="comment"># 启用选定的内核或操作系统的认证(防启动)</span></span><br></pre></td></tr></table></figure><p>这里放的密码串, 可以直接写明文, 但是这样很不安全, 因此更应该使用md5形式的摘要串, grub提供了这样的一个工具来帮我们生成: <code>grub-md5-crypt</code> 使用方法就是直接敲进去进入交互界面然后就键入要加密的密码串就可以的得到了.</p><p>现在在我折腾了之后看到的菜单, 不仅多了一条菜单而且还会发现这个时候下方的提示也变了 </p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/grub_%E6%94%B9.png" alt="grub_改"></p><p>使用p进入密码输入界面:</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/grub_password.png" alt="grub_password"></p><p>接着就会变成原来的那种, 由于我给第二个Linux系统加入了密码认证, 所以在直接Enter第二的时候, 会进入这样的页面:</p><p><img src="https://hexopic.s3-ap-northeast-1.amazonaws.com/boot_passwd%27.png" alt="boot_passwd&#39;"></p><p>如果输入错误就会直接回到GRUB的主页面, 正确当然就是直接进入系统啦</p><blockquote><p><strong>进入单用户模式</strong></p><p>说到这里, 进入单用户维护模式就变得非常简单了. </p><p>1). 编辑grub菜单(选定要编辑的title, 而后使用e命令)</p><p>2). 在选定的kernel后面加上: 1, s, S, single都行</p><p>3). 在kernel所在行, 键入<code>b</code>命令(boot)</p></blockquote><p><strong>grub的重新安装</strong></p><p> 什么时候才需要重装grub啊? 很多时候, 重新安装grub体现在很多问题的解决上. 所以当出现了一些系统无法启动的时候, 别急着重装系统! 先看看问题出在哪一个环节上, 有时候当问题出现在引导上, 修复一下也要不了多少时间而且还可以完美无损. 并且grub的重新安装还可以解决多系统在同一块硬盘上共存的问题.</p><p>重新安装一个最简单的方法就是使用<code>grub-install</code>命令 但是注意呀, 这里说的修复是指修复镜像和<code>ramdisk</code> 不包括<code>grub.conf</code> 的, 所以说如果你的<code>grub.conf</code> 损坏了, 是要进行手动的重写的.</p><p>具体的操作步骤:</p><p><a href="http://linux.vbird.org/linux_basic/0510osloader//0510osloader-centos5.php#grub_initrd">鸟哥的私房菜旧版</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
            <tag> bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS5和6的启动流程</title>
      <link href="/2017/07/12/Linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2017/07/12/Linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Linux(CentOS5&amp;6)的系统启动流程</p><span id="more"></span><h2 id="CentOS-5和6-的启动流程"><a href="#CentOS-5和6-的启动流程" class="headerlink" title="CentOS 5和6 的启动流程"></a>CentOS 5和6 的启动流程</h2><h3 id="前菜"><a href="#前菜" class="headerlink" title="前菜"></a>前菜</h3><p>抛开底层的硬件不谈, 我们知道LInux最核心的两个部分就是**<code>kernel</code><strong>和</strong><code>rootfs</code>**了</p><p>从内核的角度上说, 内核主要进行的工作有: 进程管理, 内存管理, 网络管理, 驱动程序, 文件系统, 安全功能</p><p>对程序员而说, 不会直接选择进行系统调用而是对已经对系统调用进行了一层封装的库进行调用, 在Linux下这个标准库就是<code>glibc</code>  而这些库文件都放在<code>rootfs</code>里面.</p><p>那么到底什么是库呢? 说白了就是一堆函数的集合, 而函数其实又只是一堆代码片段, 一个功能的实现,</p><p>库文件也是可以执行的, 只不过他自己没有入口, 只能依靠别的程序来调用他.</p><p>对于调用, 我们分为两种调用: <strong>过程调用</strong> 和 <strong>函数调用</strong>.</p><p>过程调用就是没有返回值的调用 而函数调用一定是有返回值的.</p><p>库之上就是我们真正生产能力的应用程序了.</p><p>作为整个系统的核心, 内核有两种设计流派: <strong>单内核设计, 微内核设计</strong></p><blockquote><p>简单的说, 微内核就好像是联邦制, 每一个功能都有一个小系统,这样造成的结果就是效率略低, 但是却能在某些功能模块出现异常的情况下, 不会使得整个内核出现致命性的错误. 而单内核即使将所有的功能集成到同一个程序.</p></blockquote><p>这两种的典型例子: 单内核: Linux  微内核: Windows, Solaris.</p><p>然而, Linux的内核特点: 支持模块化. *.ko ( 之前说过共享连接库的文件扩展名是*.so(shared), 而这里的k就是(kernel)) 也就是说, 你可以在线进行装载和卸载. </p><p>进入<code>/boot</code>下, 会发现一些和你开机引导菜单同名的几个文件, 这些文件就是Linux的压缩系统映像, 版本号的格式和我们之前说过的软件包的命名是一样的.</p><p>至于模块的位置都在<code>/lib/modules</code>下 , 同样, 系统的模块还是以版本号来进行的命名. (e.g : 在&#x2F;boot下有一个叫<code>vmlinuz-3.10.0-514.21.2.el7.x86_64</code>的系统映像, 那么他的模块就在<code>3.10.0-514.21.2.el7.x86_64</code>这个目录下)</p><p>现在进入模块的目录里面来看一下:</p><p>之前说过的<code>*.ko</code>文件都在模块目录下的kernel文件夹内, 这个位置<a href="">也是</a>真正的Linux内核模块所在.由于内核之间同样存在依赖关系, 所以也会有一些元信息文件.</p><p>那么这些文件一共有多大呢?:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">du</span> -sh /lib/modules/3.10.0-514.21.2.el7.x86_64/</span><br><span class="line">127M/lib/modules/3.10.0-514.21.2.el7.x86_64/</span><br></pre></td></tr></table></figure><p>是不是大小超乎你的意料, 事实上这个大小还是可以继续缩减的.</p><p>不知道大家有没有想象到这样的情况: 比如说在系统启动的时候我们要先加载内核进系统, 接着等到内核加载完就要开始加载根文件系统了, 这些东西都在哪里呢? 自然是在我们的硬盘上, 那么为了读取硬盘就需要硬盘驱动, 但是由于<code>Linux</code>是模块化的内核所以有可能这个驱动正好是被做了模块处理, 那么为了获得读取硬盘的能力, 就要先加载模块, 但是模块在哪呢? 在<code>/usr/lib/modules</code>下, 也是根文件系统, 这样就会出现矛盾.对于这种情况, 我们就需要一种外部的辅助手段: 把硬盘驱动先装在内核上, 让内核识别.</p><p>这样就会有两种解决方法:</p><ul><li>直接把硬盘驱动编译进内核, 但是这样的问题显然易见, 不可能将所有的硬盘驱动都扔到内核里.</li><li>加一个用来辅助的微型的文件系统, 仅包含内核需要的一些必要的驱动. 这么一个文件系统其实是一个LOOP设备, 也就是一个文件</li></ul><p>这么一个文件系统中的驱动显然是只用于当前用户的, 也就是说这个的内容并不是在最初就制作好的, 而是在安装操作系统的时候就生成的. 当然这么一个文件系统也不是必须的, 如果内核可以直接识别你的设备, 那么自然就不需要这么搞了.</p><p>这么个生成的工具就是<code>ramdisk</code> 这个有两种格式, 在CentOS5上是模拟成的硬盘的, 而6,7上是文件系统, 这是因为文件系统更加快速, 提高效率.在CentOS5上表现的是: <code>/boot/initrd-VERSION-release.img</code>. CentOS6,7上就是: <code>/boot/initramfs-VERSION-release.img</code>. (基于内存的文件系统) 还可以看到,叫System.map开头的文件, 这个是内核放置到物理内存上的映射表.</p><p>在完成加载驱动后, 就会进行根的切换, 因为上面的这个根是个假的. 如果没有这一步, 那么内核就会认为自己已经完成了根的加载了, 而放弃加载真实的根了.</p><h3 id="正餐"><a href="#正餐" class="headerlink" title="正餐"></a>正餐</h3><p><strong>CentOS系统的启动流程:</strong> (x86)</p><p>POST: <strong>加电自检</strong>: 当按下电源按钮, 这个时候会开始检查各个硬件是否存在以及他们能否正常工作(CPU, 风扇, 内存, 输入输出设备等等)  这些依靠ROM中的CMOS, BIOS加载CMOS,取得系统的硬件信息. BIOS程序的执行也依靠CPU. 所以说当我开机的时候, 主机激活CPU, 并且执行第一条指令: 叫醒 . 接着CPU就会去某ROM的某一个固定地址去加载那个地方的指令, 从而完成自检等等操作. 内存包括ROM+RAM, 在内存进行编址的时候, 都是先进行的ROM编址, 完成之后才进行的RAM编址.</p><p>BIOS是进行主板设定的地方, 但并不是说我们每一次都要进行设定, 设定的结果是保存在CMOS中的 所以在开始时, 只提供一个菜单供用户选择. 任何一台电脑都需要操作系统对不.而操作系统都在哪呢? 显然是在我们外部的存储设备上(硬盘, USB闪存等等) 问题是, 多个硬盘的情况下, 我怎么知道哪一块才是我要进的OS所在呢?</p><p>这就说到了一个Linux中非常重要的引导次序(BOOT Sequence). BIOS根据这个设置的引导次序来进行加载.决定因素就是设备需要存在并且有引导程序在. 比如: 我的引导次序是光盘, 网卡, 硬盘. 实际的系统在硬盘上.那么当开始进行引导的时候就会开始按照次序寻找: 首先是光盘, 发现当前电脑上并没有安装硬盘, 跳过. 接着是网卡, 网卡存在但是却没有引导程序, 跳过. 最后是硬盘, 存在并且在MBR分区中找到了引导程序. (How?*)开始加载相应的引导程序. 接着 这个bootloader所指向的操作系统是损坏的, 仍启动不起来.</p><blockquote><p>MBR分区内的引导程序寻找, 是依靠于磁盘设备的INT-13中断功能, 只要BIOS能够识别磁盘硬件就可以通过INT-13中断来获得磁盘第一扇区的MBR.</p></blockquote><p>这里提到了<code>bootloader</code> 见名知意:引导加载器 这个是一个程序.在操作系统安装完成就会自动装载到相应的位置上.Windows上的引导加载器叫做:<code>ntloader</code>. 不同版本的Win, 这个引导加载也是不一样的. 对于Linux而言, 他有两种引导加载:</p><ul><li><strong>LILO</strong>: LInux LOader 但是这种加载程序太古老了, 当时硬盘容量也太小了, 所以他不允许将操作系统安装在1024柱面之后. 而现在的硬盘动辄都是几万的柱面.吧</li><li><strong>GRUB</strong>: GRand Uniform Bootloader, 统一引导加载器 这种更加常用.之所以叫统一, 是因为它支持启动Windows, Linux, BSD.当前的Linux使用的都是叫做<code>grub2</code>, 其实是grub1.X版本 和过去的grub相比, 这个更新是进行的完全重写, 和原来是完全不一样的. 我们把过去的GRUB叫做GRUB Legacy.</li></ul><blockquote><p>这个程序就放在MBR中引导程序部分, 当然不同于原来的446个字节, grub采用了一个精巧的方式突破了这个限制. 接着是64字节的fat(磁盘分区表), 最后两个字节是<code>55aa</code>, 盘的有效标识.</p></blockquote><p>小结: bootloader功能就是提供一个菜单, 允许用户选择要启动的系统或者是不同的内核版本. 把用户选定的内核装载到内存的特定空间中, 解压, 展开, 之后将控制权转交给内核. 这个时候就是宣告了BIOS的使命结束.</p><p>来补充一下刚刚说过的精巧的GRUB的解决446字节限制.整个grub分成两个过程:</p><p><code>1st stage</code>: 第一阶段说白了什么都不做, 就是向磁盘上去寻真正的第二阶段, 只要能会识别硬件就可以实现了.</p><p><code>1.5阶段</code>:  grub识别硬盘上的文件系统. 这个时候遇到了一个和上面一样的问题了, 首先明确grub是存在在文件系统上的, 为了访问磁盘分区, 我就要能够使用文件系统, 而使用文件系统我还要能够访问磁盘分区.</p><p>所以说, 其实这个匹配的文件系统在系统安装的时候就已经装载在了MBR剩余的地方了.这样就解决了驱动的问题.</p><p><code>2nd stage</code>: 由于硬盘上的容量远大于446字节, grub就可以任意施展了.</p><h3 id="内核的天下"><a href="#内核的天下" class="headerlink" title="内核的天下"></a>内核的天下</h3><p>grub加载好内核之后, 就是kernel来统一天下了.</p><p>首先, kernel进行自身的初始化: 探测可识别到的所有硬件设备, 加载硬件驱动程序(当然有可能借助于ramdisk加载驱动), 以只读的方式根文件系统. 接着运行用户空间的第一个应用程序: <code>/sbin/init | /usr/lib/systemd/systemd</code></p><p>init程序可以是一个程序, 也有可能是一个脚本(CentOS5, 安卓)</p><ul><li><strong>SysV</strong>: init, CentOS 5 早期的init基本上是依靠脚本来启动的各个的服务, 这就导致每一个命令都会进行进程创建和销毁, 使得启动速度很慢, 而且不能并行并发启动服务, 因为服务间是存在依赖关系的 (配置文件&#x2F;etc&#x2F;inittab)</li><li><strong>Upstart</strong>: (Ubuntu研发) CentOS 6的init,   采用了不太一样的启动方式, 当服务<strong>开始</strong>启动的时候就解决依赖关系. 兼容SysV, 但是CentOS6并没有发挥出Upstart的威力 (配置文件&#x2F;etc&#x2F;inittab &#x2F;etc&#x2F;init&#x2F;*.conf)</li><li><strong>Systemd</strong>: 改名为systemd, 从Mac OS X中得到的灵感, Systemd不需要任何脚本来启动服务, 他自己就是一个解释器, 当要启动一个服务的时候, 如果不是必要的就只是标志启动, 但不实际上去启动它, 当第一次使用的时候才会去真正启动它. (&#x2F;usr&#x2F;lib&#x2F;systemd &#x2F;etc&#x2F;systemd&#x2F;system)</li></ul><p>现在再回来说说<code>ramdisk</code>: 上面说了使用模拟文件系统形式的ramdisk更加快速, 原因是什么呢?</p><p>内核的特性之一是: 使用缓存和缓冲来加速磁盘文件访问.但这样就会有问题: RAM当中有一段内存是分配给内核的, 而ramdisk将文件加载到内存之中, 供内核读取, 而内核把这个的当做硬盘来看待, 而我们都知道硬盘远没有内存快, 所以内核会将这部分原来就已存在在内存的一块再加载到内存中.</p><p>因此CentOS6之后就将<code>ramdisk --&gt; ramfs</code> 我们说过这些img镜像是由工具生成的.在CentOS5上是一个脚本,叫做mkinitrd, 而在CentOS6上虽然还有mkinitrd, 但现在我们更多在使用的是一个叫做dracut的工具.</p><p>**系统初始化: **</p><p>POST –&gt; BootSequence (BIOS) –&gt; Bootloader(MBR) –&gt; kernel(ramdisk) –&gt; rootfs(只读) –&gt; init&#x2F;systemd</p><p>上一张图吧:</p><p><img src="http://linux.vbird.org/linux_basic/0510osloader//osloader-flow-initramfs.jpg" alt="Boot"></p><p><strong>关于上面的systemd, 是CentOS7所采用的init程序, 参考这里<a href="https://yaoxuannn.com/2017/09/06/CentOS7%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">CentOS7启动流程</a></strong></p><h3 id="x2F-sbin-x2F-init"><a href="#x2F-sbin-x2F-init" class="headerlink" title="&#x2F;sbin&#x2F;init"></a>&#x2F;sbin&#x2F;init</h3><p>在Windows上我们也许见过这样的问题, 升级了某些驱动之后再次进入系统会出现蓝屏的现象, 原因有很多,可能是驱动和硬件不兼容, 也有可能是驱动程序有Bug.但不管怎么说, 现在要进行修复了, 在Windows上我们会进入安全模式, 这个模式下只加载最基本的核心组件, 从而最低维持系统.(几乎失去生产能力), 而在Linux下这个被叫做运行级别(Run-level). 这个概念在CentOS7上已经发生了改变,  但在传统的CentOS5和6上依然保持了原本的意义.</p><p>运行级别: 为了系统的运行和维护等应用目的而设定. 在原先的<a href="https://yaoxuannn.com/2017/07/02/Linux%E7%B3%BB%E7%BB%9F-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more">Linux系统-服务管理学习笔记</a>也已经提过. 共划分7个等级.</p><p>配置文件所在, 在上文已经提过了: <code>/etc/inittab</code> 每一行对应一个action以及与之对应的process(并不意味着<strong>一个</strong>进程) 由于我这部分的实验主机使用的是CentOS6, 因此实验结果没有5版本好.</p><p>现在来看看配置文件都写了什么:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@livecd ~]<span class="comment"># cat /etc/inittab </span></span><br><span class="line"><span class="comment"># inittab is only used by upstart for the default runlevel.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ADDING OTHER CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># System initialization is started by /etc/init/rcS.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Individual runlevels are started by /etc/init/rc.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Ctrl-Alt-Delete is handled by /etc/init/control-alt-delete.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Terminal gettys are handled by /etc/init/tty.conf and /etc/init/serial.conf,</span></span><br><span class="line"><span class="comment"># with configuration in /etc/sysconfig/init.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For information on how to write upstart event handlers, or how</span></span><br><span class="line"><span class="comment"># upstart works, see init(5), init(8), and initctl(8).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Default runlevel. The runlevels used are:</span></span><br><span class="line"><span class="comment">#   0 - halt (Do NOT set initdefault to this)</span></span><br><span class="line"><span class="comment">#   1 - Single user mode</span></span><br><span class="line"><span class="comment">#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)</span></span><br><span class="line"><span class="comment">#   3 - Full multiuser mode</span></span><br><span class="line"><span class="comment">#   4 - unused</span></span><br><span class="line"><span class="comment">#   5 - X11</span></span><br><span class="line"><span class="comment">#   6 - reboot (Do NOT set initdefault to this)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">id</span>:5:initdefault:</span><br></pre></td></tr></table></figure><p>最后一行是说默认的runlevel设置为5. 格式就是: <code>id:runlevel:action:process</code> </p><p>现在来聊下常用的action吧: wait(等待, 切换至此级别就运行一次), respawn(此process终止时候重启), initdefault(设定默认优先级别),sysinit(完成系统初始化, 一般指定为&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit )</p><p>在CentOS5上, 下一项配置就是si::sysinit:&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit 这个是一个非常大的脚本, 加载了许多东西.(挂载&#x2F;etc&#x2F;fstab中的文件系统, 读取&#x2F;etc&#x2F;sysctl.conf的内核参数, 激活交换设备, 加载LVM分区, 网络设备, 系统时钟等等…)</p><p>接着就根据不同的级别加载不同的程序了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l0:0:<span class="built_in">wait</span>:/etc/rc.d/rc 0</span><br><span class="line">l1:1:<span class="built_in">wait</span>:/etc/rc.d/rc 1</span><br><span class="line">...(omitted)</span><br><span class="line">l6:6:<span class="built_in">wait</span>:/etc/rc.d/rc 6</span><br></pre></td></tr></table></figure><p>后面意味着读取&#x2F;etc&#x2F;rc.d&#x2F;rcX.d&#x2F;下的所有脚本, 这些脚本分成了K开头和S开头的.并且都有数字, 这些数字决定了执行次序. 越小就越早执行. 所有K开头的都进行stop操作.而S开头的就进行start操作.</p><p>有一个专门用来管理这些的工具, 叫做<code>chkconfig</code>, 它能够来查看和管理rcX.d下这些链接文件.</p><p>使用–list来查看所有的自启动服务:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ chkconfig -list</span><br><span class="line">NetworkManager 0:off1:off2:on3:on4:on5:on6:off</span><br><span class="line">acpid          0:off1:off2:on3:on4:on5:on6:off</span><br><span class="line">atd            0:off1:off2:off3:off4:off5:off6:off</span><br><span class="line">...(omitted)</span><br><span class="line"><span class="comment"># 假设现在我们将级别5时候的NetworkManager关闭, 这样操作</span></span><br><span class="line">[root@WWW rc0.d]$ chkconfig --level 5 NetworkManager off</span><br><span class="line">[root@WWW rc0.d]$ chkconfig --list</span><br><span class="line">NetworkManager 0:off1:off2:on3:on4:on5:off6:off</span><br><span class="line">...(omitted)</span><br><span class="line"><span class="comment"># 看, 服务的自动启动已经被关闭了</span></span><br><span class="line">[root@WWW rc0.d]$ ll /etc/rc.d/rc5.d/</span><br><span class="line">total 0</span><br><span class="line">...(omitted)</span><br><span class="line">lrwxrwxrwx. 1 root root 24 Jul 10 16:11 K84NetworkManager -&gt; ../init.d/NetworkManager</span><br><span class="line">...(omitted)</span><br><span class="line"><span class="comment"># 此时查看就会发现, 已经变成K开头的了.那么, 为什么是84呢?</span></span><br><span class="line"><span class="comment"># 要知道这个问题我们需要看一下NetworkManager的真正脚本</span></span><br><span class="line">[root@WWW ~]$ <span class="built_in">head</span> -10 /etc/init.d/NetworkManager </span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># NetworkManager:   NetworkManager daemon</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chkconfig: - 23 84</span></span><br><span class="line"><span class="comment"># description:  This is a daemon for automatically switching network \</span></span><br><span class="line"><span class="comment">#               connections to the best available connection.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># processname: NetworkManager</span></span><br><span class="line"><span class="comment"># pidfile: /var/run/NetworkManager/NetworkManager.pid</span></span><br></pre></td></tr></table></figure><p>除了这些文件, 在系统启动的时候还会加载&#x2F;etc&#x2F;sysconfig下的种种配置.</p><h3 id="chkconfig-amp-rc脚本"><a href="#chkconfig-amp-rc脚本" class="headerlink" title="chkconfig &amp; rc脚本"></a>chkconfig &amp; rc脚本</h3><p>查看服务在所有级别的启动情况:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig [--list] [name]</span><br></pre></td></tr></table></figure><p>添加:</p><p>sysV的脚本放在&#x2F;etc&#x2F;rc.d&#x2F;init.d (&#x2F;etc&#x2F;init.d) </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add name</span><br><span class="line"><span class="comment"># 脚本的开头只要满足格式就可以:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chkconfig: LLLL(写了就是S, 没写就是K) nn nn</span></span><br></pre></td></tr></table></figure><p>将脚本按照格式写完放到&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;的下面, 并且赋予权限, 接着就可以通过<code>service XXX start</code>来运行.接着执行添加指令就可以在相应的位置上创建.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@livecd sysconfig]<span class="comment"># chkconfig --add test</span></span><br><span class="line">[root@livecd sysconfig]<span class="comment"># chkconfig --list test</span></span><br><span class="line"><span class="built_in">test</span>           0:off1:off2:off3:on4:on5:on6:off</span><br><span class="line">[root@livecd sysconfig]$ <span class="built_in">ls</span> -l /etc/rc.d/rc0.d/K33test </span><br><span class="line">lrwxrwxrwx. 1 root root 14 Jul 10 16:45 /etc/rc.d/rc0.d/K33test -&gt; ../init.d/test</span><br></pre></td></tr></table></figure><p>删除也很简单, 直接把<code>add</code>换成<code>del</code>就行了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@livecd sysconfig]<span class="comment"># chkconfig --del test</span></span><br><span class="line">[root@livecd sysconfig]<span class="comment"># chkconfig --list test</span></span><br><span class="line">service <span class="built_in">test</span> supports chkconfig, but is not referenced <span class="keyword">in</span> any runlevel (run <span class="string">&#x27;chkconfig --add test&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这个时候就会发现已经找不到对应的链接了.</p><p>还可以对当前已经存在的连接修改等级:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ chkconfig [--level levels] name &lt;on|off|reset&gt;</span><br><span class="line">    --level LLLL 省略时默认为2345</span><br><span class="line"><span class="comment"># 比如说</span></span><br><span class="line">[root@WWW ~]$ chkconfig NetworkManager off</span><br><span class="line">[root@WWW ~]$ chkconfig --list NetworkManager</span><br><span class="line">NetworkManager 0:off1:off2:off3:off4:off5:off6:off</span><br><span class="line">[root@WWW ~]$ chkconfig --level 2345 NetworkManager on</span><br><span class="line">[root@WWW ~]$ chkconfig --list NetworkManager</span><br><span class="line">NetworkManager 0:off1:off2:on3:on4:on5:on6:off</span><br></pre></td></tr></table></figure><p>接着在探索一下这一堆神奇的目录, 你会发现在2,3,4,5这四个等级的启动任务的最后都有一个叫S99local的链接, 更神奇的是, 它指向上级目录的一个叫<code>rc.local</code>的脚本. 进来看看是个什么东西:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">ls</span> -l /etc/rc.d/rc&#123;1,2,3,4,5,6&#125;.d/S99local</span><br><span class="line"><span class="built_in">ls</span>: cannot access /etc/rc.d/rc1.d/S99local: No such file or directory</span><br><span class="line"><span class="built_in">ls</span>: cannot access /etc/rc.d/rc6.d/S99local: No such file or directory</span><br><span class="line">lrwxrwxrwx. 1 root root 11 Dec 16  2011 /etc/rc.d/rc2.d/S99local -&gt; ../rc.local</span><br><span class="line">lrwxrwxrwx. 1 root root 11 Dec 16  2011 /etc/rc.d/rc3.d/S99local -&gt; ../rc.local</span><br><span class="line">lrwxrwxrwx. 1 root root 11 Dec 16  2011 /etc/rc.d/rc4.d/S99local -&gt; ../rc.local</span><br><span class="line">lrwxrwxrwx. 1 root root 11 Dec 16  2011 /etc/rc.d/rc5.d/S99local -&gt; ../rc.local</span><br><span class="line">[root@WWW ~]$ <span class="built_in">cat</span> ../rc.local</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script will be executed *after* all the other init scripts.</span></span><br><span class="line"><span class="comment"># You can put your own initialization stuff in here if you don&#x27;t</span></span><br><span class="line"><span class="comment"># want to do the full Sys V style init stuff.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> /var/lock/subsys/local</span><br></pre></td></tr></table></figure><p>所以这就很显然了, 当你有一个想要开机执行的任务(不适合写成脚本)可以把它添加到这个脚本中.网上有很多教程介绍开机任务的时候都说过编辑&#x2F;etc&#x2F;rc.local, 有的却说编辑rc.d&#x2F;rc.local. 其实这个都是说一个文件etc的下的那个其实是一个软链.<code>/etc/rc.local -&gt; rc.d/local</code> .</p><p>好了这个时候, 用户就要登录了.也就执行到了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1:2345:respawn:/sbin/mingetty tty1</span><br><span class="line">2:2345:respawn:/sbin/mingetty tty2</span><br><span class="line">...</span><br><span class="line">6:2345:respawn:/sbin/mingetty tty6</span><br><span class="line">x:5:respawn:/etc/X11/prefdm -nodaemon <span class="comment"># 图形界面</span></span><br></pre></td></tr></table></figure><p>这个时候开始加载终端, 也就进入了我们看到的第一个画面: </p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/login.png" alt="login"></p><p>这个界面的出现是因为<code>mingetty</code>之后调用了一个叫<code>login</code>的程序. <strong>Warning: 在远程连接的shell里执行这个指令远程主机就会关闭连接!</strong></p><p>在SysV的inittab里的第一句话写了这么一句: <code>si::sysinit:/etc/rc.d/rc.sysinit</code>.在CentOS6上这个由于使用了startup所以没有出现在inittab中, 而是写在了别的配置文件中, 这意味着在实际运行之前还要再把整个系统的环境设置好.这个脚本做的初始化有哪些呢?</p><p>这个脚本还是很大的(670行)主要做的事情有:</p><ul><li>获取主机名以及加载网络配置(如果没有就命名为localhost)</li><li>设置和显示banner</li><li>激活udev和selinux</li><li>挂载&#x2F;etc&#x2F;fstab文件中定义的文件系统</li><li>检测根文件系统, 并用读写的方式的方式重新挂载根文件系统</li><li>设置系统时钟</li><li>激活swap设备</li><li>根据&#x2F;etc&#x2F;sysctl.conf文件来设置内核参数</li><li>激活LVM和software raid设备</li><li>加载额外设备的驱动</li><li>清理操作</li><li>…</li></ul><blockquote><p>**总结:&#x2F;sbin&#x2F;init –&gt; (&#x2F;etc&#x2F;inittab) –&gt; 设置默认运行级别 –&gt; 运行系统初始脚本,完成系统的初始化 –&gt; 关闭对应下需要关闭的服务, 启动需要运行的服务 –&gt; 设置登录终端 **</p></blockquote><h3 id="CentOS6和5的区别"><a href="#CentOS6和5的区别" class="headerlink" title="CentOS6和5的区别"></a>CentOS6和5的区别</h3><p>init程序尽管更换为了startup, 但仍旧命名为init, 并且配置文件不是单一的inittab, 而是分了多个文件都放在<code>/etc/init</code>下, 每一个配置项都是一个*.conf的文件.</p><p> 在这个目录下的rc.conf其实最终还是执行的<code>/etc/rc.d/rc $RUNLEVEL</code> 而负责执行脚本的rcS.conf实际上运行的也就是刚刚说过的<code>rc.sysinit</code>类似的, 大家也可以猜出来tty.conf实际上就是执行的<code>mingetty</code>. </p><p><strong>注意: &#x2F;etc&#x2F;init&#x2F;*.conf文件语法, 遵循upstart配置文件的语法格式.</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
            <tag> bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统-服务管理学习笔记</title>
      <link href="/2017/07/02/Linux%E7%B3%BB%E7%BB%9F-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/07/02/Linux%E7%B3%BB%E7%BB%9F-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>学习基础的Linux的服务与进程管理.</p><span id="more"></span><h2 id="查询已安装的服务"><a href="#查询已安装的服务" class="headerlink" title="查询已安装的服务"></a>查询已安装的服务</h2><p>首先了解系统的运行级别:</p><p>参考这个: <a href="https://yaoxuannn.com/2016/11/25/OrdersinLinux-1/#more">系统运行级别</a>.</p><p>Linux的服务主要分类是这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Linux服务</span><br><span class="line"> |</span><br><span class="line"> |-RPM包默认安装的服务</span><br><span class="line"> ||</span><br><span class="line"> ||-独立的服务</span><br><span class="line"> ||</span><br><span class="line"> | |-基于xinetd的服务</span><br><span class="line"> |</span><br><span class="line"> |-源码包安装的服务</span><br></pre></td></tr></table></figure><p><del>查看系统中的服务可以通过<code>chkconfig --list</code>查看.(非原生服务)</del> 旧指令, 划掉!</p><p>应该使用<code>systemctl list-units --type=service</code>来查看.</p><p>如果要查看全部的系统的服务,使用<code>systemctl list-unit-files</code>.</p><p>这里,我们并不能知道查看到的服务是否在运行当中, 但我们可以从中看出服务的自启动情况.</p><p>这些数字和on&#x2F;off的键值对表明了服务是否是开机自启动的.数字代表的是系统运行状态, 而on&#x2F;off表示是否自启.</p><blockquote><p>chkconfig命令查询到的是RPM包安装的服务.如要查看源码包安装的服务, 一般是在&#x2F;usr&#x2F;local下.<br>而RPM包一般安装在&#x2F;etc&#x2F;init.d&#x2F;下.</p></blockquote><h2 id="服务启动与端口"><a href="#服务启动与端口" class="headerlink" title="服务启动与端口"></a>服务启动与端口</h2><p>一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等.<br>所以,主机通过”IP+端口”来区分不同的服务的.</p><p>常规的服务对应端口可以在<code>/etc/services</code>里查看, 文件很大,有<code>11176</code>行.</p><p>既然已经了解端口和服务的关系, 那么查看已经启动的服务的操作就会变成查看端口的操作.</p><p>也就是<code>netstat</code>命令.</p><p>下面好好说一下这个<code>netstat</code>.</p><p>netstat主要用于查看网络后门, 说白了就是看有什么服务在占用端口, 所以也是查看启动服务的命令.</p><p>常用的参数有:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-n (numberic~常用) 使用ip和port,而不进行反查.</span><br><span class="line">-a (all) 列出所有连接的状态(tcp/udp/unix socket)</span><br><span class="line">-t (TCP) </span><br><span class="line">-u (UDP)</span><br><span class="line">-p (pid~常用) 列出pid和服务名 </span><br><span class="line">-l (listen) 仅列出处于监听状态的服务连接</span><br></pre></td></tr></table></figure><h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><p>(独立服务.基于xinetd服务) – RPM包</p><p>学习服务管理之前, 先知道一些常用的目录, 这些都和RPM包服务有关 列举如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ : 启动脚本的位置</span><br><span class="line">/etc/sysconfig/ : 初始化环境配置文件的位置</span><br><span class="line">/etc : 配置文件的位置</span><br><span class="line">/etc/xineted.conf : xineted的配置文件</span><br><span class="line">/etc/xineted.d/ : 基于xineted服务的启动脚本</span><br><span class="line">/var/lib : 服务产生的数据</span><br><span class="line">/var/log : 日志</span><br></pre></td></tr></table></figure><p><del>查看.启动.终止.重启服务的命令就是 <code>service</code>, 注意, 这只是一直能够便利的方法,</del>(过时方法,划去!) 事实上Linux上应该通过绝对路径来进行启动的, 也就是那个<code>/etc/init.d/</code> </p><p>启动.终止.重启服务 使用 systemctl start|stop|restart sth.service</p><p>查看服务运行状态使用 systemctl status sth.service</p><p>使某个服务开机(不)自启使用 systemctl enable|disable sth.service .</p><h2 id="系统管理之ps命令"><a href="#系统管理之ps命令" class="headerlink" title="系统管理之ps命令"></a>系统管理之ps命令</h2><p>ps命令是查看当前进程的最常用的命令, 但它提供了BSD命令风格和Linux命令风格的两种语法,也就是<code>pa aux</code>和<code>ps -le</code>.</p><p>ps会输出一大堆东西, 这些东西是什么呢? </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">USER : 表示该进程是那个用户产生的</span><br><span class="line">PID : 进程的PID号</span><br><span class="line">%CPU : 该进程占用CPU资源的百分比</span><br><span class="line">%MEM : 该进程占用物理内存的百分比</span><br><span class="line">VSZ : 该进程占用虚拟内存的大小 (KB) -- 虚拟内存集</span><br><span class="line">RSS : 该进程占用实际物理内存的大小 (KB) -- 常驻内存集</span><br><span class="line">TTY : 表示该进程运行在那个终端里 ( tty1-tty表示本地控制台(也就是在腾讯云里进行登录操作的那个窗口.), 其中tty1-tty6是字符终端, tty7是图形终端 pts0-????? 是虚拟终端(也就是XShell.PuTTy这类远程工具的窗口)), 如果是问号 ? ,说明该进程不是用户在终端内启动的, 他们是由内核直接启动的一般认为这样的进程是系统进程.</span><br><span class="line">STAT : 进程的状态 ; 常见的状态有: R (running) 运行, S (sleeping) 睡眠(可中断的), D(sleeping) 不可中断的睡眠, T (stoped) 停止, Z (Zombie) 僵尸进程,  s (session leader) 创建者, 负责引导和启动, + 前台进程, &lt; 高优先级, N 低优先级, l 多线程, 克隆线程.</span><br><span class="line">START : 该进程的启动时间</span><br><span class="line">TIME : 该进程占用的CPU运算时间, 不是系统时间</span><br><span class="line">COMMAND : 产生此进程的命令名</span><br></pre></td></tr></table></figure><p><code>ps</code>还有一些可能会用到的命令组合.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">--------------</span><br><span class="line">ps -ef</span><br><span class="line">-e 显示所有进程</span><br><span class="line">-f 显示进程启动的详细信息</span><br><span class="line">--------------</span><br><span class="line">ps -ejH</span><br><span class="line">-j 任务控制模式输出</span><br><span class="line">-H 层级结构输出</span><br><span class="line">--------------</span><br><span class="line">ps -eFH</span><br><span class="line">-F 显示完整格式的进程信息</span><br><span class="line">--------------</span><br><span class="line">ps axZ / ps -eM</span><br><span class="line">a 与终端相关的进程</span><br><span class="line">x 与终端无关的进程</span><br><span class="line">Z 显示一列SELinux的数据, 同-M</span><br><span class="line">-M 显示一列SELinux的数据, 同Z</span><br><span class="line">--------------</span><br><span class="line"><span class="comment"># 显示某个用户的进程</span></span><br><span class="line">ps -U/-u root</span><br><span class="line">-U/-u 指明用户</span><br><span class="line">--------------</span><br></pre></td></tr></table></figure><p>上面的输出参数是<code>BSD</code>风格的, 现在在补充一些<code>Linux</code>风格:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NI: <span class="built_in">nice</span>值</span><br><span class="line">PRI: priority, 优先级</span><br><span class="line">PSR: processor, CPU</span><br><span class="line">RTPRIO: 实时优先级</span><br><span class="line">....man</span><br></pre></td></tr></table></figure><p>另外一个更方便的命令是<code>pstree</code>命令, 可以以树形结构展示当前进程. 加 <code>-p</code> 参数查看pid号, 同时展开.</p><h2 id="系统管理之top命令"><a href="#系统管理之top命令" class="headerlink" title="系统管理之top命令"></a>系统管理之top命令</h2><p>top命令是用来检测服务器健康的重要命令, 它的输出也是很多的, 但很多东西都和ps命令相同, 我们来看一下:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/top.png" alt="top"></p><p>最上方的状态栏就是top命令的最重要的地方了, 下面的情况基本和ps命令类似, 就不在此记录了.</p><p>首先, 最前面的时间是指当前的系统时间, 不是指运行了多长时间, 后面的时间(天数)表示的才是运行的时间, 例如: 这台服务器运行了36分钟.</p><p>后一项表示当前登录的用户数, 后面的是平均负载.(1分钟, 5分钟, 15分钟) 平均负载的数字是指等待执行的队列</p><p>事实上, 这一行的输出结果和<code>w</code>命令的输出是一样的.</p><p>第二行: 分别表示系统中的进程总数以及其中的正在运行的, 睡眠的, 正在停止的, 以及僵尸进程.</p><p>第三行的输出是一行很重要的信息, 即<code>CPU</code>的状态, 我们来看一下: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%Cpu(s): 用户模式占用的CPU百分比 默认直接显示总数情况</span><br><span class="line">sy : 系统模式占用</span><br><span class="line">ni : 改变过优先级的用户进程占用</span><br><span class="line"><span class="built_in">id</span> : 空闲CPU的百分比 (重要)</span><br><span class="line">wa : 等待IO的进程 (重要)</span><br><span class="line">hi: 硬件中断</span><br><span class="line">si: 软件中断 (进行用户空间和内核空间的切换)</span><br><span class="line">st: 偷走的 (虚拟化技术)</span><br></pre></td></tr></table></figure><p>使用<code>t</code>命令进行显示视图的切换, 使用<code>l</code>命令来进行<code>uptime</code>信息的显示和隐藏.</p><p>下面的是内存占用情况, 没有搞清楚, 暂时空缺. 等到搞清楚<code>Linux</code>的内存模型再补上.</p><p>在进入<code>top</code>的界面后, 我们会发现数据是实时刷新的, 在这个交互界面中我们可以进行排序:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P: 以占据的CPU百分比</span><br><span class="line">M: 占据内存的百分比</span><br><span class="line">T: 累计占据的CPU的时长</span><br></pre></td></tr></table></figure><p>默认的刷新时间是<code>3.0s</code>, 我们可以在交互式的界面里使用<code>s</code>来进行调整. </p><p>使用<code>m</code>可以改变内存占用情况的视图, 使用<code>1</code>命令来对<code>CPU</code>进行挨个查看.</p><p>另外, 在启动时可以直接使用<code>-d #</code>来指定刷新时间. 如果在调用的时候使用了<code>-n</code>参数, 在后面跟上数字表示刷新几次之后直接退出.</p><p>然而, <code>top</code>已经很有历史了, 现在我们使用一个更强的进程管理程序:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/htop.png" alt="htop"></p><p>看起来就比<code>top</code>更厉害吧! 还有一些很强大的功能. 下面简单列举一下:</p><p>首先..我不明白这个东西为什么要支持鼠标点击…</p><p>使用<code>&lt;F5&gt;</code>或者<code>t</code>来进行树形视图和列表视图的切换,</p><p>使用<code>p</code>来进行路径全名的展示&#x2F;缩略</p><p><code>H/K</code>分别用来进行显示&#x2F;隐藏用户进程和内核进程</p><p><strong>斜线</strong>和<strong>反斜线</strong>用来进行进程和过滤器的搜索和设定, 过滤器是动态过滤的, 很赞.</p><p>使用<strong>空格</strong>进行多选, 后序可以直接进行批量的<code>kill</code>操作, 使用<code>k</code></p><p>如果说你有多个<code>CPU</code>核心, 那么你可以将某个进程绑定到某个具体的<code>CPU</code>上. 使用<code>a</code>.</p><p><code>htop</code>最强的的两个功能来了, 对特定进程使用<code>s</code>可以进行追踪这个进程进行了什么系统调用. 并且支持即时滚动</p><p>第二个就是打开文件描述符, 尽管你可以通过打开<code>/proc</code>下的<code>fd</code>文件夹进行查看, 但是既然这个都封装了一层, 为什么不直接用呢 在相应的进程上使用<code>l</code>即可打开, 这个比直接打开<code>fd</code>可以看到更多信息哦.(比如说你不仅会看到打开的文件, 还可以查看到加载仅内存的库有哪些, 以及他们的文件类型, 以及大小)</p><h2 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h2><p>结束进程的命令有这几个 <code>kill</code>,<code>killall</code>,<code>pkill</code>, 这些命令的作用都是类似的, 区别在于有些可以杀死单一进程, 有些可以杀死多进程, 接下来一个一个说.</p><p>Linux杀死进程通过信号来执行. <code>kill -l</code>来查看所有的信号 (64个)</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/signals.png" alt="signals"></p><p>其中常用的是1.2.9.15这些.</p><table><thead><tr><th align="center">信号</th><th align="center">信号名称</th><th align="center">信号说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">SIGHUP</td><td align="center">让进程立即关闭, 然后重新读取配置文件重启(平滑重启), 举个例子就是说:正在使用服务器的用户不会被踢掉, 但是配置会重新加载</td></tr><tr><td align="center">2</td><td align="center">SIGINT</td><td align="center">程序终止信号相当于是ctrl+c, (INTERRUPT)</td></tr><tr><td align="center">9</td><td align="center">SIGKILL</td><td align="center">立即结束程序的运行, 这个信号不会被阻塞.处理.忽略, 一般用于强制结束终止进程</td></tr><tr><td align="center">15</td><td align="center">SIGTERM</td><td align="center">正常结束进程的信号, 是kill的默认信号, 如果进程发生问题, 这个信号会失去作用, 这个时候再考虑信号9</td></tr></tbody></table><p>使用kill杀死一个进程就像这样, <code>kill -9(signal) 15936(pid)</code>, 但要注意, 直接使用-9造成的影响和你<code>rm -f</code>是一样的,所以一定要小心.</p><p>在指定信号时, 支持多种方法:</p><ul><li>信号的数字标识: 1 2 9</li><li>信号的完整名称: <code>SIGHUP</code> </li><li>信号的简写名称: <code>HUP</code></li></ul><p>另外, 向Apache这样的进程会有一运行就会有10几个进程, 而kill一次只能干掉一个,于是在这种情况下我们就可以使用<code>killall</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -i -9 httpd</span><br></pre></td></tr></table></figure><p>其中, <code>-i</code>参数表示<code>interactive</code>, 会不断询问你是否要杀死某个进程.</p><p>最后再想象这样的场景; 你使用<code>last</code>命令,发现有人同时登陆了<code>terminal</code>,然后你很坏, 想把他踢了, 这个时候你想到了杀死他的登陆进程, 可是, 看的不是很清楚, 你害怕把自己给踢掉了. </p><p>这个时候怎么办呢? 此时就是使用<code>pkill</code>的时候了.</p><p><code>pkill</code>可以添加<code>-t</code>参数, 来指定TTY名, 这样就方便多了. 你先使用<code>w</code>命令, 非常快速的辨认出对方的TTY(因为在同一时间使用w的概率太低了), 接着你优雅的敲下了 <code>pkill -9 -t pts/1</code>.</p><p>有一个和<code>pkill</code>同组的命令叫<code>pgrep</code>. 从名字就可以看出, <code>grep</code>是用来做筛选的, 那么<code>pgrep</code>就是用来进行进程筛选的.</p><p>常用的选项有: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-u uid: 有效用户所指</span><br><span class="line">-U uid: 真实用户</span><br><span class="line">-t terminal 与指定终端相关的进程</span><br><span class="line">-l 显示进程名</span><br><span class="line">-a 显示完整格式的进程名</span><br><span class="line">-P pid: 显示其父进程为此处指定的进程的进程列表</span><br></pre></td></tr></table></figure><p>有一个快速从进程名获得其所有的<code>pid</code>的命令: <code>pidof</code> , 还有一个专门用来先查看进程状态的命令: <code>pidstat</code>.</p><h2 id="修改进程的优先级"><a href="#修改进程的优先级" class="headerlink" title="修改进程的优先级"></a>修改进程的优先级</h2><p>又到了使用ps的时候了, 但是注意, 如果要查看进程的优先级, 就不能使用<code>ps aux</code>了, 此时就要使用<code>ps -le</code>了.</p><p>样例输出如下:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.compri.png/" alt="优先级"></p><p>其中的PRI表示priority, NI表示Nice, 这两个值都是优先级, 越小表示优先级越高.</p><p>最终生效的是PRI这个优先级, 而且用户不能修改PRI的值(即使是root也不能), 用户仅可以修改NI的值.</p><p>最终系统计算的优先级是PRI+NI的值.</p><p>而在修改NI的时候有注意事项:</p><blockquote><p>PRI的默认值为80<br>NI的值的范围是-20 - 19 (对于root而言)<br>而普通用户只能将其改为0-19, 而且只能调整自己的进程.</p></blockquote><p>这就意味, root用户才能提高进程的优先级.</p><p>另外, <code>nice</code>仅仅可以修改新执行的命令的优先级, 用法类似这样: <code>nice -n -5 tar -zvxf node-v6.10.2.tar.gz</code>.</p><p>这样,运行的<code>tar</code>就会以<code>75</code>的<code>PRI</code>执行.</p><p>如果要改变一个已经启动的进程的优先级的话, 就要使用<code>renice</code>命令.</p><p>使用的效果就像是这样:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/renice.png" alt="renice">.</p><p>最后说一句:</p><blockquote><p>进程的优先级调整被用户发现的几率几乎为0, 优先级的调整更多是在嵌入式开发的上面. 所以,如果你不信仰玄学, 就不要随意修改优先级了.</p></blockquote><h2 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h2><p>工作管理指的是在单个登录终端中,同时管理多个工作的行为. </p><p>简单地说,就是放入后台.</p><p>想想在Windows下,放入后台其实就是指最小化, 那么为什么要最小化或者说放入后台呢?</p><p>很简单, 窗口挡着我们工作或者进行其他事了. 在Linux下类比就是占着终端了.</p><p>举个很简单的例子: <code>make</code>或者<code>make install</code>. 在执行完这个命令后,你是不是就被堵住了..? </p><p>但是工作也不能滥用:</p><ul><li>首先,放在后台的工作要是能运行一段时间的, 比如ls&#x2F;pwd这种, 你放在后台没有任何意义, 因为他们很快就执行完了.<ul><li>此外,后台的工作为了能够一直持续运行, 他不能与用户交互, 比如:vim, 把它放在后台同样没有意义, 因为它相当于是暂停了.</li></ul></li></ul><p>如何将一个命令放在后台工作呢?</p><p>有两种方法: 一个是在命令的末尾添加 <code>&amp;</code> 号(命令继续运行), 一个是在命令执行的过程中按下 <code>ctrl+z</code>.(会使得命令暂停)</p><p>接下来, 你就可以通过 <code>jobs -l</code> 来查看放入后台的工作和他们的PID号了.</p><p>来看这么一种情况:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.comjobs.png/" alt="jobs-top"></p><p>这两个top使用不同的方法进入后台, 一个是<code>ctrl+z</code>, 一个是<code>&amp;</code>, 可是神奇的是, 两个都是<code>stopped</code>的状态 ?</p><blockquote><p>补充: 看到+号-号了吗? 这个表明放入后台的次序, “+”号表明最近放入后台的工作, 而”-“表示倒数第二个, 恢复工作时会默认恢复”+”号也就是最近一个.</p></blockquote><p>原因很简单, 因为top命令的功能是将信息展示给前台, 并且提供与用户的交互(需要用户的介入). 放到后台就会直接停止.</p><p>那么如何将放在后台的工作放回到前台呢?</p><p>有这样的一组命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span> %n 放到后台 (将后台的Stopped的工作变为Running)</span><br><span class="line"><span class="built_in">fg</span> %n 放到前台 (将后台的工作拉回到前台).</span><br></pre></td></tr></table></figure><p>这里的n是指工作号 , 也就是<code>[ ]</code>里面的数字.</p><h2 id="脱离终端"><a href="#脱离终端" class="headerlink" title="脱离终端"></a>脱离终端</h2><p>假使,当我们在一个终端使用了<code>top</code>命令, 在另一个终端中我们使用<code>ps aux</code>就会看到这个进程, 那么,当第一个终端退出时, 这个<code>top</code>也将会被终止掉, 原因是因为终端在退出时, 会结束掉自己所有的进程(发送SIGHUP信号(?)), 但这并不是我们想要的, 如果这是数据库进程, 我们当然不希望它会伴随的终端的退出而结束, 所以, 这就需要脱离终端.</p><p>Linux提供三种方法:</p><ul><li>把要后台执行的命令加入到&#x2F;etc&#x2F;rc.local中</li><li>使用系统定时任务(下面会有)</li><li>使用nohup命令(标准方法)</li></ul><p>nohup是最常用的一种.</p><h2 id="查询系统资源"><a href="#查询系统资源" class="headerlink" title="查询系统资源"></a>查询系统资源</h2><blockquote><p>1.vmstat</p></blockquote><p>这个命令整合了进程,内存,交换分区,磁盘IO,系统,CPU负载情况.</p><p>vmstat [刷新延时 刷新次数] 这样的格式和<code>top</code>是很像的. 如果仅指定第一个参数, 那么<code>vmstat</code>将会一直输出下去.</p><p>例如:<code>vmstat 1 3</code></p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.comvmstat.png/" alt="vmstat"></p><p>这里有很多信息在之前的PS和TOP中都见过呢, 但仍然出现了一些没有见过的, 来说一下:</p><ul><li>procs: 进程信息字段</li><li>-r : 等待运行的进程数 ( ready? )</li><li>-b : 不可被唤醒的进程数量 ( 被阻塞(block)的进程  )</li><li>io: 磁盘读写的信息字段</li><li>b 表示block 块设备和系统的读入和写入, io的单位是kb</li><li>system : 系统信息字段 </li><li>in: 每秒被打断的的进程次数 (interrupt)</li><li>cs: 每秒进行的进程(上下文)切换次数 (switch)</li></ul><p>除了直接进行简单的表查看, 可以在<code>vmstat</code> 的后面加上<code>-s</code>来显示内存的统计数据.</p><p>vmstat也是一个很有年头的工具了, 一个更好用功能更强大的是<code>dstat</code>.</p><blockquote><p>2.dstat</p></blockquote><p>dstat支持很多信息的显示, 包括电池电量等等 并且 dstat支持插件机制, 这意味着dstat可以统计很多你原先想象不到的内容, 比如统计<code>MySQL</code>的连接 数据<code>IO</code>, <code>NFS</code>的各种状态, 无线网络的信号的强度, 邮件发送的队列情况等等.</p><p>在dstat后面加上数字表示的信息和以往不同. 这个数字表示dstat显示<strong>累积的</strong>间隔数据, 说人话就是显示出来的信息是这X秒的<code>summary</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-C 显示CPU信息 0, 3(哪一颗), total(所有的)</span><br><span class="line">-D total, sda(会列出单独的磁盘信息)</span><br><span class="line">-r 显示IO请求的统计数据</span><br><span class="line">-s 显示swapped相关的统计数据</span><br><span class="line">--ipc 进程间通信: 消息队列 信号量 共享内存 </span><br><span class="line">--tcp</span><br><span class="line">--udp</span><br><span class="line">--unix</span><br><span class="line">--raw</span><br><span class="line">--socket</span><br></pre></td></tr></table></figure><p>不加参数时, <code>dstat</code>会默认加上<code>-cdngy == -a</code>, 也就是输出: <strong>Cpu, Disk, Net, paGing, sYstem</strong>.</p><p><code>dstat</code>还有一个很强的功能, 那就是显示当前系统的<strong>最占用</strong>的进程是什么:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ dstat --top-cpu 最占用CPU的</span><br><span class="line">[root@WWW ~]$ dstat --top-mem 最占用内存的</span><br><span class="line">[root@WWW ~]$ dstat --top-io 最占用IO的进程</span><br><span class="line">[root@WWW ~]$ dstat --top-lantency 延迟最大的进程</span><br></pre></td></tr></table></figure><blockquote><p>3.dmesg</p></blockquote><p>这个命令可以查看开机信息.</p><blockquote><p>4.free</p></blockquote><p>查看内存使用状态.</p><p>在后面加: [-b|-k|-m|-g] 可以以不同的单位显示.(默认是-k)</p><p>这里要注意, free命令显示出的used不全是程序占用的, 其中还有buffer&#x2F;cache占用的, 所以真实的内存占用应该是free+buffer+cache.</p><blockquote><p>5.lsof</p></blockquote><p>列出进程打开或使用的文件信息.</p><ul><li>文件名 查询这个文件被什么进程调用</li><li>-c (char?)字符串 仅列出以字符串开头的文件</li><li>-u (user)用户名 只列出以某个用户的进程打开的文件</li><li>-p (pid)PID 列出某个进程打开的文件</li></ul><p>这个命令的输出内容是很多的. 最好加上<code>less</code>或者<code>more</code></p><blockquote><p>6.pmap</p></blockquote><p>pmap可以显示进程占用的页实际的物理地址以及其他一些信息</p><p>使用方法很简单, 直接在后面跟上进程的<code>PID</code>就好了. 选项几乎很少使用, 也就是一个<code>-x</code>用来显示详细格式的信息. </p><p>其实这个命令底层调用的文件就是<code>/proc/$PID/maps</code>这个文件. 所以另外一种实现就是直接<code>cat</code>这个文件</p><blockquote><p>7.glances</p></blockquote><p>glances是一个使用<code>python</code>实现的借由<code>python-psutil</code>库实现的一个系统监视工具,基于<code>C/S</code>架构, 可以通过套接字连接到其他的主机上来监视主机状态.</p><p>简单的看一下说明就可以上手了, 指令设计都很相像 </p><p>可以将结果输出成<code>HTML</code>格式的文档, 使用<code>-o</code>参数来指定文件类型<code>&#123;HTML,CSV&#125;</code> 首先要指定输出的文件夹: <code>-f &lt;folder&gt;</code></p><blockquote><p>8.其他</p></blockquote><ul><li>file &#x2F;bin&#x2F;ls 来判断系统位数</li><li>uname 略</li><li><del>lsb_release</del> CentOS7 已经没有了</li><li>uptime 查看运行时间 用户数 平均负载(w&#x2F;top的第一行) </li><li>cat &#x2F;proc&#x2F;cpuinfo 查看CPU的信息</li><li>cat &#x2F;proc&#x2F;meminfo</li></ul><h3 id="缓冲和缓存的区别"><a href="#缓冲和缓存的区别" class="headerlink" title="缓冲和缓存的区别"></a>缓冲和缓存的区别</h3><p>简单来说, 缓存(cache)是用来加速数据从硬盘中读取的, 而缓冲(buffer)是用来加速数据”写入”硬盘的.</p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>使用<code>at</code>来进行闹钟任务{我自己命的名 :)}</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ at now +2 minutes <span class="comment"># 两分钟后执行</span></span><br><span class="line">at&gt; ./date.sh &gt;&gt; ./date.log <span class="comment"># 执行内容</span></span><br><span class="line">at&gt; (ctrl+d 保存并退出)</span><br></pre></td></tr></table></figure><p>接着可以通过<code>atq</code>查看当前服务器上待执行的任务, 如果要进行删除操作, 执行<code>at</code>.</p><p>使用<code>at -c 工作号</code>来查看任务详情.</p><p>删除任务使用<code>at -d</code> 等价于<code>atrm</code> </p><p>设置时间,格式像这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HH:MM</span><br><span class="line">HH:MM YYYY-MM-DD</span><br></pre></td></tr></table></figure><p><code>at</code>还有一些模糊时间支持, 比如: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noon, midnight, teatime</span><br><span class="line">tomorrow</span><br></pre></td></tr></table></figure><p>有一个弱智版的<code>at</code>指令叫<code>batch</code>, 他会让系统自动进行选择执行时间(通常是在系统空闲的时候)</p><p>Crontab定时任务请参考这个 : </p><p><a href="http://yaoxuannn.com/2017/04/27/Crontab%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/#more">Crontab学习日志</a></p><h2 id="7-8的补充和更新"><a href="#7-8的补充和更新" class="headerlink" title="7.8的补充和更新"></a>7.8的补充和更新</h2><h3 id="再看看-x2F-proc-x2F"><a href="#再看看-x2F-proc-x2F" class="headerlink" title="再看看&#x2F;proc&#x2F;*"></a>再看看&#x2F;proc&#x2F;*</h3><p>现在都知道<code>/proc</code>是直接存在在内存中的, 每一个进程号对应的目录内包含的文件都是内存当中映射出来的.</p><p>现在就来好好了解一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/proc/cmdline 加载kernel的时候所执行的参数. 可以知道系统是怎么启动的.</span><br><span class="line">/proc/cpuinfo 本机的CPU参数, 包含频率 类型 和运算功能</span><br><span class="line">/proc/devices 记录了系统的主要设备的设备代号 也就是/dev/下看到的那些主设备号, 和<span class="built_in">mknod</span>有关</span><br><span class="line">/proc/filesystems 目前系统已经加载的文件系统</span><br><span class="line">/proc/interrupts 当前IRQ的分配状态</span><br><span class="line">/proc/ioports 当前系统上面各个设备的I/O地址</span><br><span class="line">/proc/kcore 内存(RAM)的大小 在64位的系统上表现为128TB, 这个是2的47次方(用户空间的大小)</span><br><span class="line">/proc/loadavg 不需要解释了吧, top/uptime等就是从这里获得的数值</span><br><span class="line">/proc/meminfo 内存使用信息</span><br><span class="line">/proc/modules 当前加载的模块信息, 也可以认为是驱动</span><br><span class="line">/proc/mounts 系统挂载的信息, 你会发现和mount命令是一样的输出</span><br><span class="line">/proc/swaps 系统加载的交换分区的信息</span><br><span class="line">/proc/partition 当前系统的分区情况</span><br><span class="line">/proc/pci 每个PCI总线上面的设备的详细情况.(但不知道为什么,在我的机子上没有这个文件, 但是使用lspci会看到结果, 原来是整合到了/proc/bus/下面了)</span><br><span class="line">/proc/uptime 和使用<span class="built_in">uptime</span>的输出结果是一致的</span><br><span class="line">/proc/version 内核的版本</span><br><span class="line">/proc/bus/* 一些总线的的设备, 还有USB的设备记录</span><br></pre></td></tr></table></figure><h3 id="谁动了我的文件"><a href="#谁动了我的文件" class="headerlink" title="谁动了我的文件 ?"></a>谁动了我的文件 ?</h3><p>在一些后台进程出现错误或者当执行某些命令的时候显示<code>device is busy</code> 就要看看到底是什么东西在占用次文件或设备. 如同在<code>Windows</code>下, 删除某些文件时候, 会报正在使用的异常, 此时就需要进行解锁类似.</p><p><code>Linux</code>下查看文件占用的命令有二: <code>fuser</code> 和 <code>lsof</code></p><p><strong>fuser</strong> 是通过文件查询正在使用该文件的程序.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ fuser [-umv] [-k [i] [signal]] file</span><br><span class="line">-u 不仅列出进程的PID, 还列出其所有者</span><br><span class="line">-m 将后面的文件名直接上提这个文件系统的最顶层, 对于umount很有效</span><br><span class="line">-v 可以显示具体的命令, 并且会美化格式</span><br><span class="line">-k 在找到之后直接给予SIGKILL</span><br><span class="line">-i 和 -k 配合, 询问是否执行</span><br><span class="line">-signal 默认是9号</span><br></pre></td></tr></table></figure><p>现在实际试一次:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ fuser -uv /etc</span><br><span class="line"><span class="comment"># 没有任何显示, 这是因为没有任何进程在使用/etc这个目录, 那/etc下的文件呢?</span></span><br><span class="line">[root@WWW ~]$ fuser -uvm /etc</span><br><span class="line">                     USER        PID ACCESS COMMAND</span><br><span class="line">/etc:                root     kernel mount (root)/</span><br><span class="line">                     root          1 .rce. (root)systemd</span><br><span class="line">...(omitted)</span><br><span class="line">                     root        578 Frce. (root)auditd</span><br><span class="line">                     polkitd     597 .rce. (polkitd)polkitd</span><br><span class="line">                     root        599 .rce. (root)systemd-logind</span><br><span class="line">                     dbus        605 .rce. (dbus)dbus-daemon</span><br><span class="line">                     chrony      607 .rce. (chrony)chronyd</span><br><span class="line">                     root        630 Frce. (root)firewalld</span><br><span class="line">                     root        631 .rce. (root)crond</span><br><span class="line">                     root        632 .rce. (root)atd</span><br><span class="line">                     root        748 .rce. (root)NetworkManager</span><br><span class="line">                     root       1023 Frce. (root)tuned</span><br><span class="line">                     root       1025 .rce. (root)sshd</span><br><span class="line">                     root       1026 Frce. (root)rsyslogd</span><br><span class="line">...(omited)</span><br></pre></td></tr></table></figure><p>这些字母代表的权限都是什么意思啊?</p><p><strong>c:</strong> 此进程在当前的目录下(非子目录)</p><p><strong>e:</strong> 可被触发成执行状态</p><p><strong>f:</strong> 是一个被打开的文件</p><p><strong>r:</strong> 代表顶层目录</p><p><strong>F:</strong> 该文件被打开了, 不过在等待回应中</p><p><strong>m:</strong> 可能被分享的动态函数库</p><p>另外一个比较常用的就是<code>lsof</code>了</p><p><code>lsof</code>是列出进程所打开的文件名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ lsof [-aUu] [+d]</span><br><span class="line">-a 多项数据需要同时成立的时候才显示出结果</span><br><span class="line">-U 仅列出Unix like系统的Socket文件类型</span><br><span class="line">-u 后面接username 列出该用户进程所打开的文件</span><br><span class="line">+d 目录文件, 找出某个目录下面的文件</span><br></pre></td></tr></table></figure><p>如果什么参数都没有加, 那么默认会输出所有的进程所打开的所有文件, 这样的输出量是可怕的.因此一般都是有目的的来查找的.</p><p>示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ lsof -u root -a -U</span><br><span class="line">COMMAND    PID USER   FD   TYPE             DEVICE SIZE/OFF  NODE NAME</span><br><span class="line">systemd      1 root   12u  unix 0xffff88003615e400      0t0 11206 /run/systemd/private</span><br><span class="line">systemd      1 root   20u  unix 0xffff8800365c8c00      0t0 11250 /run/lvm/lvmpolld.socket</span><br><span class="line">systemd      1 root   21u  unix 0xffff88003615fc00      0t0 11259 /run/systemd/shutdownd</span><br><span class="line">systemd      1 root   22u  unix 0xffff8801161ae800      0t0  6804 /run/systemd/notify</span><br><span class="line">systemd      1 root   23u  unix 0xffff8801161aec00      0t0  6806 /run/systemd/cgroups-agent</span><br><span class="line">....(omitted)</span><br><span class="line"><span class="comment"># 如果这里不加-a参数输出的结果是不一样的哦, 这是因为默认是取并集, -a表示取交集</span></span><br><span class="line">[root@WWW ~]$ lsof +d /dev</span><br><span class="line">COMMAND    PID    USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</span><br><span class="line">systemd      1    root    0u   CHR                1,3      0t0 4788 /dev/null</span><br><span class="line">systemd      1    root    1u   CHR                1,3      0t0 4788 /dev/null</span><br><span class="line">systemd      1    root    2u   CHR                1,3      0t0 4788 /dev/null</span><br><span class="line">systemd      1    root   28u  unix 0xffff8801161adc00      0t0 6829 /dev/log</span><br><span class="line">systemd      1    root   34r   CHR             10,235      0t0 6465 /dev/autofs</span><br><span class="line">kdevtmpfs   12    root  cwd    DIR                0,5     3040    3 /dev</span><br><span class="line">kdevtmpfs   12    root  rtd    DIR                0,5     3040    3 /dev</span><br><span class="line">systemd-j  473    root    0r   CHR                1,3      0t0 4788 /dev/null</span><br><span class="line">systemd-j  473    root    1w   CHR                1,3      0t0 4788 /dev/null</span><br><span class="line">systemd-j  473    root    2w   CHR                1,3      0t0 4788 /dev/null</span><br><span class="line">systemd-j  473    root    5u  unix 0xffff8801161adc00      0t0 6829 /dev/log</span><br><span class="line">systemd-j  473    root    6w   CHR               1,11      0t0 4794 /dev/kmsg</span><br><span class="line">systemd-j  473    root    9u   CHR               1,11      0t0 4794 /dev/kmsg</span><br><span class="line">lvmetad    488    root    0r   CHR                1,3      0t0 4788 /dev/null</span><br><span class="line">systemd-u  504    root    0r   CHR                1,3      0t0 4788 /dev/null</span><br><span class="line">auditd     576    root    0u   CHR                1,3      0t0 4788 /dev/null</span><br><span class="line">auditd     576    root    1u   CHR                1,3      0t0 4788 /dev/null</span><br><span class="line">auditd     576    root    2u   CHR                1,3      0t0 4788 /dev/null</span><br><span class="line">dbus-daem  596    dbus    0r   CHR                1,3      0t0 4788 /dev/null</span><br><span class="line">systemd-l  605    root    0r   CHR                1,3      0t0 4788 /dev/null</span><br><span class="line">systemd-l  605    root   17u   CHR                4,6      0t0 4808 /dev/tty6</span><br><span class="line">...(omitted)</span><br><span class="line"><span class="comment"># 会发现大量的进程都在使用/dev/null</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统基本原理(init)</title>
      <link href="/2017/06/26/Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2017/06/26/Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>简单了解一些Linux的系统原理(init), 等以后学了操作系统再来补充和更正吧~ 先来简单的了解知道个大概.</p><span id="more"></span><h2 id="操作系统的基本原理-Linux"><a href="#操作系统的基本原理-Linux" class="headerlink" title="操作系统的基本原理(Linux)"></a>操作系统的基本原理(Linux)</h2><p>先来在重复了无数遍的东西, 一个计算机由硬件做底层向上是: 操作系统(<code>内核 kernel</code>) , 由于直接的系统调用不适合编程, 所以有了诸多的库<strong>调用</strong>. 而调用就是使用&#x2F;载入别人写好的模块, 接着为了实现生产功能, 程序员面向这些库进行编程.当然也可以进行混合编程, 面对库和系统调用接口进行编程. 这就是我们静态看到的操作系统的状态.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/sys.png" alt="sys"></p><p>那么当系统运行起来, 程序在操作系统中跑起来的时候, 这又是什么状态呢.</p><p>之前说过, 当进行系统调用的时候<code>CPU</code>根据指令执行工作,而指令又分成不同等级的(普通指令–环3, 特权指令–环0), 一般特权指令都是直接对硬件进行的操作, 如果一个程序可以随便调用, 那岂不是就会大乱 ? 那么如果这些程序需要进行硬件管理的操作怎么办呢? 那就调用系统接口进行实现.  </p><p>这样指令排成队列一个一个的交给CPU去执行, 当出现了系统调用的时候, 程序就会等待内核将处理的结果交给程序. 那么此时 就要进行<strong>模式转换</strong>, 这是由程序发起的一次<strong>软中断</strong>实现的. 我们都知道操作系统划分为用户态和内核态, 或者叫模式吧, 那么在这次切换的时候, 程序运行就会从<code>用户模式 --&gt; 内核模式</code> . </p><p>那么现在来说说内核的功用: 进程管理, 文件系统, 网络功能, 内存管理, 驱动程序, 安全</p><p>当用户空间的程序需要用到以上这些功能的时候, 就要向内核发起调用来实现.</p><p>这样, 我们的<code>CPU</code>就在执行普通指令和特权指令的过程中来回切换, 这个过程就是上面说的<strong>模式切换</strong>.</p><p>事实上, 一般情况下, <code>CPU</code>是花费了更多的时间在用户模式的, 这因为只有用户模式的程序才具备生产能力.<code>(&gt;=70%)</code></p><p>我们都知道, <code>Linux</code>是可以同时执行多任务的系统. 但是一个单核<code>CPU</code>同时又只能执行一个任务, 这种是怎么实现的呢?</p><p>为了将有限的资源用在有着无限欲望的进程中, <code>CPU</code>采取了时间片的策略, 一个进程执行一段时间后就会执行另一个任务, 不管是否执行结束. 这样就会产生一个问题,有一些进程, 例如系统进程, 显然应该分配多点时间, 但一般的程序进程就不要占据太长时间了, 或者说, 多个进程在等待, 我该先走哪一个呢?</p><p>这样我们就给进程加了一个优先级的标签, 当然, 一个进程的优先级再高, 他也不能占据着<code>CPU</code>不放 . 因此, 内核使用它进程管理的功能, 如果一个进程占用<code>CPU</code>的时间过长, 内核就会直接将他踢下去, 接着从后面排队的进程中选择一个上来, 这时候的选择仍然是根据优先级, 谁的优先级高谁就被替补上来. \</p><p>在把一个进程踢下去的时候, 如果不对当前的进程进行执行上下文的状态进行保存, 那么下一次在再次执行的时候就又要从头再来了. 这些然是不合理的, 所以每一个进程在被切换下去的时候, 中间数据会放在<code>CPU</code>的寄存器中, 而指令指针永远指向下一个要执行的指令. 当再次执行到这个进程的时候, 就会进行<strong>恢复现场</strong>, 将数据再还回去.</p><p>这个切换的过程是需要占用<code>CPU</code>的资源的, 所以当太多时, <code>CPU</code>会浪费时间在切换上, 当然这个时间的消耗是难免的.</p><p>简单的理解, 进程是活动的实体, 运行中的程序的一个副本. 而程序就是一个静态的代码, 存在于磁盘上.</p><p>所以说进程是存在活动周期的,  内核对每一个进程创建了一个元数据, 存储了这个进程的种种信息. 存储进程的结构体叫做<code>task struct</code>, 这些结构体是以链表的形式存储的,最终形成<code>task list</code></p><p>在上面我们说用户代码是不能进行越权操作的, 但是谁也不能保证用户不会尝试编写这样的危险代码, 所以内核是有着非常严格的审查机制, 在不考虑漏洞的情况下, 任何时刻, 只要出现这样的越权情况出现, 中断被触发, <code>CPU</code>会立即唤醒内核.</p><p>行吧, 接下来就来看看怎么创建一个进程</p><p>像 上帝造人那样. 上帝并不想要关心人间事务, 于是他就仿造自己创造了亚当. 当系统启动时, 会先执行内核代码, 等待内核启动完毕时也就是内核接管一切的时候, 就由内核进行管理和调度 这就是第一个进程, 也就是过去<code>Linux</code>的总进程<code>init</code> 这个进程来创建子进程, 接着子进程会再创建子进程.</p><p>父进程创建子进程, 使用<code>fork()</code>来创建, 这个是<code>Linux</code>的一个系统调用接口. 而<code>fork()</code>之后又会克隆自己的数据到子进程中, 这是另一个系统调用<code>clone()</code>. 也就是说, 在创建的时候, 父进程和子进程共享一个内存空间, 这个时候子进程的数据和父进程是一模一样的, 只要子进程不会修改自己的数据, 他就永远和自己的父进程共享同一个内存空间, 如果一旦出现了子进程修改数据的时候,就会复制一个到另外的内存空间(基于<code>CoW</code>), </p><p>当进程被销毁的时候, 永远都是父进程存活而子进程死亡, 也就是<code>白发人送黑发人</code>.</p><p>在实际的执行过程中, 子进程正常执行而父进程就会进入睡眠, 直到子进程结束父进程收拾掉子进程的残存资源后就会继续执行自己了</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/pro.png" alt="pro"></p><p>接下来再说说优先级的优化问题. </p><p>进程存在优先级, 那么当有一千条进程在后面排队时, 因为在每一个结构体当中可以获取到每一个进程的优先级, 那么假设内核挨一个一个去查看, 就会进行完整的遍历, 那么当进程太多的时候就会变的很卡. </p><blockquote><p><strong>进程优先级</strong>:  </p><p><code>0-139</code>: </p><ul><li><code>1-99</code> : 实时优先级  ( 数字越大优先级越高 )</li><li><code>100-139</code>: 静态优先级  ( 数字越小优先级越高 )</li></ul></blockquote><blockquote><p>为了便于管理,  <code>Linux</code>给这个分配了<code>Nice</code>值, 这个值的范围区间是从<code>-20</code>-<code>19</code>, 对应上面的<code>100-139</code>.</p></blockquote><p>上面说过, 一个进程是一个结构体, 那么这个结构体是什么样的呢 ?</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/taskStr.png" alt="taskStr"> </p><ul><li>state 状态</li><li>thread_info 线程信息</li><li>flags 标志位</li><li>run_list tasks 任务列表</li><li>mm 栈内存结构</li><li>real_parent 真实的父进程</li><li>tty </li><li>fs files 文件描述符</li><li>signal 持有的信号</li><li>….</li></ul><p>而每一个功能又导向了一些子结构, 所以是十分复杂的.</p><p>重要的话先说, <strong>每一个进程所拥有的内存都是虚拟的</strong>. </p><p>物理内存只有一个, <code>CPU</code>只有一颗, 机器上有<code>n</code>个进程, 而且我们的进程不断的被创建和销毁, 也就意味着有内存不断的被分配和回收. 每一个进程在创建时, 都是内核在进行资源的分配, 由于不同进程对内存的大小是有区别的, 即使是同一个命令, 在数据不同的时候, 他所需要的内存也是不同的, (<code>e.g: cat anaconda-ks.cfg和cat /etc/service 后者会出现明显的卡顿</code>)  同样 内核也不知道该分给进程多少内存. 这个问题是这样解决的:</p><p>最初整个内存中一定存在的一段是属于内核的, 接着一段是要分配给其他的进程的:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/mem_alloc.png" alt="mem_alloc"></p><p>为了能够高效的分配内存, OS采取了这样的方法 :</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/page.png" alt="page"></p><p>将剩下的内存进行分页, 每一个页的大小是<code>4K</code>, 这样一个一个页的分配给进程, 如果不够就再分配,所以这些的进程的内存组成, 其实是一个一个页拼接起来的.接着, 内核将这些伪装成是一个连续的, 大段内存. 实际上呢, 是虚拟的. 不仅如此, 内核还向进程描绘了一个很棒的前景.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/fake.png" alt="fake"></p><p>每一个进程都以为除开内核就是自己, 其实实际上是用的时候在分配, 你用不到那么多就不给你, 也就是<strong>仅分配给所需要的</strong>. 每一个进程所分到的空间叫做<strong>线性地址空间</strong>, 而总共的内存叫做<strong>物理地址空间</strong>, 他们基本上是离散的对应的关系, 而这种映射关系由内核实现. 这种实现机制就叫做<strong>虚拟内存实现机制</strong>.</p><p> 一个进程的内存构成是这样的: </p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/struct.png" alt="struct"> </p><p>现在就来考虑一个进程的内存不够用了, 那么就要分配更多的内存给他. 内核开始在页中进行扫描, 使用<code>LRU</code>:最近最少使用算法. 一旦发现有页的使用最少, 就先把它挪出来, 当需要的时候就在把他给放回去, 但是这个时候, 回来的页已经不再是原来的那个了, 还记得上面说的进程的<code>task_struct</code>嘛, 这里面存放了映射关系的表, 在每一次进程访问内存的时候, 内核都要做一次转换, 将虚拟的指向物理上的. 这么一个过程由一个<code>CPU</code>上专门的硬件来负责, 叫做<code>mmu : Memory Management Unit</code> . 当一个进程被加载到内存上的时候, 我们就把这个映射关系放到<code>mmu</code>上进行实时的转换. 而进行分配的时候, <code>mmu</code>中的映射关系就要进行重新映射, 这个时候才能访问到真实的内存.</p><p>当进程访问的资源不在内存中的时候, 就要向内核发起调用请求从磁盘装载进内存,这个时候就发生了<strong>缺页异常</strong>. </p><p>尽管前面说过,  每一个进程都以为整个内存空间只有自己, 但是我们又需要进行进程间的通信(<code>IPC: Inter Process Communication</code>) 既然进程彼此不知道其他的存在, 那么我们怎么使他们进行通信啊? 如果是同一主机: 我们有多种方法, 共享内存 信号 信号量等等… 如果是不同主机进行进程间通信, <code>rpc: remote procecure call</code>远程进程调用 , <code>socket</code>套接字.</p><p><strong>Linux的内核多任务是抢占式的多任务</strong></p><p>Linux有多种进程类型: </p><ul><li>守护进程: 在系统引导过程中启动的进程, 跟终端无关的进程;</li><li>前台进程(交互式): 跟终端有关, 通过终端启动的进程.<ul><li>注意: 也可以把前台启动的进程送到后台, 以守护模式运行</li></ul></li></ul><p>接下来再来简单提一下 进程的状态</p><p>运行态: <code>running</code>  就绪态: <code>ready</code> 睡眠态: <code>sleep</code> ( 分为可中断和不可中断的 ) 停止态: 暂停于内存中 ,但不会被调度, 除非手动启动 僵死态: <code>zombie</code> </p><p>最后, 说说进程分类: </p><ul><li>CPU-Bound <code>cpu</code>密集型</li><li>IO-Bound <code>io</code>密集型</li></ul><p>一般都是交互式的进程偏<code>io</code>密集型的.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux程序包管理</title>
      <link href="/2017/06/21/Linux%E7%A8%8B%E5%BA%8F%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <url>/2017/06/21/Linux%E7%A8%8B%E5%BA%8F%E5%8C%85%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>令人头疼的程序包管理….学习笔记在此.</p><p><strong>来自未来的评论: 现在看来Linux的程序包管理是最轻松的, 比Mac, Windows好管理太多了</strong></p><span id="more"></span><h2 id="先扯扯别的"><a href="#先扯扯别的" class="headerlink" title="先扯扯别的"></a>先扯扯别的</h2><p>先来简单谈谈程序相关的一些小东西吧, 说一说为什么程序员写的代码可以在不同的操作系统上跑起来.</p><p>最底层当然就是硬件, 在往上一层是操作系统内核, 不同的操作系统的内核的操作是不同的, 同时也提供了不同的系统调用, 这样就会使得每一个系统自成一派, 为了解决这个问题, 在提供系统调用的基础上, 再封装一层接口, 使得程序员在写程序的时候, 只需要面向接口就好, 而不关心系统调用是什么样的, 这样当不同的操作系统的提供的接口都满足某个规范的时候就可以实现程序在不同的操作系统上都可以运行了.</p><p>这样的接口规范叫<code>POSIX</code> – <code>Portable OS</code> 便携式操作系统. 后面的<code>IX</code>是为了贴合<code>UNIX.LINUX</code>这样的命名规范罢了.</p><p>这样程序在源代码的级别上就是一样的了, 事实上所谓源代码文件只不过是一个文本文件罢了, 在经过预处理, 编译器做编译,形成目标代码,这样就可以通过汇编器做汇编成为机器码. 现在仍然不能运行, 因为很多程序是依赖库的. 这样就会产生两个分支, </p><ul><li><p>静态编译: </p></li><li><p>共享编译: *.so 共享对象</p><p>最后一步, 链接.</p></li></ul><p><code>Linux</code>下的可执行程序是<code>ELF</code>格式的(这里说的是格式,不是扩展名), 而<code>Windows</code>下的可执行文件是<code>EXE</code>格式的.</p><p>因此, 一旦编译成二进制格式后, 程序将会变得不兼容, 因此说, 源代码级别是相同的.  </p><p><code>Linux</code>下查看一个二进制程序依赖哪些库的命令是: <code>ldd</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Ubuntu:~$ ldd /bin/ls</span><br><span class="line">linux-vdso.so.1 =&gt;  (0x00007fff4ee35000)</span><br><span class="line">libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f99b26f7000)</span><br><span class="line">libacl.so.1 =&gt; /lib/x86_64-linux-gnu/libacl.so.1 (0x00007f99b24ef000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f99b2126000)</span><br><span class="line">libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f99b1ee8000)</span><br><span class="line">libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f99b1ce4000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00005560ba8de000)</span><br><span class="line">libattr.so.1 =&gt; /lib/x86_64-linux-gnu/libattr.so.1 (0x00007f99b1ade000)</span><br></pre></td></tr></table></figure><p>除了熟悉的<code>API(Application Programming Interface)</code>外, 还有一个叫做<code>ABI(Application Binary Interface)</code>.导致<code>Linux</code>下的程序在<code>Windows</code>下不能运行的原因就是这个<code>ABI</code> 不同. 程序在链接时就决定了是如何去寻找库的路径.</p><p>为了能跨平台的运行, 就有一种方法是库级别的虚拟化. 只要能解决库文件 以及文件格式的问题 就可以进行跨平台.</p><p><strong>Linux –[Wine] – Windows</strong></p><p><strong>Windows – [Cywin] – Linux</strong></p><p>在上一层, 为了实现跨平台, 那么就提供应用程序接口! 这个最典型的东西就是<code>Java</code>和<code>JVM</code>.</p><hr><p>系统级别的开发:</p><ul><li>C</li><li>C++</li><li>….</li></ul><p>应用级别的开发:</p><ul><li>Java</li><li>Python</li><li>PHP</li><li>perl</li><li>ruby</li><li>….</li></ul><p>二进制程序的组成部分:</p><p><strong>二进制文件, 库文件, 配置文件, 帮助文件</strong></p><p>这些文件都要放在一些目录下, 但是问题就出现了, 一个二进制程序, 我是放在<code>/bin</code>下还是<code>/sbin</code>下,还是<code>/usr/bin</code> ? <code>/usr/sbin</code> ? <code>/usr/local/bin</code> ? <code>/usr/local/sbin</code> ?</p><p>想象这样的情况. 一个程序有20个二进制, 10个库文件, 4个配置文件等等…难道每一个都要手工指定吗?</p><p>事实上, 最清楚程序内容该放在那里的人应该就是作者了. 然而又有些用户希望能够自己制定位置. 所以就想到, 将整个程序打包.</p><p>这样在加上一个程序包管理器, 就可以实现较傻瓜化的安装.</p><p>程序包管理器的好处有以下几点:</p><ul><li>能够记录程序的安装位置</li><li>卸载时能够追踪所有的目录, 不需要再记忆安装位置</li><li>自动进行安装, 该放哪就放哪.</li><li>可以方便的进行更新, 查询, 校验的操作.</li></ul><p>目前相对最早并且还存在的程序包管理器是<code>Debian</code>的, 程序包的安装格式为<code>deb</code> 这个管理器叫做<code>dpt</code>.</p><p>接着<code>redhat</code>也推出了自己的包管理工具, 叫做<code>rpm</code>, 其程序包的格式也是<code>rpm</code> 使用<code>perl</code>开发.</p><p>目前, <code>rpm</code>已经成为<code>Linux</code>的工业标准, 使用<code>C</code>语言进行了重新开发.</p><h2 id="程序包-RPM"><a href="#程序包-RPM" class="headerlink" title="程序包(RPM)"></a>程序包(RPM)</h2><blockquote><p>RPM is Package Manager.</p></blockquote><p>每一个RPM包都是要拿到源代码的, 接着将源代码<strong>制作</strong>成的.  分两种: 普通的<code>rpm</code>包, 源码<code>rpm</code>包 </p><p>源码的命名格式是: <code>name-VERSION.tar.gz</code></p><p><code>VERSION</code>的构成:  <code>major.minor.release</code> </p><p>主版本号不会轻易改变,除非是发生了翻天覆地的改变. </p><p>次版本号在添加了一个功能或者一些做了优化,以及功能的小改. </p><p>发行号也就是在修复一个<code>Bug</code>的时候会进行改变.</p><p><code>rpm</code>包的命名基本和源码包的格式相同: <code>name-VERSION-ARCH.rpm</code></p><p><code>VERSION</code>会和源码包的版本号一致 而<code>ARCH</code>是为了指明平台而存在的, 其命名的格式如下:</p><p><code>release</code>[这个是<code>RPM</code>的发行号,而不是程序的.].<code>os</code>.[el7…].<code>arch</code>[CPU架构,e.g: x86_64, i386, i686 …]</p><ul><li>noarch 表示任何硬件架构都可以运行</li></ul><p>如果一个程序的大部分功能是一般用户不需要的, 那么直接装上去的话, 会使得体积增大很多.</p><p>这个时候就想到进行拆包:</p><p><code>testapp-VERSION-ARCH.rpm</code> 主包</p><p><code>testapp-devel-VERSION-ARCH.rpm</code> 支包&#x2F;子包</p><p><code>testapp-plugin-filter-VERSION-ARCH.rpm</code> 子包的子包</p><p>支包是依赖于主包的, 因此在安装支包的时候, 应该先安装主包.</p><p>包之间, 存在依赖关系, 假设现在有, X, Y, Z 三个包. </p><blockquote><p>X &lt;- 依赖 &lt;- Y &lt;-依赖 &lt;- Z</p></blockquote><p>那么这样的话, 要安装 Z ,就要先安装 Y , 而安装 Y 就要先安装 X , 这样很有可能折腾一天, 连一个包都装不上.</p><p>为了解决这样的问题, 制作而成的程序包会有两个部分组成. 而整个程序包管理器也有两个部分组成.</p><p><strong>程序的组成清单 :</strong></p><p>由于rpm在展开前是看不到里面的内容的. 因此就把里面的内容记录在一个文件清单中.当想要获取rpm的内容时, 通过程序包管理器的接口访问这个文件就可以知道了. 这个文件清单每一个程序包独有.</p><p>除了清单文件, 还有一些安装和卸载的所用的脚本, 就比如说<code>nginx</code>在安装时是需要进行一次预配置的, 并且是以<code>nginx</code>的用户的身份来运行的, 如果系统中没有<code>nginx</code>用户, 那么脚本会自动的进行用户创建.</p><p><strong>数据库(公共)</strong>:</p><p>这个数据库中存放了程序包的名称和版本 依赖关系 功能说明 安装生成的文件路径以及校验码信息.</p><h2 id="管理程序包"><a href="#管理程序包" class="headerlink" title="管理程序包"></a>管理程序包</h2><h3 id="获取程序包"><a href="#获取程序包" class="headerlink" title="获取程序包"></a>获取程序包</h3><ul><li><strong>光盘</strong> : 最直接和最安全的方式就是使用光盘进行获取, 但是这样的程序包一般都是已经过时的.</li><li><strong>官方的FTP&#x2F;HTTP文件服务器</strong> : 虽然是经过验证并且是最较新的, 但是我们需要的包有可能官方不一定会收录进去.</li><li><strong>项目站点</strong> : 第三方软件的的官方站点的软件包</li><li><strong>第三方组织</strong> : 比如: <code>Fedora-EPEL</code>(最权威),  <code>REPL</code>..等等 , 由社区组织进行验证.</li><li><strong>自己制作</strong> : 算了吧.  : )</li></ul><p>一个可能会用到的网站: <a href="https://pkgs.org/"><strong>pkgs.org</strong></a></p><h3 id="CentOS的rpm"><a href="#CentOS的rpm" class="headerlink" title="CentOS的rpm"></a>CentOS的rpm</h3><p>现在就来学习使用rpm来进行包的管理.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ man rpm</span><br></pre></td></tr></table></figure><p>同大多数命令一样, <code>rpm</code>的<code>-v</code>和<code>-vv</code>参数, 是为了输出信息和大量调试信息. 先把这个说在最前面.</p><p>接着再说下<code>-h</code>, 这次不是显示帮助了, 而是以<code>Hash</code>的形式显示程序包的安装等等..的进度, 其实说白了就是用**#<strong>来画一个进度条. 一般来说, 一个</strong>#**表示<code>2%</code>的进度.</p><p>rpm的安装升级和卸载遵循相似的命令格式, 如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm &#123;-i|--install&#125; [install-options] PACKAGE_FILE ...</span><br><span class="line">rpm &#123;-U|--upgrade&#125; [install-options] PACKAGE_FILE ...</span><br><span class="line">rpm &#123;-F|--freshen&#125; [install-options] PACKAGE_FILE ...</span><br><span class="line">rpm &#123;-e|--erase&#125; [erase-options] PACKAGE_NAME ...</span><br></pre></td></tr></table></figure><p>使用<code>RPM</code>进行包安装时, 如果依赖关系检测失败, 则直接报错退出.</p><p>一些会用到的安装选项有:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[install-options]</span><br><span class="line">    --<span class="built_in">test</span>: 测试安装, 但是不执行真正的安装过程; dry run模式</span><br><span class="line">    --nodeps: 忽略依赖关系, 使用这个选项并不是一个理智的选择, 但在某些场景(循环依赖)下, 这个选项倒成为了一种解决办法, 更好的方法是一起安装.</span><br><span class="line">    --replacepkgs: 进行替换安装, 简单地说就是重装</span><br><span class="line">    --nodigest: 不检查包的完整性</span><br><span class="line">    --nosignature: 不检查来源合法性</span><br><span class="line">    --noscripts: 不执行程序包的脚本: --no$</span><br><span class="line">        %pre: 安装前的脚本</span><br><span class="line">        %post: 安装后的脚本</span><br><span class="line">        %preun: 卸载前的脚本</span><br><span class="line">        %postun: 卸载后的脚本</span><br></pre></td></tr></table></figure><p>对于升级, 有两种选项: 一个是**-U|–upgrade**, 一个是**-F|–freshen**, 使用前者进行更新的时候, 如果旧版本的程序包不存在, 而会直接进行安装, 而对于后者, 如果旧版的程序包不存在, 则什么都不会做.</p><p><strong>注意:</strong></p><p><strong>(1) 不要对Linux的内核进行升级, Linux是支持多内核版本共存的. 因此,直接安装新版本内核就好.</strong></p><p><strong>(2) 如果原程序包的配置文件被修改过, 升级时, 新版的配置不会覆盖老版本的配置文件, 新版本的配置文件会得到重命名, 一般叫做FILENAME.rpmnew而保留下来</strong></p><p>下面再来说说卸载. 在卸载是, 要先知道包的安装情况.</p><p>因此, 要先来谈谈包的查询.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ rpm &#123;-q|query&#125; [select-options] [query-options]</span><br><span class="line">[select-options]</span><br><span class="line">    -a: 获取本机安装的所有软件包</span><br><span class="line">    -f: 查看指定的文件是由那个程序安装生成的.</span><br><span class="line">[query-options]</span><br><span class="line">    --changelog: 查询rpm包的changlog.(更新日志)</span><br><span class="line">    -c: 列出该文件的软件包安装的所有的配置文件</span><br><span class="line">    -d: 列出该文件的软件包安装的所有的文档</span><br><span class="line">    -i: 输出该安装包的信息(几乎你所需要的常用信息都有, 很好用)</span><br><span class="line">    --scripts: 列出该安装包的所有脚本(4种, 如果有的话)</span><br><span class="line">    -l: 列出安装包安装的所有文件</span><br><span class="line">    -R: 查询指定程序包所依赖的CAPABILITY</span><br></pre></td></tr></table></figure><p>行了, 现在就来卸载安装的软件吧.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ rpm &#123;-e|--erase&#125; [--allmatches] [--justdb] [--nodeps] [--noscripts] [--notriggers] [--<span class="built_in">test</span>] PACKAGE_NAME ...</span><br><span class="line">--nodeps 忽略依赖关系, 默认如果有包依赖待删除的包的话会拒绝删除.</span><br></pre></td></tr></table></figure><p>删除软件包的细节不是很多. </p><p><code>rpm</code>的另一个很重要的功能是进行软件包的校验.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ rpm &#123;-V|--verify&#125; [select-options] [verify-options]</span><br><span class="line">[select-options]</span><br><span class="line">    <span class="comment"># 上面说过啦~</span></span><br><span class="line">[query-options]</span><br><span class="line">    <span class="comment"># 校验一个软件就是将软件包中已安装的文件信息和rpm数据库中存储的文件元信息进行对比.</span></span><br><span class="line">    <span class="comment"># 对比的信息有: 大小, 摘要, 权限, 类型, 所属等等..</span></span><br></pre></td></tr></table></figure><p>现在我们来试一试, 修改一个刚刚装好的<code>redis</code>的文件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ rpm -ql redis</span><br><span class="line">/etc/logrotate.d/redis</span><br><span class="line">...</span><br><span class="line">/usr/share/doc/redis-3.2.3/README.md</span><br><span class="line">...</span><br><span class="line">/var/run/redis</span><br><span class="line"><span class="comment"># 就拿这个README开刀.</span></span><br><span class="line">[root@WWW ~]$ <span class="built_in">echo</span> <span class="string">&quot;YOU&#x27;RE HACKED!!&quot;</span> &gt;&gt; /usr/share/doc/redis-3.2.3/README.md</span><br><span class="line">[root@WWW ~]$ rpm -V redis</span><br><span class="line">S.5....T.  d /usr/share/doc/redis-3.2.3/README.md</span><br></pre></td></tr></table></figure><p>输出了一段信息, 只要有信息就表示文件被修改过了. 前方的标记是指改变了哪些元素:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">S file Size differs 文件的大小</span><br><span class="line">M Mode differs (includes permissions and file <span class="built_in">type</span>) 文件权限改变</span><br><span class="line">5 digest (formerly MD5 <span class="built_in">sum</span>) differs 文件内容改变</span><br><span class="line">D Device major/minor number mismatch 设备文件主次设备号不匹配</span><br><span class="line">L readLink(2) path mismatch <span class="comment"># 不管他</span></span><br><span class="line">U User ownership differs 所属用户改变</span><br><span class="line">G Group ownership differs 所属组改变</span><br><span class="line">T mTime differs 时间戳改变</span><br><span class="line">P caPabilities differ</span><br></pre></td></tr></table></figure><p>根据上面的结果, 在校验时可以手工指定不检查的项目, 和上面一样, 直接<code>--noXXXX</code>就好了.</p><p>那么, <code>rpm</code>是如何实现包的合法性验证以及完整性验证呢?</p><p>软件包的完整性检验是很简单的, 只要软件包的两次计算的特征码没有出现改变, 就说明该包是完整的.</p><blockquote><p>说的明白点, 这个特征码其实就是作者在打包完成后进行的一次MD5计算, 并把这个计算得到的摘要值附在包的后面. 这样当以后检验的时候, 就使用同样的方法进行一次摘要计算.</p></blockquote><p>但事实上, 这种方法并不是很好, 因为你并不能确定这个包后的MD5摘要是作者本人提供的.任何人都可以进行篡改. 所以现在的网站上采取的都是将正确的摘要计算结果放在页面上. 接着只要用户自己进行比对就好了, 这样的策略使得只有当对方网站遭到了入侵的时候才会变的不可靠.</p><p>但是这样也不是很好, 每次我下载完成文件都要手动去进行校验,  而且对方网站被入侵的可能性也是存在的.</p><p>那么有更好的方案吗?</p><p>简单的, 只要把最初附在包最后面的特征码进行一次加密就好了, 这样用户先进行解密就好了. 但是, 为了解密得到特征码, 必须先知道密码, 这样岂不是就会造成密码满天飞的情况了吗? 这里使用到了的技术就是熟悉的公钥加密技术, 是非对称加密的一种.</p><p>一般来说, 包的完整性检验是使用的SHA256,而来源合法性是通过RSA进行的加密.</p><p>如果手中已经有了密钥文件使用<code>rpm --import &lt; KEY_FILE &gt;</code>;</p><p>那么<code>rpm</code>的数据文件都保存在哪里呢? 之前说过<code>/var/lib/</code>是保存程序运行状态的目录, <code>rpm</code>也不例外,在<code>/var/lib</code>下有<code>rpm</code>的目录文件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW 17:22 [115]/var/lib/rpm]$ <span class="built_in">ls</span></span><br><span class="line">Basenames  Conflictname  __db.001  __db.002  __db.003  Dirnames  Group  Installtid  Name  Obsoletename  Packages  Providename  Requirename  Sha1header  Sigmd5  Triggername</span><br></pre></td></tr></table></figure><p>这些其实就是<code>rpm</code>的数据文件, 从名字也可以看出来有: 软件包的依赖, 触发器, <code>md5</code>校验码等等…</p><p>这些就是<code>rpm</code>用来做缓存的., 如果在安装包或者卸载包的时候加了<code>-vv</code>的参数, 就看到<code>rpm</code>打开和关闭数据库的操作.</p><p>一旦数据文件遭到了破坏(因为是文件), 那么我们的查询种种操作就会失败, 这个时候就要进行数据库的重建.</p><p>两个指令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ rpm &#123;--initdb|--rebuilddb&#125;</span><br><span class="line">    --initdb: 初始化</span><br><span class="line">        如果事先不存在数据库, 则会新建, 否则不会执行任何操作.</span><br><span class="line">    --rebuilddb: 重建</span><br><span class="line">        无论当前存在与否, 直接进行数据库的建立.</span><br></pre></td></tr></table></figure><h2 id="管理程序包工具YUM"><a href="#管理程序包工具YUM" class="headerlink" title="管理程序包工具YUM"></a>管理程序包工具YUM</h2><p> <code>yum</code>(<code>Yellowdog Update Modifier</code>)是<code>CentOS</code>上的一个软件包安装的前端工具(C&#x2F;S架构), 它的工作前提是需要联网, 其实需要连接一个拥有巨大空间的文件服务器,这个服务器中包含了大量的<code>rpm</code>包. 而这样的服务器在网络上有很多,因此需要在配置文件中指定<code>yum</code>要访问的服务器地址.</p><p><code>yum</code>的工作原理简单说是这样的: 当用户要安装程序包的时候, <code>yum</code>接收到用户的指令, 这个时候YUM会尝试寻找本地指向的有程序包的文件服务主机的地址, 这个地址从配置文件中读取, 接着找到了之后, 而远方服务器会有仓库(repository)来存储程序包和一个描述信息(包之间的依赖关系, 包的版本等等信息), 接着<code>yum</code>从服务器上把这个文件下载下来, 放在自己的一个缓存区内. </p><p>接着读取这个文件中是否有用户请求的包的信息, 接着还会自动的解析这个文件中对于依赖关系的描述.(查询本地已安装过的包, 将依赖并且没有安装的包列出来) 接着就启动一个文件服务器的客户端, 向远方的服务器请求下载相应的包文件. </p><p>同样也是放在本地, 接着就进行安装, 安装完成后就会将这些缓存中的包删除. 但是这个元数据不会被删除. 如果每一次使用都要进行下载, 那岂不是很蠢? 但是如果服务器端的程序包进行了更新, 我怎么知道呢 ? 很简单, 远方服务器会有一个文件单独存放这个元数据文件的校验码.那么<code>yum</code>每次只要进行对这个校验码的请求就可以知道是否需要进行更新元数据文件.</p><p>在寻找远端服务器的时候, <code>yum</code>可以基于插件进行加载远端服务器的镜像, 这样就可以一个仓库, 执行多个服务器.<code>yum</code>会优先加载最近的服务器节点.</p><p><code>yum</code>面临的最大的问题是, 程序包安装过程中, 如果发生错误而导致中断, 产生的后果将是不可逆的, 无法修复.因此现在的趋势开始导向<code>dnf</code> [ 不是地下城 :) ] 这个工具, 但是现在<code>CentOS7</code>官方还没有明确的宣布, 所以还是先来学习下<code>yum</code>,  但实际上, 他们两人的命令是很相像的.</p><h3 id="进入yum的世界"><a href="#进入yum的世界" class="headerlink" title="进入yum的世界"></a>进入yum的世界</h3><p>yum的一个重要组成部分就是yum仓库(repository), 这个仓库中存储了大量的rpm包以及包的相关元数据信息文件(放置在特定的目录下: repodata) 这个目录的位置, 就是我们指定<code>yum</code>仓库的位置</p><p><code>yum</code>支持的文件服务器有: </p><ul><li><strong>ftp:&#x2F;&#x2F;</strong> </li><li><strong>http:&#x2F;&#x2F;</strong></li><li><strong>nfs:&#x2F;&#x2F;</strong></li><li><strong>file:&#x2F;&#x2F;</strong></li></ul><p>由于yum也是一个由安装包安装的软件, 所以我们也就可以用上面的rpm命令查看yum生成的相关文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ rpm -qc yum</span><br><span class="line">/etc/logrotate.d/yum <span class="comment"># 日志滚动文件</span></span><br><span class="line">/etc/yum.conf <span class="comment"># 主配置文件, 文件内引用了 /etc/yum.repos.d/*.repo </span></span><br><span class="line">/etc/yum/version-groups.conf <span class="comment"># 跟yum本身的关系不大</span></span><br></pre></td></tr></table></figure><p>yum的主配置文件<code>/etc/yum.conf</code>包含了<code>/etc/yum.repos.d/*.repo</code>. 大的<code>/etc/yum.conf</code>配置了yum所有仓库的公共配置, 而每一个<code>*.repo</code>文件就是配置的每一个仓库的地址等信息. 一个<code>yum</code>是可以指定多个仓库的, 在安装时会自动从这些仓库中选择出最新的版本. </p><p>下面来解析一下yum的公共配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line">cachedir=/var/cache/yum/<span class="variable">$basearch</span>/<span class="variable">$releasever</span></span><br><span class="line">keepcache=0 <span class="comment"># 是否保存缓存</span></span><br><span class="line">debuglevel=2</span><br><span class="line">logfile=/var/log/yum.log <span class="comment"># 日志记录的位置</span></span><br><span class="line">exactarch=1 <span class="comment"># 是否精确严格匹配硬件架构</span></span><br><span class="line">obsoletes=1 <span class="comment"># 用于更新的处理逻辑</span></span><br><span class="line">gpgcheck=1 <span class="comment"># 是否进行验证检查</span></span><br><span class="line">plugins=1 <span class="comment"># 是否启用插件</span></span><br><span class="line">installonly_limit=5 <span class="comment"># 最大的并行安装数</span></span><br><span class="line">bugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&amp;ref=http://bugs.centos.org/bug_report_page.php?category=yum</span><br><span class="line">distroverpkg=centos-release <span class="comment"># 当前的发行版</span></span><br></pre></td></tr></table></figure><p>很简单吧, 其实这个配置文件时有手册的, yum还支持很多选项的, 例如ssl验证, 代理隧道的配置, 很多.</p><p>而每一个仓库自己的配置文件长这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[epel] <span class="comment"># 这里的id应该是唯一标识</span></span><br><span class="line">name=EPEL <span class="keyword">for</span> redhat/centos <span class="variable">$releasever</span> - <span class="variable">$basearch</span> <span class="comment"># 仓库名称*</span></span><br><span class="line">baseurl=http://mirrors.tencentyun.com/epel/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/ <span class="comment"># 访问路径* 指向repodata</span></span><br><span class="line">failovermethod=priority <span class="comment"># 故障转移方法: 多个URL下, 如果坏掉了, 怎么处理.</span></span><br><span class="line"><span class="comment"># 两种选项: roundrobin 和 priority</span></span><br><span class="line"><span class="comment"># roundrobin 虽说是轮询吧, 但其实是失败后进行随机的选择, 默认值</span></span><br><span class="line"><span class="comment"># priority 按照优先级进行选择</span></span><br><span class="line">enabled=1 <span class="comment"># 是否启用本仓库  (好蠢的选项.</span></span><br><span class="line">gpgcheck=1 <span class="comment"># 是否进行检查来源和合法性.</span></span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7 <span class="comment"># 提供一个url, 指向一个密钥文件</span></span><br><span class="line"><span class="comment"># 加星号的两个是最重要的,其他的都是不太重要的可选项 注意=号两侧一定不能出现空格, 否则可能会出现迷之错误</span></span><br><span class="line"><span class="comment"># baseurl是可以指定多个的, 之前说过</span></span><br><span class="line"><span class="comment"># 还有一个重要的配置叫做mirrorlist, 这个指向一个文件, 指向的文件包含了一个url列表, 其实就是一大把baseurl.</span></span><br><span class="line"><span class="comment"># cost 也有可能会用到, 默认是1000 表示开销.</span></span><br></pre></td></tr></table></figure><p>随便找一个镜像站点(阿里云,网易,各种高校), 可以很轻易的找到<code>repodata</code>目录文件, 原来是<code>xml</code>啊, 看过你就知道我在说什么了, 嘻嘻 : )</p><p>之前说我觉得这个<code>enable</code>选项是个很蠢的选项, 其实不是, 因为你可以在一个文件中指定多个<code>repo</code>, 这时这个选项就派上用场了.</p><h3 id="yum的基本使用-1"><a href="#yum的基本使用-1" class="headerlink" title="yum的基本使用(1)"></a>yum的基本使用(1)</h3><p>yum的命令格式是下面这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum [options] [<span class="built_in">command</span>] [package ...]</span><br></pre></td></tr></table></figure><p>yum也是有很多的子命令以实现不同的管理: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">* install package1 [package2] [...] <span class="comment"># 安装包</span></span><br><span class="line">* update [package1] [package2] [...]</span><br><span class="line">* update-to [package1] [package2] [...]</span><br><span class="line">* update-minimal [package1] [package2] [...]</span><br><span class="line">* check-update</span><br><span class="line">* upgrade [package1] [package2] [...]</span><br><span class="line">* upgrade-to [package1] [package2] [...]</span><br><span class="line">* distribution-synchronization [package1] [package2] [...]</span><br><span class="line">* remove | erase package1 [package2] [...]</span><br><span class="line">* autoremove [package1] [...]</span><br><span class="line">* list [...] <span class="comment"># 列出所有的程序包, 凡是最后一栏加上@符号的, 就是已经安装过的.anaconda表示在系统安装的时候就安装的包</span></span><br><span class="line">    * available</span><br><span class="line">    * updates</span><br><span class="line">    * installed</span><br><span class="line">* info [...]</span><br><span class="line">* provides | whatprovides feature1 [feature2] [...]</span><br><span class="line">* clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]</span><br><span class="line">* makecache [fast]</span><br><span class="line">* <span class="built_in">groups</span> [...]</span><br><span class="line">* search string1 [string2] [...]</span><br><span class="line">* shell [filename]</span><br><span class="line">* reinstall package1 [package2] [...]</span><br><span class="line">* downgrade package1 [package2] [...]</span><br><span class="line">* deplist package1 [package2] [...]</span><br><span class="line">* repolist [all|enabled|disabled]</span><br><span class="line">* repoinfo [all|enabled|disabled]</span><br><span class="line">* repository-packages &lt;enabled-repoid&gt; &lt;install|remove|remove-or-reinstall|remove-or-distribution-synchronization&gt; [package2] [...]</span><br><span class="line">* version [ all | installed | available | group-* | nogroups* | grouplist | groupinfo ]</span><br><span class="line">* <span class="built_in">history</span> [info|list|packages-list|packages-info|summary|addon-info|redo|undo|rollback|new|<span class="built_in">sync</span>|stats]</span><br><span class="line">* load-transaction [txfile]</span><br><span class="line">* updateinfo [summary | list | info | remove-pkgs-ts | exclude-updates | exclude-all | check-running-kernel]</span><br><span class="line">* fssnapshot [summary | list | have-space | create | delete]</span><br><span class="line">* fs [filters | refilter | refilter-cleanup | <span class="built_in">du</span>]</span><br><span class="line">* check</span><br></pre></td></tr></table></figure><p>这些命令…其实都有可能会用到…我尽量用简洁的语言描述一下&#x2F;&#x2F;.</p><p>列出信息类的命令有这些:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum repolist [all|enabled|disabled] <span class="comment"># 列出目前的仓库. 建议加上all参数, 这样可以看到每一个仓库的启用状态. </span></span><br><span class="line">[root@WWW ~]$ yum repoinfo [all|enabled|disabled] <span class="comment"># 列出当前仓库的信息, 版本, 大小, 日期等等...</span></span><br><span class="line">[root@WWW ~]$ yum list [...] <span class="comment"># 列出所有的程序包, 凡是最后一栏加上@符号的, 就是已经安装过的.anaconda表示在系统安装的时候就安装的包</span></span><br><span class="line">  <span class="comment"># available 当前没有安装但是仓库有提供的包</span></span><br><span class="line">  <span class="comment"># updates 有更新的包</span></span><br><span class="line">  <span class="comment"># installed 已经安装在系统的包</span></span><br></pre></td></tr></table></figure><p>接下来就是进行安装工作了: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum install package1 [package2] [...] <span class="comment"># 安装包, 一次可以安装多个包.</span></span><br><span class="line"><span class="comment"># 安装时, 可以在后面跟上应用的版本号以安装不同版本</span></span><br></pre></td></tr></table></figure><p>升级也很简单了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum update [package1] [...] <span class="comment"># 可以指明包名, 也可以不指明要单独升级哪一包, 而升级所有可能的包.</span></span><br></pre></td></tr></table></figure><p>与升级相反过来(<strong>降级</strong>)的指令是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum downgrade package1 [package2] [...]</span><br></pre></td></tr></table></figure><p>如果要检查可用的升级使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum check-update</span><br></pre></td></tr></table></figure><p>接下来就是进行程序包的卸载啦:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum remove|erase package1 [package2] [...]</span><br></pre></td></tr></table></figure><p>那么安装完的程序包,我如何像<code>rpm</code>那样查看程序的信息呢 ?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum info [...] <span class="comment"># 这里是可以不用指定具体的包名从而输出所有的包的信息...相信没有人会这样查询吧..</span></span><br><span class="line"><span class="comment"># 因此如果是一般的查询的话, 建议还是加上包的名字吧.</span></span><br><span class="line">[root@WWW ~]$ yum info gcc</span><br><span class="line">Installed Packages</span><br><span class="line">Name        : gcc &lt;--- 包名</span><br><span class="line">Arch        : x86_64 &lt;--- 需要的硬件架构</span><br><span class="line">Version     : 4.8.5 &lt;--- 版本</span><br><span class="line">Release     : 11.el7 &lt;--- rpm的版本</span><br><span class="line">Size        : 37 M &lt;--- 大小</span><br><span class="line">Repo        : installed &lt;--- 仓库类别</span><br><span class="line">From repo   : os &lt;--- 来源仓库</span><br><span class="line">Summary     : Various compilers (C, C++, Objective-C, Java, ...) &lt;--- 简述</span><br><span class="line">URL         : http://gcc.gnu.org</span><br><span class="line">License     : GPLv3+ and GPLv3+ with exceptions and GPLv2+ with exceptions and LGPLv2+ and BSD</span><br><span class="line">Description : The gcc package contains the GNU Compiler Collection version 4.8.</span><br><span class="line">            : You<span class="string">&#x27;ll need this package in order to compile C code.</span></span><br></pre></td></tr></table></figure><p>是不是感觉怪怪的. 其实<code>rpm -qi</code>所输出的信息是更加有用的啊, 因为中间有包的安装时间等等<code>yum</code> 所不能输出的信息, 因此我推荐使用<code>rpm</code> 进行查询.</p><p>查询子程序(或特性)来源于哪一个软件包, 这一个功能个人感觉<code>yum</code>要优于<code>rpm</code>呐.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum provides redis-cli</span><br><span class="line">redis-3.2.3-1.el7.x86_64 : A persistent key-value database</span><br><span class="line">Repo        : epel</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /usr/bin/redis-cli</span><br><span class="line"></span><br><span class="line">redis-3.2.3-1.el7.x86_64 : A persistent key-value database</span><br><span class="line">Repo        : @epel</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /usr/bin/redis-cli</span><br><span class="line"><span class="comment"># 你看yum告诉我们了, 这个redis-cli来源于哪一个软件包, 以及当前的安装情况. 即使当前的系统没有安装这个程序, yum仍然可以把这个包给抓出来.</span></span><br><span class="line"><span class="comment"># 还记得之前说过的ip的一大堆子命令吗. 试一试ss</span></span><br><span class="line">[root@WWW ~]$ yum provides ss</span><br><span class="line">iproute-3.10.0-74.el7.x86_64 : Advanced IP routing and network device configuration tools</span><br><span class="line">Repo        : os</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /usr/sbin/ss</span><br><span class="line"></span><br><span class="line">iproute-3.10.0-74.el7.x86_64 : Advanced IP routing and network device configuration tools</span><br><span class="line">Repo        : @os</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /usr/sbin/ss</span><br></pre></td></tr></table></figure><p><code>yum</code>的这个功能等价于<code>rpm</code>的<code>-qf</code>选项, 但是<code>yum</code>是不需要指定具体的路径的, 而<code>rpm</code>是不会从<code>$PATH</code>中寻找的. 而且<code>yum</code>输出的信息要更多.</p><p>由于查询逻辑不一样( <code>rpm</code>有本地的限制 ), 所以再次推荐使用<code>yum</code>的这个功能而不是<code>rpm -qf</code>.</p><p>接下来是一个清理本地缓存的指令, 之前说过yum会将下载的元数据和程序包都缓存到本地, 在程序安装完成之后就会将程序的rpm包删除, 但是元数据会保留下来.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum clean [ package | metadata | expire-cache | rpmdb | plugins | all ]</span><br></pre></td></tr></table></figure><p>反过来, 如果想要手动进行一次缓存的重建的话, 使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum makecache</span><br></pre></td></tr></table></figure><p>其实这个就是手动进行一次下载, 其实就是在<code>yum</code>每一次下载都会进行一次缓存的重建, 因此没有必要频繁的进行手动的重建.</p><p>在我们进行软件包的下载的时候, 还有一个经常要进行的操作就是<strong>搜(shou)索(shuo)</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum search string [string2]</span><br></pre></td></tr></table></figure><p>匹配是进行的是模糊匹配, 会同时搜索程序包名和<code>summary</code>信息</p><p>很简单, 类似rpm的<code>replace</code>, yum也有一个重新安装的功能, 直接见名知意</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum reinstall package1 [package2] [...]</span><br></pre></td></tr></table></figure><p><code>yum</code>同样也可以查看一个包的依赖有哪些, 并且要比<code>rpm</code>看到的要更好看.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum deplist package1 [package2] [...]</span><br></pre></td></tr></table></figure><p>yum是支持事务的, 因此我们也可以查看这些记录, 这个就是yum的history功能:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum <span class="built_in">history</span></span><br><span class="line">ID     | Command line             | Date and time    | Action(s)      | Altered</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">    64 | remove pptpd             | 2017-06-18 10:43 | Erase          |    1 EE</span><br><span class="line">    63 | install redhat-lsb       | 2017-06-16 16:10 | Install        |   74   </span><br><span class="line">    62 | remove vim vim-tiny vim- | 2017-06-10 01:23 | Erase          |    1 EE</span><br><span class="line">    61 | install -y ruby ruby-dev | 2017-06-10 01:23 | Install        |   39   </span><br><span class="line">    60 | update                   | 2017-06-10 01:17 | I, O, U        |   41   </span><br><span class="line">    59 | install python-devel     | 2017-06-10 01:16 | Install        |    1   </span><br><span class="line">    58 | install libncurses5-dev  | 2017-06-10 00:15 | Install        |    1   </span><br><span class="line">    57 | remove vim vim-runtime g | 2017-06-10 00:13 | Erase          |    1   </span><br><span class="line">    56 | install ctags            | 2017-06-09 17:54 | Install        |    1   </span><br><span class="line">    55 | update                   | 2017-05-27 12:26 | Update         |    3   </span><br><span class="line">    54 | install redis.x86_64     | 2017-05-21 22:55 | Install        |    2   </span><br><span class="line">    53 | install tcl              | 2017-05-21 14:35 | Install        |    1   </span><br><span class="line">    52 | install privoxy          | 2017-05-20 17:20 | Install        |    1  </span><br></pre></td></tr></table></figure><p>上面的history后面可以跟上很多的参数:</p><p><code>[info|list|packages-list|packages-info|summary|addon-info|redo|undo|rollback|new|sync|stats]</code></p><p>默认的参数是<code>list</code>, 其实这个功能用的不是很多啦.</p><p>继续说<code>yum</code>的事务功能, 当你终止一个正常的安装或者卸载或者凡是涉及到事务的操作时, <code>yum</code>会生成一个事务文件, 保存在<code>/tmp/*.yumtx</code></p><p>这样就随时可以进行回复:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package zsh.x86_64 0:5.0.2-25.el7_3.1 will be erased</span><br><span class="line">--&gt; Finished Dependency Resolution</span><br><span class="line">......</span><br><span class="line">Is this ok [y/N]: </span><br><span class="line">Exiting on user <span class="built_in">command</span></span><br><span class="line">Your transaction was saved, rerun it with:</span><br><span class="line"> yum load-transaction /tmp/yum_save_tx.2017-06-24.16-09.HQGAUR.yumtx</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">[root@WWW ~]$ yum load-transaction /tmp/yum_save_tx.2017-06-24.16-09.HQGAUR.yumtx</span><br><span class="line">...</span><br><span class="line">Is this ok [y/N]: y</span><br><span class="line">Downloading packages:</span><br><span class="line">Running transaction check</span><br><span class="line">Running transaction <span class="built_in">test</span></span><br><span class="line">Transaction <span class="built_in">test</span> succeeded</span><br><span class="line">Running transaction</span><br><span class="line">  Erasing    : zsh-5.0.2-25.el7_3.1.x86_64</span><br><span class="line">  Verifying  : zsh-5.0.2-25.el7_3.1.x86_64</span><br><span class="line">Removed:</span><br><span class="line">  zsh.x86_64 0:5.0.2-25.el7_3.1                                                                                                                                            </span><br></pre></td></tr></table></figure><h3 id="yum的包组管理"><a href="#yum的包组管理" class="headerlink" title="yum的包组管理"></a>yum的包组管理</h3><p>yum支持一个独特的功能, 叫<strong>组管理</strong>.</p><p>说白了其实就是软件大礼包, 直接安装一个组就是将这个组内所有的包执行安装.</p><p>对组的操作和对单个软件包的操作基本类似, 命令也基本通用, 只要在前面加上<code>groups</code>就行了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ yum <span class="built_in">groups</span> info</span><br><span class="line">[root@WWW ~]$ yum <span class="built_in">groups</span> install</span><br><span class="line">[root@WWW ~]$ yum <span class="built_in">groups</span> list</span><br><span class="line">[root@WWW ~]$ yum <span class="built_in">groups</span> remove</span><br><span class="line">[root@WWW ~]$ yum <span class="built_in">groups</span> summary</span><br></pre></td></tr></table></figure><h3 id="yum的基本使用-2"><a href="#yum的基本使用-2" class="headerlink" title="yum的基本使用(2)"></a>yum的基本使用(2)</h3><p>现在我们拿到了一张CnetOS的光盘, 如何将这张光盘当成我们的本地<code>yum</code>仓库呢?</p><ul><li>挂载光盘到某目录<ul><li><code>mount -r -t iso9660 /dev/cdrom /media/cdrom</code></li></ul></li><li>创建配置文件<ul><li><code>[CentOS7]</code></li><li><code>name = </code></li><li><code>baseurl = </code></li><li><code>gpgcheck = </code></li><li><code>enabled = </code></li></ul></li></ul><p>其实在命令行中也可以进行配置文件的编写, 例如: <code>--nogpgcheck</code></p><p><code>yum</code>的命令行选项:</p><p> <code>-y</code> : 自动回答为<code>Yes</code></p><p><code>-q</code> : 静默模式, 不会有输出</p><p><code>--disablerepo=repoidglob</code> : 临时禁用此处指定的<code>repo</code> </p><p><code>--enablerepo=repoidglob</code> : 临时启用此处指定的<code>repo</code></p><p><code>--noplugins</code> : 禁用所有的插件</p><hr><p>在上面的配置文件的章节中 我们发现了一些以<code>$</code>开头的字符, 这些其实就是变量了.</p><p>yum的repo的配置中的可用的变量有: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$releasever</span>: 当前OS的发行版中主版本号</span><br><span class="line"><span class="variable">$arch</span>: 平台 ( i386, i586, i686 ... )</span><br><span class="line"><span class="variable">$basearch</span>: 基础平台 ( x86, x86_64, ... )</span><br><span class="line"><span class="variable">$YUM0</span>-<span class="variable">$YUM9</span>: 自定义变量</span><br></pre></td></tr></table></figure><p>这样就拼成了我们看到的<code>URL</code>: <code>http://mirrors.scuec.edu.cn/centos/$releasever/$basearch/os</code></p><h2 id="编译安装程序包"><a href="#编译安装程序包" class="headerlink" title="编译安装程序包"></a>编译安装程序包</h2><p>上面再说rpm的时候, 提到过有两种rpm包, 其中有一种是源码rpm包, 这种包的命名是这样的:</p><p><code>testapp-VERSION-release.src.rpm</code></p><p>这个src就是source的意思, 这个包内是不含二进制格式的输出的, 只有源码, 也就是这个需要我们手动进行编译. 安装后使用<code>rpmbuild</code>命令制作成二进制的<code>rpm</code>包, 而后就可以进行安装了. </p><p>之所以需要这样的包, 是因为并没有考虑到操作系统, 实际也就是CPU的架构. 这样就可以根据本机实际的情况编译出适合自己(CPU的指令集)的二进制包,. 从命名中也可以发现了, 这个包中并没有<code>arch</code>这个部分.</p><p>而这样一个过程也已经在上面说过了, 再重复一遍吧:</p><p><code>源代码 --&gt; 预处理 --&gt; 编译(gcc) --&gt; 汇编 --&gt; 链接 --&gt; 执行</code></p><p>现在我们来想这么一个问题, 一个程序的源文件肯定是很多部分组成的,而且这些文件很可能是存在依赖关系的, 那么在编译的时候我该优先编译哪一个呢? </p><p>这就是我们源代码的组织结构, 多文件组织. 显然我们不能就直接进行一个一个的<code>gcc</code>, 那么就需要一个项目管理工具, 就比如说<code>Java</code>中的<code>maven</code>. 而在<code>C/C++</code>中一个著名的项目管理工具就是<code>make</code>.很多人都把这个<code>make</code>当做成了编译器. 这样我们就不用手动的一个一个的进行<code>gcc</code>了.</p><p>那么<code>make</code>怎么能做到这么智能的知道去做什么呢? 这依靠一个重要的配置文件 – <strong>makefile</strong></p><p>而这个<code>makefile</code>又不能直接就存在或者是写死的, 因为这样就失去了灵活性, 每一个用户都希望有自己的需求, 比如: 文件的位置, 以及一些功能的取舍.</p><p>实际上的<code>makefile</code>的生成是由一个<code>Makefile.in</code>的模板进行的.  那么这么一个模板文件又是由用户指定选项来选则特性是否启用. 提供给用户进行特性选则的工具叫做<code>configure</code>. 综上, 这么一个过程就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure --&gt; Makefile.<span class="keyword">in</span> --&gt; malefile</span><br></pre></td></tr></table></figure><p>这样的话, 我们的编译安装的三个步骤就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --[OPTIONS] <span class="comment"># 生成makefile, 依赖Makefile.in</span></span><br><span class="line">make <span class="comment"># 编译的步骤</span></span><br><span class="line">make install <span class="comment"># 其实就是将生成的文件放在指定的文件夹</span></span><br></pre></td></tr></table></figure><p>在<code>(1)</code>的过程中, 通过选项传递参数, 指定启用特性, 安装路径等, 执行时会参考用户的选项和<code>Makefile.in</code>生成<code>makefile</code>, 接着, 因为有些功能的启用需要依赖其他的模块或者一些外部程序, 所以<code>configure</code>就会进行对所依赖的外部环境做检测. </p><p>在<code>(2)</code>的过程中, 根据<code>makefile</code>文件, 构建应用程序. </p><p>那么回答最初的文件 – <code>configure</code>, 这个文件难道一定是默认就会提供的吗? 不一定. 手工编写这个文件是一个很复杂和麻烦的过程. 所以一般都直接使用开发工具进行生成. 如果下载的源码包是没有提供这些文件的.我们就要使用工具进行生成:</p><ul><li><code>autoconf</code> : 生成<code>configure</code>脚本</li><li><code>automake</code>: 生成<code>Makefile.in</code></li></ul><p>对于有些软件可能不需要进行<code>configure</code>, 直接<code>make</code>就行, 而有些软件可能<code>make</code>之后直接就是二进制, 直接复制到别的地方就可以使用了.</p><p>所以说: <strong>建议在安装前查看INSTALL文档(如果没有查看README)</strong></p><p>在进行编译<code>C</code>的源代码的时候, 是有以下的前提的: ( configure就会进行检查 )</p><ul><li>开发工具: <code>make</code>, <code>gcc</code></li><li>开发环境: 开发库, 头文件 <ul><li><code>glibc</code> : 标准库</li></ul></li></ul><p>接下来就来详细一点的说明一下那三个步骤:</p><p><strong>第一步:</strong> <code>configure</code>脚本</p><ul><li><p>选项: 指定安装位置, 指定启用的特性</p></li><li><p>常见的选项: </p></li><li><pre><code class="bash">--prefix=/PATH/TO/SOMEWHERE: 指定默认安装位置--sysconfig=/PATH/TO/SOMEWHERE: 配置文件的安装位置Optional Features: 可选特性    --disable-FEATURE    --enable-FEATURE[=ARG]Optional Packages: 可选包    --with-PACKAGE[=ARG]    --without-PACKAGE<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**第二步:** `make`</span><br><span class="line"></span><br><span class="line">**第三步:** `make install`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**7月14号的更新:** </span><br><span class="line"></span><br><span class="line">上面说的就是最基本的源码编译了, 现在我们再多说一点.</span><br><span class="line"></span><br><span class="line">如果有一份这样的[文件](http://linux.vbird.org/linux_basic/0520source/main.tgz): 他们之间存在函数依赖关系并且还调用了外部库.那么在直接编译的时候就会报错.</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">main.c:(.text+0x61): undefined reference to `haha&#x27;</span><br><span class="line">sin_value.c:(.text+0x2f): undefined reference to `sin&#x27;</span><br><span class="line">...()</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>缺少库的解决方法就是在编译的时候加上<code>-lm</code>参数 如果你的库不在标准的库路径里面, 那么就需要再指定 <code>-L/path</code>  对于文件间的依赖关系, 就需要先把他们编译成对象文件, 再一起进行链接.</p><p>就像这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW c]<span class="comment"># gcc -c main.c </span></span><br><span class="line">[root@WWW c]<span class="comment"># gcc -c sin_value.c </span></span><br><span class="line">[root@WWW c]<span class="comment"># gcc -c cos_value.c </span></span><br><span class="line">[root@WWW c]<span class="comment"># gcc -c haha.c </span></span><br><span class="line">[root@WWW c]<span class="comment"># ls</span></span><br><span class="line">cos_value.c  cos_value.o  haha.c  haha.o  main.c  main.o  sin_value.c  sin_value.o</span><br><span class="line">[root@WWW c]<span class="comment"># gcc -o main main.o haha.o sin_value.o cos_value.o -lm</span></span><br></pre></td></tr></table></figure><p>这样就可以看到编译之后的文件了.</p><p>这样果然很烦人呢. 有没有一种方法能够直接自动化的进行依赖的解决呢? 这个就是我们要说的make了, 之前只是简单的说了一下, 现在我们就少未来具体的说一说这个.</p><p>首先就是我们的makefile的编写. makefile是最终执行make的重要参考, 因此现在我们来了解下这个文件的基本语法吧, 先用上面的那一只当一个范例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makefile</span><br><span class="line">main: main.o haha.o sin_value.o cos_value.o</span><br><span class="line">gcc -o main main.o haha.o sin_value.o cos_value.o -lm</span><br></pre></td></tr></table></figure><p>先把之前生成的文件都删掉, 再执行一次make命令试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">rm</span> -rf *.o main</span><br><span class="line">[root@localhost c]<span class="comment"># make</span></span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc    -c -o haha.o haha.c</span><br><span class="line">cc    -c -o sin_value.o sin_value.c</span><br><span class="line">cc    -c -o cos_value.o cos_value.c</span><br><span class="line">gcc -o main main.o haha.o sin_value.o cos_value.o -lm</span><br><span class="line">[root@localhost c]<span class="comment"># ls</span></span><br><span class="line">cos_value.c  cos_value.o  haha.c  haha.o  main  main.c  main.o  makefile  sin_value.c  sin_value.o</span><br></pre></td></tr></table></figure><p>这样就很方便的进行了多文件的编译. 但是你可能要说了, 我可以使用脚本来代替这个过程啊, 为什么非要编写这样的一个文件呢? 看下面的例子吧:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost c]<span class="comment"># make</span></span><br><span class="line">make: `main<span class="string">&#x27; is up to date.</span></span><br><span class="line"><span class="string">[root@localhost c]# vim haha.c</span></span><br><span class="line"><span class="string">[root@localhost c]# make</span></span><br><span class="line"><span class="string">cc    -c -o haha.o haha.c</span></span><br><span class="line"><span class="string">gcc -o main main.o haha.o sin_value.o cos_value.o -lm</span></span><br></pre></td></tr></table></figure><p>发现了吗, 只要这个文件没有发生改变我们就不会再去消耗CPU去编译他, (编译是一件很吃性能的事情啊) 而且当文件发生了变化, 他也可以安装相关关系来按需编译, 也就是按照相依性来更新执行文件.</p><p>现在也许你尝试着进行了<code>make clean</code> 的操作但是发现失败了. 来看一下报错吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost c]<span class="comment"># make clean</span></span><br><span class="line">make: *** No rule to make target `clean<span class="string">&#x27;.  Stop.</span></span><br></pre></td></tr></table></figure><p>他说没有对应的规则来执行. 那么什么才是make的规则呢. 是这样的, 我们的makefie的基本组成是这样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">目标(target): 目标文件1 目标文件2</span><br><span class="line">&lt;tab&gt;gcc -o 新建的可执行文件 目标文件1 目标文件2</span><br><span class="line">target:</span><br><span class="line">&lt;tab&gt;operation</span><br><span class="line">target:</span><br><span class="line">&lt;tab&gt;operation</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>现在我们加上这样的两行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost c]<span class="comment"># echo -e &quot;clean:\n\trm -rf main.o haha.o sin_value.o cos_value.o&quot; &gt;&gt; makefile </span></span><br></pre></td></tr></table></figure><p>好了, 再执行一次clean吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost c]<span class="comment"># make clean</span></span><br><span class="line"><span class="built_in">rm</span> -rf main.o haha.o sin_value.o cos_value.o</span><br></pre></td></tr></table></figure><p>但是现在我们发现, 这个makefile也太难看了, 参数都是一样的, 有什么办法来优化一下啊.</p><p>makefile和我们的shell script一样, 我们可以使用变量来进行文件内容的精简.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">makefile</span><br><span class="line">LIBS = -lm</span><br><span class="line">OBJS = main.o haha.o sin_value.o cos_value.o</span><br><span class="line">main: <span class="variable">$&#123;OBJS&#125;</span></span><br><span class="line">gcc -o main <span class="variable">$&#123;OBJS&#125;</span> <span class="variable">$&#123;LIBS&#125;</span></span><br><span class="line">clean:</span><br><span class="line"><span class="built_in">rm</span> -f main <span class="variable">$&#123;OBJS&#125;</span></span><br></pre></td></tr></table></figure><p>这样就看起来清爽多了.</p><p>最后再说一下, 软件的更新,如果使用的是rpm包进行的安装, 那么很容易就可以进行更新. 但是,源码包呢? 这是个问题. 事实上, 只要没有大改架构, 那么小范围的更新都是很方便的就可以进行更新的, 你想蛤, 其实仅仅是几段代码的差距罢了, 这个和我们的git有点像啊. 所以是不是有什么灵感呢? 由一个工具很方便的可以得到这些差距; <code>diff</code></p><p>软件包的更新就依赖于这个, 由一个命令<code>patch</code>就是用来配合diff做这个事情的, 看一下下面的实例就懂了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo &quot;This is version 1.0&quot; &gt; 1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo &quot;This is version 2.0&quot; &gt; 2</span></span><br><span class="line">[root@localhost ~]<span class="comment"># diff -u 1 2</span></span><br><span class="line">--- 12017-07-14 12:07:53.520429252 +0800</span><br><span class="line">+++ 22017-07-14 12:07:58.752424592 +0800</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-This is version 1.0</span><br><span class="line">+This is version 2.0</span><br><span class="line">[root@localhost ~]<span class="comment"># diff -u 1 2 &gt; test.patch</span></span><br><span class="line">[root@localhost ~]<span class="comment"># patch -p0 &lt; test.patch </span></span><br><span class="line">patching file 1</span><br><span class="line">[root@localhost ~]<span class="comment"># cat 1</span></span><br><span class="line">This is version 2.0</span><br></pre></td></tr></table></figure><p>只要将unified的diff输出重定向到一个文件, 接着就可以用patch进行更新和还原了, 这个在我们进行内核编译的时候是有很大用处的.</p><p>当然基于这个原理, 如果软件的架构发生了变化, 这样就不太能行得通了, 这个方法也只能在提供了patch文件才可以.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Software Package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAID参考</title>
      <link href="/2017/06/20/RAID%E5%8F%82%E8%80%83/"/>
      <url>/2017/06/20/RAID%E5%8F%82%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>写给自己的RAID参考memo.</p><span id="more"></span><h2 id="RAID参考"><a href="#RAID参考" class="headerlink" title="RAID参考"></a>RAID参考</h2><p>总是记不住, 记个笔记给自己参考, 主要信息来源于<code>Wikipedia</code>.</p><h2 id="RAID的概述"><a href="#RAID的概述" class="headerlink" title="RAID的概述"></a>RAID的概述</h2><p>RAID的全称是 <strong>独立硬盘冗余阵列</strong>（<strong>RAID</strong>, <strong>R</strong>edundant <strong>A</strong>rray of <strong>I</strong>ndependent <strong>D</strong>isks），旧称<strong>廉价磁盘冗余阵列</strong>（<strong>R</strong>edundant <strong>A</strong>rray of <strong>I</strong>nexpensive <strong>D</strong>isks），简称<strong>磁盘阵列</strong>.</p><p>RAID的基本思想就是把多个相对便宜的硬盘组合起来, 成为一个磁盘组, 使得这个磁盘组的性能和容错能力达到甚至超过一个价格昂贵的的磁盘. 根据组合方式的不同, RAID分成多个等级.而根据实现方式的不同, RAID又分为<strong>软件RAID</strong>和<strong>硬件RAID</strong>.</p><p>补充说一下软件RAID和硬件RAID的区别. 价格!价格!价格!硬件RAID动辄就是好几万元, 而软件RAID几乎不需要花费多余的软妹币.硬件RAID贵就贵在它的磁盘阵列卡.磁盘阵列卡上有CPU专门用来进行RAID任务.这样既不会消耗原本系统的I&#x2F;O总线, 性能就更好. 而且还拥有备份电池和日志等功能.</p><p>而软件实现的RAID又分两种, 一种是主板支持就可以, 这是需要消耗系统资源来进行的(<code>CPU</code>的计算, <code>IO</code>总线的资源), 但这种RAID不容易迁移(因为是和主板相关联的) 另一种是硬件辅助型的, 需要一张RAID卡以及配套的驱动程序.</p><h2 id="RAID的分级"><a href="#RAID的分级" class="headerlink" title="RAID的分级"></a>RAID的分级</h2><h3 id="RAID0"><a href="#RAID0" class="headerlink" title="RAID0"></a>RAID0</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9b/RAID_0.svg/325px-RAID_0.svg.png" alt="RAID 0"></p><p>这是RAID0, 简单的说就是将存放数据时, 分段后分散存储在这些磁盘中, 这样读写就可以并行处理.</p><p>RAID0是所有的RAID等级中速度最快的, 但是没有冗余和容错的能力.</p><p>一张盘损坏, 所有的数据都将丢失.</p><h3 id="RAID1"><a href="#RAID1" class="headerlink" title="RAID1"></a>RAID1</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/RAID_1.svg/325px-RAID_1.svg.png" alt="File:RAID 1.svg"></p><p>这是RAID1, 所有的数据都会N倍存储. 两个以上的磁盘相互做镜像. 读取速度等于硬盘数量的倍数.</p><p>是所有RAID等级中可靠性很数据安全性是最高的, 但是无论多少个磁盘做RAID1, 最终都只是一个磁盘的容量, 因此也是所有等级的RAID中利用率最低的.</p><p>当主硬盘损坏的时候, 镜像硬盘会代替主硬盘进行工作.</p><h3 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/RAID_5.svg/675px-RAID_5.svg.png" alt="File:RAID 5.svg"></p><p>这是RAID5, 如图所示, 将数据和<strong>对应的奇偶校验信息</strong>存储到RAID5的各个磁盘上, 这些信息分别存储在不同的磁盘上.</p><p>这里的下标 <code>p</code> 是指 <code>Parity</code> ( 同位检查码 ) , 就把它当成是可以恢复损坏信息的神奇数据吧, 当一张盘发生损坏的时候, 可以利用剩下的数据和刚刚说的神奇数据来算出坏掉的信息是什么.</p><p>这样看起来, RAID5就像是RAID1和RAID0的折中方案.</p><p>最少需要3张盘.</p><h3 id="RAID6"><a href="#RAID6" class="headerlink" title="RAID6"></a>RAID6</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/70/RAID_6.svg/800px-RAID_6.svg.png" alt="File:RAID 6.svg"></p><p>RAID6是RAID的升级版吧, 用了两张盘来存放神奇数据, 而且是两种不同的算法的神奇数据.</p><p>这样即使有两张盘<strong>同时</strong>损坏了, RAID6还是可以正常工作, 而且数据还是可以被救回来的.</p><p>这样算来, RAID6需要最少4个磁盘. 但是相比RAID5, RAID6需要更大的计算量和更多的IO操作, 所以一般都是使用的硬件方式实现RAID6.</p><h3 id="RAID-10-x2F-01"><a href="#RAID-10-x2F-01" class="headerlink" title="RAID 10&#x2F;01"></a>RAID 10&#x2F;01</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bb/RAID_10.svg/600px-RAID_10.svg.png" alt="File:RAID 10.svg"></p><p>RAID10也是一种常用的, 简单的说就是将RAID1实现的一组当做RAID0的一块盘.</p><p>即使每一个RAID1组中的一个磁盘损坏, 整个磁盘阵列仍会正常工作, 但只要任意一个RAID1组的两个磁盘都坏了, 整个阵列就炸了. </p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ad/RAID_01.svg/600px-RAID_01.svg.png" alt="File:RAID 01.svg"></p><p>和上面的相反, 将几个RAID0构建的磁盘当做RAID1的一个磁盘.</p><p>当有一个磁盘损坏的时候, 同RAID0组就全玩完了. 所以RAID01的可靠性较低. 一般会选择RAID10而不是RAID01.</p>]]></content>
      
      
      
        <tags>
            
            <tag> RAID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>btrfs初探</title>
      <link href="/2017/06/18/btrfs%E5%88%9D%E6%8E%A2/"/>
      <url>/2017/06/18/btrfs%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>btrfs是一个先进的文件系统, 由Oracle研发, 在2014年推出了稳定版,支持很多EXT系列文件系统不支持的特性.</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> Btrfs的最大特性就是支持<code>Cow(Copy on write 写时复制)</code>.</p><p>下面简单介绍一下Btrfs的核心特性:</p><ul><li>多物理卷支持, 支持<code>RAID</code>, 联机”添加”, “移除”, “修改”</li><li>写时复制<code>(CoW)</code>, 复制 更新 替换指针, 而非就地更新(备份)</li><li>数据和元数据校验码 <code>checksum, </code>快速检测文件是否损毁</li><li>子卷 <code>sub_volume</code></li><li>快照, 支持快照的快照, 也是基于<code>CoW</code></li><li>透明压缩: 文件存储时进行压缩,读取时自动解压缩</li></ul><h2 id="Btrfs的使用"><a href="#Btrfs的使用" class="headerlink" title="Btrfs的使用"></a>Btrfs的使用</h2><p>BTreeFS的命令有两种语法风格的, 一种是单独的一个个小命令, 一个是子命令的形式(较新).</p><p>较新的Linux命令都是以子命令的形式编写的, 就像<code>mkfs -t</code>和<code>mkfs.ext4/mkfs.btrfs</code>, 严格的说,前者也不能说是子命令, 像<code>ip</code>系列的命令才叫子命令的形式.</p><h3 id="使用前先来说一下Btrfs的构建"><a href="#使用前先来说一下Btrfs的构建" class="headerlink" title="使用前先来说一下Btrfs的构建"></a>使用前先来说一下Btrfs的构建</h3><p>创建<code>Btrfs</code>的命令仍然是<code>mkfs</code>, 只不过原理不一样了, 所以参数和<code>ext</code>系列是不一样的.</p><p>先来看一下常用的参数有哪些吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ man mkfs.brtfs</span><br><span class="line">-m| --metadata &lt;profile&gt; 指定元数据如何跨越物理卷, 合法的值有:raid0, raid1, raid5, raid6, raid10, single[默认值], dup(冗余, duplicate,仅仅是复制一份罢了).</span><br><span class="line">-d| --data &lt;<span class="built_in">type</span>&gt; 指定数据如何跨越物理卷, 和上面的是基本一样的值(没有dup选项).</span><br><span class="line">-L| --label &lt;name&gt; 声明一个小于256Bytes的字符串来当做文件系统的卷标(标签)</span><br><span class="line">-O| --feature &lt;f1&gt;,[&lt;f2&gt;...] 查看和指定文件系统和内核支持的特性</span><br><span class="line">可以使用 -O list-all</span><br></pre></td></tr></table></figure><p>接下来就要改变思路了, Btree文件系统在同一个磁盘的不同分区的意义就不大了,因为这样就失去了冗余能力,但是这样比较简单,虽然失去了意义. 所以,选取多个磁盘共同组成一个B树文件系统.  </p><p>下面来创建一个Btrfs的文件系统, 事实上过程是很简单的, 我新分配了3块虚拟磁盘, 每一个的大小是<code>10.00GB</code>, 这样现在的系统状态是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ fdisk -l</span><br><span class="line">Disk /dev/sdb: 10 GiB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sdd: 10 GiB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sdc: 10 GiB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure><p>还有一个已经都挂载的用于系统和<code>swap</code>的磁盘<code>sda</code>.</p><p>那么现在把<code>sdb</code>和<code>sdc</code>进行格式化,构成一个文件系统.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ mkfs.btrfs -L <span class="string">&quot;mydata&quot;</span> /dev/sd&#123;b,c&#125;</span><br><span class="line">Label:              mydata</span><br><span class="line">`UUID`:               </span><br><span class="line">Node size:          16384</span><br><span class="line">Sector size:        4096</span><br><span class="line">Filesystem size:    20.00GiB</span><br><span class="line">Block group profiles:</span><br><span class="line">  Data:             RAID0             2.00GiB</span><br><span class="line">  Metadata:         RAID1             1.00GiB</span><br><span class="line">  System:           RAID1             8.00MiB</span><br><span class="line">SSD detected:       no</span><br><span class="line">Incompat features:  extref, skinny-metadata</span><br><span class="line">Number of devices:  2</span><br><span class="line">Devices:</span><br><span class="line">   ID        SIZE  PATH</span><br><span class="line">    1    10.00GiB  /dev/sdb</span><br><span class="line">    2    10.00GiB  /dev/sdc</span><br></pre></td></tr></table></figure><p>很快就创建成功了, 整个文件系统的大小是<code>20.00GB</code></p><h3 id="Btrfs文件系统的使用"><a href="#Btrfs文件系统的使用" class="headerlink" title="Btrfs文件系统的使用"></a>Btrfs文件系统的使用</h3><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>btrfs支持很多子命令, 每一个子命令有包含很多的二级子命令. 其中一个是<code>filesystem</code>, 他有一个子命令可以擦看当前的btrfs的状态.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ btrfs filesystem show</span><br><span class="line">Label: <span class="string">&#x27;mydata&#x27;</span>  UUID: acc64201-b842-41ed-b651-b41c84839d63</span><br><span class="line">Total devices 2 FS bytes used 112.00KiB</span><br><span class="line">devid    1 size 10.00GiB used 2.01GiB path /dev/sdb</span><br><span class="line">devid    2 size 10.00GiB used 2.01GiB path /dev/sdc</span><br></pre></td></tr></table></figure><p>很快就可以发现文件系统mydata拥有一个<code>UUID</code>, 可是大家都知道,每一个磁盘应该都有一个<code>UUID</code>才对, 但是这样搞我不就无法定位到单个硬盘了吗, 别急.使用我们之前查看<code>UUID</code>的命令来试一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ blkid</span><br><span class="line">/dev/sda1: UUID=<span class="string">&quot;62e883b5-6150-4294-a6d2-a387b5cec8b8&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span> PARTUUID=<span class="string">&quot;8b164ce4-01&quot;</span></span><br><span class="line">/dev/sdb: LABEL=<span class="string">&quot;mydata&quot;</span> UUID=<span class="string">&quot;acc64201-b842-41ed-b651-b41c84839d63&quot;</span> UUID_SUB=<span class="string">&quot;90475d97-7147-4d75-99a0-a9e2841dcd87&quot;</span> TYPE=<span class="string">&quot;btrfs&quot;</span></span><br><span class="line">/dev/sdc: LABEL=<span class="string">&quot;mydata&quot;</span> UUID=<span class="string">&quot;acc64201-b842-41ed-b651-b41c84839d63&quot;</span> UUID_SUB=<span class="string">&quot;93d9ad4c-47f0-41ed-a387-7adaee0268c0&quot;</span> TYPE=<span class="string">&quot;btrfs&quot;</span></span><br><span class="line">/dev/sda5: UUID=<span class="string">&quot;8f65d150-3b30-40e5-8f9e-cae947a8321f&quot;</span> TYPE=<span class="string">&quot;swap&quot;</span> PARTUUID=<span class="string">&quot;8b164ce4-05&quot;</span></span><br></pre></td></tr></table></figure><p>从输出结果我们发现, 两个共同组成<code>btrfs</code>的磁盘共有一个<code>UUID</code>, 但是却多了一个叫<code>UUID_SUB</code>的属性, 这个属性就是上面说的每一个磁盘的<code>UUID</code>, 因为这些个磁盘叫做这个<code>FS</code>的子卷,因此就取名字叫<code>UUID_SUB</code>了.</p><p>上面的<code>filesystem</code>的子命令<code>show</code>可以来筛选输出的内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ brtfs filesystem show [OPTIONS]</span><br><span class="line">--mounted 仅显示挂载的btrfs文件系统</span><br><span class="line">--all-devices  显示所有的btrfs文件系统</span><br><span class="line">后面也可以直接跟上设备路径, UUID, 卷标等等</span><br></pre></td></tr></table></figure><p>至此, 我们就可以创建和查看<code>btrfs</code>文件系统了</p><p>再介绍一下<code>filesystem</code>其他的一些子命令: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ btrfs filesystem</span><br><span class="line">usage: btrfs filesystem [&lt;group&gt;] &lt;<span class="built_in">command</span>&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">    btrfs filesystem <span class="built_in">sync</span> &lt;path&gt;</span><br><span class="line">        Force a <span class="built_in">sync</span> on a filesystem</span><br><span class="line">        强制写入磁盘</span><br><span class="line">    btrfs filesystem defragment [options] &lt;file&gt;|&lt;<span class="built_in">dir</span>&gt; [&lt;file&gt;|&lt;<span class="built_in">dir</span>&gt;...]</span><br><span class="line">        Defragment a file or a directory</span><br><span class="line">        清理磁盘碎片</span><br><span class="line">    btrfs filesystem resize [devid:][+/-]&lt;newsize&gt;[kKmMgGtTpPeE]|[devid:]max &lt;path&gt;</span><br><span class="line">        Resize a filesystem</span><br><span class="line">        改变文件系统的大小</span><br><span class="line">    btrfs filesystem label [&lt;device&gt;|&lt;mount_point&gt;] [&lt;newlabel&gt;]</span><br><span class="line">        Get or change the label of a filesystem</span><br><span class="line">    查看文件系统的卷标或者进行重命名</span><br><span class="line">    btrfs filesystem usage [options] &lt;path&gt; [&lt;path&gt;..]</span><br><span class="line">        Show detailed information about internal filesystem usage .</span><br><span class="line">        显示详细的文件系统使用情况</span><br><span class="line"></span><br><span class="line">overall filesystem tasks and information</span><br></pre></td></tr></table></figure><p>其中很多命令都需要在我们进行挂载后才可以使用, 现在就来把他加入到目录树上吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">mkdir</span> /mydata</span><br><span class="line">[root@WWW ~]$ mount -t btrfs /dev/sdb /mydata <span class="comment"># 使用-t选项来限制文件系统类型</span></span><br><span class="line">[root@WWW ~]$ mount</span><br><span class="line">/dev/sda1 on / <span class="built_in">type</span> ext4 (rw,relatime,errors=remount-ro,data=ordered)</span><br><span class="line">...</span><br><span class="line">/dev/sdb on /mydata <span class="built_in">type</span> btrfs (rw,relatime,space_cache,subvolid=5,subvol=/)</span><br><span class="line"><span class="comment"># 那么如果把/dev/sdc挂载会出现什么现象呢? 我们来试试.</span></span><br><span class="line">[root@WWW ~]$ umount /mydata</span><br><span class="line">[root@WWW ~]$ mount -t btrfs /dev/sdc /mydata <span class="comment"># 这次来挂载/dev/sdc</span></span><br><span class="line">[root@WWW ~]$ mount</span><br><span class="line">/dev/sda1 on / <span class="built_in">type</span> ext4 (rw,relatime,errors=remount-ro,data=ordered)</span><br><span class="line">...</span><br><span class="line">/dev/sdb on /mydata <span class="built_in">type</span> btrfs (rw,relatime,space_cache,subvolid=5,subvol=/)</span><br><span class="line"><span class="comment"># 输出是一样的!</span></span><br></pre></td></tr></table></figure><p>现在我们就可以使用一些<code>filesystem</code>的命令了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ btrfs filesystem &#123;<span class="built_in">df</span>,<span class="built_in">du</span>,label,usage...&#125;</span><br><span class="line"><span class="comment"># df和du的功能和之前的df.du功能是一样的,只不过输出的信息有区别.</span></span><br><span class="line"><span class="comment"># 输出的信息包括: 存储的类型(元数据,数据,系统) 大小 使用情况.</span></span><br><span class="line"><span class="comment"># label 不写新标签就是显示当前卷标.</span></span><br><span class="line"><span class="comment"># usage 会显示相较df更详细的信息.但是都是围绕着那些数据类型构成来的.</span></span><br></pre></td></tr></table></figure><p>之前说过<code>btrfs</code>是支持透明压缩的 只要在挂载的时候 加上 <code>-o</code> 添加参数<code>compress=&#123;lzo|zlib&#125;</code> </p><p>这样之后, 文件就会得到自动的压缩和解压缩, 这个过程对用户是透明的.</p><p><code>Btrfs</code>支持在线调整大小, 就像<code>LVM</code>那样, 使用<code>resize</code>命令.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ btrfs filesystem resize -4G /mydata</span><br><span class="line">Resize <span class="string">&#x27;/mydata/&#x27;</span> of <span class="string">&#x27;4G&#x27;</span></span><br><span class="line"><span class="comment"># 接下来再查看一下</span></span><br><span class="line">[root@WWW ~]$ btrfs filesystem show</span><br><span class="line">Label: <span class="string">&#x27;mydata&#x27;</span>  uuid: 51136d0b-5bfb-4c0b-8d88-bb05f40455eb</span><br><span class="line">Total devices 2 FS bytes used 808.00KiB</span><br><span class="line">devid    1 size 4.00GiB used 1.81GiB path /dev/sdb</span><br><span class="line">devid    2 size 8.00GiB used 1.81GiB path /dev/sdc</span><br><span class="line">[root@WWW ~]$ <span class="built_in">df</span> -hl</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            2.0G     0  2.0G   0% /dev</span><br><span class="line">tmpfs           396M  6.1M  390M   2% /run</span><br><span class="line">/dev/sda1        16G  9.2G  5.7G  63% /</span><br><span class="line">tmpfs           2.0G     0  2.0G   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup</span><br><span class="line">tmpfs           396M   16K  396M   1% /run/user/132</span><br><span class="line">tmpfs           396M   32K  396M   1% /run/user/0</span><br><span class="line">/dev/sdb         12G   17M  6.0G   1% /mydata <span class="comment"># 缩减了4个G.</span></span><br><span class="line"><span class="comment"># 还可以直接使用max.</span></span><br><span class="line">[root@WWW ~]$ btrfs filesystem resize max /mydata</span><br><span class="line">Resize <span class="string">&#x27;/mydata/&#x27;</span> of <span class="string">&#x27;max&#x27;</span></span><br><span class="line">[root@WWW ~]$ <span class="built_in">df</span> -hl</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            2.0G     0  2.0G   0% /dev</span><br><span class="line">tmpfs           396M  6.1M  390M   2% /run</span><br><span class="line">/dev/sda1        16G  9.2G  5.7G  63% /</span><br><span class="line">tmpfs           2.0G     0  2.0G   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup</span><br><span class="line">tmpfs           396M   16K  396M   1% /run/user/132</span><br><span class="line">tmpfs           396M   32K  396M   1% /run/user/0</span><br><span class="line">/dev/sdb         16G   17M  6.0G   1% /mydata</span><br></pre></td></tr></table></figure><h4 id="物理磁盘管理"><a href="#物理磁盘管理" class="headerlink" title="物理磁盘管理"></a>物理磁盘管理</h4><p>如果我还想让这个空间更大呢?那就需要增加新的磁盘进来．就像<code>LVM</code>那样, <code>btrfs</code>进行底层设备的管理的命令是<code>device</code>子命令.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ btrfs device &lt;COMMAND&gt;</span><br><span class="line"><span class="comment"># 常用的命令是:</span></span><br><span class="line"><span class="comment"># add 增加一个设备进文件系统</span></span><br><span class="line"><span class="comment"># delete/remove 从文件系统中移除一个设备</span></span><br><span class="line"><span class="comment"># scan 寻找btrfs的设备(不会用)</span></span><br></pre></td></tr></table></figure><p>现在我们先试试为我们的文件系统增加一个磁盘来扩充空间.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ btrfs device add /dev/sdd /mydata</span><br><span class="line">root@kali:/mydata<span class="comment"># df -hl</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            2.0G     0  2.0G   0% /dev</span><br><span class="line">tmpfs           396M  6.1M  390M   2% /run</span><br><span class="line">/dev/sda1        16G  9.2G  5.7G  63% /</span><br><span class="line">tmpfs           2.0G     0  2.0G   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup</span><br><span class="line">tmpfs           396M   16K  396M   1% /run/user/132</span><br><span class="line">tmpfs           396M   24K  396M   1% /run/user/0</span><br><span class="line">/dev/sdb         24G   17M   21G   1% /mydata <span class="comment"># 真的增加了!</span></span><br></pre></td></tr></table></figure><p>删除一个设备也是很简单的, 直接将<code>add</code>换成<code>remove</code>就行了.在移除的前, <code>btrfs</code>会自动将数据迁移出去, 因此,要保证在移除后整个文件系统剩余的磁盘数量仍然能够将数据完整的保留下来.</p><h4 id="数据重分配"><a href="#数据重分配" class="headerlink" title="数据重分配"></a>数据重分配</h4><p>接下来再来看一下<code>btrfs</code>中的<code>balance</code> .这个<code>balance</code>就好像是磁盘阵列的修复, 他会将数据进行一次重新的分配.</p><p>直接启动<code>balance</code>会收到警告:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ btrfs balance start /mydata/</span><br><span class="line">WARNING:</span><br><span class="line"></span><br><span class="line">Full balance without filters requested. This operation is very</span><br><span class="line">intense and takes potentially very long. It is recommended to</span><br><span class="line">use the balance filters to narrow down the balanced data.</span><br><span class="line">Use <span class="string">&#x27;btrfs balance start --full-balance&#x27;</span> option to skip this</span><br><span class="line">warning. The operation will start <span class="keyword">in</span> 10 seconds.</span><br><span class="line">Use Ctrl-C to stop it.</span><br></pre></td></tr></table></figure><p>这是因为如果数据量很大, <code>balance</code>会成为一个很耗时的过程. 因此建议加上过滤.</p><p>在<code>balance</code>的过程中, 可以随时进行<code>pause</code>, <code>cancel</code>, <code>resume</code>的操作, 也可以随时查看状态, 使用<code>status</code>.</p><p><code>balance</code>里常用的过滤器, 我其实就只用过<strong>convert</strong>. 将对应的<code>section</code>转换为指定的格式(<code>single,dup,raid&#123;0,1,5,6&#125;</code>)</p><p>使用起来就像这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ btrfs filesystem show</span><br><span class="line">Label: <span class="string">&#x27;myNewData&#x27;</span>  uuid: 8de2ca1c-75ea-4573-ad80-4ef1768d1a6b</span><br><span class="line">Total devices 1 FS bytes used 448.00KiB</span><br><span class="line">devid    1 size 8.00GiB used 1.12GiB path /dev/sdb</span><br><span class="line">oot@kali:/mydata/backup<span class="comment"># btrfs balance start -dconvert=raid0 -sconvert=raid0 -mconvert=raid0 /mydata/ -f</span></span><br><span class="line">ERROR: error during balancing <span class="string">&#x27;/mydata/&#x27;</span>: Invalid argument</span><br><span class="line">There may be more info <span class="keyword">in</span> syslog - try dmesg | <span class="built_in">tail</span></span><br><span class="line"><span class="comment"># 报错了.这是因为一共就只有1张盘, 怎么可能跑RAID呢?</span></span><br><span class="line">[root@WWW ~]$ btrfs balance start -dconvert=single -sconvert=single -mconvert=single /mydata/ -f</span><br><span class="line">Done, had to relocate 4 out of 4 chunks</span><br><span class="line"><span class="comment"># 这样就不会报错.</span></span><br><span class="line">[root@WWW ~]$ btrfs device add /dev/sd&#123;c,d,e&#125; /mydata/</span><br><span class="line">[root@WWW ~]$ btrfs filesystem show</span><br><span class="line">Label: <span class="string">&#x27;myNewData&#x27;</span>  uuid: 8de2ca1c-75ea-4573-ad80-4ef1768d1a6b</span><br><span class="line">Total devices 4 FS bytes used 384.00KiB</span><br><span class="line">devid    1 size 8.00GiB used 1.09GiB path /dev/sdb</span><br><span class="line">devid    2 size 8.00GiB used 0.00B path /dev/sdc</span><br><span class="line">devid    3 size 8.00GiB used 0.00B path /dev/sdd</span><br><span class="line">devid    4 size 8.00GiB used 0.00B path /dev/sde</span><br><span class="line"><span class="comment"># 接下来, 转换为RAID试一试, 先看一下当前的状态</span></span><br><span class="line">[root@WWW ~]$ btrfs filesystem usage /mydata/</span><br><span class="line">Overall:</span><br><span class="line">    Device size:  32.00GiB</span><br><span class="line">    Device allocated:   1.09GiB</span><br><span class="line">    Device unallocated:  30.91GiB</span><br><span class="line">    Device missing:     0.00B</span><br><span class="line">    Used: 384.00KiB</span><br><span class="line">    Free (estimated):  31.72GiB(min: 31.72GiB)</span><br><span class="line">    Data ratio:      1.00</span><br><span class="line">    Metadata ratio:      1.00</span><br><span class="line">    Global reserve:  16.00MiB(used: 0.00B)</span><br><span class="line"></span><br><span class="line">Data,single: Size:832.00MiB, Used:256.00KiB</span><br><span class="line">   /dev/sdb 832.00MiB</span><br><span class="line"></span><br><span class="line">Metadata,single: Size:256.00MiB, Used:112.00KiB</span><br><span class="line">   /dev/sdb 256.00MiB</span><br><span class="line"></span><br><span class="line">System,single: Size:32.00MiB, Used:16.00KiB</span><br><span class="line">   /dev/sdb  32.00MiB</span><br><span class="line"></span><br><span class="line">Unallocated:</span><br><span class="line">   /dev/sdb   6.91GiB</span><br><span class="line">   /dev/sdc   8.00GiB</span><br><span class="line">   /dev/sdd   8.00GiB</span><br><span class="line">   /dev/sde   8.00GiB</span><br><span class="line"><span class="comment"># 是single, 下面执行</span></span><br><span class="line">[root@WWW ~]$ btrfs balance start -dconvert=raid5 -mconvert=raid5 -sconvert=raid5 /mydata/ -f</span><br><span class="line">Done, had to relocate 3 out of 3 chunks</span><br><span class="line">[root@WWW ~]$ btrfs filesystem <span class="built_in">df</span> /mydata/</span><br><span class="line">Data, RAID5: total=3.00GiB, used=832.00KiB</span><br><span class="line">System, RAID5: total=96.00MiB, used=16.00KiB</span><br><span class="line">Metadata, RAID5: total=288.00MiB, used=112.00KiB</span><br><span class="line">GlobalReserve, single: total=16.00MiB, used=0.00B</span><br></pre></td></tr></table></figure><h4 id="子卷使用"><a href="#子卷使用" class="headerlink" title="子卷使用"></a>子卷使用</h4><p>前面还说过了, <code>btrfs</code>支持子卷(<code>subvolume</code>). 来看一下如何创建和管理子卷吧.</p><p>子卷就是文件系统中一个拥有自己的文件目录结构的部分, 快照也是基于此创建的.  你可以直挂载一个子卷.</p><p><strong>需要注意的是,子卷的原理和LVM的实现时有区别,尽管表现起来看起来是一样的,btrfs的子卷是基于文件实现的,而不像LVM是基于block的.</strong></p><p><code>btrfs</code>的子卷管理是使用的<code>subvolume</code>子命令.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ btrfs subvolume [COMMAND]</span><br><span class="line"><span class="comment"># create 创建一个子卷</span></span><br><span class="line"><span class="comment"># list 列出所有的子卷</span></span><br></pre></td></tr></table></figure><p>先来创建一个子卷:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ btrfs subvolume create /mydata/logs</span><br><span class="line">Create subvolume <span class="string">&#x27;/mydata/logs&#x27;</span></span><br><span class="line">[root@WWW ~]$ btrfs subvolume list /mydata/</span><br><span class="line">ID 275 gen 161 top level 5 path logs</span><br></pre></td></tr></table></figure><p>上面的<code>ID</code>就是卷<code>ID</code>.</p><p>子卷是可以被单独挂载的.现在我们来做个试验吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先把父卷给卸载了</span></span><br><span class="line">[root@WWW ~]$ umount /mydata </span><br><span class="line">[root@WWW ~]$ mount -o subvol=logs /dev/sdb /mnt</span><br><span class="line">[root@WWW ~]$ btrfs subvolume show /mnt</span><br><span class="line">/mnt</span><br><span class="line">Name: logs</span><br><span class="line">UUID: 5d29a288-22b1-4044-a420-6d9c0073b565</span><br><span class="line">Parent UUID: -</span><br><span class="line">Received UUID: -</span><br><span class="line">Creation time: 2017-06-21 02:22:34 -0700</span><br><span class="line">Subvolume ID: 275</span><br><span class="line">Generation: 163</span><br><span class="line">Gen at creation: 161</span><br><span class="line">Parent ID:     5</span><br><span class="line">Top level ID:      5</span><br><span class="line">Flags:     -</span><br><span class="line">Snapshot(s):</span><br></pre></td></tr></table></figure><p>接下来再把父卷给挂回来:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要先卸载子卷哦</span></span><br><span class="line">[root@WWW ~]$ umount /mnt</span><br><span class="line">[root@WWW ~]$ mount /dev/sdb /mydata</span><br><span class="line">[root@WWW ~]$ <span class="built_in">ls</span> /mydata/logs/</span><br><span class="line">messages</span><br></pre></td></tr></table></figure><p>看,我们的文件还在里面, 这就说明当父卷挂载时,所有的子卷也都会被挂载.</p><p>接下来把他删除了吧.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ btrfs subvolume delete /mydata/logs/</span><br><span class="line">Delete subvolume (no-commit): <span class="string">&#x27;/mydata/logs&#x27;</span></span><br><span class="line">[root@WWW ~]$ btrfs subvolume list /mydata/</span><br><span class="line"><span class="comment"># 没有输出了, 说明已经被我们删掉了.</span></span><br></pre></td></tr></table></figure><p>之前说过,快照是基于子卷来构建的, 体验一下<code>btrfs</code>的快照:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ btrfs subvolume create /mydata/logs</span><br><span class="line"><span class="comment"># 然后随便往里面填一点东西</span></span><br><span class="line">[root@WWW ~]$ <span class="built_in">cp</span> -rp /etc/grub.d /mydata/logs/</span><br><span class="line"><span class="comment"># 接下来给这个子卷做个快照</span></span><br><span class="line">[root@WWW ~]$ btrfs subvolume snapshot /mydata/logs /mydata/logs_snapshot</span><br><span class="line">Create a snapshot of <span class="string">&#x27;/mydata/logs/&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;/mydata/logs_snapshot&#x27;</span></span><br><span class="line">[root@WWW ~]$ btrfs subvolume list /mydata</span><br><span class="line">ID 276 gen 170 top level 5 path logs</span><br><span class="line">ID 277 gen 170 top level 5 path logs_snapshot</span><br></pre></td></tr></table></figure><p>接着的使用方法就和LVM的快照差不多了.</p><p>删除快照的方法和删除子卷的方法一样( 因为就是子卷嘛 ).</p><p>除了这种文件系统的快照, <code>btrfs</code>还支持文件级别的快照. 方法很简单, 直接使用熟悉的<code>cp</code>命令就可以了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">cp</span> --reflink README README.snap</span><br><span class="line"><span class="comment"># 这个reflink也是基于 CoW 写时复制的机制的.</span></span><br></pre></td></tr></table></figure><h3 id="最后再说一个小东西"><a href="#最后再说一个小东西" class="headerlink" title="最后再说一个小东西"></a>最后再说一个小东西</h3><p>如何将我们的<code>ext</code>系统转变为<code>btrfs</code>文件系统呢?</p><p>直接做演示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">root@kali:/mydata/logs/grub.d<span class="comment"># fdisk /dev/sdf</span></span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.29.2).</span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, <span class="keyword">until</span> you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line">Disk /dev/sdf: 8 GiB, 8589934592 bytes, 16777216 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x0e2e36eb</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span></span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended (container <span class="keyword">for</span> logical partitions)</span><br><span class="line">Select (default p): </span><br><span class="line"></span><br><span class="line">Using default response p.</span><br><span class="line">Partition number (1-4, default 1): </span><br><span class="line">First sector (2048-16777215, default 2048): </span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (2048-16777215, default 16777215): +2G  </span><br><span class="line"></span><br><span class="line">Created a new partition 1 of <span class="built_in">type</span> <span class="string">&#x27;Linux&#x27;</span> and of size 2 GiB.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line">Disk /dev/sdf: 8 GiB, 8589934592 bytes, 16777216 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x0e2e36eb</span><br><span class="line"></span><br><span class="line">Device     Boot Start     End Sectors Size Id Type</span><br><span class="line">/dev/sdf1        2048 4196351 4194304   2G 83 Linux</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered.</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br><span class="line"></span><br><span class="line">root@kali:/mydata/logs/grub.d<span class="comment"># partprobe </span></span><br><span class="line">root@kali:/mydata/logs/grub.d<span class="comment"># mke2fs -t ext4 /dev/sdf1</span></span><br><span class="line">mke2fs 1.43.4 (31-Jan-2017)</span><br><span class="line">Creating filesystem with 524288 4k blocks and 131072 inodes</span><br><span class="line">Filesystem UUID: 213ded53-11a5-4d7b-9d3b-b196c543261b</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">32768, 98304, 163840, 229376, 294912</span><br><span class="line"></span><br><span class="line">Allocating group tables: <span class="keyword">done</span>                            </span><br><span class="line">Writing inode tables: <span class="keyword">done</span>                            </span><br><span class="line">Creating journal (16384 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span> </span><br><span class="line"></span><br><span class="line">root@kali:/mydata/logs/grub.d<span class="comment"># mount /dev/sdf1 /mnt</span></span><br><span class="line">root@kali:/mydata/logs/grub.d<span class="comment"># cd /mnt/</span></span><br><span class="line">root@kali:/mnt<span class="comment"># cp /etc/fstab ./</span></span><br><span class="line">root@kali:/mnt<span class="comment"># cat fstab </span></span><br><span class="line"><span class="comment"># /etc/fstab: static file system information.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use &#x27;blkid&#x27; to print the universally unique identifier for a</span></span><br><span class="line"><span class="comment"># device; this may be used with UUID= as a more robust way to name devices</span></span><br><span class="line"><span class="comment"># that works even if disks are added and removed. See fstab(5).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span></span><br><span class="line"><span class="comment"># / was on /dev/sda1 during installation</span></span><br><span class="line">UUID=62e883b5-6150-4294-a6d2-a387b5cec8b8 /               ext4    errors=remount-ro 0       1</span><br><span class="line"><span class="comment"># swap was on /dev/sda5 during installation</span></span><br><span class="line">UUID=8f65d150-3b30-40e5-8f9e-cae947a8321f none            swap    sw              0       0</span><br><span class="line">/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0</span><br><span class="line">root@kali:/<span class="comment"># fsck -f /dev/sdf1</span></span><br><span class="line">fsck from util-linux 2.29.2</span><br><span class="line">e2fsck 1.43.4 (31-Jan-2017)</span><br><span class="line">Pass 1: Checking inodes, blocks, and sizes</span><br><span class="line">Pass 2: Checking directory structure</span><br><span class="line">Pass 3: Checking directory connectivity</span><br><span class="line">Pass 4: Checking reference counts</span><br><span class="line">Pass 5: Checking group summary information</span><br><span class="line">/dev/sdf1: 12/131072 files (0.0% non-contiguous), 26157/524288 blocks</span><br><span class="line">root@kali:/<span class="comment"># btrfs-convert /dev/sdf1</span></span><br><span class="line">create btrfs filesystem:</span><br><span class="line">blocksize: 4096</span><br><span class="line">nodesize:  16384</span><br><span class="line">features:  extref, skinny-metadata (default)</span><br><span class="line">creating ext2 image file</span><br><span class="line">creating btrfs metadatacopy inodes [o] [         3/        12]</span><br><span class="line">conversion completeroot@kali:/<span class="comment"># </span></span><br><span class="line">root@kali:/<span class="comment"># btrfs filesystem show</span></span><br><span class="line">Label: <span class="string">&#x27;myNewData&#x27;</span>  uuid: 8de2ca1c-75ea-4573-ad80-4ef1768d1a6b</span><br><span class="line">Total devices 4 FS bytes used 1.01MiB</span><br><span class="line">devid    1 size 8.00GiB used 1.12GiB path /dev/sdb</span><br><span class="line">devid    2 size 8.00GiB used 1.12GiB path /dev/sdc</span><br><span class="line">devid    3 size 8.00GiB used 1.12GiB path /dev/sdd</span><br><span class="line">devid    4 size 8.00GiB used 1.12GiB path /dev/sde</span><br><span class="line"></span><br><span class="line">Label: none  uuid: 823109e6-34dd-4efe-ad1d-a63424b4a820</span><br><span class="line">Total devices 1 FS bytes used 102.43MiB</span><br><span class="line">devid    1 size 2.00GiB used 292.15MiB path /dev/sdf1</span><br></pre></td></tr></table></figure><p>所以,其实是很简单的,直接进行一下<code>btrfs-convert</code>就好了. 在生成的文件系统中会出现一个叫做<code>ext2_saved</code>的镜像文件, 这个文件是用来进行回滚的, 就是重新恢复成<code>EXT</code>文件系统.</p><p>其实还是<code>btrfs</code>命令, 直接加上<code>-r</code>参数 就好了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ umount /mnt/</span><br><span class="line">[root@WWW ~]$ btrfs-convert -r /dev/sdf1</span><br><span class="line">rollback complete</span><br><span class="line">[root@WWW ~]$ blkid /dev/sdf1</span><br><span class="line">/dev/sdf1: UUID=<span class="string">&quot;213ded53-11a5-4d7b-9d3b-b196c543261b&quot;</span> TYPE=<span class="string">&quot;ext4&quot;</span> PARTUUID=<span class="string">&quot;0e2e36eb-01&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件系统和磁盘管理--Part1</title>
      <link href="/2017/06/18/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86-Part1/"/>
      <url>/2017/06/18/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86-Part1/</url>
      
        <content type="html"><![CDATA[<p>Quota&amp;LVM2.</p><span id="more"></span><h2 id="初识文件系统-EXT2"><a href="#初识文件系统-EXT2" class="headerlink" title="初识文件系统(EXT2)"></a>初识文件系统(EXT2)</h2><blockquote><p>EXT2文件系统是Linux上最传统的文件系统.</p></blockquote><p>传统的磁盘和文件系统中, 一个分区就是一个文件系统, 但现在有了LVM等新技术, 使得一个分区可以获得多个文件系统.</p><p>所以现在严格的说, 文件系统应该是<strong>一个可被挂载的数据</strong>而不是一个分区.</p><p>操作系统的文件属性除了文件内容之外, 通常还会有很多属性(元信息:[大小,时间,群组,权限等等]),而<strong>操作系统会将这些元信息储存在inode中, 而文件的实际数据储存在data block中</strong>, 而这些储存的块(block)和inode的信息(总量,使用情况,剩余量等等)又被存储在一个叫做<strong>superblock</strong>的地方.</p><p>这样简单总结一下就是:</p><ul><li>superblock 记录整个文件系统的整体信息, 包括文件的inode&#x2F;block的总量&#x2F;使用量&#x2F;剩余量&#x2F;文件系统的格式和相关信息等</li><li>block 存储文件实际内容的地方, 一个文件如果过大, 会分不同的块来存储</li><li>inode 记录文件的属性, 以及此文件的内容所对应的的block块.</li></ul><p>inode&#x2F;block 的数据访问就像是这样:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/ext2.jpg" alt="ext2"></p><p>上面的浅色方格就是指inode节点, 当访问文件时,操作系统会首先找到文件对应的inode节点, 接着读取inode节点中的信息(e.g:权限), 没问题的话就会从inode中找到文件的内容实际是放在2.7.13.15这些block中, 进而进行读取或其他的文件操作.</p><p>这种文件系统叫做索引式文件系统, 不同于早期U盘使用的<strong>FAT</strong>, 那是一种向前查找的方式, 即是说:他没有Inode, 每一个文件的信息都是从每一个block的末位读到的.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/fat.jpg" alt="fat"></p><p>这样就会造成的一种情况是, 读取一个文件会使得磁盘的磁头多转好多圈才能读完一个文件的数据.</p><p>而磁盘碎片就是因为写入的block太过于分散, 导致文件的读取性能会大大的降低, 因此FAT文件系统经常需要进行磁盘的碎片清理.</p><h3 id="Linux的EXT2-x2F-3文件系统"><a href="#Linux的EXT2-x2F-3文件系统" class="headerlink" title="Linux的EXT2&#x2F;3文件系统"></a>Linux的EXT2&#x2F;3文件系统</h3><p>文件系统最一开始是将block的大小和inode的节点的数量都规划好了, 除非再进行格式化或者使用工具改变文件系统的大小.</p><p>考虑这样的情况, 一个文件系统的大小为500GB, 这是一个非常庞大的数字, 如果直接这样分组, 会导致inode和block的数量非常大, 这样就会非常不容易管理. 因此一种明智的做法设计是: <strong>进行分组</strong>.</p><p>这样的块组叫做<code>blockgroup</code>.</p><p>再考虑整体的规划上, 文件系统的最前方是一个启动扇区, 这个扇区中可以安装引导装载程序.(boot loader),这样我们就可以将不同系统的引导程序安装在系统最前端, 而不用直接覆盖MBR.</p><p>下面看整个文件系统的块组的构造情况:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/group.jpg" alt="group"></p><p>整个blockgroup的最大组成部分就是data block.这个就是文件内容的存放地方.在Ext2系统中存在三种规格的block, 分别是1KB, 2KB以及4KB.在格式化的时候,block的大小就已经被固定了, 而且每一个block还会被编上号.inode的大小会影响到整个文件系统的最大容量. 当然了,每个block当然只能放一个文件, 即使文件的大小小于block的大小.</p><p>接下来, 是inodetable, 对于索引式文件系统这个是很重要的东西!因为inode中记录了所有文件数据实际上是放在哪个block中, 基本上inode中记录了以下文件数据:</p><ul><li>文件的访问模式</li><li>该文件所属的组和所有者</li><li>该文件的大小</li><li>该文件的创建或创建时间</li><li>最近一次的修改时间</li><li>定义文件特性的标志(UID什么的)</li><li>该文件的真正指向(指针)</li></ul><p>对于inode本身呢? 它具有以下特点:</p><ul><li>每一个inode的大小固定为128bytes(256)</li><li>一个文件对应一个inode, 因此inode的数量决定了文件的最大数量</li><li>系统读取文件的时候需要先找到inode, 然后检测权限是否符合, 符合才会继续去读取block的内容</li></ul><p>事实上, inode要记录的信息非常的多, 所以仅有128bytes(256)是不够的, 这样就会想到一种扩展的方法, 我们将inode寻到的block作为文件信息的拓展就像路由器一样.</p><p>这样ext文件系统最多经过三次跳转来进行文件信息的读取. ( 直接 -&gt; 双间接 -&gt; 三间接 )</p><p>就像下面的图所展示的过程:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/jump.jpg" alt="jump"></p><p>接下来的就是超级块 前面已经简单说过超级块的作用, 就是记录文件系统的信息, 他记录的主要信息待会会再下面看到.</p><p>文件系统描述说明: 其实就是每个block group的开始和结束的block号码, 以及其他区段的位置(block号)</p><p>块对照表(block bitmap): 主要用于记载那些block是空的.</p><p>inode对照表(inode bitmap): 与块对照表相似的功能, 记录那些空闲的inode</p><p>现在就来看一下这些东西到底表现出来是个什么吧!</p><p>使用<code>dumpe2fs</code>来看, 这个命令输出的信息非常的多.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Ubuntu ~]$ dumpe2fs | less</span><br></pre></td></tr></table></figure><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/dumpe2fs.png" alt="dumpe2fs"></p><p>首先看到文件系统的名称, 也就是<code>Filesystem volumn name</code>, 而后往下看就是关于文件系统的挂载参数, 以及文件系统的状态.</p><p>接下来就是上面所提到的node和block的总数, 以及剩余多少可用, 起始的block的号码,每个block的大小,inode的大小等等..</p><p>上面的就是对ext文件系统的基础认知了.</p><p>现在, 创建一个目录文件 那么操作系统就会分配1个inode以及至少一个block给它, 你会发现即使文件是空的他依然会占用4KB的大小(一个block的大小).</p><p>对于目录, 他存放的数据是什么呢? 目录文件的block中存放的是这个目录文件下存放的所有文件的inode号码和文件名.</p><p>因此目录文件并不只会占用一个block, 如果目录里面的内容太多导致一个block承载不了这么多的内容的话, 操作系统就会再分配一个block给他. </p><p>下面模拟一次操作系统读取passwd文件过程.</p><ol><li>首先, 操作系统通过挂载点信息找到设备挂载的根目录的inode的节点号, 如你所见, 是2.( 系统最顶层的inode节点一般都是2, 并且&#x2F;目录下的<code>.</code>和<code>..</code>都指向同一个地方, 也就是根自己本身 ) 访问用户具有该inode节点中记录的权限.因此允许进入得到block的号码.</li></ol><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.compasswd.png/" alt="passwd"></p><ol><li>接着, 由上一步得到block的号码,去寻找有&#x2F;etc目录的inode的号码. ( 458753 )</li><li>下一步, 读取458753的inode的信息, 如果有权限, 获得block号码, 继续访问block的内容</li><li>从block中得到passwd文件的inode号码.</li><li>读取passwd的inode(459453), 判断权限, 如果有则获得block的内容. 读取结束.</li></ol><p>这里的第一步提到了挂载点, 其实挂载的意义在于将一个目录作为文件系统的入口目录, 要想使用文件系统, 你总要把它放在Linux中的文件树上的某个地方.</p><p>你也许会奇怪, 为什么是从2号开始的. 还记得以前说过的虚拟文件系统吗? 就是&#x2F;proc 和&#x2F;sys 这两只.他们拥有1号inode.</p><p>了解到这里, 我们再回到之前那张dumpe2fs的图.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.comdumpe2fs2.png/" alt="dumpe2fs2"></p><p>在头信息的最后, 那些红色方框中的, 就是下面要说说的日志文件系统.上面说的只是读取文件, 实际上写入文件的过程是复杂的.</p><p>在写入文件的过程中, 我们不是直接写入进block中的, 因为在进行文件的删除,编辑,写入的时候superblock,inode bitmap,block bitmap的数据都是在变化的, 这样 我们称inode table和data block为数据存放区域, 而上述的三个称为中间数据</p><p>考虑这么一种情况, 在你进行正常的文件写入的时候, 因为某些原因导致系统中断(停电, 内核错误等等), 这个时候你的文件内容虽然已经写入到了data block中, 但是却还没有同步到table和bitmap上, 这样就会有很多不好的后果.也就造成了一种<strong>数据不一致</strong>的状态.简单说就是你的文件确实已经被拷贝到了磁盘上, 但是却没有分配到inode, 这样不仅无法看到, 而且在未来还有可能被覆盖掉.</p><p>早期的ext2文件系统确实考虑到了这个情况, 但是解决方法有点蠢, ext2选择在开机时进行一次数据一致性的大检查, 这样检查的缺点在于<strong>十分费时</strong></p><p>于是在ext3文件系统中有了一个日志文件系统, 原理是这样的:</p><blockquote><p>首先, 当系统要写入一个文件时, 会现在日志记录块中记录文件要写入的信息. 接着就开始写入文件的权限和数据, 并开始更新元信息.最后完成数据和元数据的更新后, 在日志记录块中完成这个文件的记录.</p></blockquote><p>这样就不用进行整个磁盘的大检查了, 直接定位到不一致的块就行了.这个就是日志文件系统的最基础的功能.</p><h3 id="Linux的文件系统的操作"><a href="#Linux的文件系统的操作" class="headerlink" title="Linux的文件系统的操作"></a>Linux的文件系统的操作</h3><p>相信你已经发现了, Linux的内存占用似乎总是占满了所有的物理内存.这是因为提高文件系统的IO效率, Linux采取了异步处理的方式,说来也很简单就是在文件仍然没有经过改动的话,就会被设置一个Clean的标志位, 如果文件内容被修改过了, 就会标记为脏数据(Dirty), 这些操作都是在内存中进行的, 所以系统会不定期的将内存中的标记为Dirty的资源写入磁盘.</p><p>并且, 系统将常用的文件数据放在主存储器的缓冲区内, 以加速文件的读&#x2F;写. 这就是为什么Linux的物理内存会被耗光的原因.</p><h3 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h3><p>Linux的内核通过一个叫做VFS的模块功能进行的文件系统的读取.我们所操作的整个文件系统都是建立在VFS之上, 下面的图可很好的概括一下:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.comvfs.gif/" alt="vfs"></p><p>再说说一个磁盘空间的浪费问题, 前面其实已经说过, 如果一个文件的大小不够一个block的大小, 他依然会占满整个block, 而一个block又最多只能有一个文件的内容.</p><h2 id="磁盘配额-Quota"><a href="#磁盘配额-Quota" class="headerlink" title="磁盘配额(Quota)"></a>磁盘配额(Quota)</h2><p>现在就进入我们的第一个主题了.</p><p>假设我们有多人登陆同一台服务器(10人), 我们给家目录单分了一个独立的分区, 大小为10GB, 这样当然是人均分1GB的空间才公平.但是不做任何操作的话 就只能靠大家自觉 ( 不存在的好吗 )</p><p>Quota就能帮我们实现这个. 首先要说的是, Quota的作用范围仅是作用于文件系统的, 这就是说你这个分区的内容都会受到影响.然后就是Quota对root无效(Linux里的天神 &#x2F;摊手)</p><p>Quota的限制功能体现在限制容量和文件数量上(也就是通过操作block&#x2F;inode来进行的)</p><p>另外Quota中有三个关键的变量:</p><ul><li>soft 软限制, 不会超过hard.用户超过该值会发出磁盘爆满的警告, 如果在最后的grace time内将容量降低回来, 倒计时就会停止.</li><li>hard 硬限制, 用户绝对不会超过这个限制, 一旦超出, 用户就会即刻失去磁盘的使用权.</li><li>grace time 默认的宽限时间是7天, 如果在时间内你没有将磁盘的使用容量降下来, soft的值就会取代hard</li></ul><p>一个配置的例子:</p><ul><li>hard &#x3D; 500MBytes</li><li>soft &#x3D; 400MBytes</li></ul><p>以上面配置的例子来说，假设你的容量高达 450MBytes 了，那七天的宽限时间就会开始倒数， 若七天内你都不进行任何删除文件的动作来替你的磁碟用量瘦身， 那么七天后你的磁碟最大用量将变成 400MBytes (那个 soft 的限制值)，此时你的磁碟使用权就会被锁住而无法新增文件了。</p><p>下面就来操作一次吧..首先要在挂载的时候开启配额选项,<strong>此次注意:根据需要,开启针对用户的限额是usrquota, 针对组别的是grpquota.</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ mount -o remount,usrquota,grpquota /<span class="variable">$POSITION</span>(挂载点位置)</span><br></pre></td></tr></table></figure><p>接下来, 就开启quota的记录档吧.</p><blockquote><p>其实 Quota 是透过分析整个文件系统中，每个使用者(群组)拥有的文件总数与总容量， 再将这些数据记录在该文件系统的最顶层目录，然后在该记录档中再使用每个帐号(或群组)的限制值去规范磁碟使用量的</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ quotacheck [-avugfM] [/mount_point]</span><br><span class="line">选项与参数：</span><br><span class="line">-a  ：扫瞄所有在 /etc/mtab 内，含有 quota 支持的 filesystem，加上此参数后， </span><br><span class="line">      /mount_point 可不必写，因为扫瞄所有的 filesystem 了嘛！</span><br><span class="line">-u  ：针对使用者扫瞄文件与目录的使用情况，会创建 aquota.user</span><br><span class="line">-g  ：针对群组扫瞄文件与目录的使用情况，会创建 aquota.group</span><br><span class="line">-v  ：显示扫瞄过程的资讯；</span><br><span class="line">-f  ：强制扫瞄文件系统，并写入新的 quota 配置档 (危险)</span><br><span class="line">-M  ：强制以读写的方式扫瞄文件系统，只有在特殊情况下才会使用。</span><br></pre></td></tr></table></figure><p>接着就执行一次试试, 正常是会报错的, 别担心.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]$ quotacheck -avug</span><br><span class="line">quotacheck: Scanning /dev/磁盘 [挂载点] quotacheck: Cannot <span class="built_in">stat</span> old user quota</span><br><span class="line">file: No such file or directory &lt;==有找到文件系统，但尚未制作记录档！</span><br><span class="line">quotacheck: Cannot <span class="built_in">stat</span> old group quota file: No such file or directory</span><br><span class="line">quotacheck: Cannot <span class="built_in">stat</span> old user quota file: No such file or directory</span><br><span class="line">quotacheck: Cannot <span class="built_in">stat</span> old group quota file: No such file or directory</span><br></pre></td></tr></table></figure><p>接着你的挂载的根目录就会多出两个文件(如果你把用户级别的和组级别的都打开了的话)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># ll -d /挂载点/a*</span></span><br><span class="line">-rw------- 1 root root 8192 Mar  6 11:58 /home/aquota.group</span><br><span class="line">-rw------- 1 root root 9216 Mar  6 11:58 /home/aquota.user</span><br></pre></td></tr></table></figure><p>接着是最简单的一步了, 直接启动Quota的服务.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># quotaon [-avug]</span></span><br><span class="line">[root@www ~]<span class="comment"># quotaon [-vug] [/mount_point]</span></span><br><span class="line">选项与参数：</span><br><span class="line">-u  ：针对使用者启动 quota (aquota.user)</span><br><span class="line">-g  ：针对群组启动 quota (aquota.group)</span><br><span class="line">-v  ：显示启动过程的相关信息；</span><br><span class="line">-a  ：根据 /etc/mtab 内的 filesystem 配置启动有关的 quota ，若不加 -a 的话，</span><br><span class="line">      则后面就需要加上特定的那个 filesystem 喔！</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由於我们要启动 user/group 的 quota ，所以使用底下的语法即可</span></span><br><span class="line">[root@www ~]<span class="comment"># quotaon -auvg</span></span><br><span class="line">/dev/磁盘 [挂载点]: group quotas turned on</span><br><span class="line">/dev/磁盘 [挂载点]: user quotas turned on</span><br></pre></td></tr></table></figure><p>关闭此服务也是很简单的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># quotaoff [-a]</span></span><br><span class="line">[root@www ~]<span class="comment"># quotaoff [-ug] [/mount_point]</span></span><br><span class="line">选项与参数：</span><br><span class="line">-a  ：全部的 filesystem 的 quota 都关闭 (根据 /etc/mtab)</span><br><span class="line">-u  ：仅针对后面接的那个 /mount_point 关闭 user quota</span><br><span class="line">-g  ：仅针对后面接的那个 /mount_point 关闭 group quota</span><br></pre></td></tr></table></figure><p>接下来就是进行最重要的地方了, 对用户或组别进行配置.这里有两种的方式进行配置, 一种是使用命令进行终端上的配置, 不喜欢这种,推荐使用<code>edquota</code>命令, 调出vi的页面供管理员编辑.</p><p>写的方式也很简单, 直接指定soft和hard就好了, 其他的属性都是自己计算的,我们不需要管他们.</p><p>这样设置之后磁盘配额就完成了, 作为管理员, 我们当然要关注当前的磁盘使用情况, 这是就要使用<code>repquota -auvs</code>命令来获取信息了, 如果你想给某个用户发送磁盘快要满了的警告, 就直接使用<code>warnquota</code>命令就好.</p><p>最后加一句小提示: 在进行目录迁移的时候, SELINUX会进行限制, 因此你需要暂时关闭SELINUX或者修改SELINUX的规则.</p><h2 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h2><p>LVM叫做逻辑卷管理器(Logical Volume Manager)</p><p>LVM拥有动态进行磁盘空间分配的功能, 看起来是动态分配, 事实上是将所有磁盘的空间全部集合到一个整体, 再在这个整体的基础上进行分配.</p><blockquote><p>LVM 的作法是将几个实体的 partitions (或 disk) 透过软件组合成为一块看起来是独立的大磁盘 (VG) ，然后将这块大磁盘再经过分割成为可使用分割槽 (LV)， 最终就能够挂载使用了.</p></blockquote><p>一个一个来说一下这些东西,就从最小的组成的开始吧.</p><p><strong>Physical Volume, PV 叫做物理卷</strong></p><p>LVM的最底层的卷, 通过调整系统标识符来使得它成为LVM的专用标识符.</p><p><strong>Volume Group, VG 卷用户组</strong></p><p>一个VG就是将许多PV整合起来, 它的最大大小和下面的PE有关.</p><p><strong>Physical Extend, PE, 物理拓展快</strong></p><p>PE是LVM的最小存储快, 你可以把它理解成上面说过的block, 只不过这个是LVM的存储块.</p><p>一个VG最多可以包含256个PE, 这就意味着如果使用默认的PE大小(4MB), VG的最大容量是256GB</p><p><strong>Logical Volume, LV 逻辑卷</strong></p><p>这个就是最终形成的LVM了, LV包含若干个PE, 也就是像一个个block group一样, 只不过他的弹性变换是通过交换PE做到的.细节见下图:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvm1.gif" alt="lvm1"></p><p>这样, 经过PV -&gt; VG -&gt; LV 的过程, 最后将LV进行格式化合适的文件系统就可以使用了, 这个文件系统拥有扩充和减少的能力.</p><p>一个完整的流程就像这样:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvm.gif" alt="lvm"></p><p>直接实际使用一遍就行了.</p><h3 id="LVM的构建过程"><a href="#LVM的构建过程" class="headerlink" title="LVM的构建过程"></a>LVM的构建过程</h3><p>既然要进行LVM的制作, 自然要先开启LVM的功能, 现在的发行版都会自己打开这个.所以一般不用担心这个, 如果没有的话…先确认内核的支持,然后在考虑是否安装lvm这个软件吧.</p><p>准备工作就是进行分区, 这次就先分四个区吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># fdisk /dev/sdb</span></span><br></pre></td></tr></table></figure><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvm_1.png" alt="lvm_1"></p><p>接着我们将所有要成为LVM的PV的磁盘标记成<code>8e</code>.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvm_2.png" alt="lvm_2"></p><p>最后,就可以得到这样分区的磁盘:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvm_3.png" alt="lvm_3"></p><p>好了,准备工作就到这里, 下面就开工吧!</p><p><strong>LVM的构建第一步就是构建PV.</strong></p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvm_pv.png" alt="lvm_pv"></p><p>这里, 最常用的就是上面的三个命令, <code>pvscan</code>用来检测当前已存在的PV, 如果想要获得每一个PV的详细信息就使用<code>pvdisplay</code>命令.<code>pvcreate</code>见名知意,就是构建PV的命令啦.</p><p>很快的我们得到了5个PV.</p><p><strong>第二步,VG阶段</strong></p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvm_vg.png" alt="lvm_vg"></p><p>VG的构建要制定PE的大小, 使用<code>-s</code>指定.接着需要指定VG的名字, 和使用哪些PV进行构建.</p><p>如你所见, 最后一个sdb9并没有得到使用, 此时已经被使用了的sdb8就获得了这些属性.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/pv.png" alt="pv"></p><p>最后再来看一下我们的获得的VG的状态:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vgdisplay.png" alt="vgdisplay"></p><p>注意到现在的PE个数是252个. 并且由于现在我们还没有进入LV阶段, 所以所有的PE都是可以任意使用的.</p><p>现在我们进行令人激动人心的第一步, 扩展现在的VG, 还剩下一个sdb9没有使用呢.现在我们就把它加上去.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vgextend_.png" alt="vgextend_"></p><p>PE的数量增加了!这说明很顺利, 我们将sdb9加入了进来.</p><p><strong>第三步,LV阶段</strong></p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvcreate.png" alt="lvcreate"></p><p>很快就构建了一个LV, -l参数表明使用的PE个数.</p><p>现在就来看一下吧:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lv.png" alt="lv">, 总大小是5G左右.</p><p>先来简单的格式化一下:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/mkfs.png" alt="mkfs"></p><p>现在可以简单的松口气啦, 一个LV就这样可以正常工作了.</p><p>可是, LVM最神奇的功能我们还没有试一试呢.好的, 现在就来尝试一下放大LV的容量.</p><p>首先当然还需要在分出新的空间来, 继续分区后, 重复一下之前的工作.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvextend0.png" alt="lvextend0"></p><p>接下来就是魔法了:</p><p><strong>使用<code>vgextend</code>先扩展<code>vg</code></strong></p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/vgextend.png" alt="vgextend"></p><p>看!VG的大小变大了, 而且PE的个数又增长了一大截.</p><p>再看看我们的LV又没有变大:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvdisplay_1.png" alt="lvdisplay_1"></p><p>挨?没有变化, 这是为什么呢?</p><p>这会因为LV的放缩是需要手动去指定的. 命令是<code>lvresize</code>, 再来操作一次:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvresize.png" alt="lvresize"></p><p>成功了!我们改变了LV的大小.</p><p>等等!增加容易, 但是如果要减少容量岂不是会损坏文件系统?</p><p>所以,优先要进行的工作就是重新规划文件系统的大小!</p><p>假设我们现在要将sdb5拿出来, 那么就要先看一下大小:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/sdb11.png" alt="sdb11"></p><p>大小为1.0GB, 那么在待会缩减文件系统的时候, 就是减少1G的容量了.</p><p>由于缩减容量是不能在线执行的(挂载中执行), 所以要先将其<code>umount</code>.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/resize2fs.png" alt="resize2fs"></p><p>总大小是6.89G, 因此减少1G之后是5.89G, 直接执行,发现要求强制执行一次磁盘检查..好吧那就执行吧, 接着直接缩减.挂载.再查看一下..OK啦</p><p>现在系统的大小已经降下来了, 之后就可以安全的删除PV了.</p><p>删除PV前还要先将LV的容量缩减 其实现在的状态是这样的:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/fs_lv.png" alt="fs_lv"></p><p>缩减LV:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lvresize_reduce.png" alt="lvresize_reduce"></p><p>接着就要将sdb5移除了, 先别急, 我么要先确认一下当前PV的情况:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/pvdisplay_sdb5.png" alt="pvdisplay_sdb5"><br><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/pvdisplay_11.png" alt="pvdisplay_11"></p><p>咦?搞了半天空闲的PE都在sdb11里!那么就要先把sdb5和sdb11的PE进行交换..</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/pvremove.png" alt="pvremove"></p><p>交换之后,就可以把这个PV从VG中移出了,看一下pvscan的结果,sdb5已经成为未分配的状态了.</p><p>接着就可以把这个分区从PV中移走了, 这个分区就可以用做其他用途了.</p><h2 id="LVM的系统快照"><a href="#LVM的系统快照" class="headerlink" title="LVM的系统快照"></a>LVM的系统快照</h2><p>LVM技术除了提供弹性的文件系统, 还可以进行备份, 严格说来叫做系统快照(Snapshot).</p><p>原理说来也很简单:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/snapshot.gif" alt="snapshot"></p><p>上图的长虚线是快照区, 而短虚线是文件系统. 从上图可以看出来LVM开辟一块区域专门用来存放快照, 这样就会有一个限制, 那就是快照区和文件系统区必须要在一个VG内.</p><p>一旦文件系统中的文件发生了改动,快照区就会将发生之前的资料移到快照区, 然后从快照区中将发生改变的PE移出去.</p><p>那么还是直接实践吧:</p><p>先把我们刚刚移除的sdb5变回来…</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/sanp_1.png" alt="sanp_1"></p><p>多了63个可用的PE, 我们用50个来构建快照.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/sanp_2.png" alt="sanp_2"></p><p>这个和我们构建LV的不同在于, 加了<code>-s</code>参数(snapshot之意)</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/lv_sanpshot.png" alt="lv_sanpshot"></p><p>红框上面还有两个非常重要的参数.一个是快照实际的空间一个是拥有的PE数量.</p><p>这里有一个名词叫<strong>COW</strong>, 意思是<code>Copy on first write</code>,结合上面的图示, COW的优势在于原始的物理块连续, 没有碎片, 但是却将原本的一次写操作变成了1读3写.</p><p>还有一种快照技术叫做<strong>ROW</strong>(<code>Redirect on first write</code>).其实就是在数据块改变时,和COW一样分配一个新的物理块,接着就不一样了,ROW选择将原始卷中的文件映射改变,变成新的物理块,这样其实是比COW的性能更好的,因为一共是0读2写.但是缺点是原始卷中的物理块是不连续的,也就是磁盘碎片.</p><p>好了,下面来挂载试一下.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/df_snap.png" alt="df_snap"></p><p>他们两个是一模一样的呢!不过Snapshot会主动记录员nameofLV的数据!</p><p>现在来试一下快照的功能:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/sanp.png" alt="sanp"></p><p>已经被使用了1.30%.</p><p>现在我们试一试恢复原数据( <strong>实验建议:建议多拷贝一些数据到里面,这样效果才比较明显</strong> )</p><p>重新挂载.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/df-h.png" alt="df-h"></p><p>可以看出,快照和原来已经发生了变化.</p><p>接着进入snapshot, 进行备份:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/tar.png" alt="tar"></p><p>备份之后就可以将我们的原LV进行格式化了.</p><p>先将快照移除并删掉:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/umount.png" alt="umount"></p><p>格式化:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/mkfs_.png" alt="mkfs_"></p><p>重新挂载回来,之前的备份进行解包.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/remount.png" alt="remount"></p><p>好了,复原工作就结束了.</p><p>实验结束了, 现在就把LVM关闭吧.</p><p>附一下简要流程:</p><ul><li><p>先卸载系统上面的LVM 档案系统(包括快照与所有LV)；</p></li><li><p>使用lvremove 移除LV ；</p></li><li><p>使用vgchange -an VGname 让VGname 这个VG 不具有* Active 的标志；</p></li><li><p>使用vgremove 移除VG：</p></li><li><p>使用pvremove 移除PV；</p></li><li><p>最后，使用fdisk 修改ID 回来！OK啦!</p><hr></li></ul><p>17.6.20 更新:</p><h2 id="XFS文件系统"><a href="#XFS文件系统" class="headerlink" title="XFS文件系统"></a>XFS文件系统</h2><p>从CentOS7开始, 官方已经开始使用XFS文件系统而抛弃了EXT4.</p><p>这是因为在原先磁盘容量不是很大的时候, 这种预先就划分所有的inode&#x2F;block&#x2F;meta data的做法还没有什么问题.但是现在的磁盘大小动辄就是TB以上的等级, 光是进行格式化就要花费很多时间.</p><p>而XFS是一个适合高容量或者巨型资料的文件系统.</p><p>XFS 就是一个日志式档案系统, 所有EXT文件系统支持的功能. 他都支持.</p><p>在文件系统的构造上, XFS将文件系统分成了三个部分: 数据区(data section), 日志区(log section), 即时区(realtime section). 这三个区的内容是这样的:</p><h3 id="数据区-data-section"><a href="#数据区-data-section" class="headerlink" title="数据区(data section)"></a>数据区(data section)</h3><p>基本上，数据区就跟我们之前谈到的EXT系统一样，包括inode&#x2F;data block&#x2F;superblock 等资料，都放置在这个区块。这个数据区与EXT家族的block group 类似，也是分为多个储存区群组(allocation groups, AG) 来分别放置档案系统所需要的资料。每个储存区群组都包含了:</p><ul><li><p>整个档案系统的superblock</p></li><li><p>剩余空间的管理机制</p></li><li><p>inode的分配与追踪</p><p>此外，inode与block 都是系统需要用到时， 这才动态配置产生，所以格式化动作非常快！</p></li></ul><h3 id="日志区-log-section"><a href="#日志区-log-section" class="headerlink" title="日志区(log section)"></a>日志区(log section)</h3><p>这个区是XFS用来进行数据恢复以及检查错误的重要的区域.和日志区有点像,当文件系统出现变化都会先在这里进行记录, 直到该变化被完整的写入到磁盘中. 这一条记录才会被终结掉. 这样当文件系统因为某些原因导致损毁的时候 系统就可以使用这个区块进行检验, 这样就可以直到在挂掉之前文件系统在干什么, 借以快速修复文件系统.</p><p>有意思的是, 这个区块你可选择外部的磁盘. 就是说你的文件系统是可以跨磁盘的(就像btrfs那样).</p><h3 id="即时区-realtime-section"><a href="#即时区-realtime-section" class="headerlink" title="即时区(realtime section)"></a>即时区(realtime section)</h3><p>这个部分是用来进行数据写入时使用的, 当写入数据的时候, xfs会先寻找一个或者数个extent区块, 接着分配结束后, 再将数据写入到data section的inode和block里面去. 这个extent区块的大小在格式化的时候就要指定(4K-1G).一般普通的使用都直接使用预设的64K就好.</p><h2 id="XFS的构建"><a href="#XFS的构建" class="headerlink" title="XFS的构建"></a>XFS的构建</h2><p>简单介绍一下之后, 我们下面就要一起来构建XFS系统, 仍然是老朋友<code>mkfs</code>的出场啦.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ mkfs.xfs device</span><br><span class="line"><span class="comment"># 和ext一样, 后面也可以指定block, inode的相关参数,</span></span><br><span class="line"><span class="comment"># 但是特别就是指定data section的相关参数</span></span><br></pre></td></tr></table></figure><p>下面就来操作一下:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/xfs1.png" alt="xfs1"></p><p>很快就成功格式化了一个xfs的系统, 可以看到他的data, log和realtime都有不同的参数.</p><p>如果是多个核心的机器, 建议加上<code>-d adcount=[核数]</code> 的参数, 这样可以使得XFS读写系统的速度增加.</p><p>在这里插一句XFS4RAID的性能优化:</p><p>RAID中的区块叫做<code>stripe</code>, 这个<code>stripe</code> 的大小会决定我们格式化文件系统的参数的值.主要就是<code>data section</code>啦.其中的<code>sunit</code>设置为和RAID的<code>stripe</code>一样大小的, 而<code>swidth</code>由磁盘的数量和等级来定(e.g: 组建一个RAID-5的阵列, 一共有8块磁盘, 其中一个为备份盘. 此时<code>sw</code>就设置为7) 最后计算一下<code>extsize</code>就是<code>sw</code>*<code>su</code></p><p>直接进环境吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ mkfs.xfs -f -d agcount=1,su=256k,sw=7 -r extsize=1792k /dev/sdb2 </span><br></pre></td></tr></table></figure><p>查看创建的XFS的描述信息使用<code>xfs_info</code>的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ xfs_info /mydata/</span><br><span class="line">meta-data=/dev/sdb1              isize=512    agcount=4, agsize=131072 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=1 spinodes=0 rmapbt=0</span><br><span class="line">         =                       reflink=0</span><br><span class="line">data     =                       bsize=4096   blocks=524288, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line"><span class="built_in">log</span>      =internal               bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure><p>上面的<code>isize</code>是指<code>inode</code>的容量, 每一个都有<code>512bytes</code>大小, 后面的<code>agcount</code>就是储</p><p>存群组的个数, 共有<code>4</code>个.</p><p>接着后面的是每一个储存群组有的<code>block</code>的个数, 有<code>121072</code>个. 后面的<code>bsize</code>, 相信也能猜出来 恩 就是每一个<code>block</code>的大小. </p><p>后面的<code>internal</code>标识日志区的位置是在文件系统内, 而不是外部设备, 以及占用的<code>block</code>的数量.</p><h2 id="XFS的使用"><a href="#XFS的使用" class="headerlink" title="XFS的使用"></a>XFS的使用</h2><p>如果在格式化的时候我忘记了给文件系统加上UUID和Label怎么办呢? 不需要重新进行格式化的, 可以使用<code>xfs_admin</code>来查看和重新设定.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ xfs_admin [OPTIONS] &lt;DEVICE&gt;</span><br><span class="line">-l 列出label</span><br><span class="line">-u 列出UUID</span><br><span class="line">-L 设定Label</span><br><span class="line">-U 设定UUID</span><br></pre></td></tr></table></figure><p>如果文件系统损坏, 或者发生了什么错乱 就要进行修复.XFS的修复指令是<code>xfs_repair</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ xfs_repair [-fnd] &lt;DEVICE&gt; </span><br><span class="line">-f 表明后面的device其实是个文件系统而不是实体磁盘</span><br><span class="line">-n 仅仅是检查, 并不会修改系统的信息</span><br><span class="line">-d (危险参数) 对根目录(/)进行检查和修复.</span><br></pre></td></tr></table></figure><p>如果文件系统损坏, 或者发生了什么错乱 就要进行修复.XFS的修复指令是<code>xfs_repair</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ xfs_repair [-fnd] &lt;DEVICE&gt; </span><br><span class="line">-f 表明后面的device其实是个文件系统而不是实体磁盘</span><br><span class="line">-n 仅仅是检查, 并不会修改系统的信息</span><br><span class="line">-d (危险参数) 对根目录(/)进行检查和修复.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的文件和FHS &amp; sudo的使用</title>
      <link href="/2017/06/08/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8CFHS&amp;sudo/"/>
      <url>/2017/06/08/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8CFHS&amp;sudo/</url>
      
        <content type="html"><![CDATA[<p>一切皆文件. 你也是.</p><span id="more"></span><p>说到文件系统必然会扯到权限问题, 这篇笔记中就只拣相关的来说一说.</p><p>在不说到高级的权限管理的时候, Linux只有三种用户: </p><ul><li>root – 万能的用户</li><li>同一Group – 统一用户组的用户</li><li>Others – 其他用户</li></ul><p>相关的文件就是 &#x2F;etc&#x2F;passwd (所有用户) &#x2F;etc&#x2F;shadow (用户密码) &#x2F;etc&#x2F;groups (所有用户组)</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>当时用<code>ls -l</code>查看目录的时候, 会列出文件的很多元信息. 其中就包括文件的类型和权限.</p><p>文件权限区域数一数的话, 一共有10个字符.</p><blockquote><p><code>-|rwx|rw-|--- 1 root root 3231 Jun 4 17:21 install.log</code></p></blockquote><p>其中第一个是用来显示文件的类型的, 这些:</p><ul><li><strong>-</strong> regular文件</li><li><strong>d</strong> 目录</li><li><strong>l</strong> 链接文件</li><li><strong>b</strong> 块文件 设备文件中的可供存储的接口设备.</li><li><strong>c</strong> 特殊字符文件 设备文件中的串行端口设备</li></ul><p>接着的三个三个一组的就是文件权限属性, 常规的不说了.在这里说一说权限的重要意义.</p><h3 id="Linux中文件权限的重要意义"><a href="#Linux中文件权限的重要意义" class="headerlink" title="Linux中文件权限的重要意义"></a>Linux中文件权限的重要意义</h3><h4 id="对于文件"><a href="#对于文件" class="headerlink" title="对于文件"></a>对于文件</h4><p><strong>(r)</strong> 读权限,拥有此权限就可以进行文件的读取, 例如读取文本文件的文字内容等.<br><strong>(w)</strong> 可以编辑,新增或者修改该文件的内容(不包括删除).</p><blockquote><p><del>插一句, 我在做测试的时候发现删除文件的时候竟然不需要权限?奇怪?</del></p></blockquote><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/rm.png" alt="rm"></p><p>上面的情况理解了,文件删除的权限取决于该文件上级文件夹的权限.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/rm2.png" alt="rm2"></p><p><strong>(x)</strong> 改文件有被系统执行的权限.与Windows不同的是, Linux下全靠该权限来决定文件是否可被执行, 而不是文件后缀名, Linux的文件后缀名没有绝对的意义.</p><p>事实上,权限是对于<strong>文件内容</strong>而言的,与文件名的存在与否是没有什么关系的.</p><h4 id="对于目录"><a href="#对于目录" class="headerlink" title="对于目录"></a>对于目录</h4><p>目录的权限意义相比之下是比文件的权限更加重要的,所以也稍微复杂一点.<strong>目录也是文件呀!</strong></p><p>一个一个来说一下:</p><p><strong>(r)</strong> 代表你可以读取目录结构列表, 这也是目录的文件内容.简而言之, 具有读权限意味着你可以在目录中进行<code>ls</code>这样的操作.<br><strong>(w)</strong> 这个是对于目录和目录中的文件的最重要的权限.包含下列动作:</p><ul><li>新建文件 </li><li>删除文件(不论该文件的权限如何), 这也是上面的疑问.</li><li>进行对已存在的文件的重命名.</li><li>转移该目录下的文件</li></ul><p>凡是会发生变动的, 都是**(w)**权限赋予的.</p><p><strong>(x)</strong> 目录不可以执行, 那这个权限的意义是什么呢? 就是把目录当做你的工作目录啦. 通俗的说, 你可以<strong>进入</strong>该目录.</p><hr><p>接着说刚刚的文件元信息.</p><p>后面的数字是指这个文件的引用计数, 说白了就是这个文件内容的硬连接数. ( 此处存个疑问, 目录的连接数为什么这么多?或者说, 目录的连接计数是怎么计算的呢? )</p><blockquote><p><strong>更新:</strong></p><p>链接计数到底是怎么计算的呢? 我们已经知道Linux通过inode号码来进行文件索引, 而进入目录其实就是打开目录文件的操作. 你会发现除了目录文件, 你所创造的新文件都是链接计数为1的. 如果你做了硬链接的操作的话, 这个计数就会加1. 那么现在就来解决之前的疑问吧. 在创建目录文件的时候, 系统会自动在里面创建两个硬链接: <strong>.</strong> 和 <strong>..</strong> 这就是为什么你的新目录会有两个链接了, 其中一个是自己的硬链接啊!所以会自动加一. 因此 新的目录文件的连接数就是2. 同样的道理, 如果这个目录里面由一个目录的话, 他的连接数就是3 ( 2+1 ), 因为那个子目录也有一个**..**指向它. </p><p><strong>因此,目录文件的连接数最小是2, 每创建个子目录,这个数字就加一.</strong></p></blockquote><p>接着,第三列和第四列分别是文件的所有者和所属组.</p><p>接着就是文件内容的大小,单位就是<code>Byte</code>.</p><p>再往后一栏是文件最近的修改时间.(默认显示)</p><p>最后就是这个文件的文件名.如果文件名前携带”.”, 则表明该文件为隐藏文件.</p><h3 id="文件类型和扩展名"><a href="#文件类型和扩展名" class="headerlink" title="文件类型和扩展名"></a>文件类型和扩展名</h3><p>尽管Linux中的文件扩展名没有绝对的意义, 但他们可以方便管理者进行方便的辨识, 因此后缀名是作为一种规范而存在的.</p><p>先来说一下文件的种类.</p><p>之前说过的几种文件类型, 我们可以把文件划分成这些:</p><ul><li><p>普通文件 ( Regular File )</p></li><li><p>纯文本文件 ( ASCII Text ) Linux系统中最多的文件种类</p></li><li><p>二进制文件 ( Binary File ) 可执行文件</p></li><li><p>数据格式文件 ( Data File ) 比如 <code>/etc/wtmp</code> 文件,直接读取是乱码,但是使用<code>last</code>命令可以读取.</p></li><li><p>目录 ( Directory )</p></li><li><p>第一个属性为<code>d</code></p></li><li><p>链接文件 ( Link )</p></li><li><p>第一个属性为<code>l</code>, 虽然类似Win下的shortcut, 但是原理完全不一样.</p></li><li><p>设备与设备文件 ( device )</p></li><li><p>块设备文件</p></li><li><p>特殊字符文件</p></li><li><p>套接字文件 ( sockets )</p></li><li><p>管道 ( FIFO, pipe )</p></li></ul><p>关于Linux 的文件扩展名,一些基本的扩展名在这里说几个.</p><ul><li>*.sh 脚本或者批处理文件</li><li>*.Z, *.tar, *.tar.gz, *.zip, *.tgz, 这些是经过打包的压缩文件.</li><li>*.cfg, *.conf 配置相关文件</li><li>*.php, *.html 网页相关文件</li><li>*.socket, *.sock 套接字文件</li><li>*.log 日志</li><li>*.pid 记载进程号的文件</li><li>*.so 库<br>….</li></ul><h3 id="文件的权限补充"><a href="#文件的权限补充" class="headerlink" title="文件的权限补充"></a>文件的权限补充</h3><p>先说一说文件的隐藏属性. 除了上面说过的那一排, 文件还存在一些隐藏属性.</p><p>先来查看一波:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ root@Ubuntu ~]$ lsattr <span class="built_in">test</span></span><br><span class="line">-------------e-- <span class="built_in">test</span></span><br><span class="line">[ root@Ubuntu ~]$ chattr +i <span class="built_in">test</span></span><br><span class="line">[ root@Ubuntu ~]$ <span class="built_in">rm</span> -rf <span class="built_in">test</span></span><br><span class="line"><span class="built_in">rm</span>: cannot remove ‘<span class="built_in">test</span>’: Operation not permitted</span><br><span class="line">$ 即使是root也不能删除!</span><br></pre></td></tr></table></figure><p>文件的隐藏属性有一些很有趣的属性,像上面的<code>i</code>, 就是指<code>immutable</code>该文件不可写,不可改变,不可删除.只有root才可以进行该选项的设置.</p><p>简单的列一些隐藏属性:</p><p><strong>A</strong> 设置了A属性的文件,当对其进行访问时,他的访问时间(atime)并不会改变,这有利于减少磁盘的I&#x2F;O.<br><strong>a</strong> 设置了a之后, 这个文件只能增加数据,而不能删除或修改已有的数据 (只有root可进行设置)<br><strong>c</strong> 这个 对于大文件似乎有点作用,在文件存储在磁盘的时候,会自动进行压缩, 在读取时会自动解压.<br><strong>s</strong> 当设置了该属性, 文件数据会在删除的时候真的从磁盘上抹掉.</p><p>最后再说一说文件的SUID,SGID和SBIT权限. ( 其实我觉得不是很常用 ),而且这些权限在使用不当的情况下会造成很严重的后果.</p><h3 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h3><p>SUID很好理解, 仅可用于二进制可执行文件, 当赋予了该权限的文件被执行的时候, 执行者将会获得该文件所有者的权限(其实都是直接视作所有者).</p><p>这个东西的一个最好理解的例子就是passwd命令.当你执行这个命令的时候, 你就获得了root权限(暂时), 然后就会有权限去修改passwd文件.</p><h3 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h3><p>同理, SGID也只对二进制文件起效果, 执行者会暂时获得所属用户组的权限.</p><h3 id="SBIT"><a href="#SBIT" class="headerlink" title="SBIT"></a>SBIT</h3><p>SBIT仅对目录起效果,简单的说就是, 该目录下创建的所有文件和目录文件, 都不能被创建者和root以外的人删除掉.</p><p>这个三个权限的值分别为:4-&gt;GUID, 2-&gt;SGID, 1-&gt;SBIT</p><hr><h2 id="Linux目录配置标准-FHS"><a href="#Linux目录配置标准-FHS" class="headerlink" title="Linux目录配置标准 ( FHS )"></a>Linux目录配置标准 ( FHS )</h2><p>这就是重点了, FHS的全称是( Filesystem Hierarchy Standard ), 正是因为Linux的使用者,开发者太多了, 如果每一个Distribution都有自己的一套, 那岂不是学习成本飞涨? 正因为此, 大家都遵循这个规范设计, 这样就可以保持同样的目录架构.</p><p>FHS是跟着历史不断改版的, 他将目录定义成下面的四种交互作用的形态.</p><table><thead><tr><th align="center"></th><th align="center">可分享的(shareable)</th><th align="center">不可分享的(unshareable)</th></tr></thead><tbody><tr><td align="center">不变的(static)</td><td align="center">&#x2F;usr</td><td align="center">&#x2F;etc</td></tr><tr><td align="center">不变的(static)</td><td align="center">&#x2F;opt</td><td align="center">&#x2F;boot</td></tr><tr><td align="center">可变动的(variable)</td><td align="center">&#x2F;var&#x2F;mail</td><td align="center">&#x2F;var&#x2F;run</td></tr><tr><td align="center">可变动的(variable)</td><td align="center">&#x2F;var&#x2F;spool&#x2F;news</td><td align="center">&#x2F;var&#x2F;lock</td></tr></tbody></table><p>什么意思呢?</p><p><strong>可分享的</strong>: 简单的说就是可以分享给其他系统( 网络其他主机 )挂载的目录</p><p><strong>不可分享的</strong>: 本机上的设备文件或套接字, 这些都是本地机器有关.</p><p><strong>不变的</strong>: 这些数据不会变动, 随<code>distribution</code>而不变动. 例如: 函数库, 文件说明, 系统管理员所管理的主机配置文件.</p><p><strong>可变动的</strong>: 经常需要改变的数据, 例如登录文件, 新闻组等.</p><p>这是FHS中对于三层目录下应该放置什么数据, 分别是: &#x2F; (root) , &#x2F;usr (UNIX software resource)[以前一直以为是user, 其实这个和user没有什么关系], &#x2F;var (variable) 与系统运作过程有关.</p><p>FHS中规定, 根目录所在的分区,应该越小越好,应用程序安装的软件应该尽量避免与根目录放在同一分区中,这样不仅性能更好,根所在的文件系统也不那么容易发生问题.</p><p>这是因为,根目录是整个系统最重要的一个目录.不但所有的目录都是从根目录中衍生出来的,同时根目录还是与开机,还原,系统修复等操作有关.由于开机时需要特定的开机软件.内核文件.开机所需程序.函数库等文件数据.因此当系统发生错误的时候,就需要根目录下的系统还原文件.</p><p>FHS定义出根目录下面要有这些子目录才好, 这些目录是:</p><blockquote><p><strong>&#x2F;bin</strong> – 放置单用户模式下仍然能够被操作的命令, 主要有<code>cat</code>. <code>chmod</code>. <code>chown</code>, <code>date</code>. <code>mv</code>. <code>mkdir</code>. <code>cp</code>. <code>bash</code>等.<br><strong>&#x2F;boot</strong> – 放置开机会用到的文件,包括Linux的内核文件和开机菜单所需的配置文件, 一般Linux的内核文件都是<code>vmlinuz</code>命名, 如果使用Grub进行的开机引导, 则还会存在&#x2F;boot&#x2F;grub这个目录<br><strong>&#x2F;etc</strong> – Linux下的配置文件所在地,几乎所有的配置文件都在这里,一般来说,该目录下的文件只有<code>root</code>可进行修改,<strong>FHS建议,该目录下不要存放可执行的二进制文件</strong>.<br><strong>&#x2F;home</strong> – 系统默认的用户家目录,默认的用户主文件会规范到这里来.<br><strong>&#x2F;lib</strong> – 这里放置了部分系统的函数库, 系统的函数库非常多,而这里放置的主要是系统开机的时候使用到的函数库以及<code>/bin</code>和<code>/sbin</code>会用到的函数库.另外,该目录下放置了Linux内核相关的模块(&#x2F;lib&#x2F;module).<br><strong>&#x2F;media</strong> – 简单的说,该目录下放置的是可删除的设备文件 ( 光盘 软盘 等等 )<br><strong>&#x2F;mnt</strong> – 用来进行暂时挂载的目录,早期和<code>/media</code>的用途相同.<br><strong>&#x2F;opt</strong> – 用来放置第三方的软件,不过现在的软件都更习惯安装在<code>/usr/local</code>这个目录下.<br><strong>&#x2F;root</strong> – 系统管理员的主文件夹,一般会把他和根目录挂挂载在同一个分区,这是因为单用户维修模式下,用户会拥有<code>root</code>的主文件夹, 此时只挂载根目录.<br><strong>&#x2F;sbin</strong> – 只有root才有权限进行的命令.<br><strong>&#x2F;srv</strong> – 服务程序所需要取用的数据目录,似乎不常用.<br><strong>&#x2F;tmp</strong> – 一般用户或者正在进行的程序或者暂时放置文件的目录.FHS甚至建议在开机时清空&#x2F;tmp目录</p></blockquote><p>除了FHS的标准,大部分的发行版都会在根目录下增加<code>/proc</code>.<code>/sys</code>以及<code>/lost+found</code>.</p><p>这些目录也需要了解, <code>/proc</code>目录本身就是一个虚拟文件系统, 他的所有内容都是在内存中的, 所以本身不占任何磁盘空间.该目录下记载了系统内存 进程 外部设备的状态和网络状态.</p><p><code>/sys</code>和<code>/proc</code>一样, 也是一个虚拟的文件系统,主要记录内核相关的信息:目前已加载的内核模块, 内核检测到的硬件设备信息.</p><p><code>loast+found</code>仅在使用标准的<code>ext2/ext3</code>文件系统格式才会产生的目录.目的在于,当系统产生错误的时候, 会将一些丢失的目录片段丢到这里面.,当新装了一块硬盘的时候, 系统就会自动产生一个<code>lost+found</code>.</p><p>根据上面所说, 开机时会加载很多函数 配置文件 开始菜单等等…所以,绝对不能把以下目录和根分开:</p><ul><li>&#x2F;etc  [配置文件]</li><li>&#x2F;bin [重要执行文件]</li><li>&#x2F;dev [设备文件]</li><li>&#x2F;lib [函数库和内核模块]</li><li>&#x2F;sbin [系统执行文件]</li></ul><p>除了根目录, <code>/var</code>和<code>/usr</code>下也有很多重要的子目录.</p><p><code>/usr</code>下也有一个<code>bin</code>目录,和<code>/bin</code>的区别在于是否在开机时使用.</p><p><code>/usr/src</code> 一般放置源码, 其中再深入一级的<code>/linux</code>放置的是Linux的系统源码.</p><p><code>/usr/include</code> C&#x2F;C++的头文件,当使用tarball的方式进行软件安装的时候,就会用到这其中的头文件与包含文件.</p><p><code>/usr/lib</code> 是软件的函数库和目标文件;</p><p>而<code>/var</code>目录是一个随着系统运行会逐渐变大的目录.因为缓存 登录文件 程序文件( lock pid )都会出现在这里面:</p><p><code>/var/cache</code>程序运行时产生的暂存文件.</p><p><code>/var/log</code>里面保存的是登录文件和一些程序的日志.</p><p><code>/var/run</code>下会放置一些服务和程序的pid文件.</p><p><code>/var/lock</code>这里是为了确保程序或者软件在同一时间仅会有同一人在进行访问或操作而加的锁所放置的目录.</p><h2 id="sudo的简单使用"><a href="#sudo的简单使用" class="headerlink" title="sudo的简单使用"></a>sudo的简单使用</h2><p>接触sudo之前, 我们知道有个叫su的命令. su其实就是switch-user. 使用时有点像SSH命令, 可以进行登录, 可以开一个子进程, 可以直接执行之后退出, 看下面的实例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># useradd test</span></span><br><span class="line">[root@WWW ~]<span class="comment"># su -l test</span></span><br><span class="line">Last login: Mon Sep 25 20:04:14 EDT 2017 on pts/0</span><br><span class="line">[<span class="built_in">test</span>@WWW ~]$ <span class="built_in">logout</span></span><br><span class="line">[root@WWW ~]<span class="comment"># su test</span></span><br><span class="line">[<span class="built_in">test</span>@WWW root]$ <span class="built_in">logout</span></span><br><span class="line">bash: <span class="built_in">logout</span>: not login shell: use `<span class="built_in">exit</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">[test@WWW root]$ exit</span></span><br><span class="line"><span class="string">exit</span></span><br><span class="line"><span class="string">[root@WWW ~]# su test -c &#x27;</span><span class="built_in">ls</span> -a ~/<span class="string">&#x27;</span></span><br><span class="line"><span class="string">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .zshrc</span></span><br><span class="line"><span class="string">[root@WWW ~]# su -l test -c &#x27;</span><span class="built_in">ls</span> -a ~/<span class="string">&#x27;</span></span><br><span class="line"><span class="string">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .zshrc</span></span><br></pre></td></tr></table></figure><p>使用-l参数就可以指定是否进行登录, 也可以使用-c参数直接执行.</p><p>由于<code>su</code>直接进行的用户切换, 在很多场景下是不合适的. 所以这个时候就要使用<code>sudo</code> 了.</p><p>sudo能够让一个用户不需要拥有另一个用户的密码就可以那个用户的权限运行. 只要另一个用户进行授权. 这样就可以进行操作的限制. 比su要灵活的. 这么一种机制的配置文件叫sudoer.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo [COMMAND]</span><br></pre></td></tr></table></figure><p>我们来看看这个配置文件写了哪些内容.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># cat /etc/sudoers</span></span><br><span class="line"><span class="comment">## Sudoers allows particular users to run various commands as</span></span><br><span class="line"><span class="comment">## the root user, without needing the root password.</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## Examples are provided at the bottom of the file for collections</span></span><br><span class="line"><span class="comment">## of related commands, which can then be delegated out to particular</span></span><br><span class="line"><span class="comment">## users or groups.</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## This file must be edited with the &#x27;visudo&#x27; command.</span></span><br><span class="line">...(omitted)</span><br><span class="line">rootALL=(ALL) ALL</span><br><span class="line">...(omitted)</span><br></pre></td></tr></table></figure><p>这个文件主要定义了哪些用户可以得到什么操作的授权. 基本上就是上面的那种形式. 例如root的这一条就是说, 允许用户<strong>root</strong> 在<strong>任何主机</strong>上 以<strong>任何用户</strong>的身份, 执行<strong>所有命令</strong>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># sudo -u test whoami</span></span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>使用-u参数可以具体制定以谁的身份执行.</p><p>继续往后看配置文件, root的下面有个奇怪的用户:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%wheelALL=(ALL)ALL</span><br></pre></td></tr></table></figure><p>前面由一个百分号(%) , 这个表示的是组名的标记, 也就是说这个组别的所有用户.</p><p>现在我们来做个实验, 可以新开一个SSH会话方便实验. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># su -l test</span></span><br><span class="line">Last login: Mon Sep 25 20:05:57 EDT 2017 on pts/0</span><br><span class="line">[<span class="built_in">test</span>@WWW ~]$ fdisk -l</span><br><span class="line">[<span class="built_in">test</span>@WWW ~]$ sudo fdisk -l</span><br><span class="line"></span><br><span class="line">We trust you have received the usual lecture from the <span class="built_in">local</span> System</span><br><span class="line">Administrator. It usually boils down to these three things:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#1) Respect the privacy of others.</span></span><br><span class="line">    <span class="comment">#2) Think before you type.</span></span><br><span class="line">    <span class="comment">#3) With great power comes great responsibility.</span></span><br><span class="line"></span><br><span class="line">[sudo] password <span class="keyword">for</span> <span class="built_in">test</span>: </span><br><span class="line"><span class="built_in">test</span> is not <span class="keyword">in</span> the sudoers file.  This incident will be reported.</span><br></pre></td></tr></table></figure><p>他说test用户不在sudoers文件中, 此事将被报告.</p><p>但是我们有个wheel组, 所以现在试着把test加入进去.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># usermod -a -G wheel test</span></span><br></pre></td></tr></table></figure><p>再试一次:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>@WWW ~]$ sudo fdisk -l</span><br><span class="line">[sudo] password <span class="keyword">for</span> <span class="built_in">test</span>: </span><br><span class="line"><span class="built_in">test</span> is not <span class="keyword">in</span> the sudoers file.  This incident will be reported.</span><br><span class="line">[<span class="built_in">test</span>@WWW ~]$ <span class="built_in">logout</span> </span><br><span class="line">[root@WWW ~]<span class="comment"># su -l test</span></span><br><span class="line">Last login: Mon Sep 25 20:19:05 EDT 2017 on pts/1</span><br><span class="line">[<span class="built_in">test</span>@WWW ~]$ sudo fdisk -l</span><br><span class="line">[sudo] password <span class="keyword">for</span> <span class="built_in">test</span>: </span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x000c83cb</span><br></pre></td></tr></table></figure><p>仍然不行, 这是因为我们需要进行重新登录. 重新登录之后就可以进行了.</p><p>sudo的威力不知这样, 如果我们使用下面的命令, 影响是很大的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">test</span>@WWW ~]$ sudo su -</span><br><span class="line">Last login: Mon Sep 25 20:19:07 EDT 2017 on pts/0</span><br><span class="line">[root@WWW ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>无需使用密码, 就可以直接登录管理员账号. 这就是加入wheel组带来的权限. 显然我们是要针对不同的用户进行不同的权限设置的, 这个时候就应该去编辑sudoer文件. 在sudoer文件的开头写了这么一段话:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## This file must be edited with the &#x27;visudo&#x27; command.</span></span><br></pre></td></tr></table></figure><p>这样是可以检查语法错误的.</p><p>我们来试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]<span class="comment"># visudo </span></span><br><span class="line"></span><br><span class="line">     80 </span><br><span class="line">     81 <span class="comment">## Next comes the main part: which users can run what software on</span></span><br><span class="line">     82 <span class="comment">## which machines (the sudoers file can be shared between multiple</span></span><br><span class="line">     83 <span class="comment">## systems).</span></span><br><span class="line">     84 <span class="comment">## Syntax:</span></span><br><span class="line">     85 <span class="comment">##</span></span><br><span class="line">     86 <span class="comment">##      user    MACHINE=COMMANDS</span></span><br><span class="line">     87 <span class="comment">##</span></span><br><span class="line">     88 <span class="comment">## The COMMANDS section may have other options added to it.</span></span><br><span class="line">     89 <span class="comment">##</span></span><br><span class="line">     90 <span class="comment">## Allow root to run any commands anywhere</span></span><br><span class="line">     91 root    ALL=(ALL)       ALL</span><br><span class="line">     92 <span class="built_in">test</span>    ALL=(root)      ALL</span><br></pre></td></tr></table></figure><p>其实并没有这么死板, sudoer支持的写法有很多种:<br>第一配置项用户, 可以使用<strong>用户名, #uid, 用户别名, %用户组等等</strong> 如果有多个, 可以使用 逗号(,) 分割. 另外还支持取反, 使用!</p><p>用户别名也是在这个文件中进行定义的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User_Alias NETADMIN = <span class="built_in">test</span>, test2, test3</span><br><span class="line">Cmnd_Alias NETWORKING = /sbin/route, /sbin/ifconfig, /bin/ping, /sbin/dhclient, /usr/bin/net, /sbin/iptables, /usr/bin/rfcomm, /usr/bin/wvdial, /sbin/iwconfig, /sbin/m    ii-tool</span><br></pre></td></tr></table></figure><p>除了用户可以进行别名定义, 还有命令,主机也可以进行. 要注意的是, <strong>别名必须大写</strong> </p><p>主机名称也是多种多样的形式, 可以使用<strong>IP地址, 主机名, 网络地址(&#x2F;掩码), 别名等</strong> 命令也是这样, 可以直接写<strong>命令名, 目录名(该目录下的所有命令都包括), 别名</strong></p><p>到这里基本配置文件就是这样了,  现在来考虑这个问题, 如果现在经过了认证, 我如果想要立即再次执行同样的命令, 就要再次输入密码, 这样是不是有点繁琐了呢? 好在sudo考虑到了这个, 所以会提供一个免验证的令牌时间(5分钟) 只需要在一开始经过验证就行了.</p><p>sudo还提供了其他的功能, 例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">test</span>@WWW ~]$ sudo -l</span><br><span class="line">Matching Defaults entries <span class="keyword">for</span> <span class="built_in">test</span> on this host:</span><br><span class="line">    !visiblepw, always_set_home, env_reset, env_keep=<span class="string">&quot;COLORS DISPLAY HOSTNAME HISTSIZE KDEDIR LS_COLORS&quot;</span>, env_keep+=<span class="string">&quot;MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS</span></span><br><span class="line"><span class="string">    LC_CTYPE&quot;</span>, env_keep+=<span class="string">&quot;LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES&quot;</span>, env_keep+=<span class="string">&quot;LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE&quot;</span>, env_keep+=<span class="string">&quot;LC_TIME</span></span><br><span class="line"><span class="string">    LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY&quot;</span>, secure_path=/sbin\:/bin\:/usr/sbin\:/usr/bin</span><br><span class="line"></span><br><span class="line">User <span class="built_in">test</span> may run the following commands on this host:</span><br><span class="line">    (root) /sbin/route, /sbin/ifconfig, /bin/ping, /sbin/dhclient, /usr/bin/net, /sbin/iptables, /usr/bin/rfcomm, /usr/bin/wvdial, /sbin/iwconfig, /sbin/mii-tool</span><br><span class="line">    (ALL) ALL</span><br></pre></td></tr></table></figure><p>这是当前登录的用户的权限一览. 如果这个时候你想要清除免密码的冷却, 使用<code>sudo -k</code> 就行了</p><p>有趣的是,sudo还可以进行密码提示语的自定义.</p><p>最后我们说一个禁止其他用户修改root密码的小技巧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">test</span>@WWW ~]$ sudo passwd</span><br><span class="line">[sudo] password <span class="keyword">for</span> <span class="built_in">test</span>: </span><br><span class="line">Changing password <span class="keyword">for</span> user root.</span><br><span class="line">New password: </span><br><span class="line">Retype new password: </span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure><p>怎么避免上面的情况呢?</p><p>我们可以这样写:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rootALL=(ALL) ALL</span><br><span class="line"><span class="built_in">test</span>ALL=(root)/bin/passwd [a-z0-9]*, !/bin/passwd root</span><br></pre></td></tr></table></figure><p>测试一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">test</span>@WWW ~]$ sudo -l</span><br><span class="line">[sudo] password <span class="keyword">for</span> <span class="built_in">test</span>: </span><br><span class="line">Matching Defaults entries <span class="keyword">for</span> <span class="built_in">test</span> on this host:</span><br><span class="line">    !visiblepw, always_set_home, env_reset, env_keep=<span class="string">&quot;COLORS DISPLAY HOSTNAME HISTSIZE KDEDIR LS_COLORS&quot;</span>, env_keep+=<span class="string">&quot;MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS</span></span><br><span class="line"><span class="string">    LC_CTYPE&quot;</span>, env_keep+=<span class="string">&quot;LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES&quot;</span>, env_keep+=<span class="string">&quot;LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE&quot;</span>, env_keep+=<span class="string">&quot;LC_TIME</span></span><br><span class="line"><span class="string">    LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY&quot;</span>, secure_path=/sbin\:/bin\:/usr/sbin\:/usr/bin</span><br><span class="line"></span><br><span class="line">User <span class="built_in">test</span> may run the following commands on this host:</span><br><span class="line">    (root) /bin/passwd [a-z0-9]*, (root) !/bin/passwd root</span><br><span class="line">[<span class="built_in">test</span>@WWW ~]$ sudo passwd</span><br><span class="line">Sorry, user <span class="built_in">test</span> is not allowed to execute <span class="string">&#x27;/bin/passwd&#x27;</span> as root on WWW.</span><br><span class="line">[<span class="built_in">test</span>@WWW ~]$ sudo passwd root</span><br><span class="line">Sorry, user <span class="built_in">test</span> is not allowed to execute <span class="string">&#x27;/bin/passwd root&#x27;</span> as root on WWW.</span><br><span class="line">[<span class="built_in">test</span>@WWW ~]$ sudo passwd <span class="built_in">test</span></span><br><span class="line">Changing password <span class="keyword">for</span> user <span class="built_in">test</span>.</span><br><span class="line">New password: </span><br><span class="line">Retype new password: </span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
            <tag> sudo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络配置</title>
      <link href="/2017/05/26/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/05/26/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>Linux的网络配置: ifcfg系列和ip家族 :)</p><span id="more"></span><p>现在有一台Linux主机, 并未接入互联网.</p><p>如何将其接入呢?</p><p>显然,我们要配置以下项目:</p><ul><li>IP&#x2F;mask</li><li>路由: 默认网关</li><li>DNS服务器</li><li>主DNS</li><li>次DNS</li><li>第三DNS服务器(only4Linux)</li></ul><p>对于配置方式,有两种也就是;</p><ul><li>静态指定</li><li>ifcfg系列 : ifconfig, route, netstat</li><li>ip系列: object { link, addr, route }, ss, tc</li><li>配置文件 </li><li>以及一些前端可视化工具 (如: RedHat的Setup)</li><li>动态分配( DHCP ) – (Dynamic Host Configuration Protocol)</li></ul><h2 id="ifcfg系列"><a href="#ifcfg系列" class="headerlink" title="ifcfg系列"></a>ifcfg系列</h2><h3 id="配置网络接口"><a href="#配置网络接口" class="headerlink" title="配置网络接口"></a>配置网络接口</h3><p>由kernel命名.</p><p>命名规则:</p><ul><li>以太网: eth{0,1,2….} (<strong>在CentOS7中得到了重新命名,按照插口或者内核加载PCI时读取到的信息来命名</strong>)</li><li>虚拟拨号设备: ppp{0,1,2,…}(点对点)</li></ul><p><strong>ifconfig</strong></p><p>ifconfig 直接调用是就显示本机所有的接口, 在后面加上网卡的标识(也就是名字了)就可以对这张NIC进行单独的查看和配置.</p><p>直接使用起来就像是这样:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/if.png" alt="if"></p><p>基本上常规的信息都是可以看到的, 比如有:</p><p>**inet:**标识IPv4地址<br>**mtu:**最大传输单元<br>**netmask:**子网掩码<br>**broadcast:**广播地址<br>**inet6:**标识IPv6地址<br>**ether&#x2F;HWaddr:**MAC地址</p><p>在<code>flags</code>的后面能看到一些大写单词,这些表明当前这个设备的状态,</p><p>使用ifconfig可以很方便的配置对应网卡, 直接在查询的后面跟上网卡的标识加上子命令就行了.</p><p>最直接的就是网卡驱动程序的关闭和启用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ ifconfig eth0 down</span><br><span class="line">[root@WWW ~]$ ifconfig eth0 up</span><br></pre></td></tr></table></figure><p>再比如修改本机IP和子网掩码,像这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ ifconfig eth0 172.16.100.10/16</span><br></pre></td></tr></table></figure><p>注意,这样设置IP后面跟上的子网掩码的格式是不能改变的, 如果想使用类似<code>255.255.0.0</code>这样的, 需要单独使用<code>netmask</code>关键字来指定.</p><p>像这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ ifconfig eth0 172.16.100.10 netmask 255.255.0.0</span><br></pre></td></tr></table></figure><p><strong>注意:修改立即生效, 重启失效</strong></p><p>如果你在使用Xshell等远程连接工具, 请不要像我一样蠢, 真的敲了上面的命令..你会直接掉线的!</p><p>虽然ifconfig支持许多配置项的修改, 但是大部分的修改我们是用不到的.</p><p>其中有个<code>[-]promisc</code>这个选项是用来开启和关闭混杂模式的.而所谓混杂模式就是指不论目的地址是否指向他, 网卡都会将来自接口的所有数据捕获并交给他的驱动程序, 这种模式的应用比如说:<code>wireshark</code>.</p><p><strong>route</strong></p><p>路由管理命令–route</p><p>使用route查看当前主机的路由表, 常用的参数就是<code>-n</code>, 不进行反向解析, 也就是全部显示ip而不是名字.</p><p>来看一下这个输出,前几项直接翻译就好了嘛, 来看一下<code>FLAGS</code>, 这里会看到<code>U</code>和<code>G</code>两种, 如果添加主机路由, 会有<code>H</code>标识(<code>Host</code>). 像之前的<code>ifconfig</code>看到的一样, <code>U</code>表示<code>UP</code>已启用. <code>G</code>表示这是网关(<code>Gateway</code>)</p><p>如果要进行路由的添加.使用<code>add</code>子命令.</p><p>添加主机路由时, 由于目标ip直接定位到主机IP, 所以不需要添加子网掩码(其实也是可以写的,但是没有必要), 如果要添加的是一个网段的IP, 那么子网掩码是必须要指定的, 两种方法来指定, 一种是直接在后面接上子网长度, 或者明确表明关键字<code>netmask</code>加上子网IP. </p><p>在最后添加<code>dev</code>关键字来指定网卡, 数据包发往哪一个硬件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ route add -host 210.**.151.73 gw 59.**.**.1 dev eth0</span><br><span class="line">[root@WWW ~]$ route add -net 210.**.151.0/24 gw 59.**.**.1 dev eth0</span><br><span class="line">[root@WWW ~]$ route add -net 210.**.151.0 netmask 255.255.255.0 gw 59.**.**.1 dev eth0</span><br></pre></td></tr></table></figure><p>路由设置时要加入默认路由, 也就是找不到请求IP该发往哪里的救命稻草了.</p><p>如果路由表被查了个遍也没有找到, 那么就会最后查找默认路由.</p><p>默认路由的设定和一般设定几乎没有不同::</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ route add -net 0.0.0.0/0 gw 59.**.**.1 dev eth0</span><br><span class="line">[root@WWW ~]$ route add -net 0.0.0.0 netmask 0.0.0.0 gw 59.**.**.1 dev eth0</span><br></pre></td></tr></table></figure><p>也可以直接简写成:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ route add default gw 59.**.**.1 dev eth0</span><br></pre></td></tr></table></figure><p>能够添加自然就可以删除, route删除的语法要比添加容易.</p><p>以下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ route del -host 192.168.19.2</span><br></pre></td></tr></table></figure><p>这样,删除主机路由不需要添加子网掩码,直接指定目标即可</p><p>但是在删除网络路由的时候:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ route del -net 192.168.0.0</span><br><span class="line">SIOCDELRT: Invalid argument</span><br></pre></td></tr></table></figure><p>提示错误! 在删除网络路由的时候, 子网掩码是必须要添加的项目. </p><p>让我们再试一次: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ route del -net 192.168.0.0/16</span><br></pre></td></tr></table></figure><p>没有提示! Unix的哲学就是没有提示就是对的!</p><p>route命令的添加和删除就是这样了,下面就进入DNS的配置了.</p><p>传统意义上的DNS指定是通过修改配置文件进行的.</p><p>这个配置文件就是位于<code>/etc/resolve.conf</code></p><p>在其中直接指定<code>nameserver DNS&#39;s IP</code>即可, 如上文所说, 最多指定三个.</p><p>在编辑了该文件后, 可以使用<code>nslookup</code>,<code>host</code>或者<code>dig</code>进行解析测试, 推荐使用<code>dig</code>.</p><blockquote><p><code>dig</code>的简易使用教程:<br>从域名到IP的解析称为正向解析, 对应的dig操作为 dig -t A DOMAIN ( 也可以直接dig )<br>从IP到域名的解析成为反向解析, 对应的dig操作为 dig -x IP ( 有些IP并不能被反向解析 )</p></blockquote><p><strong>netstat</strong></p><p><code>ifcfg</code>系列的最后一个就是<code>netstat</code>命令, 显示当前本机的端口占用情况.</p><p>这是使用最多的功能之一~, 事实上<code>netstat</code>不仅可以查看端口, 他也可以查看本机路由表, 显示本机接口(NIC)的统计数据.</p><p>有点像上面命令的综合.</p><p>用法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ netstat -r -n</span><br><span class="line">显示的信息和使用route -n看到的是一模一样的</span><br><span class="line">[root@WWW ~]$ netstat -i</span><br><span class="line">显示的内容和ifconfig相近</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在查看TCP端口占用时, 常规上我都会加上<code>-antp</code>选项.</p><p>另外, 在Linux的某些发行版上会有<code>ifup</code>和<code>ifdown</code>这两个小脚本, 个人实验结果:</p><blockquote><p>在CentOS7上, 是个普通的bash脚本<br>在Ubuntu Server 14.04 LTS上是个标准的动态链接64位执行程序.</p></blockquote><h2 id="ip家族"><a href="#ip家族" class="headerlink" title="ip家族"></a>ip家族</h2><p>ip这一整套的工具名字叫做<code>iproute</code>, 可以在你的主机下进行<code>rpm -qf `which ip`</code>.</p><p>整个ip系列命令调用方式有点像Python3的urllib…通过整合了全部模块的<code>ip</code>, 使用子命令进行调用.</p><p>我们也可以先看看<code>iproute</code>这个包都在我们的系统上装了什么.(以CentOS7为例)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ rpm -ql iproute</span><br><span class="line">....</span><br><span class="line">/usr/sbin/arpd</span><br><span class="line">/usr/sbin/bridge</span><br><span class="line">/usr/sbin/cbq</span><br><span class="line">/usr/sbin/ctstat</span><br><span class="line">/usr/sbin/devlink</span><br><span class="line">/usr/sbin/genl</span><br><span class="line">/usr/sbin/ifcfg</span><br><span class="line">/usr/sbin/ifstat</span><br><span class="line">/usr/sbin/ip</span><br><span class="line">/usr/sbin/lnstat</span><br><span class="line">/usr/sbin/nstat</span><br><span class="line">/usr/sbin/routef</span><br><span class="line">/usr/sbin/routel</span><br><span class="line">/usr/sbin/rtacct</span><br><span class="line">/usr/sbin/rtmon</span><br><span class="line">/usr/sbin/rtpr</span><br><span class="line">/usr/sbin/rtstat</span><br><span class="line">/usr/sbin/ss</span><br><span class="line">/usr/sbin/tc</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>整个ip命令的风格也是很统一的, 总的来说是这样的:</p><p><code>ip [ OPTIONS ] OBJECT &#123; COMMAND | help &#125;</code></p><p>其中的OBJECT就是 ip 的子命令.</p><p>常用的OBJECT就是: <code>&#123; link | addr | route | ...&#125;</code></p><p>就一个一个Object来说吧:</p><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><p>link是用来查看和配置网卡设备的, 使用<code>ip link [show]</code>来查看, 当前网卡驱动的状态.</p><p>和上面的<code>ifconfig</code>类似, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOOPBACK 表明是本地回环</span><br><span class="line">BROADCAST 开启广播</span><br><span class="line">MULTICAST 组播( 集群使用 )</span><br><span class="line">UP 已启用</span><br></pre></td></tr></table></figure><p>最简单的操作就是网卡的启用和关闭了. 使用<code>ip link</code>的<code>set</code>子命令就可以了.</p><p>如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~] ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth0 down</span><br></pre></td></tr></table></figure><p>再使用<code>ifconfig</code>或者<code>ip link show</code>看一下, 就会发现UP的标识已经没有了.</p><p>也可以使用该子命令进行网卡功能的开启和关闭.就像上面说过的混杂模式的开启和关闭.</p><p>下面我们试着关闭网卡的多播功能:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth0 multicast off</span><br></pre></td></tr></table></figure><p>再开启的话即只要后面的off加上换成on就行了~.</p><p>ip-link命令 主要用于网络设备的配置,因此不是太过于常用.</p><p>与其说link子命令像ifconfig, 不如说addr子命令更像.因为它不仅显示了当前网卡的简要信息,还有当前的本机IP.</p><h3 id="addr"><a href="#addr" class="headerlink" title="addr"></a>addr</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ ip addr show</span><br></pre></td></tr></table></figure><p><strong>值得一提的是, addr显示出的IP地址是通过DHCP协动态获取的.</strong></p><p>使用addr常用的操作是进行IP地址的更换.添加.删除等.</p><p>我们直接写上add关键字,在后面跟上IP地址以及设备名就可以了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ ip addr add 192.168.42.33/16 dev eth0</span><br></pre></td></tr></table></figure><p>修改后再show一次,你就会看到eth0网卡多了一个IP地址,这个地址是<strong>辅助地址</strong>.</p><p>也就是说: 是留做备用的.除了这样增加地址, 也可以直接进行修改.</p><p>使用<code>replace</code> 关键字来进行Ip地址的更换.</p><p>删除IP的操作也很简单, 直接将上面的<code>add</code>改为<code>del</code>就行了.</p><p>回到上面添加IP的操作. 还记得对于硬盘分区,除了通过UUID, 我们还可以通过为分区添加标签(LABEL).</p><p>现在我们也可以给网卡添加LABEL了, 在你<code>add IP</code>时,可以选择在最后填上<code>label 标签名</code>.</p><p>这样在进行<code>ifconfig</code>的时候, 你会发现显示出的不再是eth..这样的名字, 而是你取得LABEL,也可以认为这是别名.</p><p>在<code>del</code>中也可以指定别名，但那就是在进行删除目标选定的操作了.</p><p>接下来再来看一下作用域.(scope), 这个选项的值在进行<code>show</code>时候也是可以看见的.默认是global.</p><p>也就意味该IP全局有效., 除了global(用于内核, IP属于内核)以外还有site(只用于IPv6), link(仅用于本设备[添加了这个IP的网卡]), host(仅用于本机[服务器]内部).</p><p>如果想要清空一张网卡上的所有IP,一个一个<code>del</code>未免太蠢了, 所以ip-address提供了<code>flush</code>命令, 直接就可以清空指定设备上的所有IP.</p><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p>ip-route作为路由表管理工具, 支持了极多的路由管理和策略.</p><p>然而常规操作依然就是<code>show</code>.<code>add</code>.<code>delete</code>.<code>flush</code>.</p><p>但是在添加路由时,ip-route支持更多功能, 比如:原地址伪装.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ ip route add 192.168.1.0/24 via 172.16.0.1 dev eth0 src 172.16.0.22</span><br></pre></td></tr></table></figure><p>最后的的src就是伪装ip了, 建议不要乱写了, 其实乱写程序也会直接报错的.</p><p><strong>注意:如果不明确注明子网掩码或者写明default,ip-route会都将其当做主机.</strong></p><p>再删除路由时, 最好指明白要删除的路由的dest和netmask, 这样可以避免一些模糊的导致删除错误.</p><h3 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h3><p>ss是一个网络状况查看工具, 当你的网络繁忙,网络连接情况十分复杂, 或者说连接数非常多的时候, <code>netstat</code>往往会比较卡.而<code>ss</code>就是一个取代<code>netstat</code>的工具. 他的速度基本上是<code>netstat</code>的10倍左右</p><p><code>ss</code>命令的大体格式就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss [OPTION] ... [FILTER]</span><br></pre></td></tr></table></figure><p>还是先从选项开始吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-t : tcp</span><br><span class="line">-u : udp</span><br><span class="line">-w : raw 原始套接字</span><br><span class="line">-x : unix unix套接字</span><br><span class="line">-a : all 所有类型</span><br><span class="line">-n : numeric 不反解</span><br><span class="line">-p : program 显示程序和PID</span><br><span class="line">-e : extend 拓展输出</span><br><span class="line">-m : memory 显示内存占用</span><br><span class="line">-o : option 选项(e.g; timer, filter)</span><br></pre></td></tr></table></figure><blockquote><p>原始套接字和标准套接字. 简单的说就是原始套接字更加底层, 它能够对较低层次的协议直接进行访问, 比如:IP,ICMP等,网络监听技术很大程度上依靠RAW SOCKET.<br>而原始套接字和标准套接字的区别就是原始套接字可以读取内核尚未处理的数据包, 而标准套接字例如流套接字就只能读取TCP协议的数据, 数据报套接字就只能读取UDP协议的数据.</p></blockquote><p>这些选项几乎和<code>netstat</code>一模一样.</p><p>相较netstat更先进的地方是, ss提供了过滤器, 这样就不需要蠢蠢的再去用管道了.</p><p>说到了过滤器, 我们就先看一下tcp的常见状态:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LISTEN 监听 ( 处于服务状态 )</span><br><span class="line">ESTABLISHED 建立连接 ( 正在通信 )</span><br><span class="line">FIN_WAIT_1</span><br><span class="line">FIN_WAIT_2</span><br><span class="line">SYN_SENT</span><br><span class="line">SYN_RECV</span><br><span class="line">CLOSED 关闭了的 </span><br></pre></td></tr></table></figure><p>基本上ss的过滤器格式为 <code>FILTER := [ state TCP-STATE ] [ EXPRESSION ]</code></p><p>简单的表达式语法就是: <code>( dport := ssh or sport = :ssh )</code></p><p><strong>特别注明一下:语法要求,两端括号一定要加上空格</strong></p><p>这样一条合法的查询语句就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ ss -antpo state established <span class="string">&#x27;( dport = :ssh or sport = :ssh )&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>关于state后的参数, ss有一个大坑,那就是没有listen状态, 而是listening.</strong></p><p>其实常用的命令参数也就是那些相近的. </p><p>以上就是ip家族的常用命令了.</p><p>上面是在说使用命令配置Linux的网络,现在我们来看一下使用配置文件进行网络的控制.</p><p>由于Linux的版本不同, 所以配置文件的位置也不一样.</p><p><strong>来自一年后9.5的更新</strong></p><p>说起来虽然说是配置文件有两种, 但是如果网络服务是由NetworkManager进行管理的, 应该配置属性到所谓旧的配置文件中, 新的配置文件似乎不会被读取到并且不会生效. 关于这个我还需要再看看. 不知道是网络配置服务根本就没有读取旧的配置文件还是说是先读取的旧配置文件但是又因为新的配置被洗掉了. </p><p>总之, 网络属性配置到旧的配置文件总是没错的. 因为NetworkManager服务会根据这个位置的配置文件来写网络属性.</p><hr><p>早期的配置文件位于</p><p><code>/etc/sysconfig/network-scripts/ifcfg-IFACE</code> &lt; - - IP,MASK,GW,DNS相关配置文件<br><code>/etc/sysconfig/network-scripts/route-IFACE</code> &lt; - - 路由相关配置文件. </p><p>而在新版的Linux, 修改网络配置, 已经转移向了&#x2F;<code>etc/network/interfaces</code>这个文件中, 而DNS服务器的配置可以在<code>/etc/resolve.conf</code>中进行临时指定(开机重写文件).</p><p>先说说旧版的配置文件中常见的或者常用的参数说明一下:</p><p><strong>DEVICE</strong>: 此配置文件应用到的设备</p><p><strong>HWADDR:</strong> 对应设备的<code>MAC</code>地址</p><p><strong>BOOTPROTO:</strong> 激活此设备的地址配置协议</p><p><strong>NM_CONTROLLED:</strong> 此网卡是否受<code>NetworkManager</code>的管理控制.</p><p><strong>ONBOOT:</strong> 系统引导的时候是否激活此设备</p><p><strong>TYPE</strong>: 接口类型, 常见的有<code>Ethernet</code>, <code>Bridge</code></p><p><strong>UUID:</strong> 设备的唯一标识</p><p><strong>IPADDR:</strong> 指明IP地址</p><p><strong>NETMASK:</strong> 子网掩码</p><p><strong>GATEWAY:</strong> 默认网关</p><p><strong>DNS1:</strong> 第一个DNS服务器指向</p><p><strong>DNS2:</strong> 第二个DNS服务器指向</p><p><strong>USERCTL:</strong> 普通用户是否可控制此设备</p><p><strong>PEERDNS:</strong> 如果BOOTPROTO是<code>dhcp</code>, 是否允许<code>dhcp seerver</code>分配的DNS服务器指向信息覆盖原来的<code>resolve.conf</code>.</p><p>现在就以新版的配置文件来进行说明.</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/interfaces.png" alt="interfaces"></p><p>最简单的配置就是直接把这个文件的<code>static</code>换成<code>dhcp</code>即可, 将下面的配置全部删去就好了.</p><p>如果配置静态IP,可以参照这个图来配置, 必要的属性就是下面的三项: <code>IP地址</code>, <code>网关</code>, <code>子网掩码</code>.</p><p>如果要配置DNSSever, 要在&#x2F;etc&#x2F;resolve.conf, 这个文件配置的信息会在重启时被重写.</p><p>之前说过Linux支持最多可以配置配三台DNSServer, 就这样写就可以了:</p><p><img src="http://hexopic.s3-ap-northeast-1.amazonaws.com/dns.png" alt="dns"></p><p>使用<code>nameserver</code>关键字来指定服务器地址.</p><p>-<strong>来自不知道什么时候之后的一个更新</strong>- 对于CentOS系统, 一直使用的就是sysconfig下的配置文件, 而Ubuntu, Debian系的系统梗偏向于使用interfaces这种文件. 所以关于时间的说法是不对的. ( 我好菜啊 )</p><p><strong>7.8 更新</strong>:</p><p>进行主机名的设置, 除了可以通过使用<code>hostname</code>来进行临时的修改, 更好的方法是使用配置文件进行改变.</p><p>这个配置文件就是<code>/etc/sysconfig/network在这里面加入</code>HOSTNAME&#96;的内容 改变将在下一次的重启生效. </p><p><strong>来自一年后9.5的更新</strong>:</p><p>修改主机名在CentOS7版本上还有一些方法, 使用hostnamectl进行主机名的管理:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]# hostnamectl status</span><br><span class="line">   Static hostname: VM-node0</span><br><span class="line">         Icon name: computer-vm</span><br><span class="line">           Chassis: vm</span><br><span class="line">        Machine ID: 634a3b7ffdeb4c1382e3bd8666b10602</span><br><span class="line">           Boot ID: dfb2a2bb36414f5781a41bb8f51c2c0f</span><br><span class="line">    Virtualization: vmware</span><br><span class="line">  Operating System: CentOS Linux 7 (Core)</span><br><span class="line">       CPE OS Name: cpe:/o:centos:centos:7</span><br><span class="line">            Kernel: Linux 3.10.0-693.2.2.el7.x86_64</span><br><span class="line">      Architecture: x86-64</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你也可以不加命令参数 同样是查看状态. 我们可以看到当前计算机的主机名是<code>VM-node0</code>. 有趣的是, 当我们使用之前说的<code>hostname</code>命令去修改主机名的时候会看到:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-node0 ~]# hostname localhost</span><br><span class="line">[root@VM-node0 ~]# hostnamectl status</span><br><span class="line">   Static hostname: VM-node0</span><br><span class="line">Transient hostname: localhost</span><br><span class="line">         Icon name: computer-vm</span><br><span class="line">           Chassis: vm</span><br><span class="line">        Machine ID: 634a3b7ffdeb4c1382e3bd8666b10602</span><br><span class="line">           Boot ID: dfb2a2bb36414f5781a41bb8f51c2c0f</span><br><span class="line">    Virtualization: vmware</span><br><span class="line">  Operating System: CentOS Linux 7 (Core)</span><br><span class="line">       CPE OS Name: cpe:/o:centos:centos:7</span><br><span class="line">            Kernel: Linux 3.10.0-693.2.2.el7.x86_64</span><br><span class="line">      Architecture: x86-64</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多了一个新的记录,  这个叫做瞬态的一个主机名 就像之前说过的, hostname修改的主机名是一个临时的结果 在重启之后会被重置. 重置的结果就是上面的一条记录所展示的<strong>静态主机名</strong>.</p><p>那么怎么使用这个工具进行修改呢?</p><p>其实也很简单 这个工具提供的修改命令特别好记:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">  status                 Show current hostname settings</span><br><span class="line">  set-hostname NAME      Set system hostname</span><br><span class="line">  set-icon-name NAME     Set icon name for host</span><br><span class="line">  set-chassis NAME       Set chassis type for host</span><br><span class="line">  set-deployment NAME    Set deployment environment for host</span><br><span class="line">  set-location NAME      Set location for host</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基本上我们只会使用到前两个了, 直接<code>set-hostname</code>就可以了.</p><p><strong>7.25 的更新:</strong></p><h2 id="udev"><a href="#udev" class="headerlink" title="udev"></a>udev</h2><p>网卡接口的传统命名都是以eth(Ethernet)开头的, 后面跟上[0,1,2,…]. 这样命名的弊端在于, 当我一个接口上面的网卡坏掉了, 接着我把一个新的网卡换上了, 他的命名依旧是同样的后缀. 而他们的HWADDR是不同的.  所以, CentOS7采用了一种可预测的, 统一的一种接口识别机制. udev从CentOS6就有了, CentOS7仍然沿用了这个.</p><p>udev是从用户空间通过系统调用来探测硬件设备, 并进行配置的应用程序. 其中最重要的就是是可预测功能.</p><p>在CentOS7上, udev支持多种不同的命名方案:</p><ul><li>Firmware 主板上的, 通过芯片</li><li>或者是 PCI总线上的拓扑结构</li></ul><p>来说说网卡的命名机制, 其一也就是基于systemd, 再者就是通过bios的方式. 我们先来看一下systemd的方式.</p><p>sysetmd的命名规则如下:</p><blockquote><p>(a) 如果主板上的固件或者BIOS为主板上的集成的设备提供的索引(就比如说PCI线上的哪个槽)可用, 并且可预测则根据次索引进行命名. e.g: eno1;</p><p>(b) 如果固件或者BIOSweiPCI-E扩展槽所提供的索引信息可用, 且可预测, 则根据此索引进行命名, e.g: ens1</p><p>(c) 如果硬件接口的物理位置先定下可用, 则根据此信息进行命名, e.g: enp2s0;</p><p>(d) 如果用户显式启用, 也可以根据MAC地址进行命名: enx2387a1dc56;</p><p>(e) 上述都不可用的时候, 则使用传统命名机制.</p></blockquote><p>上述命名机制中, 尽管我们说这是systemd的命名, 但有的仍然需要biosdevname程序的参与.这就意味我们需要安装这些程序并且启用之.</p><p>现在我们来把接口的缩写搞得清楚一点: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">en == ethernet</span><br><span class="line">wl == wlan</span><br><span class="line">ww == wwan</span><br></pre></td></tr></table></figure><p>而名称类型, 有这些:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o&lt;index&gt; -- en | o | 1 -- 这里的index,我们把它叫做设备索引号</span><br><span class="line">s&lt;slot&gt; -- en | s | 0 -- 扩展插槽的索引</span><br><span class="line">x&lt;MAC&gt; -- en | x | 2387a1dc56 -- 基于MAC地址命名</span><br><span class="line">p&lt;bus&gt;s&lt;slot&gt; -- en | p | 0 | s | 3 -- 总线的标号并加上扩展槽的索引</span><br></pre></td></tr></table></figure><p>有了这些, 我们就可以进行网卡设备的命名过程:</p><p><strong>第一步</strong> : udev有一个辅助程序. 我们之前说Linux的内核编译和管理的时候, 提到过&#x2F;sys这么个伪文件系统, 其中的信息就是来源于udev这个机制, udev将内核识别的相关硬件及信息映射出来, 输出到用户空间. 从而能够加载相应地驱动和一些额外的服务. 辅助程序: &#x2F;lib&#x2F;udev&#x2F;rename_device. 这个程序会从&#x2F;usr&#x2F;lib&#x2F;udev&#x2F;rules.d&#x2F;60-net.rules来加载, 接着根据这个文件里的指令去查询 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-XXXX ( XXXX就是对应的网卡名)这个文件, 在前面的Linux网络配置中, 我们知道这个文件中有一个HWADDR对嘛 接着就会拿着这个网卡地址去进行匹配, 如果匹配到了 就会去读取配置文件中那个叫<code>DEVICE</code>的参数 于是就会将网命名成和DEVICE保持一致. 也就是说, 它取决于配置文件.</p><p>如果第一步没能正常执行的话, 就会将进行<strong>第二步</strong>, 第二步进行的前提是安装了<code>biosdevname</code>并且在启动时的内核参数(我们说过grub在启动时是支持参数的, KERNEL后面)加上了biosdevname&#x3D;1, 也即是 <strong>安装了biosdevname, 并且没有禁用它</strong> 的话, biosdevname这个程序就会到 &#x2F;usr&#x2F;lib&#x2F;udev&#x2F;rules.d&#x2F;71-biosdevname.rules中定义的规则来进行网络接口重命名.</p><p>如果说第二步也未能执行, 那么就会进入第三步.</p><p><strong>第三步</strong>就是根据我们网卡自身所携带的信息来进行命名, 每一个设备都会带上一些属性. 这些都被映射到&#x2F;sys这个伪文件系统上 这个时候命名的规则文件就是&#x2F;usr&#x2F;lib&#x2F;udev&#x2F;rules.d&#x2F;75-net-description. 怎么进行命名呢? 这个即根据网卡加载时一些属性:ID_NET_NAME_ONBOARD, ID_NET_NAME_SLOT, ID_NET_NAME_PATH等等( 一般第一或者第二就足够把问题解决了实在没有的时候才会去找后面的 ), 这些都是变量, 由系统来赋予. 通过检查这些变量是否有值, 于是就会被命名成这些参数的值.</p><p>如果第三步仍然失败了..那么就不会进行重命名. 保留之前的eth[0,1,2,..].</p><p>如果现在想要保留原来的命名方式怎么做呢?  如果直接修改掉rules文件, udev会尽力进行自动重建( 有可能成功 也有可能失败 ) 但是为了彻底禁用, 我们则需要在内核后添加参数, 由于CentOS7使用的是grub2, 而不是旧的grub legacy, 所以和我们之前说的更改内核参数的方法并不一样. 具体的操作步骤如下:</p><blockquote><ul><li>编辑&#x2F;etc&#x2F;default&#x2F;grub文件, 在GRUB_CMDLINE_LINUX这一行添加<code>net.ifname=0</code>. </li><li>此时并不会被grub2读取, 所以我们要适应grub2自带的工具来重新生成一下配置文件</li><li>也就是: <code>grub2-mkconfig -o /boot/grub2/grub2.cfg</code></li><li>最后重启系统就行</li></ul></blockquote><p>这样就可以回归传统的命名方式.</p><h2 id="网络属性配置"><a href="#网络属性配置" class="headerlink" title="网络属性配置"></a>网络属性配置</h2><p>在先前的Linux网络配置中我们已经说了很多关于网络配置的话题. 但是这次的工具是一个专门用来管理NetworkManager的, 有着自己的一套语法. 主要体现在地址配置上. 现在来看一下: <code>nmcli</code></p><p>这个命令和IP命令很相像. 也有很多自己的OBJECT, 命令组成是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli [OPTIONS...] &#123;<span class="built_in">help</span> | general | networking | radio | connection | device | agent | monitor&#125; [COMMAND] [ARGUMENTS...]</span><br></pre></td></tr></table></figure><p>其中比较常用的就是connection和device这两个.</p><p>首先是 <strong>general</strong>  这个是用来显示总体信息的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ nmcli g status <span class="comment"># g 就是general 可以进行简写</span></span><br><span class="line">STATE      CONNECTIVITY  WIFI-HW  WIFI     WWAN-HW  WWAN    </span><br><span class="line">connected  full          enabled  enabled  enabled  enabled </span><br><span class="line"><span class="comment"># 显示了连接状态 以及支持什么样的连接</span></span><br></pre></td></tr></table></figure><p>不过general 的更多作用是要等到后面进行连接的时候才对显现出来. 我们先来看一下后面的一些OBJECT吧</p><p><strong>radio</strong></p><p>主要用来进行无线网络的配置, 一般我们也不太会用到呢..所以也先忽略掉.</p><p><strong>connection</strong> – 类似于 ip 的 addr</p><p>用来配置网络连接 因此是很重要的一个. 我们来看看他的子命令.</p><p>和ip的addr相像, 使用起来也有近似之处.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ nmcli connection(c) &#123; show | up | down | add | modify | <span class="built_in">clone</span> | edit | delete | monitor | reload | load | import | <span class="built_in">export</span> &#125;</span><br></pre></td></tr></table></figure><p>现在我们把问题聚焦在改变IP地址的应用上 我们使用modify子命令, 过程如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ nmcli connection modify enp0s8 +ipv4.addresses 192.168.56.110/24</span><br><span class="line">[root@WWW ~]$ nmcli d show enp0s8</span><br><span class="line">GENERAL.DEVICE:                         enp0s8</span><br><span class="line">...</span><br><span class="line">IP4.ADDRESS[1]:                         192.168.56.102/24</span><br><span class="line">... <span class="comment"># 咦? 怎么没有生效 ?</span></span><br></pre></td></tr></table></figure><p>和其他的IP修改一样, 这个时候都需要进行禁用之后立即启动的操作. 现在就是使用connection的子命令<code>up</code>和<code>down</code>的时候.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ nmcli c d enp0s8 ; nmcli c u enp0s8</span><br><span class="line">Connection <span class="string">&#x27;enp0s8&#x27;</span> successfully deactivated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/2)</span><br><span class="line">Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/3)</span><br><span class="line"><span class="comment"># 这个时候修改就成功了, 我们来看一下</span></span><br><span class="line">[root@WWW ~]$ nmcli d show enp0s8</span><br><span class="line">...</span><br><span class="line">IP4.ADDRESS[1]:                         192.168.56.103/24</span><br><span class="line">IP4.ADDRESS[2]:                         192.168.56.102/24</span><br><span class="line">...(omitted)</span><br><span class="line"><span class="comment"># 修改成功了, 不如在再使用ip命令来看一下</span></span><br><span class="line">[root@WWW ~]$ ip addr show enp0s8</span><br><span class="line">3: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 08:00:27:cc:fe:<span class="built_in">dd</span> brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.56.102/24 brd 192.168.56.255 scope global dynamic enp0s8</span><br><span class="line">       valid_lft 952sec preferred_lft 952sec</span><br><span class="line">    inet 192.168.56.103/24 brd 192.168.56.255 scope global secondary enp0s8</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>注意到那个[+]号了么? 其实也可以省略, 如果是要移除的时候就使用减号[-], 这个时候就不可以省略了.</p><p>整个修改网络属性的语法格式是这样的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ ip connection modify IFACE [+|-] setting.property value </span><br><span class="line"><span class="comment"># 常用的一些setting.property有:</span></span><br><span class="line"><span class="comment"># ipv4.addresses</span></span><br><span class="line"><span class="comment"># ipv4.gateway</span></span><br><span class="line"><span class="comment"># ipv4.dns # 注意这里, 没有dns1,2这样的属性</span></span><br><span class="line"><span class="comment"># ipv4.method 如果使用DHCP动态主机配置协议的话,就使用这个属性,如果是静态的就配置成manual值</span></span><br></pre></td></tr></table></figure><p><strong>device</strong> – 类似于 ip 的 link</p><p>device是用来配置网络接口的, 所以使用的场景多在网卡的连接和断开 另外这个device还可以配置wife~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device &#123;show|status|connect|disconnect|delete&#125;</span><br></pre></td></tr></table></figure><p>使用方法基本上不需要进行说明. </p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First2Redis</title>
      <link href="/2017/05/21/First2Redis/"/>
      <url>/2017/05/21/First2Redis/</url>
      
        <content type="html"><![CDATA[<p>Redis – 基于内存的键值对数据库, 强大之处在于它的值可以是数据结构.</p><span id="more"></span><p>这里先说一说Redis的几种数据类型, 也就是:</p><ul><li>字符串( String )</li><li>列表( List )</li><li>哈希映射( Hashes )</li><li>无序集合( Set )</li><li>有序集合( Sorted Set )</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>字符串是Redis中最基本的值类型, 他是二进制安全的, 这意味着一个Redis字符串能包含任意类型的数据, 例如: 一张图片或者一个序列化的对象.最多支持存储512M字节的内容.</p><p>创建&#x2F;修改和检索string, 使用<strong>SET</strong>和<strong>GET</strong>, 如果key已存在, 那么<strong>SET</strong>将会覆盖原值.在<strong>SET</strong>后添加参数可以使得赋值操作仅仅在Key存在&#x2F;不存在的情况下成功.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; set mykey somevalue</span><br><span class="line">OK</span><br><span class="line">&gt; get mykey</span><br><span class="line">&quot;somevalue&quot;</span><br></pre></td></tr></table></figure><p>在<code>mykey</code>已经存在的情况下在<strong>SET</strong>后添加参数( 有点像<code>MySQL</code>的<code>IF EXIST</code> ):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; set mykey newval nx</span><br><span class="line">(nil)</span><br><span class="line">&gt; set mykey newval xx</span><br><span class="line">OK</span><br><span class="line">&gt; get mykey</span><br><span class="line">&quot;newval&quot;</span><br></pre></td></tr></table></figure><p>可见, <code>nx</code>表明仅在<code>key</code>不存在的时候进行赋值, <code>xx</code>正相反.</p><p>Redis支持一次赋多个值和返回多个值, 使用<code>mset</code>和<code>mget</code>.<strong>( multi )</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; mset a 10 b 20 c 30</span><br><span class="line">OK</span><br><span class="line">&gt; mget a b c</span><br><span class="line">1) &quot;10&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;30&quot;</span><br></pre></td></tr></table></figure><p>尽管是<code>String</code>类型, 我们仍然可以尝试进行数学运算:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; set counter 100 </span><br><span class="line">OK</span><br><span class="line">&gt; incr counter</span><br><span class="line">(integer) 101</span><br><span class="line">&gt; incrby counter 50</span><br><span class="line">(integer) 151</span><br></pre></td></tr></table></figure><p>减法运算是: <code>decr</code>和<code>decrby</code></p><p>如果字符串不能变成数字, Redis会抛出异常:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; set str &quot;A&quot;</span><br><span class="line">OK</span><br><span class="line">&gt; incr str</span><br><span class="line">(error) ERR value is not an integer or out of range.</span><br></pre></td></tr></table></figure><h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><p>Redis中的列表是一个双端字符串列表, 按照插入顺序排序.可以添加一个元素到列表的头部或者尾部, 当一个插入元素的操作执行在一个空的<code>Key</code>的时候,就会创建一个新的列表.</p><p>同样,删除列表就直接将<code>Key</code>删除就行了.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush mylist 0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; lpush mylist 1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;0&quot;</span><br></pre></td></tr></table></figure><p><code>rpush</code>是将元素push到列表的最后, 而<code>lpush</code>相反, 是将元素push到列表的开头, 最后的<code>lrange</code>是将表中的元素列出, 后面的两个参数是分别表示开始索引和终止索引, 如果是负数n表示倒数第n个.</p><p>所以列出所有的元素的就是从开始到最后一个<code>( lrange list 0 -1 )</code></p><p>每一次的<code>push</code>操作都可以将多个元素一次性的放入表中.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush mylist 1 2 3 &quot;foo&quot;</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;foo&quot;</span><br></pre></td></tr></table></figure><p>有<code>push</code>就有<code>pop</code>, 与<code>push</code>一样, <code>pop</code>同样支持两端的<code>pop</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;foo&quot;</span><br><span class="line">&gt; lpop mylist</span><br><span class="line">&quot;1&quot;</span><br><span class="line">&gt; rpop mylist</span><br><span class="line">&quot;4&quot;</span><br><span class="line">&gt; lrange mylist</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br></pre></td></tr></table></figure><h2 id="Hashes"><a href="#Hashes" class="headerlink" title="Hashes"></a>Hashes</h2><p>Redis Hashes是字符串字段和字符串值之间的映射,因此十分适合用来展现对象.</p><p>使用起来也十分简单, 同样是<strong>SET</strong>和<strong>GET</strong>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; hmset user:1000 username justin birth 1997 verified 1</span><br><span class="line">OK</span><br><span class="line">&gt; hget user:1000 username</span><br><span class="line">&quot;justin&quot;</span><br><span class="line">&gt; hgetall user:1000</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;justin&quot;</span><br><span class="line">3) &quot;birth&quot;</span><br><span class="line">4) &quot;1997&quot;</span><br><span class="line">5) &quot;verified&quot;</span><br><span class="line">6) &quot;1&quot;</span><br></pre></td></tr></table></figure><p>如果是不存在的数据域, redis会返回<code>nil</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; hmget user:1000 username birth no-such-field</span><br><span class="line">1) &quot;justin&quot;</span><br><span class="line">2) &quot;1997&quot;</span><br><span class="line">3) (nil)</span><br></pre></td></tr></table></figure><p>同样可以对hashes中的元素进行操作, 比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; hincrby user:1000 birth 10</span><br><span class="line">(integer) 2007</span><br><span class="line">&gt; hincrby user:1000 birth -10</span><br><span class="line">(integer) 1997</span><br></pre></td></tr></table></figure><p>在Redis的Hashes中, 不知道为什么似乎没有<code>hdecrby</code>这样的指令.所以如果要进行减法运算, 就加上负值好了.</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Redis Set是一个无序的字符串集合. 你可以以O(1)的时间复杂度 (无论集合中有多少元素时间复杂度都是常量)完成添加，删除，以及测试元素是否存在的操作. </p><p>Redis Set 拥有不允许包含相同成员的属性, 多次添加相同的元素，最终在集合里只会有一个元素。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd myset &quot;1&quot; &quot;A&quot; &quot;Foo&quot; &quot;4&quot; &quot;-10&quot;</span><br><span class="line">(integer) 5</span><br><span class="line">&gt; sadd myset &quot;A&quot; &quot;1&quot;</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; smembers myset</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;4&quot;</span><br><span class="line">3) &quot;Foo&quot;</span><br><span class="line">4) &quot;A&quot;</span><br><span class="line">5) &quot;-10&quot;</span><br></pre></td></tr></table></figure><p>接下来看一下如何查看元素是否存在:</p><p><strong>sismember</strong>用于查看集合是否存在，匹配项包括集合名和元素个数.</p><p>匹配成功返回1, 匹配失败返回0.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; sismember myset 3</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sismember myset &quot;Foo&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h2><p>Sorted Set 和 Set非常相似，是一个没有重复元素的字符串集合. 不同之处是有序集合的每一个成员都关联了一个评分(score)，这个评分被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复的.</p><p>使用有序集合可以以非常快的速度（O(log(N))）添加，删除和更新元素。因为元素有序, 所以也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素.</p><p>由于<code>Sorted Set</code>和<code>Set</code>的首字母冲突了, 所以Redis中对于<code>Sorted Set</code>操作的指令都是以<code>Z</code>开头的</p><p>上面是我猜的 :)</p><p><code>zadd</code>与<code>sadd</code>类似，但是在元素之前多了一个参数，这个参数便是用于排序的. (为了形成一个有序的集合)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd members 0 kali 1 ubuntu 2 debian</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>查看集合有两种方式, <code>ZRANGE</code>是查看正序的集合，<code>ZREVRANGE</code>是查看反序的集合.</p><p>和上文所说的<code>lrange</code>一样: 0表示集合第一个元素，-1表示集合的倒数第一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; zrange members 0 -1</span><br><span class="line">1) &quot;kali&quot;</span><br><span class="line">2) &quot;ubuntu&quot;</span><br><span class="line">3) &quot;debian&quot;</span><br><span class="line">&gt; zrevrange members 0 -1</span><br><span class="line">1) &quot;debian&quot;</span><br><span class="line">2) &quot;ubuntu&quot;</span><br><span class="line">3) &quot;kali&quot;</span><br><span class="line">&gt; zrange mmebers 0 -1 withscores</span><br><span class="line">1) &quot;kali&quot;</span><br><span class="line">2) &quot;0&quot;</span><br><span class="line">3) &quot;ubuntu&quot;</span><br><span class="line">4) &quot;1&quot;</span><br><span class="line">5) &quot;debian&quot;</span><br><span class="line">6) &quot;2&quot;</span><br></pre></td></tr></table></figure><p>使用<code>WITHSCORES</code>参数会连带返回记录值。</p><p>接下来一起来看一下Redis的其他相关命令和系统管理操作.</p><h2 id="EXISTS-and-DEL"><a href="#EXISTS-and-DEL" class="headerlink" title="EXISTS and DEL"></a>EXISTS and DEL</h2><p>见名知意啦~&#96;EXISTS&#96;用来判断一个Key是否存在, 存在就返回1, 不存在就返回0;</p><p><code>DEL</code>用来删除一个键, 或者是一系列的键.返回非零表示删除成功.</p><blockquote><p>非零是因为实际上<code>DEL</code>返回的是删除的条数.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; set mykey m</span><br><span class="line">OK</span><br><span class="line">&gt; exists mykey</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; del mykey</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; exists mykey</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h2 id="TYPE-and-KEYS"><a href="#TYPE-and-KEYS" class="headerlink" title="TYPE and KEYS"></a>TYPE and KEYS</h2><p>终于可以知道值的属性了!使用<code>TYPE KEY</code>来获得属性描述.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; set mykey &quot;Foo&quot;</span><br><span class="line">OK</span><br><span class="line">&gt; type mykey</span><br><span class="line">string</span><br></pre></td></tr></table></figure><p>所有支持的类型都可能被返回, 包括: <strong>( none, string, list, set, zset, hash )</strong>.</p><p><code>KEYS</code>用来在Redis全局进行键的搜索, 使用<code>keys pattern</code>来进行检索.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; set student_name &#x27;justin&#x27;</span><br><span class="line">OK</span><br><span class="line">&gt; set student_grade 2</span><br><span class="line">OK</span><br><span class="line">&gt; keys student_*</span><br><span class="line">1) &quot;student_name&quot;</span><br><span class="line">2) &quot;student_grade&quot;</span><br></pre></td></tr></table></figure><h2 id="RANDOMKEY-and-CLEAR"><a href="#RANDOMKEY-and-CLEAR" class="headerlink" title="RANDOMKEY and CLEAR"></a>RANDOMKEY and CLEAR</h2><p>很迷的两个指令..我认为的.</p><p><code>CLEAR</code>就相当于<code>ctrl+l</code>.清屏指令</p><p>至于<code>RANDOMKEY</code>, 我是没想明白用处在哪里.</p><p><code>RANDOMKEY</code>随机返回一个键名, 如果数据库为空, 则返回空字符串.</p><p>比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; randomkey</span><br><span class="line">(nil)</span><br><span class="line">&gt; set key1 100</span><br><span class="line">OK</span><br><span class="line">&gt; set key2 200</span><br><span class="line">OK</span><br><span class="line">&gt; set key3 300</span><br><span class="line">OK</span><br><span class="line">&gt; randomkey</span><br><span class="line">&quot;key2&quot;</span><br><span class="line">&gt; randomkey</span><br><span class="line">&quot;key1&quot;</span><br></pre></td></tr></table></figure><h2 id="RENAME-and-RENAMENX"><a href="#RENAME-and-RENAMENX" class="headerlink" title="RENAME and RENAMENX"></a>RENAME and RENAMENX</h2><p>两个指令都是用来进行重命名的,区别在于:</p><ul><li><p>RENAME 直接改名, 如果新的Key已经存在, 那么将会直接进行覆盖.</p></li><li><p>RENAMENX 在改名时, 如果新的Key已经存在, 则会报错并放弃更改.</p></li></ul><p>所以更好用的应该是后面的一个.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; set key value</span><br><span class="line">OK</span><br><span class="line">&gt; set newkey val</span><br><span class="line">OK</span><br><span class="line">&gt; renamenx key newkey</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>这样更安全对嘛?</p><blockquote><p><strong>补</strong>: DBSIZE 这个指令返回当前Redis中所有键的数量.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; set key value</span><br><span class="line">OK</span><br><span class="line">&gt; dbsize</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h2 id="Redis中的时间"><a href="#Redis中的时间" class="headerlink" title="Redis中的时间"></a>Redis中的时间</h2><h3 id="限定Key的存活时间"><a href="#限定Key的存活时间" class="headerlink" title="限定Key的存活时间"></a>限定Key的存活时间</h3><p>对于任何数据都可以实现, 这主要用于临时存储, 并避免大量的<code>DEL</code>操作.</p><p>指令是: <code>expire</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; set key somevalue</span><br><span class="line">OK</span><br><span class="line">&gt; expire key 10</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get key</span><br><span class="line">&quot;somevalue&quot;</span><br></pre></td></tr></table></figure><p>10s后再次执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; get key </span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="查询key的存活时间"><a href="#查询key的存活时间" class="headerlink" title="查询key的存活时间"></a>查询key的存活时间</h3><p>多亲切的指令, 查询key存活时间的指令是: <code>TTL</code> – ( time to live ) </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; set key 100 ex 30</span><br><span class="line">OK</span><br><span class="line">&gt; ttl key</span><br><span class="line">(integer) 28</span><br><span class="line">&gt; ttl key</span><br><span class="line">(integer) 26</span><br></pre></td></tr></table></figure><h3 id="清除所有的Key"><a href="#清除所有的Key" class="headerlink" title="清除所有的Key"></a>清除所有的Key</h3><p>两个指令都是用来进行清除操作的:</p><ul><li><code>FLUSHDB</code> 清空当前数据库的所有键</li><li><code>FLUSHALL</code> 清空所有数据库中的所有键</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">-----------</span><br><span class="line">&gt; flushall</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h2 id="系统设置相关"><a href="#系统设置相关" class="headerlink" title="系统设置相关"></a>系统设置相关</h2><p>Redis可以通过使用配置文件或者<code>CLI</code>的方式进行配置.</p><p>指令的语法倒是同git很像.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; config get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;</span><br><span class="line">&gt; config set requirepass &quot;mima&quot;</span><br><span class="line">OK</span><br><span class="line">&gt; config get requirepass</span><br><span class="line">(error) NOAUTH Authentication required</span><br><span class="line">&gt; auth mima</span><br><span class="line">OK</span><br><span class="line">&gt; config get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;mima&quot;</span><br></pre></td></tr></table></figure><p>上面是对密码<code>CONFIG</code>的一个例子.</p><p>当然可以直接通过修改redis的配置文件<code>redis.conf</code>来进行修改, 其他的一些可修改项也可直接从<code>redis.conf</code>中获取.</p><p>从上面的例子也可以看出来, redis的<code>config get</code>得到的结果是键值对形式的.</p><p>像这样查询: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; config get *max-*-entries*</span><br><span class="line">1) &quot;hash-max-ziplist-entries&quot;</span><br><span class="line">2) &quot;512&quot;</span><br><span class="line">3) &quot;list-max-ziplist-entries&quot;</span><br><span class="line">4) &quot;512&quot;</span><br><span class="line">5) &quot;set-max-intset-entries&quot;</span><br><span class="line">6) &quot;512&quot;</span><br><span class="line">7) &quot;zset-max-ziplist-entries&quot;</span><br><span class="line">8) &quot;128&quot;</span><br></pre></td></tr></table></figure><p>如果不是为了配置, 而是想要查询redis的各项信息的话, 使用<code>INFO</code>命令.</p><p><strong>INFO [section]</strong> 可以查询redis几乎所有的信息.</p><p>section 有以下:</p><ul><li>server: Redis server的常规信息</li><li>clients: Client的连接选项</li><li>memory: 存储占用相关信息</li><li>persistence: RDB and AOF 相关信息</li><li>stats: 常规统计</li><li>replication: Master&#x2F;slave请求信息</li><li>cpu: CPU 占用信息统计</li><li>cluster: Redis 集群信息</li><li>keyspace: 数据库信息统计</li><li>all: 返回所有信息</li><li>default: 返回常规设置信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; info server</span><br><span class="line"># Server</span><br><span class="line">redis_version:2.8.4</span><br><span class="line">....</span><br><span class="line">....</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计学习</title>
      <link href="/2017/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
      <url>/2017/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>How 2 design a database.</p><span id="more"></span><h2 id="数据库设计的基本步骤"><a href="#数据库设计的基本步骤" class="headerlink" title="数据库设计的基本步骤"></a>数据库设计的基本步骤</h2><p><strong>需求分析 -&gt; 逻辑设计 -&gt; 物理设计 -&gt; 维护优化</strong></p><p>在进行需求分析时, 要明确的是:</p><ul><li>数据是什么</li><li>数据有哪些属性</li><li>数据和属性各自的特点有哪些</li></ul><p>从逻辑设计到物理设计, 根据选择数据库的特点不同实现起来也不一样.</p><p>一般维护优化, 譬如:</p><ul><li>根据新的需求进行建表</li><li>索引优化</li><li>大表拆分</li></ul><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul><li>系统中要存储的数据 ( 冷热分离? )</li><li>数据的存储特点</li><li>数据的生命周期</li></ul><p>我们将数据库中存储的对象称之为实体.<br>而实体与实体间是存在不同的关系的<code>( 一对一, 一对多, 多对多 )</code> 表 &lt;–&gt; 实体<br>实体中的属性 – 哪些属性或者属性的组合可以唯一标示一个实体.</p><p>譬如: 一个电商的用户表中, 可唯一表示一个用户的属性有, <code>用户名, 身份证, 电话等.</code></p><p>而这样的属性的存储是随着系统上线时间而逐渐增加的, 且需要永久存储.</p><p>而商品表中, 属性繁多<code>(编码, 名称, 描述, 品类, 供应商, 重量, 有效期, 价格...)</code>, 但在这些属性中, 能够唯一标示的属性类如 <code>( 商品名称,商品编码等 )</code>, 对于已经下线的商品, 我们可以进行归档存储, 或者进行表的迁移.</p><h3 id="逻辑设计-数据库设计的范式"><a href="#逻辑设计-数据库设计的范式" class="headerlink" title="逻辑设计[ 数据库设计的范式 ]"></a>逻辑设计[ 数据库设计的范式 ]</h3><p>在逻辑设计中, 我们将需求化成数据库的逻辑模型.</p><p>通过<strong>ER图</strong>的形式对逻辑模型进行展示.</p><p>在ER图中,矩形代表实体集,菱形代表联系集,椭圆代表实体的属性,线段将属性联系到实体集.</p><hr><p>提到数据库的逻辑设计, 就不得不说一下数据库设计的范式.</p><p>设计范式用来使数据库变得简洁高效, 避免数据冗余和异常发生.</p><p>常见的数据库范式包括: <strong>第一范式</strong>, <strong>第二范式</strong>, <strong>第三范式</strong>以及<strong>BC范式</strong>.</p><p>这些范式一个比一个复杂(或者说每一个都是以前一个作为基础的.)</p><p>目前的数据库设计大多遵循这些.</p><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>第一范式的定义是:</p><blockquote><p>数据库中的字段都是单一属性, 不可再分的</p></blockquote><p>换句话说: <strong>第一范式要求数据库中的表都是二维表.</strong></p><table><thead><tr><th align="center">ID</th><th align="center">用户名</th><th align="center">密码</th><th align="center">姓名</th><th align="center">电话</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">Justin</td><td align="center">**</td><td align="center">www</td><td align="center">0000000</td></tr></tbody></table><p>很简单 对嘛, 基本上我们设计的表都是符合第一范式的.</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>第二范式定义是:</p><blockquote><p>数据库中的表中不存在非关键字对任一候选关键字段的部分函数依赖.</p></blockquote><p>其中, 部分函数依赖指的是存在这组合关键字中的某一关键字决定非关键字的情况.</p><p><strong>看不懂在说啥?</strong></p><p>换句话说:<strong>所有的[!单!]关键字段的表都符合第二范式</strong></p><p>看下面的例子:</p><table><thead><tr><th align="center">商品名称</th><th align="center">供应商名称</th><th align="center">价格</th><th align="center">描述</th><th align="center">重量</th><th align="center">电话</th><th align="center">有效期</th><th align="center">分类</th></tr></thead><tbody><tr><td align="center">可乐</td><td align="center">一厂</td><td align="center">3.00</td><td align="center">www</td><td align="center">300g</td><td align="center">88888888</td><td align="center">2017.05</td><td align="center">饮料</td></tr><tr><td align="center">可乐</td><td align="center">二厂</td><td align="center">3.50</td><td align="center">www</td><td align="center">333g</td><td align="center">00000000</td><td align="center">2017.05</td><td align="center">饮料</td></tr></tbody></table><p>注意这个表, 可乐这个商品并不具备唯一标示的能力(因为存在不同的生产商), 所以这是一组组合关键字, 而看一下函数依赖关系就会发现:</p><p>(商品名称) -&gt; ( 价格, 描述, 重量, 有效期 )<br>(供应商名称) -&gt; ( 供应商电话 )</p><p>对于这样的表, 进行优化后成为以下三个表:</p><p>|ID|商品名称|价格|描述|重量|有效期|分类|<br>|:—:|:—:|:—:|:—:|:—:|:—-:|<br>|1|可乐|3.00|www|300g|2017.05|饮料|<br>|2|可乐|3.50|www|333g|2017.05|饮料|</p><table><thead><tr><th align="center">ID</th><th align="center">供应商名称</th><th align="center">供应商电话</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">一厂</td><td align="center">88888888</td></tr><tr><td align="center">2</td><td align="center">二厂</td><td align="center">00000000</td></tr></tbody></table><table><thead><tr><th align="center">供应商ID</th><th align="center">商品ID</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">2</td></tr></tbody></table><p>这样, 单个表中仅存在单关键字, 它就满足第二范式了, 之前存在的种种异常和数据冗余就不存在了.</p><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>第三范式建立在第二范式的基础之上.</p><p>先不说定义, 请看表:</p><p>|商品名称|价格|描述|重量|有效期|分类|分类描述|<br>|:—:|:—:|:—:|:—:|:—-:|:—:|<br>|可乐|3.00|www|300ml|2017.05|酒水饮料|碳酸饮料|<br>|苹果|3.50|www|500g| |生鲜食品|水果|</p><p>该表中存在以下传递函数:</p><p>( 名称 ) -&gt; ( 分类 ) -&gt; ( 分类描述 )</p><p>非关键字段**’分类描述’<strong>, 对</strong>名称<strong>的</strong>传递**函数有依赖.</p><p>对于每一个商品我们都会进行记录, 所以存在着冗余. 同时还存在数据的插入, 更新及删除异常.</p><p>因此, 我们将其优化成如下的三张表:</p><p>|商品ID|商品名称|价格|描述|重量|有效期|<br>|:—:|:—:|:—:|:—:|:—:|<br>|1|可乐|3.00|www|300g|2017.05|<br>|2|可乐|3.50|www|333g|2017.05|</p><table><thead><tr><th align="center">分类ID</th><th align="center">分类</th><th align="center">分类描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">酒水饮料</td><td align="center">碳酸饮料</td></tr><tr><td align="center">2</td><td align="center">生鲜食品</td><td align="center">水果</td></tr></tbody></table><table><thead><tr><th align="center">分类ID</th><th align="center">商品ID</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">2</td></tr></tbody></table><p>对第三范式的定义是:</p><blockquote><p>如果数据表中不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式.</p></blockquote><h4 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h4><p>最后来看一下BC范式, 这是对于第三范式的扩展.</p><p>定义:</p><blockquote><p>在第三范式的基础之上,数据库表中如果不存在任意字段对任一候选关键字段的传递函数依赖则符合BC范式.</p></blockquote><p>如果是复合关键字, 则符合关键字之间也不能存在函数依赖关系.</p><p>来看这样一个表:</p><table><thead><tr><th align="center">供应商</th><th align="center">商品ID</th><th align="center">供应商联系人</th><th align="center">商品数量</th></tr></thead><tbody><tr><td align="center">饮料一厂</td><td align="center">1</td><td align="center">张三</td><td align="center">10</td></tr><tr><td align="center">饮料二厂</td><td align="center">2</td><td align="center">李四</td><td align="center">20</td></tr><tr><td align="center">饮料三厂</td><td align="center">1</td><td align="center">王五</td><td align="center">20</td></tr></tbody></table><p>该表中存在不符合BCNF要求的以来依赖:</p><p>( 供应商, 商品ID ) -&gt; ( 供应商联系人, 商品数量 )<br>( 联系人, 商品ID ) -&gt; ( 供应商, 商品数量 )</p><p>该关系即为:</p><p>( 供应商 ) -&gt; ( 供应商联系人 )<br>( 供应商联系人 ) -&gt; ( 供应商 )</p><p>也就是说,关键字之间存在函数依赖关系.</p><p>那么如何更改优化呢?</p><table><thead><tr><th align="center">供应商</th><th align="center">商品ID</th><th align="center">商品数量</th></tr></thead><tbody><tr><td align="center">饮料一厂</td><td align="center">1</td><td align="center">10</td></tr><tr><td align="center">饮料二厂</td><td align="center">2</td><td align="center">20</td></tr><tr><td align="center">饮料一厂</td><td align="center">1</td><td align="center">20</td></tr></tbody></table><table><thead><tr><th align="center">供应商</th><th align="center">供应商联系人</th></tr></thead><tbody><tr><td align="center">饮料一厂</td><td align="center">张三</td></tr><tr><td align="center">饮料一厂</td><td align="center">李四</td></tr><tr><td align="center">饮料二厂</td><td align="center">王五</td></tr></tbody></table><h3 id="物理设计-以MySQL为例"><a href="#物理设计-以MySQL为例" class="headerlink" title="物理设计[ 以MySQL为例 ]"></a>物理设计[ 以MySQL为例 ]</h3><p>存储引擎的选择: InnoDB.(略)</p><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>对于数据库的表和字段的命名应遵循下述原则:</p><ul><li><p>可读性原则</p></li><li><p>表意性原则</p><ul><li>name NOT col_1</li></ul></li><li><p>长名原则</p><ul><li>例如: goods_id NOT id, student_name NOT name</li></ul></li></ul><h4 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h4><p>关于字段类型的选择,总的原则是对于相同级别的数据类型, 应该优先选择占用空间小的数据类型.</p><p><strong>优先考虑数字类型, 其次是日期或二进制类型, 最后是字符类型</strong></p><p>而对于选择这样的原则, 主要从下面两个角度考虑:</p><ul><li><p>在对数据进行比较(查询条件, JOIN, 排序)操作时: 同样的数据, 字符常常处理的比数字慢.</p></li><li><p>数据库中, 数据处理以页为单位, 列的长度越小, 利于性能提升.</p></li></ul><p>具体说来,有这些小Tips:</p><blockquote><p>1.如果列中的数据长度长不多是一致的, 应该考虑使用<code>char</code>, 否则考虑使用<code>varchar</code>.<br>2.如果列中的最大数据长度小于<code>50Byte</code>,则一般考虑使用<code>char</code>.( 当然, 如果这个列很常用, 则基于节省空间和减少I&#x2F;O的考虑, 还是可以选择用<code>varchar</code> )<br>3.一般不宜定义大于<code>50Byte</code>的<code>char</code>类型</p></blockquote><h4 id="反范式化表设计"><a href="#反范式化表设计" class="headerlink" title="反范式化表设计"></a>反范式化表设计</h4><p>简单地说, 反范式化表设计是为了性能和读取效率的考虑(毕竟表的连接还是很消耗性能的), 因此, 允许存在少量的数据冗余或适当的对第三范式的要求进行违反.</p><p>也就是: <strong>反范式化是使用空间换时间.</strong></p><p>譬如之前的表, 在为了快速读取的业务场景下, 我们仍然可以考虑设计出这样的表.</p><table><thead><tr><th align="center">订单ID</th><th align="center">商品ID</th><th align="center">商品数量</th><th align="center">商品价格</th><th align="center">商品名称</th><th align="center">过期时间</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>在上面所说的逻辑设计部分, 这样的表是不合规范的, 因为我们完全可以通过商品ID来推出商品的名称和过期时间.</p><p>但是在实际的业务场景中, 我们经常需要获取名称和时间这样的信息.(热数据)</p><p>而且, SQL语句也会得到大量的缩减.</p><p>因此考虑到这个, 我们设计出这样的表.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux三剑客-grep/awk/sed</title>
      <link href="/2017/05/06/Linux%E4%B8%89%E5%89%91%E5%AE%A2-grep-awk-sed/"/>
      <url>/2017/05/06/Linux%E4%B8%89%E5%89%91%E5%AE%A2-grep-awk-sed/</url>
      
        <content type="html"><![CDATA[<p>Linux下文本处理的三剑客–grep&#x2F;awk&#x2F;sed!</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Grep&#x2F;awk&#x2F;Sed是Linux下处理文本信息的最强的三个命令.使用它们几乎可以完成所有的文本处理, 具体说来是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep : 过滤.查找</span><br><span class="line">awk : 文本处理工具</span><br><span class="line">sed : 行编辑器</span><br></pre></td></tr></table></figure><p>使用它们不可避免的要使用正则.</p><p>因此回顾一下正则的基础:</p><p>简单的说, 我们把基础正则分为这样三个部分.</p><p><strong>单个字符</strong>–表示内容</p><p>特定的字符(直接写), 字符范围(使用中括号<code>[]</code>), 任意字符(用一个点<code>.</code>来表示).<br>使用<code>|</code>来进行逻辑或运算.</p><p><strong>重复字符</strong>–表示数量</p><p>表示从零到任意:使用星号<code>*</code><br>表示要么0个要么1个:使用问号<code>?</code><br>表示从1到任意个:使用加号<code>+</code><br>表示特定的范围:使用大括号<code>&#123;&#125;</code></p><p><strong>边界字符</strong></p><p>首字符使用尖角号<code>^</code><br>尾字符使用美元符<code>$</code></p><p><strong>元字符</strong></p><p>任何字类字符使用<code>\w</code><br>任何非字类字符使用<code>\W</code><br>划定单词边界使用<code>\b</code> – <code>(boundary)</code></p><p>另外,在使用一些字符时, <strong>千万不要忘记使用转义字符.</strong></p><p>基础的正则就是这样了.</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>这个使用率应该是最高的了, 因为他是三个命令中最简单的一个.</p><p>grep的基本命令格式是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] 匹配字符串 文件</span><br></pre></td></tr></table></figure><p>我们经常使用管道符流动的数据来替代文件, grep常用的选项是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-i (ignore-case) 忽略大小写</span><br><span class="line">-v (invert-match) 反向匹配</span><br><span class="line">-n (line-number) 输出行号</span><br></pre></td></tr></table></figure><p>这个没什么好说的了..因为大家都用的很666666. :)</p><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>sed相当于是一个自动的vim,常用来分析日志,修改配置,自动处理文件.</p><p>简单先说一下Sed的原理, Sed接受一个输入, 接着(A)将读到的<strong>一行</strong>数据写入到模式空间(其实就是一个临时缓冲区), 接着进行命令处理(B),最后输出到屏幕, (A-B)循环执行直到读取结束.</p><p>Sed实际上是行处理! 并且, Sed不改变源文件, 除非指定选项(这个后面再说), </p><p>命令格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [选项] <span class="string">&#x27;[命令]&#x27;</span> 文件名</span><br></pre></td></tr></table></figure><p>现将常用的选项参数列出来, 到了下面再慢慢说:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-e 对输入数据进行多条sed命令(;号分割)</span><br><span class="line">-n 仅仅将处理的行输出到屏幕(默认全文件)</span><br><span class="line">-i 直接修改源文件, 而不是由屏幕输出.</span><br></pre></td></tr></table></figure><p>那我们从<strong>文本处理</strong>开始!</p><p>Sed的命令有很多和Vim很像, 列举一些常用的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- a : (append) 追加</span><br><span class="line">- c : (change) 替换</span><br><span class="line">- d : (delete) 删除</span><br><span class="line">- i : (insert) 插入</span><br><span class="line">- p : (<span class="built_in">print</span>) 打印</span><br><span class="line">- s : (string) 字串替换 -- 行范围s/旧字串/新字串/g (后面说)</span><br></pre></td></tr></table></figure><p>下面来动动手吧~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ sed <span class="string">&#x27;p&#x27;</span> passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>挨!!??输出了两次?想想看这是为什么?</p><p>之前说过, sed的原理是读取一行, 而在没有加上-n参数的时候, 又会将全文件输出, 所以就造成了行行重复的情况.</p><p>同Vim一样,也可以直接使用行号或者使用斜杠进行搜索.</p><p>比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ sed -n <span class="string">&#x27;10p&#x27;</span> passwd</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">[root@WWW ~]$ sed -n <span class="string">&#x27;/user/p&#x27;</span> passwd</span><br><span class="line">tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin</span><br><span class="line">tinyproxy:x:993:991:tinyproxy user:/var/run/tinyproxy:/bin/false</span><br><span class="line">user1:x:1001:1001::/home/user1:/bin/bash</span><br><span class="line">user2:x:1002:1002::/home/user2:/bin/bash</span><br></pre></td></tr></table></figure><p>也可以选择一段距离, 比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ sed -n <span class="string">&#x27;10,20p&#x27;</span> passwd</span><br><span class="line">[root@WWW ~]$ sed -n <span class="string">&#x27;/operator/, /ftp/p&#x27;</span> passwd</span><br></pre></td></tr></table></figure><p>将数字中的逗号变为波浪线即可进行步进式的跳跃.</p><p>也可以进行取反: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ sed -n <span class="string">&#x27;10!p&#x27;</span> passwd</span><br><span class="line"><span class="comment"># 表示除了第十行都进行p操作</span></span><br></pre></td></tr></table></figure><p>接着来看一下<code>-i</code>和<code>-a</code>两个插入命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ sed <span class="string">&#x27;2a =========&#x27;</span> passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">=========</span><br><span class="line">......</span><br><span class="line">[root@WWW ~]$ sed <span class="string">&#x27;2i =========&#x27;</span> passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">=========</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>也就是说, i是向前插入, a是向后插入.</p><p>很简单对吧? 删除命令也是很简单的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">nl</span> passwd | sed <span class="string">&#x27;2d&#x27;</span></span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">3 daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>删除同样也支持跳行和段选择.</p><p>最后就是替换命令了, 替换支持行替换和字串替换.</p><p>相对来说, 行替换要更简单一点.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ sed <span class="string">&#x27;2c Hello&#x27;</span> passwd | <span class="built_in">nl</span></span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">2 Hello</span><br><span class="line">3 daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>如果在替换命令中使用了段选择, 不会使每一行都做替换, 而是把他们作为一个整体.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ sed <span class="string">&#x27;1,34c Hello&#x27;</span> passwd | <span class="built_in">nl</span></span><br><span class="line">1 Hello</span><br><span class="line">[root@WWW ~]$ sed <span class="string">&#x27;s/root/ROOT/g&#x27;</span> passwd </span><br><span class="line">ROOT:x:0:0:ROOT:/ROOT:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>来看一个操作实例吧, 现在我们从ifconfig中读取ip地址:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ ifconfig | grep inet | sed -e <span class="string">&#x27;s/inet //;s/net.*//&#x27;</span></span><br><span class="line">xx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure><p>其中我们使用了多重操作, 也就是添加<code>-e</code>参数, 并使用分号进行多个<code>sed</code>命令.</p><p>接下来来看一下Sed稍微高级一点的用法:</p><ul><li>使用&amp;来复制前一个字符串</li><li>大小写转换</li></ul><p>使用<code>&amp;</code>的一个实例像这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ sed <span class="string">&#x27;s/^[a-z]\+/&amp;   /&#x27;</span> passwd</span><br></pre></td></tr></table></figure><p>接着来看一下这几个大小写转换符:</p><ul><li>u 转大写(以首字母为单位) (U 以词为单位) </li><li>l 转小写(以首字母为单位) (L 以词为单位)</li></ul><p>比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ sed &#x27;s/^[a-z-]\+/\U&amp;/&#x27; passwd</span><br></pre></td></tr></table></figure><p>会将所有的用户名变成大写.</p><p>接着,如同我们在Python小技巧中说过的捕获组, 正则拼成的组, 也是可以有编号进行引用的.就像这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ sed <span class="string">&#x27;s/\(^[0-9A-Za-z-]\+\):x:\([0-9]\+\):\([0-9]\+\).*$/USER:\1   UID:\2   GID:\3/&#x27;</span> passwd</span><br></pre></td></tr></table></figure><p>这样会输出类似:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User:root   UID: 0 GID:0 </span><br><span class="line">User:bin   UID: 1 GID:1 </span><br><span class="line">User:daemon   UID: 2 GID:2 </span><br></pre></td></tr></table></figure><p>这样的语句.</p><p>sed也可以进行多文件间的操作, 比如这两个命令:(<strong>注意:其中的<code>w</code>命令是会进行真实写入的!会直接对文件进行改变并且指针在文件头.</strong>)</p><p>比方说我们先写入一些数据:(和下面的演示有出入,只要分清字母和数字就好)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">echo</span> -e <span class="string">&quot;13243\n545343\n112324&quot;</span> &gt; 123.txt</span><br><span class="line">[root@WWW ~]$ <span class="built_in">echo</span> -e <span class="string">&quot;ghreqwre\ndwegfew\ndwqcsa&quot;</span> &gt; abc.txt</span><br></pre></td></tr></table></figure><p>接着演示文件间的读取和写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ sed <span class="string">&#x27;1r abc.txt&#x27;</span> 123.txt <span class="comment"># 写入缓存区中,不会生效</span></span><br><span class="line">3413254</span><br><span class="line">aDSWvsdfv</span><br><span class="line">fwqwqfwqfwq</span><br><span class="line">fqefqq</span><br><span class="line">14354354</span><br><span class="line">2132421</span><br><span class="line">[root@WWW ~]$ sed <span class="string">&#x27;$r abc.txt&#x27;</span> 123.txt <span class="comment"># 写到尾部</span></span><br><span class="line">[root@WWW ~]$ sed <span class="string">&#x27;1w abc.txt&#x27;</span> 123.txt</span><br><span class="line">3413254</span><br><span class="line">14354354</span><br><span class="line">2132421</span><br><span class="line">[root@WWW ~]$ <span class="built_in">cat</span> abc.txt <span class="comment"># 文件被改变</span></span><br><span class="line">3413254</span><br></pre></td></tr></table></figure><p>sed的执行单位是行, 直到读取完整个文件.</p><p>但我们可以通过<code>q</code>命令使其提前退出.</p><p>比如:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">nl</span> passwd | sed <span class="string">&#x27;3q&#x27;</span></span><br><span class="line">1root:x:0:0:root:/root:/bin/bash</span><br><span class="line">2bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">[root@WWW ~]$ <span class="built_in">nl</span> passwd | sed <span class="string">&#x27;/nologin/q&#x27;</span></span><br><span class="line">1root:x:0:0:root:/root:/bin/bash</span><br><span class="line">2bin:x:1:1:bin:/bin:/sbin/nologin</span><br></pre></td></tr></table></figure><p>至此, sed的命令就差不多了.</p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>awk是一个与Sed类似的文本与数据处理工具, 同样也是一次处理一行内容.</p><p>不同的是, awk对每行可进行切片, 并且awk是可以进行编程的, 因此他十分灵活.</p><p>awk的格式为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;条件1&#123;动作1&#125;条件2&#123;动作2&#125;...&#x27;</span> 文件名</span><br></pre></td></tr></table></figure><p>awk的内置变量(1)同shell参数很像, 使用<code>$0</code>表示整行, <code>$1</code>表示第一个字段, <code>$2</code>表示第二个字段….以此类推..</p><p>awk的分割符用 <code>-F &#39;&#39; </code>来进行声明</p><p>比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">cat</span> passwd | awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $1 &quot;----&quot; $7&#125;&#x27;</span></span><br><span class="line">root----/bin/bash</span><br><span class="line">bin----/sbin/nologin</span><br><span class="line">daemon----/sbin/nologin</span><br><span class="line">adm----/sbin/nologin</span><br></pre></td></tr></table></figure><p>awk的内置变量(2)是NR,NF,FILENAME,分别表示每行的记录号, 字段的数量, 和正在处理的文件名. </p><p>awk是支持逻辑运算的, 比如下面这个:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ awk -F <span class="string">&quot;:&quot;</span> <span class="string">&#x27;&#123;if ($3&gt;100) print &quot;Deny:  &quot;,$1&#125; &#123;if ($3&lt;100) print &quot;Access:   &quot;,$1&#125;&#x27;</span> passwd</span><br><span class="line">Access:    root</span><br><span class="line">Access:    bin</span><br><span class="line">Deny:   libstoragemgmt</span><br><span class="line">Access:    tcpdump</span><br><span class="line">Deny:   nginx</span><br></pre></td></tr></table></figure><p>awk有两种输出函数, 一个是<code>printf</code>, 一个是<code>print</code>, 其中<code>printf</code>更加古老, 需要手动加上最后的换行符, <code>print</code>会自动加上.</p><p><code>printf</code>基本上和编程语言的同名函数用法相同,都是格式化输出.</p><p>作为awk的重要功能, 我们来看一下他的逻辑判断式:</p><ul><li><del>, !</del>  :  匹配正则表达式</li><li>&#x3D;&#x3D;, !&#x3D;, &lt;, &gt;  :  判断逻辑表达式</li></ul><p>匹配正则以<code>~</code>开头, 后面加上有斜线规定的正则, 后面的指令就只对匹配到的内容有效果了.</p><p>比如这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;$1~/^r.*$/&#123;print $1&#125;&#x27;</span> passwd</span><br><span class="line">root</span><br><span class="line">rpc</span><br></pre></td></tr></table></figure><p>当然也可以反选择, 只要把<code>~</code>进行取反就可以啦, 也就是<code>!~</code>.</p><p>以上是awk的基础格式.</p><p>什么?还有扩展的? 是的, awk的command2拓展就像是这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ awk [options] <span class="string">&#x27;BEGIN&#123;print &#x27;</span>start<span class="string">&#x27;&#125; pattern&#123;commands&#125; END&#123; print &quot;end&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>使用awk扩展格式可以手动制表, 仍然用<code>passwd</code>来举例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;BEGIN&#123;print &quot;Line\tCol\tUser&quot;&#125;&#123;print NR&quot;\t&quot;NF&quot;\t&quot;$1&#125;END&#123;print &quot;-------&quot;FILENAME&quot;-------&quot;&#125;&#x27;</span> passwd </span><br><span class="line">LineColUser</span><br><span class="line">17root</span><br><span class="line">....</span><br><span class="line">317tomcat</span><br><span class="line">327tinyproxy</span><br><span class="line">-------passwd-------</span><br></pre></td></tr></table></figure><p>现在我们利用awk的逻辑控制运算功能, 做一个小实例:(请使用du取代这个愚蠢的实例.)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">ls</span> -la | awk <span class="string">&#x27;BEGIN&#123;size=0&#125;&#123;size+=$5&#125;END&#123;print &quot;The total size of the directory is &quot;size/1024/1024&quot;M&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>在BEGIN段中, 我们初始化了size,接着让awk一行一行读入大小的值并累加到size上,最后输出.</p><p>同样, 我们也可以统计passwd文件的行数, 从而得知有多少用户(请使用wc命令,取代这个愚蠢的实例)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ awk -F <span class="string">&quot;:&quot;</span> <span class="string">&#x27;BEGIN&#123;count=0&#125;$1!~/^$/&#123;count++&#125;END&#123;print &quot;There are &quot;count&quot; users&quot;&#125;&#x27;</span> passwd</span><br></pre></td></tr></table></figure><p>awk也可以使用for循环和数组, 没想到吧?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ netstat -tanp | awk <span class="string">&#x27;$6~/LISTEN|ESTABLISHED/&#123;sum[$6]++&#125;END&#123;for (i in sum)print i, sum[i]&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">LISTEN 9</span><br><span class="line">ESTABLISHED 16</span><br></pre></td></tr></table></figure><p>到这里awk的使用就算是差不多了, 简单小结一下吧:</p><p>awk的内置参数要知道, $n(数字) 代表那一列的值, NR, NF 分别代表<strong>Record每行记录数</strong>, <strong>Field字段数</strong>.</p><p>awk支持逻辑符, 判断, 数组, 循环等等, 还有<code>BEGIN</code>和<code>END</code>.</p><h2 id="其他管道命令"><a href="#其他管道命令" class="headerlink" title="其他管道命令"></a>其他管道命令</h2><p>接着记录一下Linux的管道命令, 这些在进行文本处理的时候也是超级常用的.</p><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>这个命令其实也是很常用的,听名字就知道是干什么的了–做字符串的裁剪以剪出我们需要的信息.</p><p>事实上,这个命令的历史很久的.简单的使用方法就像是这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">cut</span> -d <span class="string">&quot;分割字符&quot;</span> -f fields <span class="comment"># d其实就是delimiter嘛  fields就是要裁剪的数据域</span></span><br><span class="line">[root@WWW ~]$ <span class="built_in">cut</span> -c 字符范围</span><br></pre></td></tr></table></figure><p>举个例子就明白了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line">[root@WWW ~]$ <span class="comment"># 现在我们可以把这之间的:当成分隔符,这样$PATH的构成就是</span></span><br><span class="line">[root@WWW ~]$ <span class="comment"># |1|2|3|4|5|6|</span></span><br><span class="line">[root@WWW ~]$ <span class="built_in">echo</span> <span class="variable">$PATH</span> | <span class="built_in">cut</span> -d <span class="string">&quot;:&quot;</span> -f 1</span><br><span class="line">/usr/lib64/qt-3.3/bin</span><br></pre></td></tr></table></figure><p>简单吧,另外cut还能精确的定位到一节字符串的某个位置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">echo</span> <span class="variable">$PATH</span> | <span class="built_in">cut</span> -c 1,5</span><br><span class="line">// <span class="comment"># 这个是第一个usr两边的斜线</span></span><br><span class="line">[root@WWW ~]$ <span class="built_in">echo</span> <span class="variable">$PATH</span> | <span class="built_in">cut</span> -c 1-5</span><br><span class="line">/usr/</span><br></pre></td></tr></table></figure><p>上面就是在使用cut命令的<code>-c</code>进行的精准截取, <code>,</code>表示<strong>就选择这两个位置的字符</strong>, <code>-</code>表示<strong>选择这两个字符以及他们中间的所有字符</strong>, 其实就类似Python的切片, <code>cut</code>也可以不写两端来进行直到头尾的操作.</p><p>当然你也发现了, cut在处理多个空格的情况下是比较吃力的, 这个时候就要选择<code>awk</code>了.</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort是个很有趣的指令,他可以根据不同的数据类型来进行排序.<strong>这里要注意一下,排序的依据还取决于当前系统的语系.使用LANG&#x3D;C来使得语系统一,优化排序</strong></p><p>常用的选项和参数如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">sort</span> [options] [file or stdin]</span><br><span class="line"><span class="comment"># options</span></span><br><span class="line"><span class="comment"># -f 忽略大小写(很好奇为什么不是i,难道是familiar?) 哦,-i的意思是忽略不可打印的字符,不过基本用不到吧....</span></span><br><span class="line"><span class="comment"># -r 反向排序(reverse)</span></span><br><span class="line"><span class="comment"># -k 排序依据(用什么东西来进行排序)</span></span><br><span class="line"><span class="comment"># -t 分割符号(默认是TAB, 这个选项经常和-k一起使用)</span></span><br></pre></td></tr></table></figure><p>使用sort,我们可以很轻易的得到按照用户名排序的passwd文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span></span><br></pre></td></tr></table></figure><p>假如说系统的passwd文件不是按照uid排的序的话, 使用sort同样可以达到同样的目的, 这个时候就要使用到<code>-k</code>和<code>-t</code>了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span> -t <span class="string">&quot;:&quot;</span> -k 3</span><br></pre></td></tr></table></figure><p>稍微解释一下,<code>-t &quot;:&quot;</code>的意思是说以<code>:</code>当做分割符, <code>-k 3</code>的意思是说以第三个的数据域(也就是uid了)当做排序依据.</p><h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>这个命令经常用于进行处理重复的行, 一个经典的使用例子就是统计曾经登录的用户的登录次数.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ last | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br></pre></td></tr></table></figure><p>我的机器上的输出结果是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  1 </span><br><span class="line">  1 reboot</span><br><span class="line">121 root</span><br><span class="line">  1 wtmp</span><br></pre></td></tr></table></figure><p><strong>一开始我省略了sort命令,结果发现输出的结果是这样的:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">107 root</span><br><span class="line">  1 reboot</span><br><span class="line"> 14 root</span><br><span class="line">  1 </span><br><span class="line">  1 wtmp</span><br></pre></td></tr></table></figure><p><code>root</code>的结果被分开了, 这样就导致<code>uniq</code>的统计结果出现了错误. 这样我们就能发现了<code>uniq</code>的处理逻辑: <strong>从上到下的搜索,如果是一样的就不再增加新条目,一旦遇到不同的,则直接将之前的的条目归档.</strong></p><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>这个是一个很好用的统计工具哦, <code>wc</code>可以很方便的统计行数,字数,字符数.</p><p>尤其对于一些成行的文件,这个命令可以很灵活的获取一些你想要的值.( 比如<code>/etc/passwd</code>这样的文件,行数即为用户数 )</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">echo</span> `<span class="built_in">cat</span> /etc/passwd | <span class="built_in">wc</span> -l`<span class="string">&quot;个用户&quot;</span></span><br><span class="line">36个用户</span><br></pre></td></tr></table></figure><p>直接使用<code>wc</code>,会按照次序输出行数,字数,字节数.</p><p><code>wc</code>对于单词的界定是被空格分割的非零长度的字符序列.</p><p>使用一下选项来限制输出的信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">wc</span> -l (lines) -w (words) -m (chars)</span><br></pre></td></tr></table></figure><h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h3><p><img src="http://linux.vbird.org/linux_basic/0320bash//0320bash_5.png" alt="tee 的工作流程示意图"></p><p>像上面的图那样, tee会将输出流复制一份到文件,另外一份到标准输出流(也就是屏幕了)</p><p>例如,当你想要将处理的信息输出到屏幕外,还想存一份日志或者什么.那么<code>tee</code>就是一个十分适合的工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ last | <span class="built_in">tee</span> last.list | <span class="built_in">cut</span> -d <span class="string">&quot; &quot;</span> -f 1</span><br></pre></td></tr></table></figure><p>这样不仅会新建一个叫<code>last.list</code>的文件,还会将信息同步输出到屏幕上.</p><p>如果文件是已经存在的,那么文件指针将会指向文件头.</p><p>如果是要进行追加,就要添加<code>-a</code>参数. 如果文件的参数是<code>-</code>,那么将会输出标准输出 ( 也就是说会在屏幕上输出两倍的信息 )</p><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p>tr的用法还是很灵活的, 因为你可以使用正则来进行各种替换和删除.</p><p>直接上实例吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~] <span class="built_in">cat</span> /etc/passwd | <span class="built_in">tr</span> [:lower:] [:upper:] </span><br></pre></td></tr></table></figure><p>这样便将所有的字母变成了大写.像这样的变量还有:</p><ul><li><code>[:alnum:]</code>所有的字母和数字</li><li><code>[:alpha:]</code>所有的字母</li><li><code>[:blank:]</code>所有的水平空格</li><li><code>[:digit:]</code>所有的数字</li><li><code>[:upper:]</code>大写字母</li><li><code>[:lower:]</code>小写字母</li></ul><p>另外tr可以加上参数来说明模式: <code>-d</code>是匹配删除, <code>-t</code>是用来将SET1映射成SET2.</p><p>在使用正则的情况下: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">cat</span> /etc/passwd | <span class="built_in">tr</span> [a-z] [A-Z]</span><br></pre></td></tr></table></figure><p>和上面的效果是一样的.</p><p>删除功能的示例如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">cat</span> /etc/passwd | <span class="built_in">tr</span> -d <span class="string">&quot;:&quot;</span></span><br></pre></td></tr></table></figure><p>然后你就会看到一团子东西, 所有的分隔符已经被删去了.</p><p>tr还有一个有趣的参数<code>-c</code> 意思就是取补集, 换言之就是除了给定的SET之外的. 如果和-d连续使用就是说仅保留给定的字符集. 这样子的一个应用就是生成随机字符串:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW mage_shell_edu]<span class="comment"># tr -cd a-zA-Z0-9 &lt; /dev/urandom | head -c 20 | xargs</span></span><br><span class="line">hd5t7kDdpOwBoiKhYP9K</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># tr -cd a-zA-Z0-9 &lt; /dev/urandom | head -c 20 | xargs</span></span><br><span class="line">PDR1Eb6ZJkFc5851TeUc</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># tr -cd a-zA-Z0-9 &lt; /dev/urandom | head -c 20 | xargs</span></span><br><span class="line">NdH7qFJY7Xo3wWo9Vub8</span><br><span class="line">[root@WWW mage_shell_edu]<span class="comment"># tr -cd a-zA-Z0-9 &lt; /dev/urandom | head -c 20 | xargs</span></span><br><span class="line">jgcXXMGVNoZJPUtY9Kp6</span><br></pre></td></tr></table></figure><p>最后一个xargs其实就是为了换行而已, 关于xargs的用法, 下面会有.</p><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>在<code>NT</code>下, 你应该使用过一些<code>txt</code>裁剪工具对吧.这个<code>split</code>就是类似的一个外部命令.</p><p><code>split</code>可以将大文档分割成一个个小的档案.并且支持单位.</p><p><code>split</code>支持按行数分割, 按大小两种方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">split</span> [OPTION] [INPUT [PREFIX]]</span><br><span class="line"><span class="comment"># OPTION 常用的就是 -b 按字节分割 -l 按行数分割</span></span><br><span class="line"><span class="comment"># INPUT 就是输入</span></span><br><span class="line"><span class="comment"># PREFIX 是指生成的文件名前缀</span></span><br></pre></td></tr></table></figure><p>现在来试一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">split</span> -l 4 /root/test mytest_</span><br><span class="line">[root@WWW ~]$ <span class="built_in">split</span> -b 100 /root/test mytest_</span><br></pre></td></tr></table></figure><p>然后我的机器上就多出来了几个文件, 命名形式是: <code>mytest_a&#123;a,b,c,d...&#125;</code></p><p>如果我是想将屏幕上的信息进行裁剪之后再输出文件怎么办呢?</p><p>还记得之前的那个短横线 <code>-</code> 这个横线就可以来解决问题.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">ls</span> -al /| <span class="built_in">split</span> -l 4 - lsroot_</span><br></pre></td></tr></table></figure><p>那如果我要进行文件的合并怎么办呢, 其实这个并不需要什么特定的工具了,直接使用数据流重定向就可以了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">cat</span> mytest_* &gt;&gt; mytest</span><br></pre></td></tr></table></figure><p>这样就可以了.</p><p>最后再来看一个参数代换的命令:</p><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p>这个命令是个很神奇的命令,参数代换并不能理解吧, 其实说白了就是将前面的输出当做命令的参数.所以这个命令的用处是很大的.</p><p>比如说</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ <span class="built_in">cat</span> /etc/passwd \ <span class="built_in">cut</span> -d <span class="string">&#x27;:&#x27;</span> -f 1 | xargs -n 1 <span class="built_in">id</span></span><br></pre></td></tr></table></figure><p>这样就可以打印出所有用户的UID,GID和所属组名.</p><p>这样看来<code>xargs</code>就像是<code>find</code>命令后面的那个<code>-exec COMMAND &#123;&#125; \;</code>一样的感觉.</p><p>解释一下上面的参数是什么意思: 如果参数是很多个就一定要指定<code>-n</code>参数, 这个告诉<code>xargs</code>一次处理的命令参数数量</p><p>另外,如果xargs后面没有指定命令,那么默认就是<code>echo</code>. 另外一个可能会用到的参数是<code>-e</code>(EOF)的意思, 在后面可以跟上一个字符串, 当<code>xargs</code>扫描到了这个字符串就会直接停止工作.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RegExp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python小技巧-3</title>
      <link href="/2017/05/05/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-3/"/>
      <url>/2017/05/05/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-3/</url>
      
        <content type="html"><![CDATA[<p>Python编程技(mo)巧(fa).[环境:Python3.6.0]</p><span id="more"></span><h2 id="Py的魔法"><a href="#Py的魔法" class="headerlink" title="Py的魔法"></a>Py的魔法</h2><h3 id="派生内置不可变类并修改实例化行为的魔法"><a href="#派生内置不可变类并修改实例化行为的魔法" class="headerlink" title="派生内置不可变类并修改实例化行为的魔法"></a>派生内置不可变类并修改实例化行为的魔法</h3><p>一个类的实例化方法是<code>__init__</code> ?</p><p>不是呢, 是<code>__new__</code>, <code>__init__</code>只是初始化方法.</p><p>魔法原料:</p><blockquote><p><strong><em>_new</em>_</strong>:创建对象时调用，会返回当前对象的一个实例<br><strong><em>_init</em>_</strong>:创建完对象后调用，对当前对象的一些实例初始化，无返回值</p></blockquote><p>魔法咒语:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>如果__new__和__init__同时存在，会优先调用__new__.</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>__new__方法会返回所构造的对象，__init__则不会 (__init__无返回值).</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>如果__new__返回一个对象的实例，会隐式调用__init__.</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>如果__new__不返回一个对象的实例，__init__不会被调用.</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>在对象的实例创建完成后调用。参数被传给类的构造函数.</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>如果基类有__init__方法，子类必须显示调用基类的__init__.</span><br></pre></td></tr></table></figure><p>如果说现在我想写个继承于tuple的子类.这个类能够自动过滤掉非数字的元素,(就叫它NumTuple类吧).</p><p>这个部分<code>Pyhton3</code>和<code>Python2</code>差别还是很大的, <code>Py2</code>中叫做类型<code>(type)</code>, <code>Py3</code>中叫做类<code>(class)</code></p><p>这里使用的环境是Python3,所以函数签名已经改变了, Python2的函数签名就像是公交车.</p><p>从上面的魔法咒语中就能明白, 实现这个功能的关键就在<code>__new__</code>方法了.通过重载<code>__new__</code>方法,可以操作要返回的对象.那么,为了调用其父类的<code>__init__</code>方法, 我们使用<code>super</code>.</p><p><code>super</code>是Python中的类, 用来做基类和子类的对象代理, 什么是对象代理呢?</p><p>可以简单的理解成Java中的多态? 简单的说就是调用同辈或者父类的函数, 比如这样的小栗子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self, token</span>):</span><br><span class="line">  write2DB(token)</span><br><span class="line">  render()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Auth</span>(<span class="title class_ inherited__">Handler</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self, token</span>):</span><br><span class="line">    <span class="keyword">if</span> validate(token):</span><br><span class="line">      <span class="built_in">super</span>().login(token) <span class="comment"># 等同于super(Auth, self)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  exit()</span><br></pre></td></tr></table></figure><p>这样子类就可以非常便利的调用父类的方法了.</p><p>现在尝试实现一下<code>NumTuple</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumTuple</span>(<span class="title class_ inherited__">tuple</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">self, iterable</span>):</span><br><span class="line">    g = ( x <span class="keyword">for</span> x <span class="keyword">in</span> iterable <span class="keyword">if</span> <span class="built_in">isinstance</span>(x, <span class="built_in">int</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(x, <span class="built_in">float</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>().__new__(self, g)</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, iterable</span>):</span><br><span class="line">    self.proto = iterable</span><br><span class="line">    <span class="built_in">super</span>().__init__()</span><br></pre></td></tr></table></figure><h3 id="节省内存的魔法"><a href="#节省内存的魔法" class="headerlink" title="节省内存的魔法"></a>节省内存的魔法</h3><hr><p>实例化对象是一件消耗内存的操作. 想想这么一种场景, 一个网络游戏服务要给每一个玩家实例化一个角色类, 这数百万的实例会消耗掉许多内存,在Python中节省内存是很简单的.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, uid, name, status=<span class="number">0</span>, level=<span class="number">1</span></span>);</span><br><span class="line">    self.uid = uid</span><br><span class="line">    self.name = name</span><br><span class="line">    self.status = status</span><br><span class="line">    self.level = level</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  __slots__ = [<span class="string">&#x27;uid&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;status&#x27;</span>, <span class="string">&#x27;level&#x27;</span>]</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, uid, name, status=<span class="number">0</span>, level=<span class="number">1</span></span>);</span><br><span class="line">    self.uid = uid</span><br><span class="line">    self.name = name</span><br><span class="line">    self.status = status</span><br><span class="line">    self.level = level</span><br></pre></td></tr></table></figure><p>这两个类基本一样, 唯一的不同就在第二个类多了一个<code>__slots__</code>, 这个属性表示该类的实例有且仅有这几个属性, 且不能再添加.</p><p>实例化看一下效果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> XX <span class="keyword">import</span> Person1, Person2</span><br><span class="line"></span><br><span class="line">p1 = Person1(<span class="string">&quot;0001&quot;</span>, <span class="string">&quot;P1&quot;</span>)</span><br><span class="line">p2 = Person2(<span class="string">&quot;0002&quot;</span>, <span class="string">&quot;P2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(<span class="built_in">dir</span>(p1)) - <span class="built_in">set</span>(<span class="built_in">dir</span>(p2))) <span class="comment"># 看看两者之间究竟有什么差别!</span></span><br></pre></td></tr></table></figure><p>最后打印出来的结果是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;__weakref__&#x27;, &#x27;__dict__&#x27;&#125;</span><br></pre></td></tr></table></figure><p>其中,最占用内存的就是<code>__dict__</code>了, 这个属性允许对象动态的进行属性的增加.</p><p>你可以试试为<code>p1</code>增加一个属性, 接着查看一下<code>p1.__dict__</code>, 你会发现这个对象消耗了很多资源.</p><p>查看大小的方法可以使用<code>sys</code>模块提供的<code>getsizeof</code>方法.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.getsizeof(p1.__dict__)</span><br><span class="line"><span class="comment"># 132</span></span><br></pre></td></tr></table></figure><p>在<strong>Python3</strong>中,这个已得到优化, 占用<strong>132</strong>个字节, 而在<strong>Python2</strong>中, 仅仅为一个对象增加两个属性就会消耗掉<strong>1048</strong>个字节!</p><h3 id="上下文管理的魔法"><a href="#上下文管理的魔法" class="headerlink" title="上下文管理的魔法"></a>上下文管理的魔法</h3><hr><p>Python提供了with关键字提供了便捷的上下文管理, 比如最经典的用于IO流的使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;sample.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  cont = f.read()</span><br><span class="line"><span class="comment"># f.close() 不再需要了</span></span><br></pre></td></tr></table></figure><p>如果说我想让我自己的类也实现这样的魔法呢?</p><p>事实上, 只要实现两个方法就可以实现上下文的管理: <code>__enter__</code>和<code>__exit__</code>.</p><p>现在我们实现一个支持上下文管理的类.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Query</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">self.name = name</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Enter!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span><br><span class="line">    <span class="keyword">if</span> exc_type:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Error!&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Exit!&quot;</span>)</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Query info about %s...&#x27;</span> % self.name)</span><br></pre></td></tr></table></figure><p>现在我们就可以使用<code>with</code>关键字来进行自动的上下文管理了.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> QUery(<span class="string">&#x27;name&#x27;</span>) <span class="keyword">as</span> q:</span><br><span class="line">  q.query()</span><br><span class="line"><span class="comment"># print(q)</span></span><br></pre></td></tr></table></figure><p>这样写仍然有一点麻烦, 好在Python提供了装饰器使得代码得到了简化.</p><p>可以这样写: ( 从标准库contextlib中导入contextmanager )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Query</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">    self.name = name</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Query info about %s&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_query</span>(<span class="params">name</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Begin&quot;</span>)</span><br><span class="line">  q = Query(name)</span><br><span class="line">  <span class="keyword">yield</span> q</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;End&quot;</span>)</span><br></pre></td></tr></table></figure><p>这样再调用, <code>create_query</code>函数就会返回一个<code>_GeneratorContextManager</code>对象, 而这个对象就是我们使用<code>with</code>后面<code>as</code>出来的东西, 该对象就绑上了之前说的<code>__enter__</code>, <code>__exit__</code>.</p><p>再调用时就像是这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> create_query(<span class="string">&#x27;Justin&#x27;</span>) <span class="keyword">as</span> q:</span><br><span class="line">  q.query()</span><br></pre></td></tr></table></figure><p>简单的说, <code>@contextmanager</code>使得我们通过编写生成器来进行代码的简化.</p><p>另外, 只要你返回的对象具有<code>close</code>方法, 就可以通过另一个装饰器写出更简的代码.</p><p>这个装饰器也就是<code>contextlib</code>下的<code>closing</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from contextlib import closing</span><br><span class="line">from urllib.request import urlopen</span><br><span class="line">with closing(urlopen(&quot;https://yaoxuannn.com&quot;)) as res:</span><br><span class="line">  print(res)</span><br></pre></td></tr></table></figure><p>其实这个装饰器实现起来也是特别容易的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">closing</span>(<span class="params">self</span>):</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">yield</span> self.thing</span><br><span class="line">  <span class="keyword">finally</span>:</span><br><span class="line">    self.thing.close()</span><br></pre></td></tr></table></figure><h3 id="setter和getter的魔法"><a href="#setter和getter的魔法" class="headerlink" title="setter和getter的魔法"></a>setter和getter的魔法</h3><hr><p>在Java中, 我们编写getter和setter函数来对对象实例的属性进行更改和读取.</p><p>而在Python中, 相信你也发现了我们可以直接进行读取和更改, 这往往是不安全的, 比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="string">&#x27;I&#x27;</span>m <span class="keyword">not</span> a number!!<span class="string">&#x27;</span></span><br><span class="line"><span class="string">result = number * 2</span></span><br><span class="line"><span class="string">print(result)</span></span><br><span class="line"><span class="string"># I&#x27;</span>m <span class="keyword">not</span> a number!!I<span class="string">&#x27;m not a number!!</span></span><br></pre></td></tr></table></figure><p>所以,更推荐调用函数, 因为我们可以进行处理.</p><p>Python作为动态语言拥有将属性访问”重定向”到函数的能力的.重点就在于一个装饰器<code>property</code></p><p><strong>使用property的其中一个注意点是:一定不要把public的属性用property装.否则,会无限递归.(因为函数名和变量名相同)</strong></p><blockquote><p>补充: Python中的私有变量.<br>Python中是不存在私有变量的, 只要你想,所谓的私有变量可以随意访问.<br>有两种所谓的私有变量, 一种是一条下划线的<code>_variable</code>, 这个你你几乎可以认定为是public的变量, 但, 作为一种规范, 他可以告诉别人我的这个变量是一个私有变量, 没事就别碰它.<br>另外一种, 是加了两条下划线的变量<code>__variable</code>.<br>这种变量可以认定为是Python的私有变量.因为解释器会自动把<code>_variable</code>变成<code>_ClassName__variable</code>.(这不就是自己骗自己吗!!??).</p></blockquote><p>请看示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self._score = <span class="number">0</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure><p>这样就可以:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = Student()</span><br><span class="line">s.score = <span class="number">90</span></span><br><span class="line">s.score <span class="comment"># 90</span></span><br><span class="line">s.score = <span class="number">9999</span></span><br><span class="line">ValueError: ....</span><br></pre></td></tr></table></figure><p>其实,<code>property</code>还有另一种巧妙的用法:( 还有这种操作.jpg )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 继续上面的Student类的定义:</span></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">  <span class="keyword">return</span> self._age</span><br></pre></td></tr></table></figure><p>好了,我不去定义<code>@age.setter</code>,这样我们的<code>age</code>属性就会变成一个只读属性!</p><h3 id="使类实现比较操作的魔法"><a href="#使类实现比较操作的魔法" class="headerlink" title="使类实现比较操作的魔法"></a>使类实现比较操作的魔法</h3><hr><p>观察下一些常用来比较的对象, 比如说数字和字符串,不难发现他们都会有一些神奇的魔术方法:</p><p>比如:<code>__eq__</code>.<code>__gt__</code>.<code>__lt__</code>.<code>__le__</code>.<code>__ne__</code>.<code>__ge__</code>.</p><p>所以, 如果实现运算符的重载, 实现这些方法就可以了.</p><p>这都没什么, 但有些复杂并且实现的函数略多.</p><p>所以, 可以使用标准库<code>functools</code>中的<code>total_ordering</code>来进行操作的简化.</p><p>只要装饰整个类, 就可以通过只实现两个方法(必须包括<code>等于</code>方法)来完成全部的运算符的重载.</p><p>使用的例子就像是这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> total_ordering</span><br><span class="line"><span class="meta">@total_ordering</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, age</span>):</span><br><span class="line">    self.age = age</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, that</span>):</span><br><span class="line">    <span class="keyword">return</span> self.age == that.age</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, that</span>):</span><br><span class="line">    <span class="keyword">return</span> self.age &lt; that.age</span><br></pre></td></tr></table></figure><h3 id="Python进行类型检查的魔法"><a href="#Python进行类型检查的魔法" class="headerlink" title="Python进行类型检查的魔法"></a>Python进行类型检查的魔法</h3><hr><p>Python是一个弱类型语言, 尽管可以在方法中进行类型检查<code>(isinstance)</code>, 但这样远没有Java的类型检查安全 Java.C.C++的类型检查都是在编译的时候进行 的.而动态语言Python, 他的解释器是不可能实现这种检查的.</p><p>所以为了能够在对变量声明时对变量进行类型声明以及对变量赋值的时候进行类型检查, Python同样提供了一些魔法:(描述符)</p><ul><li><code>__set__</code></li><li><code>__get__</code></li><li><code>__delete__</code></li></ul><p>你也许有这样的疑问, 既然之前都说了可以通过<code>@property</code>装饰器来使得属性的改变和获取都变成我们定义的函数,为什么需要这个东西呢?</p><p><strong>注意:__get__和__set__和property的用法完全不同!</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Attr</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, <span class="built_in">type</span></span>):</span><br><span class="line">    self._name = name</span><br><span class="line">    self._<span class="built_in">type</span> = <span class="built_in">type</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, cls</span>):</span><br><span class="line">    <span class="keyword">return</span> instance.__dict__[self._name]</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, self._<span class="built_in">type</span>):</span><br><span class="line">      <span class="keyword">raise</span> TypeError(<span class="string">&#x27;expected an %s &#x27;</span> % self._<span class="built_in">type</span>)</span><br><span class="line">    instance.__dict__[self._name] = value</span><br></pre></td></tr></table></figure><p>这样得到一个用来进行类型规范的辅助类.</p><p>通过创建这个辅助类的实例来当做用作真正要用到的类的属性, 这样方法才可以得到调用.</p><p>就像是这样:</p><pre><code class="python">class Student(object):  name = Attr(&quot;name&quot;, str)  age = Attr(&#39;age&#39;, int)s1 = Student()s1.name = &quot;J&quot;s1.age = 5# 没有问题s1.name = 7# TypeError: expected an &lt;class &#39;str&#39;&gt;s1.age = &quot;5&quot;# TypeError: expected an &lt;class &#39;int&#39;&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bash基础</title>
      <link href="/2017/05/01/Shell%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/05/01/Shell%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>学习Shell脚本第一步!</p><span id="more"></span><p>Linux下使用的Shell标准Shell是bash, 这是BShelll家族的一员, BSD.Unix下的标准SHell是CShell.</p><p>BShell(Bourne Shell)主要包括sh.ksh.Bash.psh.zsh, Cshell主要包括csh, tcsh.</p><h2 id="Bash的基础功能"><a href="#Bash的基础功能" class="headerlink" title="Bash的基础功能"></a>Bash的基础功能</h2><h3 id="命令别名和快捷键"><a href="#命令别名和快捷键" class="headerlink" title="命令别名和快捷键"></a>命令别名和快捷键</h3><p>在Shell中使用alias可以看到当前的别名, 有些命令敲起来很长, 很不方便, 所以就建立一个映射.</p><p>一个最典型的例子就是: ll &#x3D; <code>ll -l --color=auto</code>. </p><p>临时更改SHell别名可以直接在alias中设置, <code>alias sth.=&#39;another th&#39;</code>.</p><p>这样的设置在重启机器后就会失效, 如果想要永久设置就在.bashrc下.</p><p>编辑后,该文件不会立即生效.这里使用<code>source</code>来使得系统重新载入.</p><p>接下来我来说一下Liuux中命令的生效顺序:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一顺位: 执行用绝对路径或相对路径执行的命令</span><br><span class="line">第二顺位: 执行别名</span><br><span class="line">第三顺位: 执行Bash的内部命令</span><br><span class="line">第四顺位: 执行按照<span class="variable">$PATH</span>的环境变量定的目录查找顺序找到的第一个命令</span><br></pre></td></tr></table></figure><p>下面说一些超常用的快捷键:</p><blockquote><p>Ctrl + c terminate current order.<br>Ctrl + l clear screen<br>Ctrl + a move cursor to the head of the line<br>Ctrl + e move cursor to the end of the line<br>Ctrl + u delete from the head of the line to the current position of the cursor</p></blockquote><p>另外补充一个: 使用 ALT+. 可以复制上一条命令的最后一个单词, 这里说的单词是指命令的<strong>词</strong>. ( 使用远程连接的话, 需要使用Esc来代替ALT, 或者可以想个办法做mapping.</p><h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h3><p>Bash是可以查看历史命令的, 在早期的BShell是没有历史命令功能的.</p><p>查看历史使用<code>history</code>命令, 和这个关联的文件时<code>.bash_history</code>, 我们知道使用history加上<code>-c</code>参数可以清空历史命令.</p><p>事实上, 历史仍然保存在文件中, <code>-c</code>仅仅是清空Buffer中的命令, 而如果想要彻底删个干净就要在<code>-c</code>之后再加上<code>-w</code>执行一遍.<code>-w</code>的意思是将缓存的历史命令写入到文件中(覆盖).,</p><p>在我们每次注销的时候, 系统会自动执行<code>-w</code>.</p><p>另外, 历史命令还有这样的使用方法.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!! 重复执行上一条命令</span><br><span class="line">!字符串 执行最后一条以该字符串开头的命令</span><br></pre></td></tr></table></figure><p>在Shell中使用Tab键进行命令补全, 这是一个很重要的功能, 它不仅大大加速我们的命令输入, 而且还有一定的查错能力.</p><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>首先要明确的是三个标准输入输出: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">键盘 /dev/stdin     0  标准输入</span><br><span class="line"></span><br><span class="line">显示器 /dev/stdout  1  标准输出</span><br><span class="line"></span><br><span class="line">  /dev/stderr   2  标准错误输出</span><br></pre></td></tr></table></figure><p>命令的输出默认当然就是显示屏幕上, 也就是标准输出1.</p><p>但是Bash是可以重定向输出流的,像这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig &gt; test.log</span><br></pre></td></tr></table></figure><p>命令输出 &gt; &#x2F; &gt;&gt; 仅能保存正确的输出, 如果遇到错误的情况还是会输出到屏幕上, 这就是因为标准错误输出和标准输出是两个东西.</p><p>参见下表:</p><table><thead><tr><th align="center">类型</th><th align="center">符号</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">标准输出重定向</td><td align="center">Command &gt; file</td><td align="center">覆盖方式</td></tr><tr><td align="center">标准输出重定向</td><td align="center">Command &gt;&gt; file</td><td align="center">追加方式</td></tr><tr><td align="center">标准错误输出重定向</td><td align="center">COOMAND 2&gt;file</td><td align="center">覆盖方式</td></tr><tr><td align="center">标准错误输出重定向</td><td align="center">COOMAND 2&gt;&gt;file</td><td align="center">追加方式</td></tr></tbody></table><p><strong>注意:标准错误输出重定向的时候,&gt;&gt;和文件之间是没有空格的!一旦出现空格,重定向就会失效</strong></p><p>但是,仔细想一下<code>2&gt;/2&gt;&gt;</code>这种我们根本就不会使用到, 因为如果已经知道命令是错的, 为什么我还要执行呢?</p><p>所以下表更有参考价值:</p><table><thead><tr><th align="center">类型</th><th align="center">符号</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">标准错误输出和正确输出重定向</td><td align="center">命令 &gt; 文件 2&gt;&amp;1</td><td align="center">覆盖方式</td></tr><tr><td align="center">标准错误输出和正确输出重定向</td><td align="center">命令 &gt;&gt;文件 2&gt;&amp;1</td><td align="center">追加方式</td></tr><tr><td align="center">标准错误输出和正确输出重定向</td><td align="center">命令 &amp;&gt;文件</td><td align="center">覆盖方式</td></tr><tr><td align="center">标准错误输出和正确输出重定向</td><td align="center">命令 &amp;&gt;&gt;文件</td><td align="center">追加方式</td></tr><tr><td align="center">标准错误输出和正确输出重定向</td><td align="center">命令&gt;&gt;文件1 2&gt;&gt;文件2</td><td align="center">追加方式</td></tr></tbody></table><p>其中,13和24等价.</p><p>另外, 如果不想将输出输出到文件中, 可以重定向到”黑洞”中, 也就是<code>/dev/null</code>, 这个文件就像是路由黑洞一样吃进去就没反应了, 或者类比成Windows下的回收站.</p><p>这个文件就是可以理解成Linux预置的垃圾桶, 在一些命令&#x2F;脚本执行过程中发生的一些无关紧要的错误, 我没有必要将其显示出来. 而是可以直接丢弃掉.</p><p>关于输入重定向, 我们以<code>wc</code>来举个例子, <code>wc</code>可以统计输入流中的字节数, 单词数, 行数.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span>&lt;anaconda-ks.cfg </span><br><span class="line"><span class="comment"># 148  228 2523</span></span><br><span class="line"><span class="built_in">wc</span>&lt;anaconda-ks.cfg  -l</span><br><span class="line"><span class="comment"># 148</span></span><br><span class="line"><span class="built_in">wc</span>&lt;anaconda-ks.cfg  -w</span><br><span class="line"><span class="comment"># 228</span></span><br><span class="line"><span class="built_in">wc</span>&lt;anaconda-ks.cfg  -c</span><br><span class="line"><span class="comment"># 2523</span></span><br></pre></td></tr></table></figure><p>这个意思是<code>anaconda-ks.cfg</code>文件中, 有148行, 228个单词, 2523个字节.</p><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>首先来说一下多命令执行符这个东西.</p><p>同高级语言一样, Shell的对多命令顺序执行的执行符和一些逻辑关联词是一样的.</p><table><thead><tr><th align="center">多命令执行符</th><th align="center">格式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">;</td><td align="center">1;2</td><td align="center">顺序执行, 没有逻辑联系</td></tr><tr><td align="center">&amp;&amp;</td><td align="center">1&amp;&amp;2</td><td align="center">逻辑与, 只有1正确执行, 2才会执行</td></tr><tr><td align="center">&amp;Iota;&amp;Iota;</td><td align="center">1 &amp;Iota;&amp;Iota; 2</td><td align="center">逻辑或, 只有1执行不正确, 2才会执行</td></tr></tbody></table><p>一个简单的综合使用就像是这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./abash.sh &amp;&amp; <span class="built_in">echo</span> <span class="built_in">yes</span> || <span class="built_in">echo</span> no</span><br></pre></td></tr></table></figure><p>接下来看一下管道符:</p><p><code>|</code>.</p><p>简单的一个竖杠, 可以将命令1的正确输出作为命令2的操作对象.</p><p>来看一个简单的小栗子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | grep ESTABLISHED | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><p>这个命令组合显示当前已建立的连接数.</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>最后来看一下通配符.</p><table><thead><tr><th align="center">通配符</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">?</td><td align="center">匹配一个任意字符</td></tr><tr><td align="center">*</td><td align="center">匹配0个或任意, 可以匹配任意内容</td></tr><tr><td align="center">[]</td><td align="center">匹配中括号内的任意一个字符</td></tr><tr><td align="center">[-]</td><td align="center">匹配中括号内任意一个字符, -表示一个范围</td></tr><tr><td align="center">[^]</td><td align="center">逻辑非, 匹配不是中括号内的一个字符</td></tr></tbody></table><p>接着再来说一下Bash中的特殊字符:</p><table><thead><tr><th align="center">符号</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">‘’</td><td align="center">在单引号中的特殊符号都失去意义</td></tr><tr><td align="center">“”</td><td align="center">除了”$”, “&#96;”, “&quot;, 其他都失去特殊含义</td></tr><tr><td align="center">&#96;&#96;</td><td align="center">调用系统命令, Bash中会优先执行</td></tr><tr><td align="center">$()</td><td align="center">等价于&#96;&#96;,引用系统命令</td></tr><tr><td align="center">#</td><td align="center">注释</td></tr><tr><td align="center">$</td><td align="center">调用变量的值</td></tr><tr><td align="center">\</td><td align="center">转义字符</td></tr></tbody></table><p>其中, 推荐使用 $() 来代替 &#96;, 因为更清晰.</p><hr><p>在开始进行Shell编程前, 必须还要了解一些环境变量,位置参数变量以及预定义变量.</p><p>我们已经知道如何去定义一个变量: <code>a=4</code>.</p><p>但是这样定义的变量是不能在Shell间通用的,现在就可以引入环境变量的概念了.</p><p>环境变量是作用于系统的一类变量, 只要在声明时加上<code>export</code>关键字就可以生效了.</p><p>使用<code>set</code>查看所有的系统变量, 使用<code>env</code>仅仅查看环境变量.</p><p>接下来说一下位置参数变量, 其实这个就像是<code>Python</code>的<code>sys.argv</code>, 获取脚本参数的变量.</p><p>有这些位置参数:</p><table><thead><tr><th align="center">参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">$n</td><td align="center">n是数字, 0代表本身, 1-?就是后面的参数</td></tr><tr><td align="center">$*</td><td align="center">命令行中的所有参数(作为整体)</td></tr><tr><td align="center">$@</td><td align="center">命令行中的所有参数(作为单独的部分)</td></tr><tr><td align="center">$#</td><td align="center">参数的个数(不包括脚本本身)</td></tr></tbody></table><p>最后, 就是一些预定义变量了.</p><p>主要有三个:</p><table><thead><tr><th align="center">参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">$?</td><td align="center">返回上次命令执行的状态</td></tr><tr><td align="center">$$</td><td align="center">当前进程的PID</td></tr><tr><td align="center">$!</td><td align="center">后台运行的最后一个进程的PID</td></tr></tbody></table><p>接下来开始进行Shell的学习吧!</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><hr><p>之前说过了如何去声明和打印一个变量, 但要知道的是, Linux中的所有变量默认都是字符串型的.</p><p>也就是说:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># a=11</span></span><br><span class="line">[root@localhost ~]<span class="comment"># b=22</span></span><br><span class="line">[root@localhost ~]<span class="comment"># c=$a+$b</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $c</span></span><br><span class="line">11+22</span><br></pre></td></tr></table></figure><p>这样就没办法进行数值运算了.所以先来学习一下怎么声明种类.</p><p>使用declare来声明变量类型,语法结构和支持的类型是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> [+/-][Opt.] 变量名</span><br><span class="line">- : 设定</span><br><span class="line">+ : 取消</span><br><span class="line">-a : (array)数组型</span><br><span class="line">-i : (interger)整数</span><br><span class="line">-x : (<span class="built_in">env</span>)环境变量</span><br><span class="line">-r : (read-only)只读变量</span><br><span class="line">-p : (<span class="built_in">print</span>)打印变量声明的类型</span><br></pre></td></tr></table></figure><p>举几个例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># aa=11 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># bb=22</span></span><br><span class="line">[root@localhost ~]<span class="comment"># declare -i cc=$aa+$bb</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $cc</span></span><br><span class="line">33</span><br></pre></td></tr></table></figure><p>或者声明数组变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># movie[0]=a</span></span><br><span class="line">[root@localhost ~]<span class="comment"># movie[1]=b</span></span><br><span class="line">[root@localhost ~]<span class="comment"># declare -a movie[2]=c</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $&#123;movie&#125;</span></span><br><span class="line">a</span><br><span class="line">[root@localhost ~]<span class="comment"># echo $&#123;movie[1]&#125;</span></span><br><span class="line">b</span><br><span class="line">[root@localhost ~]<span class="comment"># echo $&#123;movie[*]&#125;</span></span><br><span class="line">a b c</span><br></pre></td></tr></table></figure><p>现在可以告诉你啦!</p><p>之前使用的<code>export</code>实际上调用的就是<code>declare</code>的<code>-x</code>选项, 不信的话你可以试试<code>declare -p</code>, 接着你就会看到大部分的系统环境变量都是<code>declare -x</code>.</p><p>最后再看一下,只读属性<code>(-r)</code>, 请注意:<strong>不要随意添加只读属性, 因为只读的属性是不可删除 不可改变 不可取消的</strong>.</p><p>现在就来学习数值运算了.</p><p>虽然之前说的声明类型同样可以进行数值运算, 但是这还是有点麻烦的.</p><p>所以当进行表达式(expression)运算时, 使用<code>expr</code>来进行运算.</p><p>e.g:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># aa=11</span></span><br><span class="line">[root@localhost ~]<span class="comment"># bb=22</span></span><br><span class="line">[root@localhost ~]<span class="comment"># dd=$(expr $aa + $bb)</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $dd</span></span><br><span class="line">33</span><br></pre></td></tr></table></figure><p><strong>注意!expr后面的运算符两侧必须要加空格否则会失效</strong></p><p>这就很好敲了? 相信你一定满脸MMP..</p><p>是的..这个命令更难敲.</p><p>所以来看一下这个:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># aa=22 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># bb=11</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ff=$(( $aa+$bb ))</span></span><br><span class="line">[root@localhost ~]<span class="comment"># # 或者</span></span><br><span class="line">[root@localhost ~]<span class="comment"># gg=$[$aa+$bb]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $ff</span></span><br><span class="line">33</span><br><span class="line">[root@localhost ~]<span class="comment"># echo $gg</span></span><br><span class="line">33</span><br></pre></td></tr></table></figure><p>这样就更好记了.</p><p>那么Shell支持哪些运算呢?</p><p>按照优先级从高到低:</p><table><thead><tr><th align="center">运算符</th></tr></thead><tbody><tr><td align="center">单目正负</td></tr><tr><td align="center">逻辑非.按位反</td></tr><tr><td align="center">乘除 取模</td></tr><tr><td align="center">加减</td></tr><tr><td align="center">左移 右移</td></tr><tr><td align="center">比较运算</td></tr><tr><td align="center">按位运算</td></tr><tr><td align="center">逻辑运算</td></tr><tr><td align="center">赋值及运算赋值符</td></tr></tbody></table><p>继续下去..我们来看一下变量测试</p><p>这个东西只有Shell中才有, 其他语言中是没有的.</p><p>好吧..这个东西主要是用来脚本调优.(真的我觉得没什么用)</p><p>下一个表来看,其实语法上没什么难的..</p><p>好了变量测试就先这样吧..</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Crontab学习日志</title>
      <link href="/2017/04/27/Crontab%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2017/04/27/Crontab%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>Crontab是Linux下一个强大的计划任务工具.</p><span id="more"></span><p>基本上Linux发行版上都会默认安装的工具.</p><h2 id="检测安装"><a href="#检测安装" class="headerlink" title="检测安装"></a>检测安装</h2><p>可以通过使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">service crond status</span><br></pre></td></tr></table></figure><p>来检测是否安装.</p><p>如果没有,你可以先好好凝视一下你的服务器或者虚拟机,也许它是假的:). </p><p>接着使用<code>yum install crontabs</code>(Cent OS)进行安装.</p><p><strong>7.7的更新:</strong> 在新版的CentOS6|7上crontab使用了新的程序包. 可以使用rpm进行查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@WWW ~]$ rpm -q cronie</span><br><span class="line">cronie-1.4.11-14.el7_2.1.x86_64</span><br></pre></td></tr></table></figure><p>另外还可以看到有一个叫<code>cronie-anacron-1.4.11-14.el7_2.1.x86_64</code>的程序包.</p><p>这个<code>anacron</code>是什么呢?</p><p>这里我们把整个周期性任务计划相关的程序包来进行一下小结:</p><ul><li><code>cronie</code>: 主程序包, 提供了<code>crond</code>守护进程和相关的辅助工具.</li><li><code>cronie-anacron</code>: <code>cronie</code>的补充程序, 用于监控<code>cronie</code>任务执行情况, 比如当指定时间执行的任务未能正常运行, 则<code>anacron</code>会再随后进行任务的启动</li><li><code>crontabs</code>: 包含CentOS提供的系统维护的任务</li></ul><p>因此要确保<code>crontab</code>正常运行, 就要先保证<code>crond</code>正常在运行.</p><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>先来感受一下定时任务的便利吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>进入编辑界面,在最后添加一行之后, 保存退出.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * <span class="built_in">date</span> &gt;&gt; /tmp/date.log</span><br></pre></td></tr></table></figure><p>接着你可以使用<code>tail -f /tmp/date.log</code>, 这时候就会发现每分钟这个文件就会得到更新 显示当期的时间</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>crontab 的核心在于crond这个进程, 这个系统服务每分钟都会从配置文件中刷新任务.</p><p>有时间到了后crond就会启动这个任务.</p><p>而crontab这个就是用户操作,用来调整定时任务的工具了, 最后, 配置文件负责以文件的形式设置定时任务.</p><p>用户的<code>cron</code>: 每个用户都有一个专门的<code>cron</code>任务文件: <code>/var/spool/cron/USERNAME</code> </p><p><code>crontab</code>的使用方法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u | user] [-l | -r | -e] [-i]</span><br><span class="line">-l: 列出所有任务</span><br><span class="line">-e: 编辑任务</span><br><span class="line">-r: 移除所有任务</span><br><span class="line">-i: 同-r一起使用, 使用交互式模式让用户有选择的进行移除.(和大部分的交互效果一样)</span><br></pre></td></tr></table></figure><p> 在cron任务中, <code>%</code>是有特殊的意义 所以是要进行转义的. 另外在<code>cron</code>中, 如果想要获得秒级的运行就要使用这样的形式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * <span class="keyword">for</span> min <span class="keyword">in</span> 0 1 2; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">&quot;exec.&quot;</span>; <span class="built_in">sleep</span> 20; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>其实这里使用到的<code>sleep</code>指令不仅仅是执行秒的睡眠, 还可以进行分钟和小时, 甚至天的. 只要加上单位就行</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>作为我们修改的对象,只有知道怎么书写任务,才可以更好的使用, 接下来就来看一下Crontab的配置文件的组成.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* * * * * [user-name] COMMAND</span><br><span class="line">| | | | |__星期0~7(0/7均表示周日)</span><br><span class="line">| | | |____月份1~12</span><br><span class="line">| | |______日期1~31</span><br><span class="line">| |________小时0~23</span><br><span class="line">|__________分钟0~59</span><br></pre></td></tr></table></figure><p>为更好地理解这些参数,请看下面的一些实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每天晚上21:30重启服务器</span></span><br><span class="line">30 21 * * * service httpd restart</span><br><span class="line"><span class="comment"># 每月1, 10, 22日的21:30重启服务器 </span></span><br><span class="line">30 21 1,10,22 * * service httpd restart</span><br><span class="line"><span class="comment"># 每月1到10日4:45重启Apache</span></span><br><span class="line">45 4 1-10 * * service httpd restart</span><br><span class="line"><span class="comment"># 每隔2分钟打印一个日志</span></span><br><span class="line">*/2 * * * * <span class="built_in">tail</span> -n 5 /var/log/pptpd.log</span><br><span class="line"><span class="comment"># 每奇数分钟打印一个日志</span></span><br><span class="line">1-59/2 * * * * <span class="built_in">tail</span> -n 5 /var/log/pptpd.log</span><br><span class="line"><span class="comment"># 每天晚11:00到第二天早上7点, 每隔一小时重启Apache</span></span><br><span class="line">0 23-7/1 * * * service httpd restart</span><br></pre></td></tr></table></figure><p>简单的小结一下:</p><blockquote><p>* 表示任何时候都匹配(Universal 通配符 &#x2F;摊手)<br>可以用”A,B,C”表示 A || B || C<br>使用”A-B”表示 range(A,B)<br>用”*&#x2F;A”表示每A分钟(小时..等)执行一次</p></blockquote><p>每一条任务都是有用户依托的,因此在跟踪运行时会发现类似这样的记录:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Apr 27 00:47:01 localhost CROND[21437]: (root) CMD (/usr/local/sa/agent/secu-tcs-agent-mon-safe.sh /usr/local/sa/agent &gt; /dev/null 2&gt;&amp;1)</span><br><span class="line">Apr 27 00:48:01 localhost crond[619]: (*system*) RELOAD (/etc/cron.d/sysstat)</span><br><span class="line">Apr 27 00:48:01 localhost crond[619]: (tester) ORPHAN (no passwd entry)</span><br><span class="line">Apr 27 00:48:01 localhost CROND[21556]: (root) CMD (/usr/local/sa/agent/secu-tcs-agent-mon-safe.sh /usr/local/sa/agent &gt; /dev/null 2&gt;&amp;1)</span><br><span class="line">Apr 27 00:48:01 localhost CROND[21557]: (root) CMD (/usr/local/qcloud/stargate/admin/start.sh &gt; /dev/null 2&gt;&amp;1 &amp;)</span><br></pre></td></tr></table></figure><p>可以看到有tester.root的任务在执行.</p><h2 id="Crontab的常见异常和错误"><a href="#Crontab的常见异常和错误" class="headerlink" title="Crontab的常见异常和错误"></a>Crontab的常见异常和错误</h2><p>Crontab的常见错误有以下几点:</p><ul><li>环境变量</li><li>CLI双引号中使用%时, 未加反斜线 \</li><li>第三和第五个域之间执行的是或操作</li><li>分钟设置误用</li></ul><p>一个一个来说明一下.</p><p>首先,我们来做个小实验,在当前用户的.bash_profile内加上下面的内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">APPDIR=/etc</span><br><span class="line"><span class="built_in">export</span> APPDIR</span><br></pre></td></tr></table></figure><p>接着使用<code>source .bash_profile</code> 使得立即生效,在CLI下试试<code>echo $APPDIR</code>,会输出<code>/etc</code>说明没有问题.</p><p>但是当我们在crontab中加上这样的定时任务后<code>*/1 * * * * echo $APPDIR&gt;/tmp/appdir.log</code>.</p><p>会发现这个文件中只有空行,并没有获得<code>$APPDIR</code>这个环境变量值.</p><p>所以,在进行任务设置时要小心这个不能识别的问题.</p><hr><p>对于第二和第三个,一起看一下:</p><p>首先回顾一下之前的参数说明第三和第五个他们是有关系的(星期和日),所以这里他们在实际运行时是采取的<strong>或</strong>的操作,<del>(这个先存疑,使用在线工具测试是正常的,但教学来源表明这是或的操作)</del>已解决,采取的或操作.</p><p>即:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">59 1 1-7 4 0 /root/a.sh</span><br></pre></td></tr></table></figure><p>这个任务表示什么?</p><p>如果你觉得是四月的第一个星期日的1:59分执行bash脚本,那就错了.</p><p>他执行的次数远比原来多.这是因为他会在每月的1-7日以及周日执行,大约会执行11次.</p><p>所以,应该这么写:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">59 1 1-7 4 * <span class="built_in">test</span> `<span class="built_in">date</span> -\%w -eq 0 &amp;&amp; /root/a.sh`</span><br></pre></td></tr></table></figure><p>这样经过验证的结果就是正确的.</p><p>另外,在这个任务中我们使用了反斜线<code>\</code>,在CLI下这个操作是不需要的,但在计划任务里是需要的</p><hr><p>分钟数设置时的易错点: 如果想要执行每两小时的任务,也许你会这么写:<code>* 0,2,4,6,8,10,12,14,16,18,20,22 * * *  COMMAND</code>,但事实上,这样是错误的,因为他意味这在这些时的每分钟都会执行一次.</p><p>正确的方式应该要把分钟数<strong>设置成0</strong>,也就是这个样子的:<code>0 */2 * * * COMMAND</code>.</p><p>如果想让Crontab执行秒级的任务,就要借助Shell的sleep方法, 也就是像这样: <code>date &amp;&amp; sleep 0.5s &amp;&amp; date</code>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Crontab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python小技巧_2</title>
      <link href="/2017/04/26/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-2/"/>
      <url>/2017/04/26/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-2/</url>
      
        <content type="html"><![CDATA[<p>Python编程技巧.[环境:Python3.6.0]</p><span id="more"></span><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><p>字符串最主要的处理之一就是分割.</p><p>最基础简单的分割方式就是使用<code>split</code>函数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.split(<span class="string">&quot;l&quot;</span>)</span><br><span class="line"><span class="comment"># [&quot;He&quot;, &quot;&quot;, &quot;o&quot;]</span></span><br></pre></td></tr></table></figure><p>哎?出现了一个空字符串!, 这并不是我们想要的, 再讲如何消去它之前, 我们先来说一下为什么会产生.</p><p>可以做做这样的小实验:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;aaaa&quot;</span>.split(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment"># [&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;]</span></span><br></pre></td></tr></table></figure><p>产生了五个空字符串, 然而我们只传了四个呀. 那么就开始猜测, 会不会是两个字符串的叠加效果呢?(此时可以试试<code>&quot;a&quot;.split(&quot;a&quot;)</code>)</p><p>所以说, 这个情况是在寻找符合条件的字符串的两边时,发现要么没有了, 要么还是原来的条件.</p><p>现在提供一个可以快速消去空字符串的方法,不仅仅在这里适用,只要是为了剔除空数据, 都是可以的!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;Only&quot;</span>,<span class="string">&quot;&quot;</span>] <span class="keyword">if</span> x]</span><br><span class="line"><span class="comment"># [&quot;Only&quot;]</span></span><br></pre></td></tr></table></figure><p>这种基本方法还是有一点的笨拙的, 如果遇到字符串中含有多个split点时, 就懵逼了.</p><p>所以,还是要请出主角–<strong>正则表达式re模块</strong></p><blockquote><p>当你遇到了一个问题的时候, 为了解决它, 你想到了使用正则表达式, 这时, 你就有了两个问题. :)</p></blockquote><p>正则模块需要引入.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> re.split(<span class="string">&quot;[,./|]&quot;</span>, <span class="string">&quot;Hel.lo,W|or/ld!&quot;</span>):</span><br><span class="line">    text += n</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line"><span class="comment"># HelloWorld!</span></span><br></pre></td></tr></table></figure><p>小结一下:当字符串不是很复杂的时候,仍然建议使用默认的字符串的<code>split</code>函数, 因为他更快速.如果遇到较为棘手的切割, 最好使用正则的切割.</p><p>想象这么一种场景: 你需要获得文件的后缀名&#x2F;你想知道你个网址使用的协议是什么.</p><p>抽象出来就是判断字符串的开头或者结尾.</p><p>就如同方法名一样简单, 两个方法分别用来检测头和尾. <code>startswith</code>和<code>endswith</code>.</p><p>举个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, stat</span><br><span class="line">os.listdir(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="comment"># [&#x27;e.py&#x27;, &#x27;c.java&#x27;, &#x27;d.cpp&#x27;, &#x27;b.sh&#x27;, &#x27;f.sh&#x27;, &#x27;a.py&#x27;, &#x27;g.js&#x27;] 事先写好了有一些测试用数据</span></span><br><span class="line"><span class="comment"># 接下来使用列表解析找出所有的py和sh</span></span><br><span class="line">[ file <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">if</span> file.endswith((<span class="string">&#x27;.py&#x27;</span>, <span class="string">&#x27;.sh&#x27;</span>)) ]</span><br><span class="line"><span class="comment"># [&#x27;e.py&#x27;, &#x27;b.sh&#x27;, &#x27;f.sh&#x27;, &#x27;a.py&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>方法内可以传入元组进行多适配, 但一定不接受列表.</strong></p><p>接下来就可以使用这样的方法找到一堆数据中所有的<code>ftp://</code>的服务器地址.(略 :) )</p><p>下面说一个超实用的正则魔法!</p><p><code>re.sub</code>可以进行替换, 如果继续利用正则的捕获组就能进行格式的变换,(比如把<code>04/05/2017</code>变成<code>2017-05-04</code>).</p><p><code>sub</code>接受三个参数, 分别是<code>[&#39;正则表达式&#39;, &#39;替换后的字符串&#39;, &#39;需要替换的字符串&#39;]</code>.</p><p>接下来再说一下什么是正则中的捕获组.</p><p>捕获组简单的说就是一个小整体,还是用实例来说明下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">log = <span class="built_in">open</span>(<span class="string">&quot;/var/log/nginx/access.log&quot;</span>, <span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(re.sub(<span class="string">r&#x27;(\d&#123;2&#125;)/([a-zA-Z]&#123;3&#125;)/(\d&#123;4&#125;)&#x27;</span>, <span class="string">r&#x27;\3-\2-\1&#x27;</span>, log))</span><br></pre></td></tr></table></figure><p>一个一个来说明, <code>access.log</code>的文件类似</p><p><code>5?.6?.2?.?1? - - [03/May/2017:23:19:25 +0800] &quot;GET /??/ HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36&quot;</code></p><p>这个实例是将所有的时间改为<code>2017-May-03</code>的形式.</p><p>接着来看一下捕获组, 就是那个用括号抱起来的东西. 被抱起来的从0开始计数, 在后面使用反斜线加上组号就可以进行引用.</p><p>另外, 正则的捕获组可以添加名字的, 像这样使用: <code>?P&lt;名字&gt;</code>, 引用时这样: <code>\g&lt;名字&gt;</code>.</p><p>将上面的例子进行一下更改就变成这样: <code>re.sub(r&#39;(?P&lt;day&gt;\d&#123;2&#125;)/(?P&lt;month&gt;[a-zA-Z]&#123;3&#125;)/(?P&lt;year&gt;\d&#123;4&#125;)&#39;, r&#39;\g&lt;day&gt;-\g&lt;month&gt;-\g&lt;year&gt;&#39;, log)</code>.</p><p>说完了分割, 接下来再来看另一个重要的操作–拼接.</p><p>传统的拼接方法上面也展示过了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">&quot;Hel&quot;</span>, <span class="string">&quot;lo,&quot;</span>, <span class="string">&quot;Worl&quot;</span>, <span class="string">&quot;d&quot;</span>]</span><br><span class="line">greeting = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> part <span class="keyword">in</span> l:</span><br><span class="line">  greeting += part</span><br><span class="line"><span class="built_in">print</span>(greeting)</span><br><span class="line"><span class="comment"># Hello,World</span></span><br></pre></td></tr></table></figure><p>这样拼接还是有一点麻烦的, 更好地方法是使用<code>str.join</code>方法.</p><p>这个方法接受一个可迭代对象作为参数, 调用者(self)就是分割符, 比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;,&quot;</span>.join([<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>])</span><br><span class="line"><span class="comment"># Hello,world</span></span><br></pre></td></tr></table></figure><p>但是,我们遗漏了一种情况, 如果传入的可迭代对象包含多个类型的数据怎么办呢?</p><p>先试一试吧:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.join([<span class="string">&#x27;123&#x27;</span>, <span class="number">456</span>, <span class="string">&#x27;789&#x27;</span>])</span><br></pre></td></tr></table></figure><p>呀!报错了! 看样子还是要处理这个问题的.</p><p>一种解决方法是使用列表解析:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">example = [<span class="string">&#x27;123&#x27;</span>, <span class="number">456</span>, <span class="string">&#x27;789&#x27;</span>]</span><br><span class="line"><span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> example])</span><br></pre></td></tr></table></figure><p>这样虽然可以处理, 但如果数据很大的话, 会占用很多资源.</p><p>所以, 使用<code>Generator</code>是更优的选择.</p><p>因为他的开销更小.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">example = [<span class="string">&#x27;123&#x27;</span>, <span class="number">456</span>, <span class="string">&#x27;789&#x27;</span>]</span><br><span class="line"><span class="string">&quot;&quot;</span>.join((<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> example))</span><br></pre></td></tr></table></figure><p>接着再来说说文本的排版.</p><p>我们经常遇到的一种情况是, 对一个字典进行输出.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;:&#x27;J&#x27;,</span><br><span class="line">&quot;age&quot;:22,</span><br><span class="line">&quot;sex&quot;:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们期望的输出是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name :  &#x27;J&#x27;</span><br><span class="line">age  :  22</span><br><span class="line">sex  :  1</span><br></pre></td></tr></table></figure><p>由于键的长度并不一样, 所以直接输出是做不到的.</p><p><code>str</code>有几个方法可以帮助我们达成这个目标.</p><p>准确的说, 这些方法只是填充字符串而已.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">s.ljust(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># &#x27;       abc&#x27;</span></span><br><span class="line">s.ljust(<span class="number">10</span>,<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line"><span class="comment"># &#x27;=======abc&#x27;</span></span><br><span class="line">s.center(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># &#x27;   abc    &#x27;</span></span><br></pre></td></tr></table></figure><p>另外一个类似的方法是使用<code>format</code>函数, <code>format</code>接受一个字符串和格式字符串, 使用起来的效果就像是这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">format</span>(s, <span class="string">&#x27;&gt;10&#x27;</span>)</span><br><span class="line"><span class="comment"># &#x27;       abc&#x27;</span></span><br><span class="line"><span class="built_in">format</span>(s,, <span class="string">&#x27;^10&#x27;</span>)</span><br><span class="line"><span class="comment"># &#x27;   abc    &#x27;</span></span><br></pre></td></tr></table></figure><p>那么现在来完成开头提出的问题, 排版输出键值长度不一致的字典:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kv = &#123;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Python&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;createTime&#x27;</span>:<span class="string">&#x27;2017-04-26&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;mtime&#x27;</span>:<span class="string">&#x27;2017-05-03&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;author&#x27;</span>:<span class="string">&#x27;Justin&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 得到字典</span></span><br><span class="line">m = <span class="built_in">max</span>(<span class="built_in">map</span>(<span class="built_in">len</span>, kv.keys()))</span><br><span class="line"><span class="comment"># 得到键的最大长度</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br><span class="line">  <span class="built_in">print</span>(k.ljust(m), <span class="string">&quot;:&quot;</span>, kv[k])</span><br><span class="line"><span class="comment"># name       : Python</span></span><br><span class="line"><span class="comment"># createTime : 2017-04-26</span></span><br><span class="line"><span class="comment"># mtime      : 2017-05-03</span></span><br><span class="line"><span class="comment"># author     : Justin</span></span><br></pre></td></tr></table></figure><p>除了分割和拼接, 字符串另一个重要的处理就是删除(叫剔除应该更好), </p><p>比如剔除两端的空格, 剔除指定字符,等等..</p><p>str类仍然封装了很多丰富的方法.</p><p>*<strong>strip一类方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;!  ++Hello==  ?&quot;</span></span><br><span class="line">s.strip(<span class="string">&quot;? !&quot;</span>) <span class="comment"># &quot;++Hello==&quot;</span></span><br><span class="line">s.lstrip(<span class="string">&quot;+&quot;</span>) <span class="comment"># &quot;Hello==&quot;</span></span><br><span class="line">s.rstrip(<span class="string">&quot;=&quot;</span>) <span class="comment"># &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><p>*strip不能搞定中间的字符, 我们可以通过切片加拼接的方式完成.</p><p>比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hel:lo&quot;</span></span><br><span class="line">s = s[:<span class="number">3</span>] + s[<span class="number">4</span>:]</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="comment"># Hello</span></span><br></pre></td></tr></table></figure><p>但是切片的方法略显笨重,来看一下字符串的<code>replace</code>方法(别忘了正则的<code>sub</code>方法呀.)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;123\n456\n789&quot;</span></span><br><span class="line">s = s.replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">s</span><br><span class="line"><span class="comment"># &quot;123456789&quot;</span></span><br></pre></td></tr></table></figure><p>但是, 你现在也注意到了, <code>replace</code>方法只能匹配一个字符, 如果遇到多个就不行了.</p><p>比如剔除字符串<code>s = &quot;123.456,789;&quot;</code>中所有的特殊字符.</p><p>这个时候还是需要靠强大的正则了, 也就是之前说的<code>sub</code>函数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sub(<span class="string">&quot;[.,;]&quot;</span>, <span class="string">&quot;&quot;</span>,s)</span><br></pre></td></tr></table></figure><p>就可以了.</p><p>最后再来说一下<code>translate</code>方法, <code>str</code>和<code>re</code>, 他们的作用稍有不同, 我们分开来说.</p><p>首先, <code>translate</code>方法可以实现 伪加密(更换顺序)和剔除指定字符的效果. 一个联动的函数是<code>str.maketrans</code>.</p><p>其中, <code>translate</code>接受一个参数, 一个映射表(需要实现<code>__getitem__</code>接口), 这个映射表一般有<code>str.maketrans</code>产生.</p><p><code>str.maketrans</code>最多接受三个参数, 前两个为映射字符串, 最后一个是将选定的字符串映射成<code>None</code>, 被映射成<code>None</code>的字符串会在<code>translate</code>的过程中被删除.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;123\n456\t789\r&quot;</span></span><br><span class="line">s.translate(<span class="built_in">str</span>.maketrans(<span class="string">&quot;123789&quot;</span>, <span class="string">&quot;789123&quot;</span>,<span class="string">&quot;\n\r\t&quot;</span>))</span><br><span class="line"><span class="comment"># &quot;789456123&quot;</span></span><br></pre></td></tr></table></figure><p>到此, 字符串处理的基本就结束了.</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Python有个特别好用的函数特性, 叫做<strong>装饰器</strong>.</p><p>装饰器可以帮助我们减少大量代码的冗余, 使得函数的利用更加便利.</p><p>一个非常的经典的例子就是这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">  <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">  <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这是一个非常经典的斐波那契数列递归,但如果使用这个函数进行<code>fib(50)</code>的话, 也许你可以先去泡杯咖啡.</p><p>一种优化方案是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n, cache=<span class="literal">None</span></span>):</span><br><span class="line">  <span class="keyword">if</span> cache <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> n <span class="keyword">in</span> cache:</span><br><span class="line">    <span class="keyword">return</span> cache[n]</span><br><span class="line">  cache[n] = fib(n-<span class="number">1</span>, cache) + fib(n-<span class="number">2</span>, cache)</span><br><span class="line">  <span class="keyword">return</span> cache[n]</span><br></pre></td></tr></table></figure><p>在这里,我们建立了一个缓存池(原函数缓慢的原因就是因为大量的重复计算, 计算得到的值都没有得到保存.), 如果能从缓存池中读取, 就不再计算而直接读取.</p><p>对于这个问题,事实上好多递归函数都存在这个问题.</p><p>比如爬楼梯问题:</p><blockquote><p>一个共有10个台阶的楼梯, 从下面走到上面, 一次只能迈1-3的阶梯, 在不能后退的情况下, 走完楼梯一共有多少种方法?</p></blockquote><p>传统的递归解法是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">climb</span>(<span class="params">n, steps</span>):</span><br><span class="line">   <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   count = <span class="number">0</span></span><br><span class="line">   <span class="keyword">if</span> n &gt;<span class="number">0</span>:</span><br><span class="line">     <span class="keyword">for</span> step <span class="keyword">in</span> steps:</span><br><span class="line">       count += climb(n - step, steps)</span><br><span class="line">   <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>计算<code>climb(50, (1,2,3))</code>试试, 你的咖啡已经凉了.</p><p>我们仍然可以考虑加上缓存的方法, 但是那就意味着还要再重新书写一遍近乎是一样的代码.</p><p>这时引入装饰器, <strong>装饰器也是个函数, 接受一个函数, 在他的内部生产一个符合要求的函数(比如生成缓存池, 记录日志等等), 再调用参数(也就是传进来的函数), 接着将这个包装的函数返回出去.就成为了一个满足要求的函数.</strong></p><p>本来的过程是这样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func = wraaper(func)</span><br></pre></td></tr></table></figure><p>这样有点麻烦, 所以Python提供了这样的语法糖:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@wraaper</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>为上述递归问题写一个装饰器就像是这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">caching</span>(<span class="params">func</span>):</span><br><span class="line">  cache = &#123;&#125;</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">wrap</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">if</span> args <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">      cache[args] = func(*args)</span><br><span class="line">    <span class="keyword">return</span> cache</span><br><span class="line">  <span class="keyword">return</span> wrap</span><br></pre></td></tr></table></figure><p>这样再调用<code>fib</code>和<code>climb</code>, 就可秒出结果.</p><p>再比如说一个很常用的功能, 我想知道我的函数执行了多长时间.我就可以也写个装饰器:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">record</span>(<span class="params">func</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">wrap</span>(<span class="params">*args</span>):</span><br><span class="line">    start = time.time()</span><br><span class="line">    func(*args)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(end-start)</span><br><span class="line">  <span class="keyword">return</span> wrap</span><br></pre></td></tr></table></figure><p>但是这个装饰器不是太实用, 我们可以添加让他在超过一定时间就记录日志的功能.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, logging, random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">record</span>(<span class="params">func</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args</span>):</span><br><span class="line">    start = time.time()</span><br><span class="line">    res = func(*args)</span><br><span class="line">    used = time.time() - start</span><br><span class="line">    <span class="keyword">if</span> used &gt; <span class="number">2.0</span>:</span><br><span class="line">      logging.warn(<span class="string">&quot;%s : %s &gt; %s&quot;</span> % (func.__name__, <span class="built_in">str</span>(used), <span class="built_in">str</span>(<span class="number">2.0</span>)))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@record</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">  <span class="keyword">if</span> randint(<span class="number">0</span>,<span class="number">1</span>):</span><br><span class="line">    time.sleep(<span class="number">2.5</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">  test()</span><br></pre></td></tr></table></figure><p>接着运行的结果就像是这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Test                                         </span><br><span class="line">Test                                         </span><br><span class="line">WARNING:root:test : <span class="number">2.500215768814087</span> &gt; <span class="number">2.0</span>  </span><br><span class="line">Test                                         </span><br><span class="line">Test                                         </span><br><span class="line">Test                                         </span><br><span class="line">Test                                         </span><br><span class="line">Test                                         </span><br><span class="line">WARNING:root:test : <span class="number">2.501840591430664</span> &gt; <span class="number">2.0</span>  </span><br><span class="line">Test                                         </span><br><span class="line">WARNING:root:test : <span class="number">2.5007271766662598</span> &gt; <span class="number">2.0</span> </span><br><span class="line">Test                                         </span><br><span class="line">Test                                         </span><br><span class="line">WARNING:root:test : <span class="number">2.5005836486816406</span> &gt; <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>但是这个装饰器仍然不够灵活, 他的时间阈值是个固定值,如果是个可调节的值就更好了.</p><p>为了达成装饰器同样可以接受参数, 我们就需要写个三层嵌套的装饰器.</p><p>也就是说: <strong>一个返回装饰器的函数.</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args **kw</span>):</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;%s %s():&quot;</span> % (text, func.__name__))</span><br><span class="line">      res = func(*args, **kw)</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">  <span class="keyword">return</span> wraaper</span><br><span class="line"><span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><p>这就是一个最简单的展示接受参数的装饰器.</p><p>使用中你会发现这样的情况.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@log(&quot;execute&quot;)</span><br><span class="line">def now():</span><br><span class="line">  print(&quot;2017-05-05&quot;)</span><br><span class="line">now()</span><br><span class="line"># execute now():</span><br><span class="line"># 2017-05-05</span><br></pre></td></tr></table></figure><p>看起来很正常是吗.但是如果你试试查看<code>now.__name__</code>的时候就会发现, <code>now</code>已经被<code>wrapper</code>污染了.</p><p>所以返回的是<code>wrapper</code>.这并不是我们所希望的.</p><p><code>Python</code>的<code>functools</code>包内的<code>wraps</code>提供了我们需要的功能.</p><p>由于<code>wraps</code>也是一个装饰器, 所以使用起来也非常方便, 在原基础上加上这样的一行代码即可解决问题 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args **kw</span>):</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;%s %s():&quot;</span> % (text, func.__name__))</span><br><span class="line">      res = func(*args, **kw)</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">  <span class="keyword">return</span> wraaper</span><br><span class="line"><span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python小技巧</title>
      <link href="/2017/04/23/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-1/"/>
      <url>/2017/04/23/Python%E5%B0%8F%E6%8A%80%E5%B7%A7-1/</url>
      
        <content type="html"><![CDATA[<p>Python编程技巧.[环境:Python3.6.0]</p><span id="more"></span><h2 id="Part-1-基本数据结构与collections"><a href="#Part-1-基本数据结构与collections" class="headerlink" title="Part 1 基本数据结构与collections"></a>Part 1 基本数据结构与collections</h2><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>过滤操作是一个很常用的操作,Python作为函数式编程语言,提供了非常好的解析支持.</p><p>比如过滤负数,常规操作如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = [-<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">10</span>,-<span class="number">2</span>]</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> data:</span><br><span class="line">  <span class="keyword">if</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">    res.append(n)</span><br></pre></td></tr></table></figure><p>但事实上,仅仅需要<strong>一行</strong>就可以解决问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = [x <span class="keyword">for</span> x <span class="keyword">in</span> data <span class="keyword">if</span> x &gt;= <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>如果使用<code>filter</code>函数,也仅仅需要<strong>一行</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x : x &gt;= <span class="number">0</span>, data)</span><br></pre></td></tr></table></figure><p>经过测试,列表解析的速度更快,因此应该更多的使用解析的方式.</p><p>同样,对于字典.集合等基本数据结构,解析方式都可以快速的进行过滤.</p><p>请看:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line">data = &#123;k: randint(<span class="number">60</span>,<span class="number">100</span>) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">22</span>)&#125; <span class="comment"># 随机生产一个字典</span></span><br><span class="line">res = &#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> data.items() <span class="keyword">if</span> v &gt;= <span class="number">90</span>&#125; <span class="comment"># 筛选出所有v &gt;= 90 的键值对.</span></span><br></pre></td></tr></table></figure><p>对于集合:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;randint(-<span class="number">10</span>,<span class="number">10</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br><span class="line">res = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> data <span class="keyword">if</span> x &gt;= <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p>其实只要理解了解析式,过滤操作就会变得很简单了.</p><h3 id="命名-统计-字典排序"><a href="#命名-统计-字典排序" class="headerlink" title="命名.统计.字典排序"></a>命名.统计.字典排序</h3><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>当我们用一个列表来存储一条类似数据库记录的对象时,会遇到这样的问题.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">student = (<span class="string">&#x27;Justin&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;justin13wyx@gmail.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Name:&#x27;</span>,studnet[<span class="number">0</span>]) <span class="comment"># Is there anyone who can figure out what student[0] refer to ???</span></span><br></pre></td></tr></table></figure><p>此时,如果我们想要取得student的姓名,就要通过数组下标的方式来查找,这样会大大降低程序的可读性.</p><p>首先,我们想到了<code>C</code>的<code>#DEFINE</code>,即:常量声明.</p><p>那么我们的程序就会变成这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME = <span class="number">0</span></span><br><span class="line">AGE = <span class="number">1</span></span><br><span class="line">SEX = <span class="number">2</span></span><br><span class="line">MAIL = <span class="number">3</span></span><br><span class="line">student = (<span class="string">&#x27;Justin&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;justin13wyx@gmail.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Name:&quot;</span>,student[NAME]) <span class="comment"># Now it is clear to see. Buuuut...,it is a little complicated,isn&#x27;t it ?? </span></span><br><span class="line"><span class="comment"># ---------------------------</span></span><br><span class="line">NAME, AGE, SEX, MAIL = <span class="built_in">range</span>(<span class="number">4</span>) <span class="comment"># This is a better way.</span></span><br></pre></td></tr></table></figure><p>为了给元组中的每个元素命名,我们引入<code>collections</code>中的<code>namedtuple</code>.</p><p>这个namedtuple构造器的方法签名是这样的:<code>namedtuple(typename, field_names, *, verbose=False, rename=False, module=None)</code></p><p>其中,typename决定类型的名字(<strong>注意:这个名字决定返回的tuple子类的名字</strong>)<code>field_names</code>是一个列表.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Student = namedtuple(<span class="string">&#x27;Student&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;mail&#x27;</span>])</span><br><span class="line">s = Student(<span class="string">&#x27;name&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;mailAddr&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;name&#x27;</span>])</span><br></pre></td></tr></table></figure><p>此时使用<code>isinstance</code>来测试一下 <code>isinstance(s, tuple)</code>, 会返回<code>True</code><br>同样使用<code>isinstance(s,Student)</code>会返回<code>True</code>.<br>使用<code>type(s)</code>来看看, 会返回 <code>&lt;class &#39;__main__.Student&#39;&gt;</code>.</p><p>所以,<code>namedtuple</code>是可以<strong>动态创建类</strong>的,这个创建的类是<code>tuple</code>的子类.</p><h4 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h4><p>常规的统计方法是这样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line">data = [randint(<span class="number">0</span>,<span class="number">10</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]</span><br><span class="line">counter = <span class="built_in">dict</span>.fromkeys(data, <span class="number">0</span>) <span class="comment"># 生成</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> data:</span><br><span class="line">  counter[x] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样处理后的<code>counter</code>就是一个<code>data</code>的频度字典了.</p><p>接着可以使用<code>sorted</code>函数来进行从大到小的排序从而得到结果.</p><p>一种更便利的方式是引入<code>collections</code>的<code>Counter</code>类</p><p>Counter类继承于<code>dict</code>,适用方法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = Counter(data)</span><br><span class="line">c.most_common(3) # 选出频度最高的三个元素</span><br></pre></td></tr></table></figure><p><code>most_common</code>方法返回的是一个元素为<code>tuple</code>的<code>list</code>.</p><p>如果要进行词频统计,我们需要正则模块<code>re</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;./text&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">txt = f.read()</span><br><span class="line"><span class="comment"># 现在就可以开始统计了</span></span><br><span class="line">c = Counter(re.split(<span class="string">&#x27;\W+&#x27;</span>, txt))</span><br><span class="line">c.most_common(<span class="number">10</span>) <span class="comment"># 选出最高的十个单词</span></span><br></pre></td></tr></table></figure><h4 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h4><p>如果曾经尝试过字典排序,你就会发现:<strong>字典中的可迭代对象是key</strong></p><p>可以通过下面这段代码来验证</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line">d = &#123; k:randint(<span class="number">0</span>,<span class="number">20</span>) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) &#125;</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">iter</span>(d)) <span class="comment"># 返回的是0,1,2,3...8,9.</span></span><br></pre></td></tr></table></figure><p>但是更多的场景下,我们需要对字典的值进行排序.</p><p>有以下几个point:</p><ul><li>使用sorted的key参数</li><li>使用zip函数进行拼接</li><li>可以变出来V-&gt;k这样的</li><li>使用dict.items()变元组</li><li>这样变出来的只能是K-&gt;V</li></ul><p>直接说一下<code>sorted</code>函数的使用吧,我们继续使用上面的字典<code>d</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>也可以使用zip进行元组列表的拼接.</p><h3 id="字典公共键"><a href="#字典公共键" class="headerlink" title="字典公共键"></a>字典公共键</h3><p>如何获取多个字典的公共键?</p><p>说到这个问题,想想这么一种场景,有多个字典记载了不同场比赛球员的进球情况,现在需要得知谁在这三场比赛中都进了球.</p><p>这样就需要获取复数个字典的公共键.</p><p>获取键的方式是<code>dict.keys()</code>函数,他会返回一个<code>&lt;class &#39;dict_keys&#39;&gt;</code>对象.</p><p>这个对象是可以像集合一样进行交并集操作的,这就为我们提供了一个思路.</p><blockquote><p>再在这里插一下快速获取测试数据的一种方法,使用random提供的randint和sample可以快速构建测试数据.</p></blockquote><p>请看下面的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint, sample</span><br><span class="line"><span class="comment"># 在本例中可以这样设计测试数据</span></span><br><span class="line">s1 = &#123; k:randint(<span class="number">1</span>,<span class="number">5</span>) <span class="keyword">for</span> k <span class="keyword">in</span> sample(<span class="string">&#x27;abcdef&#x27;</span>, randint(<span class="number">3</span>,<span class="number">6</span>)) &#125;</span><br></pre></td></tr></table></figure><p>得到了测试数据<code>s1</code>,<code>s2</code>,<code>s3</code>,我们就可以开始编写代码了.</p><p>首先,我们想到了使用<code>map</code>函数,为了遍历多个字典,那么如何将他们两两做处理呢?</p><p>这就需要Python函数式编程另一个很常用的成员<code>reduce</code>了.</p><p><code>reduce</code>是来源于<code>functools</code>包的,需要引入.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br></pre></td></tr></table></figure><p><code>reduce</code>接受一个<code>function</code>作为处理函数,后面是一个<code>sequence</code>.</p><p>其处理流程就有点像递归(我觉得…),前一个的处理结果就是下一个的参数,</p><p>那么有了这些前导函数的铺垫,我们就可以来看一下这个功能的实现啦.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fromN random <span class="keyword">import</span> randint, sample</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getData</span>():</span><br><span class="line">  <span class="keyword">return</span> &#123; k: randint(<span class="number">0</span>,<span class="number">4</span>) <span class="keyword">for</span> k <span class="keyword">in</span> sample(<span class="string">&#x27;abcdef&#x27;</span>, randint(<span class="number">3</span>,<span class="number">6</span>)) &#125;</span><br><span class="line">s1 = getData()</span><br><span class="line">s2 = getData()</span><br><span class="line">s3 = getData()</span><br><span class="line"><span class="comment"># 至此我们完成了准备工作</span></span><br><span class="line">reduce(<span class="keyword">lambda</span> a,b : a&amp;b, <span class="built_in">map</span>(<span class="built_in">dict</span>.keys, [s1,s2,s3]))</span><br><span class="line"><span class="comment"># Awesome! 只需要一行代码就可以解决问题 !</span></span><br></pre></td></tr></table></figure><h3 id="使用Deque来实现历史记录"><a href="#使用Deque来实现历史记录" class="headerlink" title="使用Deque来实现历史记录"></a>使用Deque来实现历史记录</h3><p><code>Deque</code>是一个双端队列(环形缓冲区),使用这么一个数据结构可以实现一个历史记录的功能.</p><p>根据Deque的长度来决定历史记录的条数,多出来的记录会被删除,仅保留最新的N条.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">q = deque([], <span class="number">5</span>) <span class="comment"># 一定要声明!否则这个deque的最大长度是默认的NULL</span></span><br></pre></td></tr></table></figure><p>这样就可以得到一个deque对象了,接着我们存入数据:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">q.append(<span class="number">12</span>)</span><br><span class="line">q.append(<span class="number">23</span>)</span><br><span class="line">q.append(<span class="number">34</span>)</span><br><span class="line">q.append(<span class="number">45</span>)</span><br><span class="line">q.append(<span class="number">56</span>)</span><br><span class="line">q</span><br><span class="line"><span class="comment"># Out: [12,23,34,45,56]</span></span><br><span class="line">q.append(<span class="number">67</span>)</span><br><span class="line">q</span><br><span class="line"><span class="comment"># Out: [23,34,45,56,67]</span></span><br></pre></td></tr></table></figure><p>可以看出,第一个值已经被挤出去了.</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>这之中有两个极易混淆的东西,一个叫<strong>迭代器(iterator)</strong>,一个叫<strong>可迭代对象(iterable)</strong></p><p>涉及到的核心方法和接口有<code>__iter__</code>和<code>__next__</code>.一个最最最简单的迭代实现就像是这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> Ter()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ter</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure><p>调用时就像是这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = T()</span><br><span class="line">ter = <span class="built_in">iter</span>(t) <span class="comment"># 因为t实现了iter接口</span></span><br><span class="line"><span class="built_in">next</span>(ter) <span class="comment"># ter实现了next接口</span></span><br><span class="line"><span class="comment"># Out:0</span></span><br></pre></td></tr></table></figure><p>在这个例子中,<code>ter</code>是迭代器,<code>t</code>是一个可迭代对象.也就是说,实现了<code>iter</code>接口的就是一个可迭代对象.</p><p>对于字符串,我们都知道是一个可迭代的对象,如果你使用Python2,在检测时会发现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hasattr</span>(<span class="string">&quot;str&quot;</span>, <span class="string">&#x27;__iter__&#x27;</span>) <span class="comment"># 返回的是False</span></span><br><span class="line"><span class="comment"># 但是:</span></span><br><span class="line"><span class="built_in">hasattr</span>(<span class="string">&quot;str&quot;</span>, <span class="string">&#x27;__getitem__&#x27;</span>) <span class="comment"># 返回True</span></span><br></pre></td></tr></table></figure><p>在Python3中你是看不到这个现象的,因为str对象已经实现了<code>__iter__</code>接口</p><p>所以说,如果一个对象实现了<code>__getitem__</code>接口或者<code>__iter__</code>接口,它就是可迭代的.就可以使用<code>iter()</code>方法获得他的迭代器.</p><p>接着,就可以使用<code>next()</code>方法对一个迭代器进行迭代.</p><p>用迭代器实现一个小栗子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallLiZi</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, end</span>):</span><br><span class="line">self.start = start</span><br><span class="line">self.end = end</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> SmallLiZier(self.start, self.end)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallLiZier</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, end</span>):</span><br><span class="line">self.start = start</span><br><span class="line">self.end = end</span><br><span class="line">self.index = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">self.index += <span class="number">1</span></span><br><span class="line"><span class="comment"># print(self.index, self.end)</span></span><br><span class="line"><span class="keyword">if</span> self.index &gt;= self.end:</span><br><span class="line"><span class="keyword">raise</span> StopIteration</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> self.isPrime(self.index):</span><br><span class="line">self.index += <span class="number">1</span>  </span><br><span class="line"><span class="built_in">print</span>(self.index)</span><br><span class="line"><span class="keyword">return</span> self.index</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isPrime</span>(<span class="params">self, num</span>):</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,num):</span><br><span class="line"><span class="keyword">if</span> num % n == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这就是一个完全没有考虑算法的简单小程序,每次<code>next</code>得到一个素数.</p><p>这个例子也可以通过**生成器(generator)**来实现, 一个简单的生成器的小栗子就像是这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">g = f()</span><br><span class="line"><span class="built_in">next</span>(g) <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">next</span>(g) <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">next</span>(g) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>如果使用<code>type()</code>查看<code>g</code>对象, 就会发现他是一个生成器对象(<code>&lt;class &#39;generator&#39;&gt;</code>), 这个对象同时实现了<code>__iter__</code>.<code>__next__</code>接口.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__iter__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(g) <span class="comment"># True</span></span><br><span class="line"><span class="string">&quot;__next__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(g) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><hr><p>简单的迭代大家都会, 在这里说说反向迭代.</p><p>反向迭代的意思就是倒序迭代, 譬如,给定一个列表我们可以反向(迭代)输出.</p><p>实现的方法很多, 大家一定都已经想到了很多办法: 比如,使用<code>reverse</code>函数反向列表, 使用倒序切片<code>[::-1]</code>得到一个新的反向列表.</p><p>但这样的方法都不是很好, 因为<code>reverse</code>改变了原来的列表,切片操作会得到新的列表, 太占用资源.</p><p>这个时候就要使用<code>reversed()</code>来得到一个<code>反向迭代器</code>, 也就是<code>&lt;class &#39;list_reverseiterator&#39;&gt;</code>.</p><p>我们已经知道, <code>iter()</code>方法调用的是<code>__iter__</code>接口, 那么<code>reversed</code>调用的是什么神奇的小东西呢?</p><p>再次查看一个列表, 我们发现果然里面有一个<code>__reversed__</code>!</p><p>那么, 我们就可以是用这个特性来写一个灵活的发生器了!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FloatRange</span>:          </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start,end,step</span>):</span><br><span class="line"> self.start = start     </span><br><span class="line"> self.end = end         </span><br><span class="line"> self.step = step       </span><br><span class="line">                        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):      </span><br><span class="line"> n = self.start         </span><br><span class="line"> <span class="keyword">while</span> n &lt; self.end:    </span><br><span class="line">   <span class="keyword">yield</span> n              </span><br><span class="line">   n += self.step       </span><br><span class="line">                        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__reversed__</span>(<span class="params">self</span>):  </span><br><span class="line"> d = self.end           </span><br><span class="line"> <span class="keyword">while</span> d &gt; self.start:  </span><br><span class="line">   <span class="keyword">yield</span> d              </span><br><span class="line">   d -= self.step       </span><br></pre></td></tr></table></figure><hr><p>Python中的一个强大特性就是<strong>切片操作</strong>, 然而,并不是每一个对象都可以进行切片的.</p><p>比如, 我们以一个文件句柄来做举例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;./somefile&quot;</span>)</span><br><span class="line">f[<span class="number">10</span>:<span class="number">20</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;_io.TextIOWrapper&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> subscriptable.</span><br></pre></td></tr></table></figure><p>很好, 他报错了.看样子文件句柄是不能直接迭代的.</p><p>难道没有还是什么好的办法能够直接迭代读取文件呢?</p><p>方法自然是有的. Python标准库<code>itertools</code>中提供了<code>islice</code>接口.</p><p>来尝试一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;./somefile&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> islice(f, <span class="number">10</span>, <span class="number">20</span>):</span><br><span class="line">  <span class="built_in">print</span>(line)</span><br><span class="line"><span class="comment"># 哈哈有效果啦!</span></span><br></pre></td></tr></table></figure><p>但是当继续迭代时:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> f.readlines():</span><br><span class="line">  <span class="built_in">print</span>(n)</span><br><span class="line"><span class="comment"># woc, 怎么不从头开始 ?!</span></span><br></pre></td></tr></table></figure><p><strong>注意, islice的操作并不能像原生的切片操作一样,事实上,这样的切片事实上还是迭代,只是将不合要求的部分舍去了.</strong></p><p>可我就是想要原生切片的效果!</p><p>好…那么先来看一下数组下标的实现.</p><p>先来写一个小列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">l[<span class="number">0</span>] <span class="comment"># 1</span></span><br><span class="line">l.__getitem__(<span class="number">0</span>) <span class="comment"># 1</span></span><br><span class="line">l.__getitem__(<span class="number">1</span>) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><p>哦!原来是这样, 所谓下标就是调用了<code>__getitem__</code>方法.</p><p>那么实现下标查找和切片就变得可能了.</p><p>我们写一个这样的类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:                 </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file</span>): </span><br><span class="line">    self.file = file        </span><br><span class="line">    self.index = <span class="number">0</span>          </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, n</span>): </span><br><span class="line">    <span class="keyword">while</span> self.index &lt; n-<span class="number">1</span>:</span><br><span class="line">      f.readline()          </span><br><span class="line">      self.index += <span class="number">1</span>       </span><br><span class="line">    <span class="keyword">return</span> f.readline()</span><br></pre></td></tr></table></figure><p>好了,现在它可以使用下标来读取文件了.</p><p>接下来实现切片:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file</span>):</span><br><span class="line">self.file = file</span><br><span class="line">self.index = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, n</span>):</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(n, <span class="built_in">int</span>):</span><br><span class="line"><span class="keyword">while</span> self.index &lt; n - <span class="number">1</span>:</span><br><span class="line">self.file.readline()</span><br><span class="line">self.index += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> f.readline()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(n, <span class="built_in">slice</span>):</span><br><span class="line">start = n.start</span><br><span class="line">end = n.stop</span><br><span class="line"><span class="built_in">print</span>(end)</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">if</span> start <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">start = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">range</span>(end):</span><br><span class="line"><span class="keyword">if</span> line &gt;= start:</span><br><span class="line">res.append(self.file.readline())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">self.file.readline()</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>好了,现在就可以对文件进行真正的切片了.</p><p><strong>8.30的更新: 上述的两个文件读取的代码有误, 待重新开发.</strong></p><p>顺便提一个问题, 重新获取文件描述符和移动文件指针哪一个更节省资源呢 ?</p><p>我们知道操作系统对文件描述符的数量是有限制的. 而这个所谓描述符其实就是对应的就是一个整数来映射打开的目标文件. 而所谓文件指针其实就是结构体的一个属性而已. 那么就这样来看, 似乎是直接移动文件指针更好. 不知道这样想是否正确? </p><hr><p>之前在谈字典的迭代的时候, 我们提到了<code>zip</code>函数, 现在再来更细致的说一下它.</p><p><code>zip</code>的基本功能就是返回一个<strong>迭代的</strong>zip对象, 一开始我都没有注意到, 以为只是拼接这么简单, 没想到返回的对象竟然是迭代对象.(后来看了一下, 真的呢..”<strong>next</strong>“ in dir(z)..True…)</p><p>所以说在使用<code>list(z)</code>进行转列表时, <code>z</code>就会失去了作用.</p><p>如果传入<code>zip</code>的列表长度不一致会怎么样呢 ? 自己做实验 ! (哈哈哈.难道你能把我的头放到键pan.cdsvfbgnrtjhe..</p><p>如果传入<code>zip</code>的列表长度不一致,<code>zip</code>会选择最小长度的并且抛弃其他列表所有超出的元素..</p><p>使用<code>zip</code>来进行一次并行迭代(在一个for循环进行多个对象的同时迭代):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line">chi = [randint(<span class="number">60</span>,<span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">44</span>)]</span><br><span class="line">math = [randint(<span class="number">60</span>,<span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">44</span>)]</span><br><span class="line">eng = [randint(<span class="number">60</span>,<span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">44</span>)]</span><br><span class="line"><span class="comment"># 得到测试数据</span></span><br><span class="line">total = []</span><br><span class="line"><span class="keyword">for</span> c,m,e <span class="keyword">in</span> <span class="built_in">zip</span>(chi):</span><br><span class="line">  total.append(c+m+e)</span><br></pre></td></tr></table></figure><hr><p>说完了并行迭代, 我们再来看一下串行迭代.</p><p>所谓串行迭代就是指按照顺序迭代多个可迭代对象.</p><p>比如这样的一种情况:</p><p>有四个班的成绩, 每个班的人数不一样, 现在想要统计英语大于90的人的总数, 怎么做呢?</p><p>现在不能并行迭代了, 因为人数不一样的, 如果我们能够把他们拼到一起就好了,所以现在就来使用<code>itertools.chain</code>吧, 他能把多个<code>iterable</code>拼接到一起</p><p>用法就像是这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">total = chain(p1,p2,p3)</span><br></pre></td></tr></table></figure><p>那么, 使用<code>chain</code>这个问题的一种可能的实施方案是这样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">c1 = [randint(<span class="number">60</span>,<span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">44</span>)]</span><br><span class="line">c2 = [randint(<span class="number">60</span>,<span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">41</span>)]</span><br><span class="line">c3 = [randint(<span class="number">60</span>,<span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">39</span>)]</span><br><span class="line">c4 = [randint(<span class="number">60</span>,<span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">43</span>)]</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> stu <span class="keyword">in</span> chain(c1,c2,c3,c4):</span><br><span class="line">  <span class="keyword">if</span> stu &gt; <span class="number">90</span>:</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">count <span class="comment"># 36(样例输出)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本命令的常用参数</title>
      <link href="/2017/04/15/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0/"/>
      <url>/2017/04/15/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>Linux中的命令参数非常之多,但当中有很大一部分是很少甚至一直用不到的,因此在这里我把一些极其常用的命令的参数做一个整理以及一些记忆的方法,供大家参考.</p><span id="more"></span><h2 id="实用小工具"><a href="#实用小工具" class="headerlink" title="实用小工具"></a>实用小工具</h2><p>Linux中配置了时间.日历.计算器等实用小工具,个人认为使用这些工具的目的就是加快效率,因此本身他们就没有什么参数,需要提及一下的是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> +%Y/%m/%d</span><br><span class="line"><span class="built_in">date</span> +%H:%M</span><br></pre></td></tr></table></figure><p>这种模式化的命令我们完全可以将其封装成<code>alias</code>,写入<code>.bashrc</code>中,方便调用.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal 04 2017</span><br></pre></td></tr></table></figure><p>对于这样的命令就没有必要再封装了,因为其本身是很灵活的.</p><p>对于计算器::</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc</span><br></pre></td></tr></table></figure><p>他本身的参数就没有什么意义,因此也没必要去记.</p><h2 id="关机-x2F-重启命令"><a href="#关机-x2F-重启命令" class="headerlink" title="关机&#x2F;重启命令"></a>关机&#x2F;重启命令</h2><p><strong>在关机前,推荐主动调用一下sync这个工具,尽管那些关机命令已经封装进去这个工具的调用,但还是自己调用一下比较放心</strong></p><p>推荐使用<code>shutdown</code>, 因为他会根据当前系统的状态,逐一关闭当前正在运行的服务,而<code>halt</code>会不理会系统的状态,还可以进行强制的硬件关机.</p><p>可能用到的参数有:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h (halt) 关机</span><br><span class="line">shutdown -r (restart) 重启</span><br><span class="line">shutdown -k 仅仅是广播一条警告信息</span><br><span class="line">shutdown -c 取消当前的的关机schedule. (会有广播)</span><br></pre></td></tr></table></figure><p>一些常见的shutdown例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now 立即关机</span><br><span class="line">shutdwon -h 10:23 在10:23关机</span><br><span class="line">shutdown -r (+)10 在十分钟后重启(+号可略去)</span><br><span class="line">shutdown -k now <span class="string">&#x27;Your Linux will shutdown NOW!!&#x27;</span> 仅发送警告,不会真的关机.</span><br></pre></td></tr></table></figure><p>除了shutdown,还有一些能达到相同结果的命令 如:<code>halt poweroff init reboot</code></p><h2 id="文件系统相关命令"><a href="#文件系统相关命令" class="headerlink" title="文件系统相关命令"></a>文件系统相关命令</h2><h3 id="文件目录管理相关"><a href="#文件目录管理相关" class="headerlink" title="文件目录管理相关"></a>文件目录管理相关</h3><p><code>pwd</code>也是有参数的! 没想到吧?</p><p>事实上我还觉得这个参数是很有用的,他可以显示出当前目录的真实目录,而不是连接的.</p><p>这个参数就是**<code>-P</code>**,意指<code>physical</code>.</p><p>譬如,在<code>/lib -&gt; /usr/lib</code>这样的目录下直接使用<code>pwd</code>,输出的是<code>/lib</code>,使用<code>pwd -P</code>输出<code>/usr/lib</code>.</p><p><code>mkdir</code></p><p>常用参数为 <code>-p</code>,意指<code>parents</code>,可以理解成递归创建.</p><p><code>ls</code></p><p>常用的参数如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a (all) 全部的文件包括隐藏</span><br><span class="line">-h (human) 更易读的方式</span><br><span class="line">-l (long) 长数据串,显示metadata</span><br><span class="line">-S (Size) 按照大小排序</span><br><span class="line">-t (time) 按照时间排序</span><br></pre></td></tr></table></figure><p><code>cp</code></p><p>一般的发行版都会自动加上<code>-i</code>参数,意指(interactive),询问目标文件存在时是否覆盖.</p><p>常用的参数如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-a (archive) 等同于 -pdr 相当于是一次 完全复制本身 的过程</span><br><span class="line">-p (preserve) 保留属性</span><br><span class="line">-d 如果源文件是连接文件,则复制链接本身,而不是文件</span><br><span class="line">-r (recursive) 递归复制,用于目录的复制.</span><br></pre></td></tr></table></figure><p><code>cat</code></p><p>我认为只有一个参数有意义,即: <code>-n</code> (number) 显示出行号.</p><p>与之很像的命令 <code>nl</code> 但是,<code>nl</code>默认忽略空行.需要加<code>-b a</code>参数.</p><p><code>tail</code></p><p>DEBUG时超重要的命令了,我觉得.</p><p>参数:<code>-f</code> ,意指<code>follow</code>,跟踪查看.</p><p><code>touch</code></p><p>听名字感觉这个命令是用来改变文件时间的元信息的. 只是文件不存在时会自动创建一个空文件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> -a (access time) 仅仅修改access time</span><br><span class="line">同样还有 -m (modified time)</span><br><span class="line"><span class="built_in">touch</span> -c ([non-] create) 仅仅修改时间,如果文件不存在,不创建文件.</span><br><span class="line"><span class="built_in">touch</span> -d (<span class="built_in">date</span>) 修改时间为<span class="string">&quot;XXX&quot;</span></span><br></pre></td></tr></table></figure><h3 id="搜索相关"><a href="#搜索相关" class="headerlink" title="搜索相关"></a>搜索相关</h3><p><code>which</code><br><code>whereis</code><br><code>locate</code><br><code>find</code></p><p>查找命令傻傻分不清楚??</p><p>先从参数说起好了.</p><p><code>which</code> ( 用于寻找执行文件,查找命令 )</p><ul><li>-a (all) 将所有$PATH目录中的命令均列出.</li></ul><p><code>whereis</code> (用于寻找特定文件(DB))</p><p><code>locate</code> (超好用的搜索(DB))</p><ul><li>-i 忽略大小写</li><li>-r regularExp 正则匹配</li></ul><blockquote><p>数据库更新: updatedb</p></blockquote><p><code>find</code> (绝对能找到,但是慢(DISK))</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">find的参数实在是太多了.</span><br><span class="line">但好在有规律可循.下面有一些常用的模板.</span><br><span class="line">命令格式是 find 路径 参数 -<span class="built_in">exec</span> 要执行的命令 &#123;&#125; \;</span><br><span class="line">find /etc /opt -name file</span><br><span class="line">find /etc -perm +7000</span><br><span class="line">find / -mtime 0 <span class="comment"># 表示将过去24小时到现在修改过的文件</span></span><br><span class="line">find /etc newer /etc/passwd 对比新旧</span><br><span class="line">find /home -user root</span><br><span class="line">find / -nouser</span><br></pre></td></tr></table></figure><h3 id="文件压缩相关"><a href="#文件压缩相关" class="headerlink" title="文件压缩相关"></a>文件压缩相关</h3><p>文件压缩的命令的参数基本相似,但也有不同.</p><p>说之前来看一下<code>zcat</code>和<code>bzcat</code>,这两个相当于是压缩文件的<code>cat</code>命令,前提是文件压缩前是文本文件.</p><p><code>gzip</code><br><code>bzip2</code> –能够保留源文件</p><p>相较于gzip,bzip2的压缩更好,推荐使用bzip2.</p><ul><li>-c (stdout)</li><li>-v (verbose)</li><li>-d (decompress)</li></ul><p>对于<code>bzip2</code>:</p><ul><li>-k (keep)</li><li>-z (compress)</li></ul><p><code>tar</code> 是非常常用的压缩和解压缩命令,安装源码包是是必不可少的命令,他的参数也是很多的:</p><ul><li>-c (create) 压缩</li><li>-t (list) 查看压缩包</li><li>-v (verbose) 显示进度</li><li>-x (extract) 解包</li><li>-P 保留原文件的属性和权限 (Preserve)</li><li>-j 以bzip2的方式打包 文件名为*.tar.bz2;</li><li>-z 以gzip的方式打包 文件名为*.tar.gz;</li></ul><h3 id="磁盘挂载相关"><a href="#磁盘挂载相关" class="headerlink" title="磁盘挂载相关"></a>磁盘挂载相关</h3><p>对于容量的查看,有<code>df</code>.<code>du</code>两个命令.</p><p>其中<code>du</code>用来查看目录, <code>df</code>用来查看磁盘.</p><p>两者的参数基本一样:</p><ul><li>-h (human) 更易阅读的方式.</li><li>-a (all) 所有</li><li>-k 以KB的形式显示</li><li>-m 以MB的形式显示</li></ul><p>不同的是,</p><ul><li>df -i (inode) 显示inode的使用情况</li><li>du -s (summarize) 仅显示文件夹的容量</li></ul><p>使用<code>fdisk</code>来进行MBR分区<br>使用<code>parted</code>来进行GPT分区.</p><p>准确的说这两个外部命令完全就是工具性质的了.因此也没有什么参数.</p><p><code>mount</code>挂载命令</p><ul><li>-a 根据&#x2F;etc&#x2F;fstab自动挂载</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python&#39;s Memo(1)</title>
      <link href="/2017/04/13/Python-s-Memo-1/"/>
      <url>/2017/04/13/Python-s-Memo-1/</url>
      
        <content type="html"><![CDATA[<p>基础数据结构篇</p><span id="more"></span><h2 id="Python-的备忘录–基础数据结构篇"><a href="#Python-的备忘录–基础数据结构篇" class="headerlink" title="Python 的备忘录–基础数据结构篇"></a>Python 的备忘录–基础数据结构篇</h2><p>Python基础数据结构主要有列表(list),元组(tuple),词典(dict)以及集合(set)</p><blockquote><p>快速记忆的方法:</p></blockquote><ul><li>列表 [ ]</li><li>元组 ( )</li><li>词典 { : }</li><li>集合 [( )]</li></ul><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>list中的元素可以是不同类型的.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用<span class="built_in">len</span>()来获取列表长度</span><br><span class="line">使用[]下标来获取元素</span><br><span class="line">允许传入负值来倒序遍历</span><br></pre></td></tr></table></figure><p>操作list:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">append(ele) <span class="comment"># push一个元素</span></span><br><span class="line">pop([index]) <span class="comment"># 删除一个元素</span></span><br><span class="line">insert(index, ele) <span class="comment"># 插入一个元素</span></span><br><span class="line">extend() <span class="comment"># 拓展list</span></span><br><span class="line">sort()</span><br><span class="line">reverse() <span class="comment"># 排序</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>tuple类似列表,但初始化后便不可再更改.</p><p><strong>MEMO</strong> 定义一个tuple时,会遇到这样的歧义:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tp = () // 声明了一个空的<span class="built_in">tuple</span></span><br><span class="line">tp = (<span class="number">1</span>) //是声明了一个包含<span class="number">1</span>的<span class="built_in">tuple</span>,还是一个长度为<span class="number">1</span>的<span class="built_in">tuple</span> ??</span><br></pre></td></tr></table></figure><p>因此,在遇到这样的情况时,使用长度加上逗号的方式来声明.</p><p><strong>MEMO</strong> 只有tuple本身的元素不会发生变化.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果在<span class="built_in">tuple</span>中插入了一个<span class="built_in">list</span>,<span class="built_in">list</span>中的元素是可以变化的.</span><br></pre></td></tr></table></figure><h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>dict就类似于其他语言的<code>Map</code>,即键(Key)值(Value)对,<br>字典的查找速度很快,原因是dict的Key是经过了Hash计算的.<br>因此,Key是不可变的对象.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="string">&#x27;Key&#x27;</span> <span class="keyword">in</span> <span class="built_in">dict</span> 来判断是否存在Key.</span><br></pre></td></tr></table></figure><p>操作dict</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;J&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="string">&quot;19&quot;</span>&#125;</span><br><span class="line">dd = d.copy() <span class="comment"># 深拷贝,内存地址变化</span></span><br><span class="line">d.clear() <span class="comment"># 清空</span></span><br><span class="line">dd.items() <span class="comment"># 返回键值对对象,可迭代使用</span></span><br><span class="line">dd.get(<span class="string">&quot;name&quot;</span>[, default]) <span class="comment"># 获取值, 不存在返回default的值.</span></span><br><span class="line">dd.keys()</span><br><span class="line">dd.values() <span class="comment"># 兄弟方法,分别得到键和值</span></span><br><span class="line">dd.update() <span class="comment"># 更新字典,传入可迭代的对象(字典),用来拓展或覆盖旧值.</span></span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set是一组不包含重复元素的集合们需要提供一个list作为输入.<br>list中存储的元素是无序的.</p><p>操作set</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line">s <span class="comment"># &#123; 1,2,3,4,5 &#125;</span></span><br><span class="line">s.add(<span class="number">6</span>)</span><br><span class="line">s <span class="comment"># &#123; 1,2,3,4,5,6 &#125;</span></span><br><span class="line">s.remove(ele) <span class="comment"># 删除元素</span></span><br></pre></td></tr></table></figure><p><strong>MEMO</strong> Set相当于是数学中的集合,可进行求交集\并集…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">s2 = <span class="built_in">set</span>([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">s1 &amp; s2 <span class="comment">#  &#123; 2,3 &#125;</span></span><br><span class="line">s1 | s2 <span class="comment">#  &#123; 1,2,3,4 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对SSL/TLS的理解</title>
      <link href="/2017/04/04/%E5%AF%B9SSL-TLS%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2017/04/04/%E5%AF%B9SSL-TLS%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>说说我对HTTPS的理解</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>TLS是现在广泛使用的安全协议,全名为传输层安全协议(Transport Layer Security).它的前身是SSL,即安全套接层(Secure Socket Layer).</p><p>网景公司（Netscape）在1994年推出首版网页浏览器，网景导航者时，推出HTTPS协议，以SSL进行加密，这是SSL的起源。</p><p>后来,Google在04年发布 在SSL 3.0中发现设计缺陷，建议禁用此一协议。攻击者可以向TLS发送虚假错误提示，然后将安全连接强行降级到过时且不安全的SSL 3.0，然后就可以利用其中的设计漏洞窃取敏感信息。最后各大公司都选择了强制使用TLS.</p><p>目前SSL&#x2F;TLS已成为互联网上保密通讯的工业标准</p><p><strong>更新</strong>: 这个SSL&#x2F;TLS就像是在应用层和传输层中间多加的半层. 其实就是库嘛, 应用程序可以选择性的进行调用. 以Web服务为例, 如果没有调用的话就是http, 如果调用了的话就是https了.反正提供了API. 二者虽然只有一个字的差距但是却又很大的不同的. 一个是文本格式的, 一个是二进制的格式的.</p><p>尽管他自己是半个层, 但是其内部也是分了很多层的(进行了分层设计), 简单的说一下:</p><ol><li>最底层: 基础算法原语的实现, aes, rsa, md5</li><li>向上一层: 各种算法的实现</li><li>再向上一层: 组合算法实现的半成品</li><li>用各种组件拼装而成的种种成品密码学协议&#x2F;软件:<ol><li>tls, ssh, …</li></ol></li></ol><h2 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h2><p>提到了TLS,就一定要说一下HTTPS了,一般对HTTPS的定义是<code>HTTP over SSL/HTTP over TLS/HTTP over Secure</code>.</p><p>而提到了HTTPS,有不得不说一下浏览器了.那么我来慢慢按照顺序来说一下.</p><p>首先,HTTPS借由HTTP(<code>如果对HTTP不熟悉可以考虑看一下隔壁的HTTP阅读笔记</code>)来传输信息,但为了某些需要,要加密某些信息,此时它就借助了SSL&#x2F;TLS来加密传输的数据包.一般的,HTTPS的默认使用端口为<code>443</code>.</p><p>最重要的部分就是协议实现的方式了.<br>下面来说下: (可以结合下面的图来看, <a href="http://hexopic.s3-ap-northeast-1.amazonaws.com/SSL_handshake_with_two_way_authentication_with_certificates.svg">超清版的.SVG</a>)</p><p><strong>首先</strong>客户端向Web服务器发送一个HTTPS请求,该请求包含了客户端的条件以及一个随机数.<strong>关键字</strong>:{ <strong>本地条件</strong> }</p><ul><li>具体内容包括：支持的协议版本，比如TLS1.0版，一个客户端生成的随机数（稍后用于生成“会话密钥”），支持的加密算法（如RSA公钥加密）和支持的压缩算法。</li></ul><p>此时,客户端的随机数被Server端获得.</p><p><strong>然后</strong>收到一个Server回应消息，这个回应中确定了双方在后来要使用的各种连接参数.<strong>关键字</strong>:{ <strong>确定参数</strong> }</p><ul><li>这次的回应包括：确认使用的加密通信协议版本，比如TLS 1.2版本（如果浏览器与服务器支持的版本不一致，服务器关闭加密通信），一个服务器生成的随机数（稍后用于生成“对话密钥”），确认使用的加密方法（如RSA公钥加密），服务器证书。</li></ul><p>此时,双方手中都有了双方的随机数.<br>至此,Phase 1结束.</p><ul><li><strong>{ Phase1中交换了随机数,确定了连接参数 }</strong></li></ul><p><strong>再然后</strong>当双方知道了连接参数，客户端与服务器交换证书(依靠被选择的公钥系统)(Phase2-Phase3)</p><p>服务器端向客户端发送自己的证书和公钥并要求客户端提供证书. <strong>看到这里,想必会有这样的疑问:客户端哪里来的证书?</strong></p><p>我认为,本机的电子证书是通过浏览器中预设的CA来获取的.</p><blockquote><p>SSL 服务器证书提供加密和安全功能。<br>客户端证书提供用户身份验证功能。<br>客户端证书由证书颁发机构颁发给用户。</p></blockquote><p>客户端这边,通过CA的公钥解密服务器端的证书,还会检测是否被吊销, 确认是否有效.</p><ul><li>所以说,这里的证书是经过了认证中心的私钥加密的</li></ul><p><strong>关键字:{ 确认服务器端身份 }</strong></p><p>此时,客户端手中多了服务器端的公钥.<br>至此,Phase2结束.</p><ul><li><strong>{Phase2中客户端验证了服务器的身份}</strong></li></ul><p><strong>接着</strong>根据之前的请求,客户端向服务器端发送自己的证书和自己的公钥.</p><blockquote><p>客户端有证书即双向身份认证，没证书时随机生成公钥。</p></blockquote><p>服务器端对客户端发来的证书进行检查,如果有问题会直接中断私密通信.</p><p><strong>然后</strong>,客户端再次生成一个随机数,<strong>注意,此时生成的随机数是经过了服务器端公钥的加密的</strong>,接着将其发送到了服务器端. </p><p>当服务器端收到了这个随机数,(我们把他叫做<code>pre-master-secret</code>),双方会根据之前商定的加密方法,对之前的两个随机数加上这个PMS,生成一个会话密钥(<code>MS</code>).</p><p>此时,服务器端手中自己的公钥和私钥,以及<code>MS</code><br>客户端手中有自己的公钥和私钥,以及<code>MS</code><br>至此,Phase3结束.</p><ul><li><strong>{Phase3中双方得到了会话密钥}</strong></li></ul><p><strong>最后</strong>,双方关键数据的加密传输均使用这个“会话密钥”–主密钥</p><p>结束SSL握手.</p><p>至此,全部的SSL握手结束.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/SSL_handshake_with_two_way_authentication_with_certificates.svg/1024px-SSL_handshake_with_two_way_authentication_with_certificates.svg.png" alt="SSL"></p><h2 id="SSL-x2F-TLS的延时问题"><a href="#SSL-x2F-TLS的延时问题" class="headerlink" title="SSL&#x2F;TLS的延时问题"></a>SSL&#x2F;TLS的延时问题</h2><p>既然HTTPS的数据传递是相对安全的,那为什么不给每一个域名都配上HTTPS呢?</p><p>原因很简单,<strong>延时</strong>,因为复杂的握手机制,会使得访问时间延长很多,那么到底有多少呢?</p><p>首先,HTTPS是建立在HTTP的,HTTP又是建立在TCP&#x2F;IP上的,因此必定存在三次握手.</p><p>所以,我们可以得到:</p><blockquote><p>HTTP耗时 &#x3D; TCP握手<br>HTTPs耗时 &#x3D; TCP握手 + SSL握手</p></blockquote><p>我们可以做一个小测试:</p><p>命令行工具curl有一个w参数，可以用来测量TCP握手和SSL握手的具体耗时，以访问支付宝为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -w <span class="string">&quot;TCP handshake: %&#123;time_connect&#125;, SSL handshake: %&#123;time_appconnect&#125;\n&quot;</span> -so /dev/null https://www.alipay.com</span><br></pre></td></tr></table></figure><p>我测试的一些结果样本供参考:</p><blockquote><p>TCP handshake: 0.053, SSL handshake: 0.129<br>TCP handshake: 0.079, SSL handshake: 0.187<br>TCP handshake: 0.075, SSL handshake: 0.145<br>TCP handshake: 0.077, SSL handshake: 0.150</p></blockquote><p>从结果可以看到，SSL握手的耗时大概是TCP握手的二-三倍。</p><p>也就是说，在建立连接的阶段，HTTPs链接比HTTP链接要长2-3倍的时间，当然了,具体数字取决于CPU的快慢和网络状况。</p><h2 id="最后-再来说说session恢复的问题"><a href="#最后-再来说说session恢复的问题" class="headerlink" title="最后,再来说说session恢复的问题"></a>最后,再来说说session恢复的问题</h2><p>如果出于某种原因，对话中断，就需要重新握手。</p><p>之前说过,SSL是很要时间的,因此,要想出一种办法来快速恢复.</p><p>这时有两种方法可以恢复原来的session：一种叫做<strong>session ID</strong>，另一种叫做<strong>session ticket</strong>。</p><p>session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的”对话密钥”，而不必重新生成一把。</p><p><img src="http://image.beekka.com/blog/2014/bg2014092009.png" alt="sessionID"></p><p>上图中，客户端给出session ID，服务器确认该编号存在，双方就不再进行握手阶段剩余的步骤，而直接用已有的对话密钥进行加密通信。</p><p>但是,sessionID是存储在一个服务器上的,一旦有发向另一台的请求,就又会重新开始了.</p><p>为了解决这个问题,session ticket应运而生.</p><p><img src="http://image.beekka.com/blog/2014/bg2014092012.png" alt="sessionticket"></p><p>上图中，客户端不再发送session ID，而是发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。</p><h2 id="补充-SSH-Secure-Shell-的原理和处理过程"><a href="#补充-SSH-Secure-Shell-的原理和处理过程" class="headerlink" title="补充:SSH(Secure Shell)的原理和处理过程"></a>补充:SSH(Secure Shell)的原理和处理过程</h2><p>首先,需要知道几种不同的SSH Key,</p><ul><li>HOST KEY  由服务端创建, 用于对服务端进行认证</li><li>User Key  由用户创建, 用于对用户进行验证</li><li>Server Key 服务端创建(有效期默认为1小时) 用于加密Session Key–在SSH-2中作为一个概念而存在</li><li>Session Key 存在于会话中, 用于对传输的数据进行加密</li></ul><p>类似上文的SSL&#x2F;TLS, SSH原理与之很相似.</p><p>需要以下几个阶段:</p><ul><li>协议协商阶段 (就如同HTTPS交换信息一样)</li><li>服务端认证阶段</li><li>客户端认证阶段</li><li>传输阶段</li></ul><h3 id="阶段一-协商"><a href="#阶段一-协商" class="headerlink" title="阶段一:协商"></a>阶段一:协商</h3><p>SSH服务器会打开默认的22端口等待客户端的连接, 一旦客户端发起TCP连接请求, 服务端收到后就会向客户端发送SSH协议版本信息.</p><p>接着客户端就会根据版本信息与自己的版本,决定选用哪个版本的,发送给服务端.</p><p>服务端进行检查自己是否支持客户端决定选用的SSH版本, 在该过程中, 如果发现版本不兼容的情况, 任何一方都可以直接中断连接.</p><h3 id="阶段二-认证"><a href="#阶段二-认证" class="headerlink" title="阶段二: 认证"></a>阶段二: 认证</h3><p>此时,双方已经建立了通信通道, <code>要注意,此时的通道依然是明文传输.</code> 服务端发送Host Key&amp;Server Key带上一个128位的MD5(由一个8字节的随机数生成,用来防止IP地址欺诈),客户端收到后,会先到<code>~/.ssh/known_hosts</code>文件中检查是否已经包含,如果没有会发出警告,询问用户是否要信任该主机,并附上其RSA指纹.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host <span class="string">&#x27;host (12.18.429.21)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure><p>如果有,就会进行下一步.</p><p>接着,客户端向服务器端发送Session Key, 这个时候是建立SSH隧道中最需要保密,最重要的时刻,因为session key维系着数据传输的保密性.一旦Session key泄露,整个SSH的安全机制就会变得荡然无存, 因此客户端会使用Host key和Server key对这个session key进行双重加密.</p><p>服务器端收到这个Session key,一个安全的通道就被建立起来了,双方会通过这个Session key进行数据的加密和解密.另外,在正式这个通道前, 服务端会再次要求客户端发送Session Key加密的确认信息,如果无误, 则完成服务端的认证过程.</p><p>对于客户端的认证,最常见的两种认证方式就是password和public key, 由于password的方式是一般调用的本地系统接口.因此其配置简单(或者说无需配置), 但是暴力破解是可能的.</p><p>较好的方式是使用public key的方式.</p><p>下面简单说一下, 这种方法的运作流程.</p><ol><li>客户端发起一个Public Key的认证请求，并发送RSA Key的模数作为标识符.</li><li>服务端检查是否存在请求帐号的公钥（Linux中存储在~&#x2F;.ssh&#x2F;authorized _ keys文件中），以及其拥有的访问权限。如果没有则断开连接</li><li>服务端使用对应的公钥对一个随机的256位的字符串进行加密，并发送给客户端</li><li>客户端使用私钥对字符串进行解密，并将其结合session id生成一个MD5值发送给服务端。 结合session id的目的是为了避免攻击者采用重放攻击(简单的说就好像是模拟发送一个一样的请求,就像经常在Fiddier进行的一样,也可以理解成窃听到身份token,然后发送给服务端,从而获得token所有者的身份权限)</li><li>服务端采用同样的方式生成MD5值与客户端返回的MD5值进行比较，完成对客户端的认证.</li></ol><h3 id="阶段三-传输"><a href="#阶段三-传输" class="headerlink" title="阶段三: 传输"></a>阶段三: 传输</h3><p>使用Session Key提供的对称加密算法,保证数据传输的安全.</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
            <tag> SSL/TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常用内置模块</title>
      <link href="/2017/04/04/Python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
      <url>/2017/04/04/Python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>Python内置了很多模块,这些模块往往很有用.</p><span id="more"></span><h2 id="处理时间和日期–datetime"><a href="#处理时间和日期–datetime" class="headerlink" title="处理时间和日期–datetime"></a>处理时间和日期–datetime</h2><p>1.获取当前的时间–以datetime对象方式返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">now = datetime.now()</span><br><span class="line">//now 是一个datetime对象</span><br><span class="line">//datetime.datetime(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">30</span>, <span class="number">1</span>, <span class="number">53</span>, <span class="number">42</span>, <span class="number">679114</span>)</span><br><span class="line"><span class="built_in">print</span>(now)</span><br><span class="line">//<span class="number">2017</span>-03-<span class="number">30</span> 01:<span class="number">53</span>:<span class="number">42.679114</span></span><br></pre></td></tr></table></figure><p>2.获取指定时间和日期,直接像构造一个datetime对象就行了.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time = datetime(<span class="number">2018</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(time)</span><br><span class="line">//<span class="number">2018</span>-04-<span class="number">10</span> <span class="number">13</span>:<span class="number">21</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure><p>3.时间戳</p><p>为了解决不同时区的时间不同的问题,时间戳成为了统一全球的时间表达方式,并且,这也成为了计算机保存时间的统一方式.</p><p>至于时间戳为什么能够达到统一,来看这个例子.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00 //标准时间</span><br><span class="line">timestamp = 0 = 1970-1-1 08:00:00 UTC+8:00 //北京时间</span><br></pre></td></tr></table></figure><p>所以说,timestamp和时区根本就没有关系,只要timestamp定下来,其UTC时间就定下来了,转换到任意时区的时间也是完全固定的.在时间校准的情况下,全球各地的计算机在任意时刻的时间戳都是相同的.</p><p>将一个datetime对象转换为时间戳形式很简单.</p><p>直接调用<code>timestamp()</code>来构造一个<strong>浮点型</strong>的时间戳.</p><blockquote><p>注意:Python中的timestamp是一个浮点数,小数是指毫秒,你也许会问,为什么在JAVA,JavaScript中的时间戳是整数呢? 事实上,这些编程语言已经将其乘了1000.所以在表示时要注意进行转换.</p></blockquote><p>反过来,将一个timestamp转换成为datetime只要调用datetime的<code>fromtimestamp()</code>方法即可.</p><p>4.字符串与时间的计算和转换</p><p>转换的过程事实上是相似的,如同其他语言,都要使用格式化符号来表示年份,星期,月,日和具体的时间.</p><p>字符串转datetime</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cday = datetime.strptime(<span class="string">&#x27;2018-6-1 18:19:59&#x27;</span>, <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(cday)</span><br><span class="line">//<span class="number">2018</span>-06-01 <span class="number">18</span>:<span class="number">19</span>:<span class="number">59</span></span><br></pre></td></tr></table></figure><p>datetime转字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">current = now.strftime(<span class="string">&quot;%a, %b %d %H:%M&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(current)</span><br><span class="line">//Thu March <span class="number">30</span> 02:<span class="number">55</span>  </span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior">官方文档:时间 格式化符号参考</a></p><h3 id="时间的加减"><a href="#时间的加减" class="headerlink" title="时间的加减"></a>时间的加减</h3><p>由于计算机是使用的时间戳来存储的时间,那么就可用<code>+</code>或<code>-</code>来进行运算.</p><p>但是,如果为了更好地迁移,可以使用这样的模块<code>timedelta</code>.</p><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta, timezone</span><br><span class="line">now = datetime.now()</span><br><span class="line">now + timedelta(hours=<span class="number">14</span>)</span><br><span class="line">now + timedelta(days=<span class="number">1</span>)</span><br><span class="line">now + timedelta(days=<span class="number">2</span>,hours=<span class="number">12</span>)//这些都是可行的</span><br></pre></td></tr></table></figure><p>你会发现,我多import进来了一个timezone.<br>这个部件可将时间进行UTC时间的转换.</p><p>如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zone = timezone(timedelta(hours=<span class="number">8</span>))</span><br><span class="line">now = datetime.now()</span><br><span class="line">time = now.replace(tzinfo=zone) //就是timezone info啦</span><br><span class="line">time //强制设为UTC+8h</span><br></pre></td></tr></table></figure><p>如果需要UTC时间,可以直接调用<code>datetime.utcnow()</code></p><p>交换时区除了通过datetime对象的<code>replace</code>方法强制更改外,带有时区属性的datetime通过<code>astimezone()</code>方法,来进行转换.</p><p>比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)</span><br><span class="line"><span class="built_in">print</span>(utc_dt)</span><br><span class="line">//<span class="number">2017</span>-03-<span class="number">29</span> <span class="number">18</span>:<span class="number">55</span>:<span class="number">04.681162</span>+<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">bj_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">8</span>)))</span><br><span class="line"><span class="built_in">print</span>(bj_dt)</span><br><span class="line">//<span class="number">2017</span>-03-<span class="number">29</span> <span class="number">18</span>:<span class="number">56</span>:<span class="number">22.085203</span>+08:<span class="number">00</span></span><br></pre></td></tr></table></figure><p>如果在获取datetime对象时,没有指定时区,就会被视作本地时间.</p><p>所以,不如使用timestamp来存放datetime对象.</p><h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><p>见名知意,内建的集合模块,封装了很多有用的集合类</p><p>主要有:<code>namedtuple</code>,<code>deque</code>,<code>defaultdict</code>, <code>OrderedDict</code>, <code>Counter</code>….</p><p><strong>namedtuple</strong>:</p><p>假使我们构建一个元组:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q = (<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>并不能知道这个元组是干什么用的,在这种情况下,就到了namedtuple登场的时候了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Point = namedtuple(<span class="string">&quot;Point&quot;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">p = Point(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">p.x</span><br><span class="line">// <span class="number">1</span></span><br><span class="line">p.y</span><br><span class="line">// <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这样对象就得到了很好的管理,做个试验吧:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isinstance(p,Point)</span><br><span class="line">isinstance(p,tuple)</span><br></pre></td></tr></table></figure><p><strong>deque</strong>:</p><p>双向队列,如同其他的语言,deque具有<code>append()</code>,<code>pop()</code>,还支持<code>appendleft()</code>和<code>popleft()</code>.</p><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//导入</span><br><span class="line">q = deque([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">q.append(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">q // [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">q.appendleft(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">q // [<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;D&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>defaultdict</strong>:</p><p>专用来处理访问dict不存在key的一种方法.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dd = default(<span class="keyword">lambda</span>: <span class="string">&#x27;N/A&#x27;</span>) //default</span><br><span class="line">dd[<span class="string">&#x27;Key1&#x27;</span>] = <span class="string">&quot;Key1&quot;</span></span><br><span class="line">dd.<span class="string">&quot;Key2&quot;</span> // N/A</span><br></pre></td></tr></table></figure><p>defaultdict,也可这样使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldict = collections.defaultdict(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure><p>这样生成的,<code>ldict</code>就会变成子元素都是<code>list</code>的一个defaultdict了.</p><p>而defaultdict又是dict的子类,所以这个对象会变得非常灵活.(感觉上有点像泛型,虽然他们有质的区别)</p><p><strong>OrderDict</strong></p><p>我们都知道,dict的排列顺序是随机的,Key是无序的.</p><p>为了能够在迭代时确认Key的顺序,我们便使用<code>OrderDict</code></p><p><strong>Counter</strong></p><p>Counter是一个简单的计数器,但他的用法却可以很灵活</p><p>比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">c= Counter()</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">&#x27;Hello,World&#x27;</span>:</span><br><span class="line">  c[char] += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><p><code>c</code>的输出为Counter<code>(&#123;&#39;l&#39;:3, &#39;o&#39;:2, .....&#125;)</code></p><h2 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h2><p>先来简要介绍一下Base64编码的原理,Base64使用 a-z A-Z 0-9 + &#x2F; 这64个字符来表示二进制数据(不计等号,等号是用来补空位的),由于,计算机内的编码方式是2进制,2^6&#x3D;64,因此,便将6个比特映射到一个Base64可打印字符上,就可以进行转换了.</p><p>比如:<code>man</code>这个字符串,转为Base64编码的过程为:</p><table><thead><tr><th align="center">文本</th><th align="center">M</th><th align="center">A</th><th align="center">N</th></tr></thead><tbody><tr><td align="center">ASCII</td><td align="center">77</td><td align="center">97</td><td align="center">110</td></tr></tbody></table><p>ASCII转为二进制位:<br><code>01001101 01100001 01101110</code></p><p>6比特分组:<br><code>010011 010110 000101 101110</code></p><p>得到索引:<br><code>19  22  5  46</code></p><p>查表进行Base64编码:<br><code>TWFu</code></p><p>所以,Base64编码后的数据比原始数据略长，为原来的4&#x2F;3.</p><p>到这里就出现问题了,如果我二进制数据的长度不是6的整数倍怎么办呢?</p><p>事实上,当原数据长度不是3的整数倍时, 如果最后剩下一个输入数据，在编码结果后加2个“&#x3D;”；如果最后剩下两个输入数据，编码结果后加1个“&#x3D;”；如果没有剩下任何数据，就什么都不加.</p><p>现在就可以来看一下Python对Base64的支持了.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">encoded = base64.b64encode(<span class="string">b&#x27;Hello,World&#x27;</span>)//注意这里是二进制格式化字符串</span><br><span class="line"><span class="built_in">print</span>(encoded)</span><br><span class="line">//<span class="string">b&#x27;SGVsbG8sV29ybGQ=&#x27;</span></span><br><span class="line"><span class="built_in">type</span>(encoded)</span><br><span class="line">//&lt;<span class="keyword">class</span> <span class="string">&#x27;byte&#x27;</span>&gt;</span><br><span class="line">//返回的也是二进制数据</span><br></pre></td></tr></table></figure><h2 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h2><p>hashlib是python的摘要算法模块,提供常见的摘要算法如:SHA,MD5等等</p><p>简单的说,摘要算法就是通过一个函数，把任意长度的数据转换为一个长度固定的数据串</p><p>只要源数据有一丁点的改变,摘要(digest)就会有翻天覆地的变化.所以经常用来进行软件或信息的检验.</p><p>摘要函数是一个单向函数，计算f(data)很容易，但通过digest反推data却非常困难。</p><p>md5d的摘要示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(<span class="string">&quot;Hello,World&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">md5.update(<span class="string">&quot;This is Python!&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">md5.hexdigest()</span><br><span class="line">//<span class="string">&#x27;d6a6851cd4f390744645be4f5646b52a&#x27;</span></span><br></pre></td></tr></table></figure><p>还可以使用更加安全的SHA算法,调用方法基本类似.</p><h2 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h2><p><strong>注意:当使用不当时.itertools极其容易无限迭代</strong></p><p>因此做实验时建议考虑加上time.sleep()</p><p>拥有无限迭代的迭代器有:</p><h3 id="count-进行自增1的迭代"><a href="#count-进行自增1的迭代" class="headerlink" title="count: 进行自增1的迭代"></a>count: 进行自增1的迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools, time</span><br><span class="line">naturals = itertools.count(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> naturals:</span><br><span class="line">  <span class="built_in">print</span>(n)</span><br><span class="line">  time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>输出:<code>1 2 3 4 5 6 7.....</code></p><h3 id="cycle-进行循环迭代"><a href="#cycle-进行循环迭代" class="headerlink" title="cycle: 进行循环迭代"></a>cycle: 进行循环迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cycles = itertools.cycle(<span class="string">&quot;ABCD&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">str</span> <span class="keyword">in</span> cycles:</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line">  time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>输出: <code>A B C D A B C D A....</code></p><h3 id="repeat-进行重复迭代-准确的说-这也可以不叫做无限迭代"><a href="#repeat-进行重复迭代-准确的说-这也可以不叫做无限迭代" class="headerlink" title="repeat: 进行重复迭代(准确的说,这也可以不叫做无限迭代)"></a>repeat: 进行重复迭代(准确的说,这也可以不叫做无限迭代)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repeats = itertools.repeat(<span class="string">&quot;A&quot;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> repeats <span class="keyword">in</span> cycles:</span><br><span class="line">  <span class="built_in">print</span>(repeats)</span><br></pre></td></tr></table></figure><p>输出: <code>A A A</code></p><p>一次迭代,迭代器就会失效!</p><p>为了结束无限循环,可以使用<code>takewhile()</code>来截断出一个有限的序列:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">naturals = itertools.count(<span class="number">1</span>)</span><br><span class="line">ns = itertools.takewhile(<span class="keyword">lambda</span> x: x &lt;= <span class="number">10</span>, naturals)</span><br><span class="line">//在这里其实也可以直接遍历ns,因为itertools模块返回的都是迭代器Iterator</span><br><span class="line"><span class="built_in">list</span>(ns)</span><br><span class="line">//[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>再说两个经常用的函数:<code>chain()</code>和<code>groupby()</code></p><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itertools.chain</span><br></pre></td></tr></table></figure><p>将两个迭代器进行拼接,也可以理解成是在拓展一个迭代器.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> itertools.chain(<span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;XYZ&quot;</span>):</span><br><span class="line">  <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><p>输出: <code>&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itertools.groupby()</span><br></pre></td></tr></table></figure><p>有点像数据库查询的<code>GROUPBY</code>..将元素分组,可以这样接受数据:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key,val <span class="keyword">in</span> itertools.groupby(<span class="string">&quot;AaaBbbCcc&quot;</span>, <span class="keyword">lambda</span> x : x.upper()):</span><br><span class="line">  <span class="built_in">print</span>(key, <span class="built_in">list</span>(val))</span><br><span class="line">///返回</span><br><span class="line">A [<span class="string">&quot;A&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>]</span><br><span class="line">B [<span class="string">&quot;B&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;b&quot;</span>]</span><br><span class="line">C [<span class="string">&quot;C&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;c&quot;</span>]</span><br></pre></td></tr></table></figure><p>只要后面函数的返回值相同,那么元素就被认为是同组的,这个返回的值就是元素的组名.</p><h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h2><p>pickle这个模块负责进行对象的持久化,或者叫序列化.</p><p>一个对象的生命周期是不可能比一个Pyhton程序还长的,所以,为了使得这个对象在下次程序启动是仍能使用,pickle便提供了这样的接口.</p><p>pickle的核心API就是<code>dump/dumps/load/loads</code>这四个.</p><p>这是一个持久化的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: [<span class="number">1</span>, <span class="number">2.0</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>: (<span class="string">&quot;character string&quot;</span>, <span class="string">b&quot;byte string&quot;</span>),</span><br><span class="line">    <span class="string">&#x27;c&#x27;</span>: &#123;<span class="literal">None</span>, <span class="literal">True</span>, <span class="literal">False</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.pickle&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)</span><br></pre></td></tr></table></figure><p>将已序列化的对象复原:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.pickle&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = pickle.load(f)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VIM编辑器的使用</title>
      <link href="/2017/03/24/VIM%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/03/24/VIM%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>快来使用VIM提升你的逼格！</p><span id="more"></span><h2 id="VIM概述"><a href="#VIM概述" class="headerlink" title="VIM概述"></a>VIM概述</h2><p>先来说一下VI吧，VI是VIM的前身，VI的全名叫做Visual Interface(可视化接口)，而VIM叫做VI Improved，也就是VI的升级版。</p><p>那么有哪些令人称赞的升级呢？</p><ul><li>多级撤销 (VI仅能撤销一布)</li><li>跨平台 </li><li>语法高亮</li><li>支持图形界面(NOT recommanded)</li></ul><h2 id="VIM编辑器的操作"><a href="#VIM编辑器的操作" class="headerlink" title="VIM编辑器的操作"></a>VIM编辑器的操作</h2><p>VIM有三种最常用的模式：</p><ul><li>Command Mode 命令模式</li><li>Insert Mode 输入模式</li><li>Last Line Mode 底行模式</li></ul><blockquote><p><strong>插一句重要的话，VIM的学习和Linux一样，是实践科学！所以一定要在实际环境中多使用，仅通过看文档是不会有实际作用的！</strong><br><strong>这篇文档是列举了一些常用的VIM技巧和指令以及一些释义，相当于是一篇实验指南吧，希望能给大家起到一点参考的作用</strong></p></blockquote><p>好了，让我们现在开始吧！</p><h3 id="VIM的指令结构"><a href="#VIM的指令结构" class="headerlink" title="VIM的指令结构"></a>VIM的指令结构</h3><p>VIM有很多指令是支持数字+指令的，</p><p>譬如：dd是用来删除整行的命令，那么我们可以使用2dd来删除两行</p><p>凡是支持这样结构的命令，我会有标注。</p><p>进入输入模式的参考</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>i</td><td>在当前光标处进行编辑(insert)</td></tr><tr><td>I</td><td>在行首插入</td></tr><tr><td>A</td><td>在行末插入</td></tr><tr><td>a</td><td>在光标后插入编辑(append)</td></tr><tr><td>o</td><td>在当前行后插入一个新行(open)</td></tr><tr><td>O</td><td>在当前行前插入一个新行</td></tr></tbody></table><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:e file</span><br></pre></td></tr></table></figure><p>进入vim后通过指令也可以打开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim file</span><br></pre></td></tr></table></figure><p>如果当前目录下没有文件名为file的文件，VIM会为我们创建它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim +n file</span><br></pre></td></tr></table></figure><p>打开file，默认光标在第n行</p><p>如果n大于文件的最大行，则跳到最后一行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim +/reg file</span><br></pre></td></tr></table></figure><p>打开file，高亮所有匹配到的关键字，光标出现在首次出现的哪一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim file1 file2 file3</span><br></pre></td></tr></table></figure><p>VIM同样支持多文件打开</p><p>如何在多文件之间跳转呢？ ( Buffer )</p><ul><li>使用 <code>:n</code> 下一个文件 <code>:N</code> 上一个文件</li><li>使用 <code>:prev</code> 上一个 <code>:next</code> 下一个</li></ul><p>如果想要获得我打开了哪些文件，可以在底盘输入：</p><ul><li>:ls (没错，就是ls)</li></ul><h3 id="保存与退出文件"><a href="#保存与退出文件" class="headerlink" title="保存与退出文件"></a>保存与退出文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w &lt;可选 文件路径&gt;</span><br></pre></td></tr></table></figure><p>将文件从内存写入硬盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:saveas &lt;必须 文件路径&gt;</span><br></pre></td></tr></table></figure><p>另存为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></table></figure><p>关闭文件(仅适用于未修改的文件)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></table></figure><p>关闭文件(强制) <strong>所做的更改无效，数据会丢失</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br><span class="line">:x</span><br></pre></td></tr></table></figure><p>保存并关闭(应该是使用最多的命令了)</p><p>这些命令都可以组合使用。</p><h3 id="光标移动与定位"><a href="#光标移动与定位" class="headerlink" title="光标移动与定位"></a>光标移动与定位</h3><p>光标的四向移动：(支持数字)</p><ul><li>h 左移 </li><li>j 下移</li><li>k 上移</li><li>l 右移</li></ul><p>至于为什么用这个而不用方向键…..</p><p>有人说使用这四个键更快速，然而事实是，VI编辑器是在ADM-3A终端机上创建的，</p><p>这玩意就长这样：</p><p><img src="http://www.catonmat.net/images/why-vim-uses-hjkl/lsi-adm-3a.jpg" alt="ADM-3A"></p><p>这是它的键盘：</p><p><img src="https://catonmat.net/images/why-vim-uses-hjkl/lsi-adm3a-full-keyboard.jpg" alt="keyboard"></p><p>所以说这玩意儿是没有我们现在的方向键的</p><p>细节图：</p><p><img src="http://www.catonmat.net/images/why-vim-uses-hjkl/adm-3a-hjkl-keyboard.jpg" alt="KeyBoard_detail"></p><p>更快速的移动：(支持数字)</p><ul><li>w 下一个单词的开头</li><li>e 下一个单词的结尾</li><li>b 上一个单词的开头</li><li>ge 上一个单词的结尾</li></ul><p>行内移动还有：</p><ul><li>0 或 ^ 行头</li><li>$ 行尾</li><li>f&lt;字母&gt;向后搜索&lt;字母&gt;并跳转到第一个匹配的位置</li><li>F&lt;字母&gt;向前搜索&lt;字母&gt;并跳转到第一个匹配的位置</li></ul><p>翻页指令如下：</p><ul><li>ctrl + f  向前(front)翻页</li><li>ctrl + u  向上(up)翻<strong>半</strong>页</li><li>ctrl + b  向后(back)翻页</li><li>ctrl + d  向下(down)翻<strong>半</strong>页</li></ul><p>可以直接使用<code>:line</code>来定位</p><p><code>gg</code>快速移到第一行<br><code>G</code> 快速移到最后一行<br><code>&lt;num&gt;G</code> 移到<code>&lt;num&gt;</code>行</p><p>如果没有行号，使用<code>:set nu</code>来开启</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>如打开文件一样，在底盘输入<code>/reg</code>来向后搜索</p><p>光标出现在首次出现的reg的位置(这次就不是行头了)</p><p>向前搜索使用:<code>?reg</code>,光标会出现在上方第一个匹配的reg的位置</p><p>接着使用<code>n</code>和<code>N</code>来向后向前搜索</p><h3 id="文件操作之删除"><a href="#文件操作之删除" class="headerlink" title="文件操作之删除"></a>文件操作之删除</h3><p>删除的指令如下：</p><ul><li>x    删除游标所在的字符(支持数字)</li><li>X    删除游标所在前一个字符(支持数字)</li><li>dd删除整行(支持数字)</li><li>dw删除一个单词(支持数字)</li><li>d$或D删除至行尾</li><li>d^删除至行首</li><li>dG删除到文档结尾处</li><li>d1G删至文档首部</li></ul><h3 id="文件操作之复制剪切粘贴"><a href="#文件操作之复制剪切粘贴" class="headerlink" title="文件操作之复制剪切粘贴"></a>文件操作之复制剪切粘贴</h3><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>使用<strong>y</strong>来复制</p><ul><li>yy  复制游标所在的整行&lt;支持数字&gt;</li><li>y^或y0 复制至行首 不含光标所在处字符。</li><li>y$  复制至行尾。含光所在处字符。</li><li>yw  复制一个单词。&lt;支持数字,在w前&gt;</li><li>yG  复制至文本末。</li><li>y1G 复制至文本开头。</li></ul><h4 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h4><p>使用<strong>p</strong>来粘贴</p><ul><li>p  粘贴至光标后（下）</li><li>P  粘贴至光标前（上）</li></ul><h4 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h4><p>好吧..我承认，我骗了你们 (微笑</p><p>事实上，<code>dd</code>命令就是剪切，由此我们可以得到一个酷炫的技能–交换上下行<code>(ddp)</code></p><h3 id="文件操作之替换"><a href="#文件操作之替换" class="headerlink" title="文件操作之替换"></a>文件操作之替换</h3><p>个人觉得替换是很便利的命令(尤其是R，很炫酷)</p><ul><li><p>r+&lt;字母&gt;将游标所在字母替换为指定字母</p></li><li><p>R连续替换，直到按下Esc</p></li><li><p>cc替换整行，即删除游标所在行，并进入插入模式</p></li><li><p>cw替换一个单词，即删除一个单词，并进入插入模式</p></li><li><p>C(大写)替换游标以后至行末</p></li><li><p>~反转游标所在字母大小写</p></li><li><p><code>u&lt;num&gt;</code>撤销一次或num次操作</p></li><li><p>U(大写)撤销当前行的所有修改</p></li><li><p>Ctrl+rredo，即撤销undo的操作</p></li></ul><h3 id="文件操作之缩进"><a href="#文件操作之缩进" class="headerlink" title="文件操作之缩进"></a>文件操作之缩进</h3><p>VIM的缩进非常方便，使用：</p><ul><li><code>&gt;&gt;</code> 整行向右缩进</li><li><code>&lt;&lt;</code> 整行向左缩进</li><li>:set shiftwidth 可以进行缩进和回退的字符数的设置</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记(2)</title>
      <link href="/2017/03/19/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
      <url>/2017/03/19/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<p>Python的IO编程</p><span id="more"></span><p>操作IO的能力都是有操作系统决定的，因此，使用高级语言来操作都是调用的系统所提供的低级C接口。</p><p><u>本文探讨的IO都是同步的</u></p><h2 id="非二进制文件读写"><a href="#非二进制文件读写" class="headerlink" title="非二进制文件读写"></a>非二进制文件读写</h2><p>向其他脚本语言相似，Python提供了以下非二进制文件IO模式：</p><table><thead><tr><th align="center">模式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">以只读方式打开文件。文件的指针将会放在文件的开头。</td></tr><tr><td align="center">r+</td><td align="center">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td align="center">w</td><td align="center">打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td align="center">w+</td><td align="center">打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td align="center">a</td><td align="center">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="center">a+</td><td align="center">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><p>总结一下就是：</p><blockquote><p>凡是有<code>+</code>的都可以读写，只有<code>r</code>模式不会创建新文件(抛出IOError的异常)，<code>w</code>和<code>a</code>都会在没有找到文件时创建，只有<code>a</code>的初始指针在文件尾。</p></blockquote><p><strong>基本API</strong>:</p><p>使用<code>open()</code>来打开一个文件，从</p><p><code>open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code></p><p>可看出，默认的模式为 <strong>r</strong> ,必要参数只有一个，那就是<code>file</code>,这里，<code>file</code>是一个 <code>path-like-object</code> ,除了我们认为的文件，还能打开内存的字节流，网络流，自定义流等等。</p><p>这样我们便得到了一个<code>file</code>对象，有用的属性有：</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">file.closed</td><td align="center">返回文件是否已关闭</td></tr><tr><td align="center">file.name</td><td align="center">返回文件的名字</td></tr><tr><td align="center">file.mode</td><td align="center">返回文件的打开模式</td></tr></tbody></table><p>使用<code>read()</code>来读取一个文件的全部内容，Python会把内容全部塞到内存中，用一个<code>str</code>,来表示。</p><p>使用<code>write()</code>来向一个文件写入内容（<strong>注意：操作系统往往不会在我们调用write()时就立即写入数据，而是先暂存到内存中，空闲时在慢慢写入</strong>（这个可以使用交互式的Shell来试一下：执行写入操作后先不要关闭句柄，到资源管理器中看一下，会发现文件大小不变）），而当我们调用<code>close()</code>方法时，OS才会去确保把数据全部写入。</p><p>因此，必须在文件使用完毕后调用<code>close()</code>方法（否则可能会有数据滞留内存中）。</p><p>如果想要立即写入数据，可以调用<code>flush()</code>方法来刷新文件内部缓冲，相当于是主动写入。</p><p>如果想要知道当前文件指针的位置，则可以直接调用<code>tell()</code>方法，返回文件指针的位置(字节数)</p><p>使用<code>seek(offset[,from])</code>方法来调整指针位置,参数是支持负数的（也就是向前偏移）</p><p>在做IO时一般都要考虑IO异常的产生，因此要进行异常处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  f = <span class="built_in">open</span>(<span class="string">&quot;sample&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;IO异常！Error:&quot;</span>,e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  <span class="keyword">if</span> f:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>这样写比较繁琐，所以Python提供了<code>with</code>语法糖:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;sample&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  <span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure><p>这样就使得代码变得更加简洁，而且不需要再调用<code>close</code>方法。</p><p>回到前面说的，<code>read</code>方法会把文件全部读取到内存中，这对于小文件是可行的，如果文件大小超过了8G，内存可能就爆了。</p><p>所以，最好使用反复调用<code>read(size)</code>这样来读取，或是使用<code>readlines()</code>来读取，这种读取方法非常适合读取配置文件或单行文本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">  <span class="built_in">print</span>(line.strip())</span><br></pre></td></tr></table></figure><h2 id="二进制IO和FS操作"><a href="#二进制IO和FS操作" class="headerlink" title="二进制IO和FS操作"></a>二进制IO和FS操作</h2><p>对于二进制的文件操作基本与之前的文件读写操作类似，不同的是访问模式：（也就是在之前的访问模式后加b &#x3D; _binary_）</p><table><thead><tr><th align="center">模式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">rb</td><td align="center">以只读方式打开一个二进制文件。文件的指针将会放在文件的开头。</td></tr><tr><td align="center">rb+</td><td align="center">打开一个二进制文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td align="center">wb</td><td align="center">打开一个二进制文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td align="center">wb+</td><td align="center">打开一个二进制文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td align="center">ab</td><td align="center">打开一个二进制文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="center">ab+</td><td align="center">打开一个二进制文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><hr><p>对于文件系统的操作，主要使用一个在Python中非常重要的模块 – <code>os</code>.</p><p>先来看一下<code>os</code>的一些基本属性吧。</p><blockquote><p>os中有很多API在Windows下是不可用的，如果想让os发挥最大作用，也许你需要一台高贵的Mac或者一只免费的penguin</p></blockquote><p>使用<code>os.name</code>,获取系统类型 ： 如<code>windows</code>为<code>nt</code>，<code>Linux/Unix/Mac OS X</code>为<code>posix</code></p><p>使用<code>os.uname()</code>,获取详细的系统信息， 不支持<code>Windows</code></p><p>os还提供了一系列的方法来进行文件系统的操作，就好像在跑命令行一样。</p><p>来看一个综合实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os,sys,stat</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;We are now at &quot;</span>+os.getcwd())</span><br><span class="line">os.chdir(<span class="string">&quot;./io&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;We are now at&quot;</span>,os.getcwd())</span><br><span class="line">content = os.listdir(os.getcwd())</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> content:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Now let us create a new dir&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    os.mkdir(<span class="string">&quot;./temp&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> FileExistsError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] Error:File exists&quot;</span>)</span><br><span class="line">content = os.listdir(os.getcwd())</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> content:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">os.chdir(<span class="string">&quot;./temp&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;temp.file&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    text = <span class="string">&quot;Now let us write data in this empty file&quot;</span></span><br><span class="line">    f.write(text)</span><br><span class="line">    f.flush()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Stream Position:&quot;</span>,f.tell(),<span class="string">&quot;And length of this file is &quot;</span>,<span class="built_in">len</span>(text))</span><br><span class="line">    f.seek(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    f.write(<span class="string">&quot;Rewrite&quot;</span>)</span><br><span class="line">    f.flush()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Let us see some info of this new file:&quot;</span>,os.stat(<span class="string">&quot;./temp.file&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now let change the mode of this file as Read-Only:&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> PermissionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] Error:&quot;</span>,e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br><span class="line">os.chmod(<span class="string">&quot;./temp.file&quot;</span>, stat.S_IREAD)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Now let us change the name of this file&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.rename(<span class="string">&quot;./temp.file&quot;</span>, <span class="string">&quot;./temp.file.new&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> (PermissionError,FileExistsError) <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] Error&quot;</span>,e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Is the change successfully?&quot;</span>)</span><br><span class="line">c = os.listdir(<span class="string">&quot;./&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Alright~Our test is nearly end.\nNow Let us remove the creations.&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> c[<span class="number">0</span>] == <span class="string">&quot;temp.file.new&quot;</span>:</span><br><span class="line">    os.chmod(<span class="string">&quot;./temp.file.new&quot;</span>, stat.S_IWRITE)</span><br><span class="line">    os.remove(<span class="string">&quot;./temp.file.new&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> c[<span class="number">0</span>] == <span class="string">&quot;temp.file&quot;</span>:</span><br><span class="line">    os.chmod(<span class="string">&quot;./temp.file&quot;</span>, stat.S_IWRITE)</span><br><span class="line">    os.remove(<span class="string">&quot;./temp.file&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(os.getcwd())</span><br><span class="line">os.chdir(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.remove(<span class="string">&quot;./temp&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] Error:&quot;</span>,e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Oops..It seems that remove cannot delete a dir&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Now we use rmdir method&quot;</span>)</span><br><span class="line">os.rmdir(<span class="string">&quot;./temp&quot;</span>)</span><br></pre></td></tr></table></figure><p>也许你会奇怪，为什么<code>os</code>模块中并没有封装剪切、复制这样的常用方法。(虽然我们已经可以使用上面的IO解决) </p><p>铛铛铛！ Python为我们封装了<code>shutil</code>模块。<code>shutil</code>提供了各种剪切复制方法(文件，对象，信息，模式…都可以)</p><p>事实上他的复制也就是我们所想的那样：</p><p><strong>删除了部分注释</strong></p><p>特意又去看了2.7的源码…基本没有改动(3.6增加了对文件链接的处理、以及3.3&#x2F;3.4对异常的更改)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">copyfile</span>(<span class="params">src, dst, *, follow_symlinks=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">if</span> _samefile(src, dst):</span><br><span class="line">        <span class="keyword">raise</span> SameFileError(<span class="string">&quot;&#123;!r&#125; and &#123;!r&#125; are the same file&quot;</span>.<span class="built_in">format</span>(src, dst))</span><br><span class="line">    <span class="keyword">for</span> fn <span class="keyword">in</span> [src, dst]:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            st = os.stat(fn)</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> stat.S_ISFIFO(st.st_mode):</span><br><span class="line">                <span class="keyword">raise</span> SpecialFileError(<span class="string">&quot;`%s` is a named pipe&quot;</span> % fn)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> follow_symlinks <span class="keyword">and</span> os.path.islink(src):</span><br><span class="line">        os.symlink(os.readlink(src), dst)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(src, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fsrc: <span class="comment"># 文件输入流</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(dst, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fdst: <span class="comment"># 文件写入流</span></span><br><span class="line">                copyfileobj(fsrc, fdst)</span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copyfileobj</span>(<span class="params">fsrc, fdst, length=<span class="number">16</span>*<span class="number">1024</span></span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        buf = fsrc.read(length) <span class="comment"># 读数据</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> buf:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        fdst.write(buf) <span class="comment"># 写数据</span></span><br></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>Python支持bytes序列化和流行的JSON序列化。</p><p>本文仅谈一下JSON的部分。</p><p>JSON中允许的数据类型有:</p><ul><li>{}</li><li>[]</li><li>“string”</li><li>1234.56</li><li>true&#x2F;false</li><li>null</li></ul><p>与之对应的Python数据类型为：</p><ul><li>dict</li><li>list</li><li>str</li><li>int&#x2F;float</li><li>True&#x2F;False</li><li>None</li></ul><p>使用起来也很容易，使用<code>dumps()</code>来进行序列化，使用<code>loads()</code>来反序列化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br><span class="line">json.dumps(d)</span><br><span class="line">&lt;<span class="keyword">return</span>&gt; <span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span></span><br><span class="line">json_str = <span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span></span><br><span class="line">json.loads(json_str)</span><br><span class="line">&lt;<span class="keyword">return</span>&gt; &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>既然使用起来这么方便，那么我们可否直接序列化一个类的实例呢？</p><p>答案是：<strong>可以</strong></p><p>比方说我们定义一个Student类，有name,age,score参数，我们便可以定义这样的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student2dict</span>(<span class="params">std</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: std.name,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: std.age,</span><br><span class="line">        <span class="string">&#x27;score&#x27;</span>: std.score</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接着，在序列化该实例时，调用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Student(<span class="string">&quot;Justin&quot;</span>, <span class="number">19</span>, <span class="number">100</span>)</span><br><span class="line">json.dumps(student, default=student2dict)</span><br></pre></td></tr></table></figure><p>就可以按照我们的想法来序列化了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记(1)</title>
      <link href="/2017/03/17/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2017/03/17/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<p>Python中的进程和线程.</p><span id="more"></span><blockquote><p>线程，是操作系统分发给CPU的最小执行单位，至少一条线程组成进程。</p></blockquote><p>要想实现多任务，自然就会有以下三种方法：</p><ul><li>多进程模式</li><li>多线程模式</li><li>多线程+多进程模式</li></ul><p>Python对于线程和进程的支持都不错，在以上三种模式中，前两种较为常见。</p><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p><code>os</code>模块中封装了OS的<code>fork</code>调用，通过这个可以非常方便的创建子进程.(pid &#x3D; process id)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Process (%s) is running...&quot;</span> % os.getpid())<span class="comment"># os.getpid() 可以获得当前进程的id</span></span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;I am a child process (%s) and my parent is (%s)&quot;</span> % (os.getpid(), os.getppid()))<span class="comment"># os.getppid() 可以获得当前进程的父进程的id</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Create a child process (%s)&quot;</span> % pid)</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>fork</code>调用只有<code>Unix/Linux</code>才有，由于<code>Mac</code>是基于<code>Unix</code>的，所以也可以，那么如何在<code>Windows</code>上使用<code>python</code>编写多进程程序呢？</p><p>Python提供了<strong>multiprocessing</strong>模块来实现跨平台的多进程。</p><p>这个模块中提供了 <code>Process</code>，<code>Pool</code>, <code>Queue</code> 和 <code>Pipe</code> 这四个类</p><h3 id="开辟子进程–Process"><a href="#开辟子进程–Process" class="headerlink" title="开辟子进程–Process"></a>开辟子进程–Process</h3><p>先从<code>Process</code>开始：</p><p>通过Process()来构造一个子进程实例，它接受的参数有：(group&#x3D;None,target&#x3D;None,name&#x3D;None,args&#x3D;(),kwargs&#x3D;{},*,daemon&#x3D;None)</p><p>一个个来分析：</p><ul><li>group 是不需要赋值的，这是一个保留参数，日后Python实现了ThreadGroup类，这个参数便可以发挥作用</li><li>target 是可以被<code>run()</code>方法调用的一个可被调用的对象，其实就是子进程要执行的代码</li><li>name 子进程的名字</li><li>args target的参数 tuple型</li><li>kwargs target的参数 dict型</li><li>daemon 是否为守护进程(前台进程&#x2F;后台进程)</li></ul><p>现在来看一个实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_proc</span>(<span class="params">name</span>): <span class="comment"># 声明子进程任务</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Run child process %s (%s)...&quot;</span> % (name, os.getpid()))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Parent process is %s&quot;</span> % os.getpid())</span><br><span class="line">  p = Process(target=run_proc, args=(<span class="string">&quot;test&quot;</span>,)) <span class="comment"># 构造子进程</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Child process will start...&quot;</span>)</span><br><span class="line">  p.start() <span class="comment"># 准备就绪</span></span><br><span class="line">  p.join() <span class="comment"># 等待执行结束</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Child process end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>其中，<code>start()</code>方法表示进程准备就绪，等待CPU的调用<br><code>join()</code>方法使得主进程等待子进程的结束再执行后续，通常用于进程间的同步</p><blockquote><p><strong>run()<strong>方法和</strong>start()<strong>方法的区别：</strong>run()<strong>方法相当于是简单调用了一下子进程的</strong>target</strong>方法，仅仅是一般调用，而start()方法才是真的开启了进程执行。<br>可以尝试执行两个分别打印100次数字和字母的进程，分别调用**run()<strong>和</strong>start()<strong>试试，你会发现使用</strong>run()<strong>调用的结果是先打印完100个数字(字母)，再打印字母(数字)，而</strong>start()<strong>调用的结果是混合打印。(计算机处理的速度很快，最好加上</strong>time.sleep(random.random())**，就能看到非常明显的结果)</p></blockquote><h3 id="进程池–Pool"><a href="#进程池–Pool" class="headerlink" title="进程池–Pool"></a>进程池–Pool</h3><p>在需要批量建立许多子进程的场景下，可以使用进程池。</p><p>构造一个进程池的标准方法是<code>Pool([processes[,initializer[,intargs[,maxtasksperchild[,context]]]]])</code></p><p>其中常用的就应该只有processes这个参数了，表示构造的子进程的数量，缺省值是<code>os.cpu_count()</code>的值，也就是你CPU的核数。</p><p>话不多说，在一个实例中感受一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">long_time_task</span>(): <span class="comment"># 声明子进程任务</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Starting run %s (%s)&quot;</span> % (name, os.getpid()))</span><br><span class="line">  start = time.time()</span><br><span class="line">  time.sleep(random.random()*<span class="number">3</span>)</span><br><span class="line">  end = time.time()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Task %s runs %0.2f seconds.&quot;</span> % (name, (end - start)))</span><br><span class="line"><span class="keyword">if</span> __name__ = <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Parent process is %s&quot;</span> % os.getpid())</span><br><span class="line">  p = Pool(<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    p.apply_async(long_time_task, args=(i,))</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Waiting for all subprocesses done...&quot;</span>)</span><br><span class="line">  p.close()</span><br><span class="line">  p.join()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;All subprocesses done.&quot;</span>)</span><br></pre></td></tr></table></figure><p>其中，我们建立了一个四进程的进程池，使用<code>apply_async(func[,args[,kwds[,callback[,error_callback]]])</code>来为子进程调用一个函数。</p><p>后面使用<code>close()</code>使得进程池中不会再被提交进其他的任务，一旦等到所有的任务完成，工作进程就会退出。</p><p>在调用<code>join()</code>之前必须要先调<code>close()</code>或<code>terminate()</code>方法</p><h3 id="子进程中的IO–新的模块subprocess"><a href="#子进程中的IO–新的模块subprocess" class="headerlink" title="子进程中的IO–新的模块subprocess"></a>子进程中的IO–新的模块subprocess</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocesses</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;# ls -l -a -h&quot;</span>)</span><br><span class="line">ec = subprocesses.call([<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="string">&quot;-h&quot;</span>]) <span class="comment"># call方法返回一个returncode对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Exit Code:&quot;</span>,ec)</span><br></pre></td></tr></table></figure><p>运行该代码，结果和直接在命令行键入命令是同等效果。</p><p>接下来我们来看一下subprocess中的Popen类，该类用于在一个新进程中执行一个子程序。</p><p>Popen的构造器接受19个参数，很可怕…，不过常用的也就前几个，其他用缺省值就好，需要用时再查Doc，</p><p><code>Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None)</code></p><ul><li>args 也就是在Shell中手工输入命令了，如果是string，直接执行，如果是sequence，就把第一个元素作为命令。</li><li>stdin,stdout,stderr 在Popen.communicate()很常用 也就是流的位置了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;$ nslookup&#x27;</span>)</span><br><span class="line">p = subprocess.Popen([<span class="string">&#x27;nslookup&#x27;</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">output, err = p.communicate(<span class="string">b&#x27;set q=mx\npython.org\nexit\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(output.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Exit code:&#x27;</span>, p.returncode)</span><br></pre></td></tr></table></figure><p>重点来说一下<code>communicate()</code>这个方法，它接受两个参数，其中一个就是相当于我们在Shell中直接输入的命令，二就是timeout参数</p><h3 id="进程间的通信–Queue-amp-Pipe"><a href="#进程间的通信–Queue-amp-Pipe" class="headerlink" title="进程间的通信–Queue&amp;Pipe"></a>进程间的通信–Queue&amp;Pipe</h3><p>进程间通信的方式有很多种：</p><ul><li><p>管道（pipe）及有名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p></li><li><p>信号（signal）：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。</p></li><li><p>消息队列（message queue）：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。</p></li><li><p>共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p></li><li><p>信号量（semaphore）：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。</p></li><li><p>套接字（socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</p></li></ul><p>先从Queue开始：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue, Process</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">q</span>):</span><br><span class="line">  <span class="keyword">for</span> n <span class="keyword">in</span> [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>]:</span><br><span class="line">    q.put(n)</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">q</span>):</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    value = q.get(<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  q = Queue()</span><br><span class="line">  pw = Process(target=write, args=(q,)) <span class="comment"># 创建写进程</span></span><br><span class="line">  pr = Process(target=read, args=(q,)) <span class="comment"># 创建读进程</span></span><br><span class="line">  pw.start()</span><br><span class="line">  pr.start()</span><br><span class="line">  pw.join()</span><br><span class="line">  pr.terminate()</span><br></pre></td></tr></table></figure><p>然后是Pipe:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pipe, Process</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">conn</span>):</span><br><span class="line">  conn.send([<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>])</span><br><span class="line">  conn.close</span><br><span class="line"><span class="keyword">if</span> __name__ = <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">   parent_conn,child_conn = Pipe()</span><br><span class="line">   p = Process(target=func, args=(child_conn,)) <span class="comment">#子进程绑定发送任务</span></span><br><span class="line">   <span class="built_in">print</span>(parent_conn.recv()) <span class="comment"># [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]  父进程接受到子进程发来的信息</span></span><br><span class="line">   p.join()</span><br></pre></td></tr></table></figure><hr><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>Python所提供的线程，不是虚拟出来的而是，真实的POSIX线程。</p><p>标准库中提供两个模块：<code>_thread</code>,<code>threading</code>。其中<code>_thread</code>是低级模块，<code>threading</code>是对<code>_thread</code>的封装，是一个高级模块。</p><p>还是用一个例子来切入吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;thread (%s) is running...&#x27;</span> % threading.current_thread().name)</span><br><span class="line">  n = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s &gt;&gt;&gt; %s&#x27;</span> % (threading.current_thread().name, n))</span><br><span class="line">    time.sleep()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;thread %s ended&quot;</span> % threading.current_thread().name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;thread %s is running ...&quot;</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=<span class="string">&quot;LoopThread&quot;</span>)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;All done!&quot;</span>)</span><br></pre></td></tr></table></figure><p>基本上，thread的API和process的很相似的，构造器参数是一模一样的，线程的启动，等待也和process类似。</p><p>上述代码中，出现最多的接口就是<code>threading.current_thread()</code>了，这个方法永远返回当前运行的线程实例，每个进程都会有至少一个线程，这个线程叫主线程，主线程可以开启新的子线程，主线程的名字为MainThread，子线程的名字在我们创建实例的时候制定，若为空，则Python会自动为其命名。</p><p>线程和进程最大的区别就是，每一条进程的资源是拷贝过来的，因此他们互不影响，而线程不同，所有的变量是线程共享的。</p><p>所以接下来，我们来看一下线程的锁。</p><h3 id="Lock-in-Thread"><a href="#Lock-in-Thread" class="headerlink" title="Lock in Thread"></a>Lock in Thread</h3><p>先来看一下在没有锁机制的情况下，多线程之间是怎样把数据改乱的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line">balance = <span class="number">0</span> <span class="comment"># 关键数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">n</span>):</span><br><span class="line">  <span class="keyword">global</span> balance</span><br><span class="line">  balance += n</span><br><span class="line">  balance -= n</span><br><span class="line">  <span class="comment"># 相当于没做操作，值不变</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_thread</span>(<span class="params">n</span>):</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">    change(n)</span><br><span class="line">t1 = threading.Thread(target=run_thread, args=(<span class="number">5</span>,))</span><br><span class="line">t2 = threading.Thread(target=run_thread, args=(<span class="number">8</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"><span class="built_in">print</span>(balance) <span class="comment"># 不一定是0了 实际测试中我出现了 -8 13 5 11等值</span></span><br></pre></td></tr></table></figure><p>为什么会有这样的结果呢，原因是，<code>balance += n</code> 这一步看似简单的语句中，执行顺序是<code>temp = balance + n</code> –&gt; <code>balance = temp</code>，这样的步骤，而两条线程又是混搭执行的，所以可能会出现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp1 = balance + n</span><br><span class="line">temp2 = balance + n</span><br><span class="line">balance = temp1  <span class="comment"># 5</span></span><br><span class="line">balance = temp2  <span class="comment"># 8</span></span><br><span class="line">temp1 = balance - n</span><br><span class="line">balance = temp1 <span class="comment"># 3</span></span><br><span class="line">temp2 = balance - n</span><br><span class="line">balance = temp2 - n <span class="comment"># -5</span></span><br></pre></td></tr></table></figure><p>为了解决这个问题，我们引入锁机制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">balance = <span class="number">0</span></span><br><span class="line">lock = threading.Lock() <span class="comment"># 取得锁实例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_thread</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        <span class="comment"># 先要获取锁:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 此时就没问题</span></span><br><span class="line">            change_it(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 改完了一定要释放锁:</span></span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure><p>这种简单的锁非常容易造成死锁的.</p><p>就比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> threading</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lock = threading.Lock()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line"><span class="meta">... </span>   lock.acquire()</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(<span class="string">&quot;要被锁住了.&quot;</span>)</span><br><span class="line"><span class="meta">... </span>   lock.require()</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(<span class="string">&quot;(这一句执行不到)啊!被锁住了!&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = threading.Thread(target=run)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.start()</span><br><span class="line">要被锁住了</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exit()</span><br><span class="line">(main_thread已经被锁住了, 无法退出.)</span><br></pre></td></tr></table></figure><p>这显然不是我们要的结果.所以在比较资源控制复杂的情况下, 更应该使用Python提供的递归锁(RLock)</p><p>原理很简单, 递归锁对象由一个计数器,每加锁一次,该计数器加一,每解锁一次,该计数器减一.</p><p>除了锁,上面提到的信号量也是解决资源冲突问题的一个方式:</p><p>信号量就可以简单的控制临界区资源的最大线程数.</p><p>使用起来和锁几乎是一样的, 其实信号量就是锁的进一步封装.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">data = <span class="string">&quot;secretData&quot;</span></span><br><span class="line">semaphore = threading.BoundedSemaphore(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">  semaphore.acquire()</span><br><span class="line">  <span class="built_in">print</span>(data)</span><br><span class="line">  time.sleep(<span class="number">1</span>)</span><br><span class="line">  semaphore.release()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">  t = threading.Thread(target=run)</span><br></pre></td></tr></table></figure><p>接着, 你会看到每1s最多也就有5条线程在访问临界区资源.</p><p>线程的队列也可以达到锁的作用, 这里的队列和上面的进程队列不一样, 上面的队列是为了进行通信, 而线程之间本身就可以通信.( 当然了,他们的API设计基本是一样的 )</p><p><strong>注意啦:在终端下直接跑的Python是单线程的,所以当队列的元素超过了maxsize以及在Queue.qsize()为0的时候get都会造成线程堵塞,然后就GG了.</strong></p><p>一共有三种Queue, 除了上面的最基本的Queue,还有LifoQueue和PriorityQueue.</p><p>见名知意, LIFO就是(Last in First out)后进先出的队列, 而P就是优先队列, 后进先出队列和基本的队列的使用的方法没有什么不同.</p><p>而优先队列在put的时候, 要加入权重, 接着在取出的时候就会按照权重的大小从小开始排列.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">q = queue.priorityQueue()</span><br><span class="line">q.put((<span class="number">10</span>, <span class="string">&quot;Justin&quot;</span>))</span><br><span class="line">q.put((<span class="number">45</span>, <span class="string">&quot;tin&quot;</span>))</span><br><span class="line">q.put((<span class="number">5</span>, <span class="string">&quot;Jus&quot;</span>))</span><br><span class="line">q.get()</span><br><span class="line">(<span class="number">5</span>, <span class="string">&quot;Jus&quot;</span>)</span><br><span class="line">q.get()</span><br><span class="line">(<span class="number">10</span>, <span class="string">&quot;Justin&quot;</span>)</span><br><span class="line">q.get()</span><br><span class="line">(<span class="number">45</span>, <span class="string">&quot;tin&quot;</span>)</span><br></pre></td></tr></table></figure><p>解决了全局变量的干扰问题，我们想到，为什么不用局部变量呢？</p><p>如果使用局部变量，那么每一条线程间的调用就只能通过函数传参来实现，很蠢.</p><p>所以，下一个登场的新角色–ThreadLocal!</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><code>ThreadLocal</code>使用起来很方便，只要先声明一个全局的<code>ThreadLocal</code>实例，接着把需要传递的参数作为该实例的属性添加上去就好。</p><p>调用时，只要读属性就好。</p><p>就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="comment"># 创建全局ThreadLocal对象:</span></span><br><span class="line">local_school = threading.local()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_student</span>():</span><br><span class="line">    std = local_school.student <span class="comment"># 获取值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s (in %s)&#x27;</span> % (std, threading.current_thread().name))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_thread</span>(<span class="params">name</span>):</span><br><span class="line">    local_school.student = name <span class="comment"># 绑定值</span></span><br><span class="line">    process_student()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target= process_thread, args=(<span class="string">&#x27;Alice&#x27;</span>,), name=<span class="string">&#x27;Thread-A&#x27;</span>)</span><br><span class="line">t2 = threading.Thread(target= process_thread, args=(<span class="string">&#x27;Bob&#x27;</span>,), name=<span class="string">&#x27;Thread-B&#x27;</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对JavaScript闭包的理解</title>
      <link href="/2017/01/17/%E5%AF%B9JavaScript%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2017/01/17/%E5%AF%B9JavaScript%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>对JS闭包的理解</p><span id="more"></span><p>每当我们声明一个函数，这个函数就会有<strong>闭包域</strong>，这个闭包域也就是我们常说的闭包。</p><blockquote><p>大家都知道的两点：<br> 1.闭包域内声明的变量和方法，外部无法访问到。<br> 2.闭包域可以访问到外部的变量和方法。</p></blockquote><p>这很好理解，子函数的生命周期依附于父函数，父函数内的变量(从全局看是私有变量)，对于子函数来讲是全局的。</p><p>当在一个闭包域中又包含另一个闭包域(也就是在函数内部声明另一个函数)，子闭包域即当前的子函数对象的<em>function scopes</em>会产生一个<em>closure</em>对象属性，在这个对象中包含子闭包域对父闭包域的所有引用。</p><p>先来一发代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var foo = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">var i = 0;</span><br><span class="line"><span class="keyword">for</span>(i = 0; i &lt; 6; i ++) &#123;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo2</span></span> () &#123;</span><br><span class="line">console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo2();</span><br><span class="line">&#125;;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p><em>foo2</em>是子函数，接下来我们看一下Chrome Debugger的内容：</p><img src="goo1.png"><blockquote><p>先插一句：function scope不是对象，不是属性，我对他的理解是JavaScript引擎对函数的一种参数引用机制。</p></blockquote><p>可以清楚地看到，foo2的function scopes内有Closure和Global两个对象属性，foo2这个函数对象所引用的i值为6。</p><p>倘若在子闭包域仍旧存活的状态下(当然此时父函数依然在栈中)，父函数的私有变量其值出现变化。那么，对这个私有变量进行引用的子闭包域内的closure对象内的引用值也会发生变化，因为其实质是<strong>引用</strong>。</p><p>接下来，举一个经典的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span> () &#123;</span><br><span class="line">var result = [];</span><br><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">result.push(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> i * i;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">var results = foo();//results:[<span class="keyword">function</span>,function...function];</span><br><span class="line">var ele1 = results[0];</span><br><span class="line">var ele2 = results[1];</span><br><span class="line">var ele3 = results[2];</span><br><span class="line">/*分别调用*/</span><br><span class="line">ele1();//9</span><br><span class="line">ele2();//9</span><br><span class="line">ele3();//9</span><br></pre></td></tr></table></figure><p>运行后程序会如注释所展示的那样，每一个ele的结果都是一样的，也就是i最后的值3的平方。只要知道实质是<strong>引用</strong>这一点，也就很好理解为什么会出现这样的结果了。</p><p>当调用了foo()的时候，foo内部的私有变量result数组内的每一个元素都被push进了一个需要对另一个私有变量i进行引用的function，这些匿名函数的function scope内的closure都会有对<strong>当前i的引用</strong>，函数体内的i的值取决于函数调用时的i的值。</p><hr><p>现在我们来试着令其正常输出为0，1，4.</p><p>第一种思路：通过函数传参立即执行以保存状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">var result = [];</span><br><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">result.push((function(i) &#123;</span><br><span class="line">return function () &#123; </span><br><span class="line">return i * i;</span><br><span class="line">&#125;)(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种思路：通过Function构造器，以字符串拼接的形式保存状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">var result = [];</span><br><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">result.push(new Function(<span class="string">&quot;return &quot;</span> i + <span class="string">&quot;*&quot;</span> + i + <span class="string">&quot;;&quot;</span>);)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>在ES6中，新增了<strong>let</strong>关键字，使得变量获得了块级作用域。</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">var result = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">result.push(<span class="function"><span class="title">function</span></span> () &#123;<span class="built_in">return</span> i * i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
